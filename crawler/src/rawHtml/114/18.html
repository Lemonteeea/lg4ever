<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">数据结构与算法面试宝典 - 拉勾教育</h1>

  <meta
    content="数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季"
    name="keywords"
  />

  <meta
    content="数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。"
    name="description"
  />

  <title>数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  数据结构与算法面试宝典
                </div>
                <div data-v-5f686215="" class="name">
                  德鲁伊
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  前微软资深软件工程师
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 |&nbsp;告别盲目刷题，击破算法面试
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 759px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：数据结构之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 栈：从简单栈到单调栈，解决经典栈问题
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 队列：FIFO 队列与单调队列的深挖与扩展
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 优先级队列：堆与优先级队列，筛选最优元素
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 树：如何深度运用树的遍历？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 并查集：如何利用两行代码写并查集？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          加餐与答疑 | 第一期 ：一问一答
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：算法之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08&nbsp;|
                          排序：如何利用合并与快排的小技巧，解决算法难题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10&nbsp;|
                          双指针：如何掌握最长、定长、最短区间问题的解题决窍？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12&nbsp;|
                          回溯：我把回溯总结成一个公式，回溯题一出就用它
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | DP：我是怎么治好“DP&nbsp;头痛症”的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：一题多解篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19&nbsp;|
                          最小体力消耗路径：如何突破经典题型，掌握解题模板？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20&nbsp;| 5
                          种解法，如何利用常量空间求解最长有效括号长度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21&nbsp;| 安排会议室：如何利用多种方法安排会议室？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：代码模板篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 |&nbsp;数据结构模板：如何让解题变成搭积木？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    彩蛋
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 |&nbsp;算法的精进之路
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 146px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/04/22
                  <span data-v-1605a430="" class="auth">德鲁伊</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/35:14"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="2114"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/35:14</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">
                            91.93M
                          </div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/35:14
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="8221" class="">
                      面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。
                    </p>
                    <p data-nodeid="8222">
                      但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成<strong
                        data-nodeid="8692"
                        >从题目出发，去考虑如何破解一个题</strong
                      >。
                    </p>
                    <p data-nodeid="8223">本讲将会重点学习：</p>
                    <ul data-nodeid="8224">
                      <li data-nodeid="8225">
                        <p data-nodeid="8226">如何挖掘题目的特点</p>
                      </li>
                      <li data-nodeid="8227">
                        <p data-nodeid="8228">
                          如何利用特点匹配到数据结构和算法知识点
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8229">
                      完成这两步动作，需要你熟练地掌握前面“一解多题”模块介绍的数据结构与算法知识点。养兵千日，用在一时，是时候派上用场了。
                    </p>
                    <h3 data-nodeid="8230">最大矩形</h3>
                    <p data-nodeid="8231">
                      【<strong data-nodeid="8707">题目</strong
                      >】给定一个数组，里面有<em data-nodeid="8708">n</em
                      >个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为
                      1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
                    </p>
                    <p data-nodeid="8232">输入：[2,1,5,6,2,3]</p>
                    <p data-nodeid="8233">输出：10</p>
                    <p data-nodeid="8234">
                      解释：柱状图的示例，其中每个柱子的宽度为
                      1，给定的高度为<code data-backticks="1" data-nodeid="8715"
                        >[2,1,5,6,2,3]</code
                      >。
                    </p>
                    <p data-nodeid="8235">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__gKAfuSVAAJVGh0lZ7k739.png"
                        alt="Drawing 0.png"
                        data-nodeid="8719"
                      />
                    </p>
                    <div data-nodeid="8236">
                      <p style="text-align: center">输入 最大矩形</p>
                    </div>
                    <h3 data-nodeid="8237">暴力算法</h3>
                    <p data-nodeid="8238">
                      当拿到题目之后，一种最简单、最暴力的算法立马会出现在我们脑海里面。那就是：
                    </p>
                    <ul data-nodeid="8239">
                      <li data-nodeid="8240">
                        <p data-nodeid="8241">
                          分别选定两个柱子，然后计算这两个柱子为边界，构成的最大矩形的面积；
                        </p>
                      </li>
                      <li data-nodeid="8242">
                        <p data-nodeid="8243">
                          取出所有的矩形面积中的最大面积。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8244">
                      那么根据这个思路，可以得到代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> h = Integer.MAX_VALUE;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) {
</div></li><li><div class="code-word">            h = Math.min(h, A[k]);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> h;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; N; j++) {
</div></li><li><div class="code-word">                ans = Math.max(ans,
</div></li><li><div class="code-word">                   minHeight(A, i, j) * (j - i + <span class="hljs-number">1</span>));
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8246">
                      但是，这个代码的时间复杂度实在太高，达到
                      O(N<sup>3</sup>)，在面试中并不能给你加分。那么有没有什么更好的办法呢？
                    </p>
                    <h3 data-nodeid="8247">特点 1：区间</h3>
                    <p data-nodeid="8248">
                      可以发现，求解的时候，我们非常依赖一个区域里面的最小值：就是
                      minHeight() 函数。
                    </p>
                    <p data-nodeid="8249">
                      那么，有没有什么办法，可以<strong data-nodeid="8737"
                        >快速地</strong
                      >获取：一个数组区间里面的最小值呢？此时问题破解的关键聚焦到下面这个问题上。
                    </p>
                    <blockquote data-nodeid="8250">
                      <p data-nodeid="8251">
                        给定一个数组：如何快速地查询一个区间里面的最小值？
                      </p>
                    </blockquote>
                    <p data-nodeid="8252">
                      如果我们能在 O(1)
                      的时间得到一个区间里面的最小值，那么就可以把暴力算法的时间复杂度优化到
                      O(N<sup>2</sup>)。
                    </p>
                    <p data-nodeid="8253">
                      因此，此时我们需要快速匹配到一个算法和数据结构来满足这样的特点。想到这里，你的脑海里面应该浮现如下的场景：
                    </p>
                    <p data-nodeid="8254">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__hyAKNRHAADJi9Tt1Jc075.png"
                        alt="Drawing 1.png"
                        data-nodeid="8747"
                      />
                    </p>
                    <p data-nodeid="8255">
                      那么，我们需要什么样的数据结构/算法呢？
                    </p>
                    <ul data-nodeid="8256">
                      <li data-nodeid="8257">
                        <p data-nodeid="8258">
                          如果是在面试中，你发现脑海里面空空如也，一点也想不到有什么办法可以处理这个区间查询问题，就需要立马转换思路，尝试寻找别的破题办法。因为很有可能，这里踩了你的知识盲区，要在短时间发现一种算法解决这个问题的可能性还是挺小的。
                        </p>
                      </li>
                      <li data-nodeid="8259">
                        <p data-nodeid="8260">
                          如果是在准备面试阶段，那么你应该立马搜索一下有什么样的数据结构可以满足这样的要求。大概率情况下，这种基础问题已经有很多现成的数据结构来支撑了，所以不需要你再去“挠破脑袋”当发明家了。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8261">
                      就现在而言，我们肯定是处在一个准备面试的阶段。所以，下面我会带你走一遍“搜索”的步骤。
                    </p>
                    <p data-nodeid="8262">
                      求解区间的最小值/最大值问题，一般有 2 类算法与数据结构：
                    </p>
                    <ul data-nodeid="8263">
                      <li data-nodeid="8264">
                        <p data-nodeid="8265">ST（Sparse Table）算法</p>
                      </li>
                      <li data-nodeid="8266">
                        <p data-nodeid="8267">线段树（Segment Tree）</p>
                      </li>
                    </ul>
                    <p data-nodeid="8268">
                      接下来，我们分别介绍一下这两种算法（说不定哪天你在面试中碰到这个关键问题，就轻而易举答出来了）。
                    </p>
                    <h4 data-nodeid="8269">ST 算法</h4>
                    <p data-nodeid="8270">
                      在面试时，我们总是先看到问题，然后希望匹配到一个算法，能够刚好满足我们期望的时间复杂度。那么
                      ST 算法可以满足我们的要求吗？
                    </p>
                    <p data-nodeid="10275" class="">
                      先来看一下
                      <strong data-nodeid="10281">ST 算法的特点</strong>：
                    </p>

                    <ul data-nodeid="8272">
                      <li data-nodeid="8273">
                        <p data-nodeid="8274">
                          ST 算法需要预处理，并且在预处理阶段，时间复杂度为
                          O(NlgN)，空间复杂度为 O(NlgN)；
                        </p>
                      </li>
                      <li data-nodeid="8275">
                        <p data-nodeid="8276">
                          ST 算法预处理结束之后，在查询阶段，时间复杂度为 O(1)。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8277">
                      如果我们用上 ST 算法，那么时间复杂度可以从
                      O(N<sup>3</sup>) 变为 O(N<sup>2</sup> + NlgN) =
                      O(N<sup>2</sup>)。这样一来复杂度就下降了一个数量级，还是非常值得一试的。
                    </p>
                    <p data-nodeid="14390" class="">
                      下面我们讲一下 ST 算法
                      <strong data-nodeid="14396">2 个核心思想</strong>。
                    </p>

                    <h5 data-nodeid="8279">1. 一分为二</h5>
                    <p data-nodeid="30859" class="">
                      任何一个区间都可以分为<strong data-nodeid="30869"
                        >两个可能重合的区间</strong
                      >。比如给定的区间为 [start, end]，那么：
                    </p>

                    <ul data-nodeid="8281">
                      <li data-nodeid="8282">
                        <p data-nodeid="8283">
                          这个区间可以分为 [start, end1], [start2,
                          end]，即第一个区间必须以 start
                          为起点，第二个区间必须以 end 为终点；
                        </p>
                      </li>
                      <li data-nodeid="8284">
                        <p data-nodeid="8285">
                          两个区间<strong data-nodeid="8813">可以重合</strong>；
                        </p>
                      </li>
                      <li data-nodeid="8286">
                        <p data-nodeid="8287">
                          两个区间的长度<strong data-nodeid="8823">必须</strong
                          >是 2<sup>p</sup> 长度（p 是非负整数）。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8288">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__iqAUkNNAABpKQ8hpO8389.png"
                        alt="Drawing 2.png"
                        data-nodeid="8826"
                      />
                    </p>
                    <p data-nodeid="8289">
                      【<strong data-nodeid="8852">例 1</strong>】比如有一个区间
                      [10, 17]，长度为 8，那么可以拆分为 [10, 13], [14,17]
                      长度为 2<sup>2</sup> 的两个区间。下图是拆分之后<strong
                        data-nodeid="8853"
                        >不存在重合</strong
                      >的情况：
                    </p>
                    <p data-nodeid="8290">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__jGAJ-BPAAB07QZeoiU141.png"
                        alt="Drawing 3.png"
                        data-nodeid="8856"
                      />
                    </p>
                    <p data-nodeid="8291">
                      【<strong data-nodeid="8882">例 2</strong>】比如有一个区间
                      [10, 18]，长度为 9。那么可以拆分为 [10, 17] 和 [11, 18]
                      长度为 2<sup>3</sup> 的两个区间。下图是拆分之后存在<strong
                        data-nodeid="8883"
                        >部分重合</strong
                      >的情况：
                    </p>
                    <p data-nodeid="8292">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__jiAOH3WAABwKY4dT9s988.png"
                        alt="Drawing 4.png"
                        data-nodeid="8886"
                      />
                    </p>
                    <p data-nodeid="8293">
                      【<strong data-nodeid="8912">例 3</strong>】比如有一个区间
                      [10, 10]，长度为 1，那么可以拆分为 [10, 10] 和 [10,
                      10]，这两个区间完全重合，且长度为 2<sup>0</sup>
                      的两个区间。这是拆分之后<strong data-nodeid="8913"
                        >完全重合</strong
                      >的情况。
                    </p>
                    <p data-nodeid="8294">
                      基于此，我们可以得到<strong data-nodeid="8919"
                        >结论 1</strong
                      >。
                    </p>
                    <blockquote data-nodeid="8295">
                      <p data-nodeid="8296">
                        给定一个数组，这个数组里面的任意一个有效区间<strong
                          data-nodeid="8929"
                          >总是</strong
                        >可以表达为：可能重叠的两个 2<sup>p</sup> 长度区间。
                      </p>
                    </blockquote>
                    <p data-nodeid="8297">
                      那么，假设我们已经得到所有 2<sup>p</sup>
                      长度的区间的信息。那么“区间 [start, end]
                      上的最小值：可以先取出两个长度为 2<sup>p</sup>
                      的子区间的最小值，再从中选择最小的即可。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">区间[start, end]上的最小值 = min(区间[l, l+2&lt;sup&gt;p&lt;/sup&gt;)上的最小值
</div></li><li><div class="code-word">                         区间[r-2&lt;sup&gt;p&lt;/sup&gt;+1, r]上的最小值)
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8299">
                      基于结论 1，我们可以得到<strong data-nodeid="8948"
                        >结论 2</strong
                      >。
                    </p>
                    <blockquote data-nodeid="8300">
                      <p data-nodeid="8301">计算顺序：</p>
                      <ol data-nodeid="8302">
                        <li data-nodeid="8303">
                          <p data-nodeid="8304">
                            先计算出长度为 2<sup>0</sup> 的所有区间的最小值；
                          </p>
                        </li>
                        <li data-nodeid="8305">
                          <p data-nodeid="8306">
                            再计算长度为 2<sup>1</sup> 的所有区间的最小值；
                          </p>
                        </li>
                        <li data-nodeid="8307">
                          <p data-nodeid="8308">
                            然后计算长度为 2<sup>2</sup> 的所有区间的最小值；
                          </p>
                        </li>
                        <li data-nodeid="8309">
                          <p data-nodeid="8310">
                            直到长度为 2<sup>x</sup> 的区间的最小值。
                          </p>
                        </li>
                      </ol>
                      <blockquote data-nodeid="8311">
                        <p data-nodeid="8312">
                          其中 2<sup>x</sup> 刚好大于等于给定的数组长度。
                        </p>
                      </blockquote>
                    </blockquote>
                    <h5 data-nodeid="8313">2. 指数表示法</h5>
                    <p data-nodeid="8314">
                      当拆分完成之后，原本一个区间的表示是 [start,
                      end]，分为两个长度（len）一样的区间。更进一步，这两个区间可以表示为
                      &lt;start1, len&gt;, &lt;start2, len&gt;。
                    </p>
                    <p data-nodeid="34976" class="">
                      例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10,
                      len=8&gt;, &lt;start2=11, len=8&gt;。
                    </p>

                    <p data-nodeid="8316">
                      例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10,
                      len=4&gt;, &lt;start2=14,len=4&gt;。
                    </p>
                    <p data-nodeid="8317">
                      重新表示之后，区间 &lt;start, len&gt; 中，由于长度信息 len
                      总是 2<sup>p</sup>，因此我们可以只记录<strong
                        data-nodeid="9016"
                        >指数 p</strong
                      >。
                    </p>
                    <p data-nodeid="8318">
                      例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10,
                      p=3&gt;, &lt;start2=11, p=3&gt;。
                    </p>
                    <p data-nodeid="8319">
                      例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10,
                      p=2&gt;, &lt;start2=14,p=2&gt;。
                    </p>
                    <p data-nodeid="8320">
                      如果我们将区间采用指数 p 表示之后，就只需要使用空间
                      st[N][log2(N)+1]，也就是空间复杂度为 O(NlgN)。
                    </p>
                    <p data-nodeid="8321">
                      那么基于以上两个核心思想，我们可以写出 ST
                      算法的代码了。这里可以分为两步，一步是预处理，另一步是查询。
                    </p>
                    <p data-nodeid="8322">
                      <strong data-nodeid="9062"
                        >预处理构建 st[][] 数组代码如下</strong
                      >：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[][] st)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 第一步：</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//    - 处理长度为1的区间</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//      即[i, i + 1)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 区间的表示：</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    st[i][<span class="hljs-number">0</span>] = A[i];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 递推：</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">//      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= N; j++) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里要处理的区间[i, i + (1&lt;&lt;j)]</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// last = i + (1&lt;&lt;j)</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 根据左闭右开原则，last是可以取到n的。这点要注意。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; (i + (<span class="hljs-number">1</span> &lt;&lt; j)) &lt;= N; i++) {
</div></li><li><div class="code-word">      st[i][j] = Math.min(st[i][j - <span class="hljs-number">1</span>], 
</div></li><li><div class="code-word">                          st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8324">
                      <strong data-nodeid="9066">查询阶段的代码如下：</strong>
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] st, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span>
</span></div></li><li><div class="code-word">{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这里我们将区间[l, r]分为两个区间</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// [l, l+log2(len)] =&gt; [l, len=log2(len)]</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> len = r - l + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> j = log2(len);
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> Math.min(st[l][j], st[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8326">
                      需要注意的是，在查询阶段，如果一个区间的长度本来就是
                      2<sup>p</sup>，那么就可以拆分成两个完全重合的区间。
                    </p>
                    <p data-nodeid="8327">
                      得到 ST
                      算法的代码之后，我们就可以开始解决这道题目了。代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">log2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(Math.log(N) / Math.log(<span class="hljs-number">2</span>));
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] createST(<span class="hljs-keyword">int</span> N) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> powerOf2 = log2(N);
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span>[][] st = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][powerOf2 + <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">            st[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[powerOf2+<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> st;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[][] st)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 第一步：</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//    - 处理长度为1的区间</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//      即[i, i + 1)</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 区间的表示：</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">            st[i][<span class="hljs-number">0</span>] = A[i];
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 递推：</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">//      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= N; j++) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 这里要处理的区间[i, i + (1&lt;&lt;j)]</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// last = i + (1&lt;&lt;j)</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 根据左闭右开原则，last是可以取到n的。这点要注意。</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; (i + (<span class="hljs-number">1</span> &lt;&lt; j)) &lt;= N; i++) {
</div></li><li><div class="code-word">                st[i][j] = Math.min(st[i][j - <span class="hljs-number">1</span>],
</div></li><li><div class="code-word">                                    st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] st, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// 这里我们将区间[l, r]分为两个区间</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// [l, l+log2(len)] =&gt; [l, len=log2(len)]</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> len = r - l + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> j = log2(len);
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> Math.min(st[l][j], st[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span>[][] st = createST(N);
</div></li><li><div class="code-word">        buildST(A, st);
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; N; j++) {
</div></li><li><div class="code-word">                ans = Math.max(ans, 
</div></li><li><div class="code-word">                  minHeight(st, i, j) * (j - i + <span class="hljs-number">1</span>));
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8329">
                      <p data-nodeid="8330">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9076"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9080"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9084"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8331">
                      不过，这种算法的时间复杂度仍然是
                      O(N<sup>2</sup>)。这里请你思考一下，还有没有更好的办法呢？
                    </p>
                    <h4 data-nodeid="8332">线段树</h4>
                    <p data-nodeid="8333">
                      不妨尝试一下线段树。在处理区间信息的时候，线段树是一个非常有用的数据结构。下面我们来了解一下它的特点（可以先不管它长什么样）：
                    </p>
                    <ul data-nodeid="8334">
                      <li data-nodeid="8335">
                        <p data-nodeid="8336">
                          构建线段树，时间复杂度为 O(NlgN)；
                        </p>
                      </li>
                      <li data-nodeid="8337">
                        <p data-nodeid="8338">
                          查询阶段，时间复杂度为 O(lgN)；
                        </p>
                      </li>
                      <li data-nodeid="8339">
                        <p data-nodeid="8340">空间复杂度为 O(4N)。</p>
                      </li>
                    </ul>
                    <h5 data-nodeid="8341">1. 线段树的思想</h5>
                    <p data-nodeid="8342">
                      <strong data-nodeid="9102">线段树的思想</strong
                      >是用一棵平衡二叉树来表示一个数组区间上的信息：
                    </p>
                    <ul data-nodeid="8343">
                      <li data-nodeid="8344">
                        <p data-nodeid="8345">根结点记录整个数组的信息；</p>
                      </li>
                      <li data-nodeid="8346">
                        <p data-nodeid="8347">左子树记录数组左半部分的信息；</p>
                      </li>
                      <li data-nodeid="8348">
                        <p data-nodeid="8349">右子树记录数组右半部分的信息。</p>
                      </li>
                    </ul>
                    <p data-nodeid="8350">
                      <strong data-nodeid="9113">【例 1】</strong>
                      假设给定的数组为 A[] = {1, 2, 3,
                      4}，需要记录的信息为区间里面的最小值。那么线段树构成如下：
                    </p>
                    <p data-nodeid="8351">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__nKANd_2AACTipb_MQs065.png"
                        alt="Drawing 5.png"
                        data-nodeid="9116"
                      />
                    </p>
                    <p data-nodeid="8352">
                      那么查询的时候，就需要从根结点开始往下查。假设我们要基于这棵树查询区间
                      [1, 3] 的最小值信息。
                    </p>
                    <ul data-nodeid="8353">
                      <li data-nodeid="8354">
                        <p data-nodeid="8355">
                          <strong data-nodeid="9125">第 1 步</strong>
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8356">
                      首先，我们访问到根结点，可以发现 [0, 3] 区间与 [1, 3]
                      区间处于相交的情况，因此根结点的信息，对于我们要查询的结果是没有帮助的，所以需要将
                      [0, 3] 区间拆分为 [0, 1] 和 [2,3] 区间。
                    </p>
                    <p data-nodeid="8357">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__nyAG63XAACqx6B5uVU521.png"
                        alt="Drawing 6.png"
                        data-nodeid="9149"
                      />
                    </p>
                    <p data-nodeid="8358">
                      这里我们得到<strong data-nodeid="9155">原则 1</strong>：
                    </p>
                    <blockquote data-nodeid="8359">
                      <p data-nodeid="8360">
                        区间相交的时候，需要拆分树结点区间，然后分别看左右子树。
                      </p>
                    </blockquote>
                    <ul data-nodeid="8361">
                      <li data-nodeid="8362">
                        <p data-nodeid="8363">
                          <strong data-nodeid="9160">第 2 步</strong>
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8364">
                      接下来，我们先看左子树，可以发现区间 [0, 1] 与区间 [1,3]
                      仍然是处于相交的状态。
                    </p>
                    <p data-nodeid="8365">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__oKAY7Z0AACvIcu60-4225.png"
                        alt="Drawing 7.png"
                        data-nodeid="9172"
                      />
                    </p>
                    <p data-nodeid="8366">
                      因此还需要再次利用原则
                      1，分别观察它们的左右子树，如下图所示：
                    </p>
                    <p data-nodeid="8367">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__oiAT5PpAACwh7u3Cyk265.png"
                        alt="Drawing 8.png"
                        data-nodeid="9176"
                      />
                    </p>
                    <p data-nodeid="8368">
                      我们再接着遍历左右子树的时候，不难发现有以下两种情况:
                    </p>
                    <p data-nodeid="8369">
                      Case 1. [0,0] 与区间 [1,3] 不相交，无视 [0,0]
                      区间上的信息；
                    </p>
                    <p data-nodeid="8370">
                      Case 2. [1,1] 被区间 [1,3]
                      包含，需要保留这个区间上的信息。
                    </p>
                    <p data-nodeid="39092" class="">
                      由此，我们就得到<strong data-nodeid="39102"
                        >原则 2</strong
                      >
                      和<strong data-nodeid="39103">原则 3</strong>。
                    </p>

                    <blockquote data-nodeid="8372">
                      <p data-nodeid="8373">
                        <strong data-nodeid="9218"
                          >原则
                          2：树结点区间与查询区间不相交时，无视树结点的信息。</strong
                        ><br />
                        <strong data-nodeid="9219"
                          >原则
                          3：树结点区间包含查询区间内部时，保留树结点的信息。</strong
                        >
                      </p>
                    </blockquote>
                    <ul data-nodeid="8374">
                      <li data-nodeid="8375">
                        <p data-nodeid="8376">
                          <strong data-nodeid="9223">第 3 步</strong>
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8377">
                      最后，看一下右边子树，我们发现 [2, 3]
                      树结点区间包含查询区间，因此，需要使用原则 3。
                    </p>
                    <p data-nodeid="8378">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__piAASjRAACwfmU76M4079.png"
                        alt="Drawing 9.png"
                        data-nodeid="9231"
                      />
                    </p>
                    <ul data-nodeid="8379">
                      <li data-nodeid="8380">
                        <p data-nodeid="8381">
                          <strong data-nodeid="9235">第 4 步</strong>
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8382">
                      那么最终，我们只选取两个树结点的信息，如下图所示：
                    </p>
                    <p data-nodeid="8383">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__p-AaesyAADICuyRzZ8398.png"
                        alt="Drawing 10.png"
                        data-nodeid="9239"
                      />
                    </p>
                    <p data-nodeid="8384">
                      那么我们可以得到区间 [1,3] 上的最小值：
                    </p>
                    <blockquote data-nodeid="8385">
                      <p data-nodeid="8386">
                        min([1,1] 区间上的最小值，[2,3] 区间上的最小值) = 2
                      </p>
                    </blockquote>
                    <p data-nodeid="8387">
                      经过上面的查询，这里我总结了 3 个原则。
                    </p>
                    <blockquote data-nodeid="8388">
                      <p data-nodeid="8389">
                        原则
                        1：区间相交的时候，需要拆分树结点区间，然后分别看左右子树。<br />
                        原则
                        2：树结点区间与查询区间不相交时，无视树结点的信息。<br />
                        原则 3：树结点区间包含查询区间内部时，保留树结点的信息。
                      </p>
                    </blockquote>
                    <p data-nodeid="8390">
                      3
                      个原则分别代表区间之间的三种关系。你不需要去死记这个关系，只需要注意以下两点：
                    </p>
                    <ul data-nodeid="8391">
                      <li data-nodeid="8392">
                        <p data-nodeid="8393">树中的结点的区间会不停地拆分；</p>
                      </li>
                      <li data-nodeid="8394">
                        <p data-nodeid="8395">查询区间一直固定不变。</p>
                      </li>
                    </ul>
                    <h5 data-nodeid="8396">2. 查询的本质</h5>
                    <p data-nodeid="8397">
                      似乎让你单纯地记录这个查询流程太枯燥了，因此我们还需要更深入地去想一下线段树查询的本质，理解之后再去记忆就比较简单了。你可以这样想，给定一个二叉树，然后又给了一个查询区间，那么可以把查询的过程表示成
                      2 步。
                    </p>
                    <ul data-nodeid="8398">
                      <li data-nodeid="8399">
                        <p data-nodeid="8400">第 1 步：裁剪</p>
                      </li>
                    </ul>
                    <p data-nodeid="8401">
                      我们修剪一下这棵二叉树，让所有的叶子结点都在查询区间范围内。
                    </p>
                    <p data-nodeid="8402">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__q2APtnlAADfBsWCUTs679.png"
                        alt="Drawing 11.png"
                        data-nodeid="9271"
                      />
                    </p>
                    <p data-nodeid="84386">
                      需要注意的是，当区间 [2,3]
                      已经包含查询区间的时候，其子树上的结点就没有必要保留了。最终，我们将灰色的树结点都去掉，只保留：<br />
                      1） “包含”查询区间的叶结点；<br />
                      2）根结点到这些叶结点的<strong data-nodeid="84403"
                        >路径</strong
                      >。
                    </p>
                    <ul data-nodeid="84387">
                      <li data-nodeid="84388">
                        <p data-nodeid="84389">第 2 步：收集叶子结点的信息</p>
                      </li>
                    </ul>

                    <p data-nodeid="8411">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__rWAFHv2AACwSnQB1C4869.png"
                        alt="Drawing 12.png"
                        data-nodeid="9286"
                      />
                    </p>
                    <p data-nodeid="8412">
                      当裁剪完成之后，只需要再查看存留的二叉树的叶结点信息就可以了。
                    </p>
                    <p data-nodeid="8413">
                      不过我们这里并不真正地去裁剪这棵二叉树，而是在遍历的时候，只提取出相应的信息（区间上的最小值）即可。
                    </p>
                    <p data-nodeid="8414">
                      下面是一道关于二叉树的裁剪的练习题，希望你可以尝试解决一下。
                    </p>
                    <p data-nodeid="86457" class="">
                      <strong data-nodeid="86466">练习题 1</strong>：
                      给你二叉搜索树的根结点 root ，同时给定最小边界 low
                      和最大边界 high。通过修剪二叉搜索树，使所有结点的值在
                      [low, high]
                      中。修剪树不应该改变保留在树中的元素的相对结构（如果没有被移除，原有的父代子代关系都应当保留）。可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根结点。注意，根结点可能会根据给定的边界发生改变。
                    </p>

                    <p data-nodeid="8416">
                      输入如下所示的二叉搜索树，并且 low = 1，high = 3。
                    </p>
                    <p data-nodeid="8417">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__r6AYsviAACOtqFSsXc299.png"
                        alt="Drawing 13.png"
                        data-nodeid="9302"
                      />
                    </p>
                    <p data-nodeid="8418">输出：</p>
                    <p data-nodeid="8419">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__sWAaVRCAABqvED48GE222.png"
                        alt="Drawing 14.png"
                        data-nodeid="9306"
                      />
                    </p>
                    <blockquote data-nodeid="8420">
                      <p data-nodeid="8421">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9310"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9314"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9318"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8422">
                      完成练习题之后，你可以想一下，线段树查询与练习题 1
                      的裁剪有什么异同点？可以把你的思考写在留言区，我们一起讨论。
                    </p>
                    <h5 data-nodeid="8423">3. 线段树的更新</h5>
                    <p data-nodeid="8424">
                      虽然这道题没有用到<strong data-nodeid="9328"
                        >线段树的更新</strong
                      >，但是面试的时候你可能会用到，所以我们还是要讲一下，
                    </p>
                    <p data-nodeid="8425">
                      当我们要更新某个区间上的值时，需要将线段树路径上所有的点的区间信息都更新掉（更新的时候，采用后续遍历即可），如下图所示：
                    </p>
                    <p data-nodeid="8426">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__tGALBeoAADYdvwyPEo939.png"
                        alt="Drawing 15.png"
                        data-nodeid="9332"
                      />
                    </p>
                    <h5 data-nodeid="8427">4. 线段树的存储</h5>
                    <p data-nodeid="8428">
                      可能现在你准备开始用包含左右指针的二叉树写线段树了，不过还有更高效的方式——用数组表示一棵二叉树。
                    </p>
                    <p data-nodeid="8429">
                      你可以回忆一下，“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="9342"
                        >03 | 优先级队列：堆与优先级队列，筛选最优元素</a
                      >”学习堆的时候，我们已经用过一个数组来表示二叉树了，如下图所示：
                    </p>
                    <p data-nodeid="8430">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__t2AaDg8AADItUzBiIo402.png"
                        alt="Drawing 16.png"
                        data-nodeid="9346"
                      />
                    </p>
                    <p data-nodeid="94677" class="">
                      这里也可以用数组来表示线段树，主要是因为：
                    </p>

                    <ul data-nodeid="8432">
                      <li data-nodeid="8433">
                        <p data-nodeid="8434">数组具有更好的内存连续性；</p>
                      </li>
                      <li data-nodeid="8435">
                        <p data-nodeid="8436">内存连续性对 CPU 缓存更友好；</p>
                      </li>
                      <li data-nodeid="8437">
                        <p data-nodeid="8438">
                          对 CPU 缓存更友好的数据结构能够运行得更快。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8439">
                      但是，通常我们学习的二叉树表示，会不停地 new TreeNode()
                      导致内存特别碎片化，因此对 CPU
                      缓存并不友好，导致运行得变慢。
                    </p>
                    <p data-nodeid="8440">
                      当给定一个数组的时候，我们需要利用这个树创建一个线段树。根据线段树的定义：
                    </p>
                    <ul data-nodeid="8441">
                      <li data-nodeid="8442">
                        <p data-nodeid="8443">根结点记录整个数组的信息；</p>
                      </li>
                      <li data-nodeid="8444">
                        <p data-nodeid="8445">左子树记录数组左半部分的信息；</p>
                      </li>
                      <li data-nodeid="8446">
                        <p data-nodeid="8447">右子树记录数组右半部分的信息。</p>
                      </li>
                    </ul>
                    <p data-nodeid="8448">
                      这里我们可以肯定的是，根结点的信息，实际上需要依赖左子树的信息，以及右子树的信息才能够生成的。所以，这个二叉树的创建肯定是一个后序遍历。
                    </p>
                    <p data-nodeid="8449">
                      然后再根据数组表示二叉树的方法，有以下 3 种：
                    </p>
                    <ul data-nodeid="8450">
                      <li data-nodeid="8451">
                        <p data-nodeid="8452">i 结点的父结点 par = (i-1)/2；</p>
                      </li>
                      <li data-nodeid="8453">
                        <p data-nodeid="8454">i 结点的左子结点 2 * i + 1；</p>
                      </li>
                      <li data-nodeid="8455">
                        <p data-nodeid="8456">i 结点的右子结点 2 * i + 2。</p>
                      </li>
                    </ul>
                    <h5 data-nodeid="8457">5. 线段树的模板代码</h5>
                    <p data-nodeid="8458">
                      此时，我们可以写出线段树的模板代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 表示线段树的数组treeArray[]</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 数组里面的值表示区间里面的最小值</span>
</div></li><li><div class="code-word"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] treeArray = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leftNodePos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> (rootPos &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rightNodePos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> (rootPos &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-comment">// treeArray[rootPos] 将会记录数组[start, end]</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 这个区间上的信息。在本题中，信息为区间上的最小值</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos, <span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-comment">// 范围为空</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (start &gt; end)
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果区间：只有一个数</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (start == end) {
</div></li><li><div class="code-word">        treeArray[rootPos] = A[start];
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 否则需要将区间分为两半</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">        buildTree(leftNodePos(rootPos), A, start, mid);
</div></li><li><div class="code-word">        buildTree(rightNodePos(rootPos), A, mid + <span class="hljs-number">1</span>, end);
</div></li><li><div class="code-word">        <span class="hljs-comment">// 构建成功之后，需要利用左子树的信息和右子树的信息来</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 来更新 [start, end] rootNode 的信息</span>
</div></li><li><div class="code-word">        treeArray[rootPos] =
</div></li><li><div class="code-word">            Math.min(treeArray[leftNodePos(rootPos)], 
</div></li><li><div class="code-word">                     treeArray[rightNodePos(rootPos)]);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-comment">/**
</span></div></li><li><div class="code-word"> * 查询区间[queryStart, queryEnd]这个区间上的最小值信息
</div></li><li><div class="code-word"> *
</div></li><li><div class="code-word"> * treeArray[rootPos]表示区间 [start, end]上的最小值。
</div></li><li><div class="code-word"> * 可以把前面的三个参数看成
</div></li><li><div class="code-word"> * class TreeNode {
</div></li><li><div class="code-word"> *      int val;        &lt;-- arg: treeArray[rootPos];
</div></li><li><div class="code-word"> *      int rangeStart; &lt;-- arg: start
</div></li><li><div class="code-word"> *      int rangeEnd:   &lt;-- arg: end
</div></li><li><div class="code-word"> *      TreeNode left;  &lt;-- leftNodePos(rootPos);
</div></li><li><div class="code-word"> *      TreeNode right: &lt;-- rightNodePos(rootPos);
</div></li><li><div class="code-word"> * }
</div></li><li><div class="code-word"> */
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">queryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end,
</span></span></div></li><li><div class="code-word">                      <span class="hljs-keyword">int</span> queryStart, <span class="hljs-keyword">int</span> queryEnd) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 无效区间，返回最大值</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (start &gt; end || queryStart &gt; queryEnd) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 原则1： 包含于查询区间内部</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (queryStart &lt;= start &amp;&amp; end &lt;= queryEnd) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> treeArray[rootPos];
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 原则2：不相交时，放弃区间信息，这里我们返回最大值</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (end &lt; queryStart || queryEnd &lt; start) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 原则3：当相交的时候，需要将[start, end]进行拆分</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 由于我们建树的时候，都是平分，所以这里将区间也进行平分</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> Math.min(queryTree(leftNodePos(rootPos),
</div></li><li><div class="code-word">                               start, mid, queryStart, queryEnd),
</div></li><li><div class="code-word">                    queryTree(rightNodePos(rootPos),
</div></li><li><div class="code-word">                               mid + <span class="hljs-number">1</span>, end, queryStart, queryEnd));
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-comment">// 当我们要更新数组中A[inx] = value的时候</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 线段树中存储的区间的信息，也是需要更新的</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end,
</span></span></div></li><li><div class="code-word">                <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> value) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果树中的结点不在我们的更新路径上</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (start &gt; end || idx &lt; start || idx &gt; end) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果已经找到了叶子结点</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (start == idx &amp;&amp; idx == end) {
</div></li><li><div class="code-word">        treeArray[rootPos] = value;
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里后序遍历</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果是非叶子结点，那么</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 先更新左右子结点，再更新根结点</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 更新左子树</span>
</div></li><li><div class="code-word">    updateTree(leftNodePos(rootPos), start, mid, idx, value);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 更新右子树</span>
</div></li><li><div class="code-word">    updateTree(rightNodePos(rootPos), mid + <span class="hljs-number">1</span>, end, idx, value);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 更新根结点</span>
</div></li><li><div class="code-word">    treeArray[rootPos] =
</div></li><li><div class="code-word">        Math.min(treeArray[leftNodePos(rootPos)],
</div></li><li><div class="code-word">                 treeArray[rightNodePos(rootPos)]);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8460">
                      <p data-nodeid="8461">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9372"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9376"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9380"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8462">
                      那么我们通过使用线段树，就写出求解的代码了，如下所示（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-comment">// ... 并查集的模板代码....</span>
</div></li><li><div class="code-word">   <span class="hljs-function"><span class="hljs-keyword">public</span>
</span></div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> {
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = heights == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : heights.length;
</div></li><li><div class="code-word">        treeArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];
</div></li><li><div class="code-word">        buildTree(<span class="hljs-number">0</span>, heights, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; N; j++) {
</div></li><li><div class="code-word">                <span class="hljs-comment">// rootPos = 0表示根结点</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// [0, N-1]表示根结点代表：[0, N-1]这个区间上的最小值信息</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> minHeight = queryTree(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>, i, j);
</div></li><li><div class="code-word">                ans = Math.max(ans, minHeight * (j - i + <span class="hljs-number">1</span>));
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8464">
                      <p data-nodeid="8465">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9385"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9389"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9393"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8466">
                      接下来，我们分析一下时间复杂度，一共会有 N x N
                      个区间需要查询，每次查询的时间复杂度为
                      O(lgN)，所以时间复杂度为 O(N<sup>2</sup>
                      lgN)，空间复杂度为 O(N)。
                    </p>
                    <p data-nodeid="8467">
                      到这里，我们利用一些区间信息查找常用的手段进行了优化：
                    </p>
                    <ul data-nodeid="8468">
                      <li data-nodeid="8469">
                        <p data-nodeid="8470">
                          使用 ST 算法将时间复杂度优化到 O(N<sup>2</sup>)；
                        </p>
                      </li>
                      <li data-nodeid="8471">
                        <p data-nodeid="8472">
                          使用线段树将时间复杂度优化到O(N<sup>2</sup> lgN)。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8473">
                      可是，这两种算法都还是会超时，接下来应该怎么办呢？
                    </p>
                    <p data-nodeid="8474">
                      其实，真正面试的时候，你应该注意，一开始找到的题目特点是基于区间查询的方式，实际上就把优化的上限限定死了。一共有
                      N x N 个区间要查，无论查多快，时间复杂度都不会比 O(N x N)
                      更好。
                    </p>
                    <p data-nodeid="8475">
                      这就意味着，一开始，我们破题的大方向就是错的。当然，在这里我是发扬了要把一个题的特点深挖到底的精神，在练习的时候可以这么操作。如果是在面试中，还没有走到使用
                      ST 算法，线段树，就应该尝试寻找题目的其他特点了。
                    </p>
                    <h3 data-nodeid="8476">特点 2：选与不选</h3>
                    <p data-nodeid="8477">
                      首先，我们假设问题是有一个最优解的，而这个<strong
                        data-nodeid="9423"
                        >最优解</strong
                      >肯定是<strong data-nodeid="9424"
                        >原始数组的一个连续子数组</strong
                      >。那么，对于数组中的元素而言，就存在 2 种可能：
                    </p>
                    <ul data-nodeid="8478">
                      <li data-nodeid="8479">
                        <p data-nodeid="8480">被最优解选中</p>
                      </li>
                      <li data-nodeid="8481">
                        <p data-nodeid="8482">没有被最优解选中</p>
                      </li>
                    </ul>
                    <p data-nodeid="8483">
                      但是，如果我们去讨论每个元素的选/不选，时间复杂度就会瞬间爆炸到
                      O(2<sup>N</sup>)。但是你先别着急放弃这个特点，我们决心把这个特点死磕到底。
                    </p>
                    <p data-nodeid="8484">
                      接着看题目，由于最大矩形的制约因素是被选中<strong
                        data-nodeid="9441"
                        >区域的最小值</strong
                      >制约的。那么当给定一个区域 [start, end]
                      的时候，对于这个区间里面的最小值而言，只有两种可能。
                    </p>
                    <p data-nodeid="8485">
                      第一种可能：被最优解选中，此时解为 area = minHeight * (end
                      - start + 1)。
                    </p>
                    <p data-nodeid="8486">
                      第二种可能：没有被最优解选中，那么可以利用最小值，将区域切分为两半：
                    </p>
                    <ul data-nodeid="98783">
                      <li data-nodeid="98784">
                        <p data-nodeid="98785" class="">
                          计算左边区域的最大矩形的面积；
                        </p>
                      </li>
                      <li data-nodeid="98786">
                        <p data-nodeid="98787">
                          计算右边区域的最大矩形的面积。
                        </p>
                      </li>
                    </ul>

                    <p data-nodeid="8492">然后再取这两种可能的最大矩形面积。</p>
                    <p data-nodeid="8493">
                      我们发现，利用区间里面的最小值（选/不选），可以将区间切分为更小的区间。
                    </p>
                    <p data-nodeid="8494">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__vmAdDMGAAX2VnfI0w8074.png"
                        alt="Drawing 17.png"
                        data-nodeid="9452"
                      />
                    </p>
                    <p data-nodeid="8495">此时，我们就可以使用分治算法了。</p>
                    <h4 data-nodeid="8496">分治算法 1</h4>
                    <p data-nodeid="8497">
                      根据前面的思路，我们可以写出分治的代码（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里得到一个区域里面的最大矩形面积</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这个区间域为[b, e)</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 注意e是取不到的</span>
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRangeMaxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果为空区间</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (b &gt;= e) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果区间中只有一个元素</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> == e) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> heights[b];
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果有多个元素。那么找到范围里面的最小值</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果有多个最小值，那么我们就找离中心最近的那个，尽量把区域进行等分</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> mid = b + ((e-b) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> minIndex = b;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b + <span class="hljs-number">1</span>; i &lt; e; i++) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (heights[i] &lt; heights[minIndex]) {
</div></li><li><div class="code-word">                minIndex = i;
</div></li><li><div class="code-word">            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[minIndex]) {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 多个最小值，那么谁离mid更近，我们用谁</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">if</span> (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {
</div></li><li><div class="code-word">                    minIndex = i;
</div></li><li><div class="code-word">                }
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 在使用 最小值 情况下的面积</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> useMinIndexArea = heights[minIndex] * (e - b);
</div></li><li><div class="code-word">        <span class="hljs-comment">// 不用 minIndex 那么就会把区间分为两部分</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> leftMaxArea = getRangeMaxArea(heights, b, minIndex);
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> rightMaxArea = getRangeMaxArea(heights, minIndex + <span class="hljs-number">1</span>, e);
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> Math.max(useMinIndexArea,
</div></li><li><div class="code-word">                         Math.max(leftMaxArea, rightMaxArea));
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = heights == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : heights.length;
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> getRangeMaxArea(heights, <span class="hljs-number">0</span>, N);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8499">
                      <p data-nodeid="8500">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9459"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9463"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9467"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8501">
                      <strong data-nodeid="9476">复杂度分析</strong
                      >：正常情况下，时间复杂度为
                      O(NlgN)，最差情况下，比如数组是一个已排序的数组，并且里面元素都不相同，那么时间复杂度会变为
                      O(N<sup>2</sup>)，空间复杂度为 O(lgN)。
                    </p>
                    <p data-nodeid="8502">
                      【<strong data-nodeid="9488">小结</strong
                      >】这里你可以回想一下我们在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6697&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="9486"
                        >08 |
                        排序：如何利用合并与快排的小技巧，解决算法难题？</a
                      >”学习的排序技巧，原来我们学习快速排序的时候，会用“三路切分”将区间分为三部分。而在这里，我们是用最小值将区间切分成两半。
                    </p>
                    <p data-nodeid="8503">
                      那么有没有办法可以进一步优化呢？我们可以看到，分治的核心代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> mid = b + ((e - b) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> minIndex = b;
</div></li><li><div class="code-word"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b + <span class="hljs-number">1</span>; i &lt; e; i++) {
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (heights[i] &lt; heights[minIndex]) {
</div></li><li><div class="code-word">    minIndex = i;
</div></li><li><div class="code-word">  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[minIndex]) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 多个最小值，那么谁离mid更近，我们用谁</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {
</div></li><li><div class="code-word">      minIndex = i;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8505">
                      这段代码本质就是在搜索一个区间里面的最小值。如果你还有印象，寻找一个区间的信息，我们可以得到如下信息：
                    </p>
                    <ul data-nodeid="8506">
                      <li data-nodeid="8507">
                        <p data-nodeid="8508">
                          ST 算法预处理时间复杂度 O(NlgN)，查询区间最小值
                          O(1)，空间复杂度 O(NlgN)；
                        </p>
                      </li>
                      <li data-nodeid="8509">
                        <p data-nodeid="8510">
                          线段树建树 O(NlgN)，查询区间最小值 O(lgN)，空间复杂度
                          O(N)。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8511">
                      下面我再给你留两个练习题，请你分别用这两个算法再优化一下分治算法。如果有什么疑问，可以写在留言区，我会逐一为你解答。
                    </p>
                    <p data-nodeid="8512">
                      <strong data-nodeid="9498">练习题 2</strong>：请使用 ST
                      算法优化分治算法。并且分析优化之后的时间/空间复杂度。
                    </p>
                    <blockquote data-nodeid="8513">
                      <p data-nodeid="8514">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9502"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9506"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9510"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8515">
                      <strong data-nodeid="9515">练习题 3</strong
                      >：请使用线段树算法优化我们的分治算法，并且分析优化之后时间/空间复杂度。
                    </p>
                    <blockquote data-nodeid="8516">
                      <p data-nodeid="8517">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9519"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9523"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9527"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h4 data-nodeid="8518">分治算法 2</h4>
                    <p data-nodeid="8519">
                      在前面的分治算法中，我们在切分数组的时候，采用了一个区域里面的最小值进行切分。在最差情况下（数组元素不同且有序），会得到
                      O(N<sup>2</sup>) 时间复杂度。
                    </p>
                    <p data-nodeid="8520">
                      不知道你有没有想起我们切分数组的算法。
                    </p>
                    <ul data-nodeid="8521">
                      <li data-nodeid="8522">
                        <p data-nodeid="8523">
                          合并排序：切分的时候，直接从数组的中间开始切分。时间复杂度最差也为
                          O(NlgN)。
                        </p>
                      </li>
                      <li data-nodeid="8524">
                        <p data-nodeid="8525">
                          快速排序：切分的时候，采用数组中的随机值进行切分。时间复杂度最差也为O(N<sup>2</sup>)。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8526">
                      于是，我们可以得到一个<strong data-nodeid="9545"
                        >结论。</strong
                      >
                    </p>
                    <blockquote data-nodeid="8527">
                      <p data-nodeid="8528">
                        我们在切分数组的时候：如果采用值进行切分，那么最差情况下的时间复杂度会掉到
                        O(N<sup>2</sup>)；如果采用中间的下标进行切分，那么时间复杂度为
                        O(NlgN)。
                      </p>
                    </blockquote>
                    <p data-nodeid="8529">
                      就这道题而言，如果我们想把分治算法变成
                      O(NlgN)，应该怎么办？相信你已经想到了方向，那就是切分的时候，采用下标进行切分。
                    </p>
                    <p data-nodeid="8530">
                      到这里，我们已经可以写出伪代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxRangeArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (b &gt;= e) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果只有一个元素</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> == e) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> heights[b];
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 用数组中间的那个元素将数组分为两半</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = b + ((e - b) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> leftMaxArea = getMaxRangeArea(heights, b, mid);
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> rightMaxArea = getMaxRangeArea(heights, mid + <span class="hljs-number">1</span>, e);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果一定要包含heights[mid]</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 求出containsMidIndexArea; &lt;-- 那么这里怎么求?</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> Math.max(containsMidIndexArea,
</div></li><li><div class="code-word">                    Math.max(leftMaxArea, rightMaxArea));
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8532">
                      接下来，我们看一下问题的核心部分，当包含 heights[mid]
                      的时候，应该如何计算？共有两种情况。
                    </p>
                    <ul data-nodeid="8533">
                      <li data-nodeid="8534">
                        <p data-nodeid="8535">
                          Case 1：其他元素都比 heights[mid] 大，heights[mid]
                          成了短板。
                        </p>
                      </li>
                      <li data-nodeid="8536">
                        <p data-nodeid="8537">
                          Case 2：存在比 heights[mid] 小的元素，heights[mid]
                          只是参与一下。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8538">
                      关于这两种情况的处理， 核心代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> minHeight = heights[mid];
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> containsMidIndexArea = minHeight;
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> left = m - <span class="hljs-number">1</span>, right = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">while</span> (left &gt;= b || right &lt; e) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (right &gt;= e || left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {
</div></li><li><div class="code-word">        minHeight = min(minHeight, heights[left]);
</div></li><li><div class="code-word">        left--;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        minHeight = min(minHeight, heights[right]);
</div></li><li><div class="code-word">        right++;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmp = minHeight * (right - left - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    containsMidIndexArea = max(containsMidIndexArea, tmp);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8540">
                      那么，到此为止，我们就可以写出完全是 O(NlgN) 的代码了。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxRangeArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (b &gt;= e) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果只有一个元素</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> == e) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> heights[b];
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 用数组中间的那个元素将数组分为两半</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = b + ((e - b) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> leftMaxArea = getMaxRangeArea(heights, b, mid);
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> rightMaxArea = getMaxRangeArea(heights, mid + <span class="hljs-number">1</span>, e);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果一定要包含heights[mid]</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 那么就有两种情况。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> minHeight = heights[mid];
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> containsMidIndexArea = minHeight;
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> left = mid - <span class="hljs-number">1</span>, right = mid + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (left &gt;= b || right &lt; e) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (right &gt;= e || 
</div></li><li><div class="code-word">          left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {
</div></li><li><div class="code-word">        minHeight = Math.min(minHeight, heights[left]);
</div></li><li><div class="code-word">        left--;
</div></li><li><div class="code-word">      } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        minHeight = Math.min(minHeight, heights[right]);
</div></li><li><div class="code-word">        right++;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmp = minHeight * (right - left - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">      containsMidIndexArea = Math.max(containsMidIndexArea, tmp);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> Math.max(containsMidIndexArea,
</div></li><li><div class="code-word">                    Math.max(leftMaxArea, rightMaxArea));
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = heights == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : heights.length;
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> getMaxRangeArea(heights, <span class="hljs-number">0</span>, N);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8542">
                      <p data-nodeid="8543">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9581"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9585"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9589"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8544">
                      <strong data-nodeid="9594">复杂度分析</strong>：时间复杂度
                      O(NlgN)，空间复杂度 O(1)（不算栈空间）。
                    </p>
                    <p data-nodeid="8545">
                      【<strong data-nodeid="9600">小结</strong
                      >】在写这个算法的时候，我们需要注意两个地方。
                    </p>
                    <p data-nodeid="8546">
                      <strong data-nodeid="9613">其一</strong>：在处理
                      heights[mid] 的时候，将<strong data-nodeid="9614"
                        >包含</strong
                      >关系分为以下 2 种：
                    </p>
                    <ul data-nodeid="8547">
                      <li data-nodeid="8548">
                        <p data-nodeid="8549">
                          包含 heights[mid]，并且找到的区域内的元素都比
                          heights[mid] 大；
                        </p>
                      </li>
                      <li data-nodeid="8550">
                        <p data-nodeid="8551">
                          不包含 heights[mid]，这种情况需要递归处理 [b, mid) 和
                          [mid + 1, e)。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8552">
                      容易出错的地方在于，包含 heights[mid]
                      的时候，实际上有两种情况的（前面我们提到的Case 1 和 Case
                      2）。这里只处理了 Case 1，但是没有处理 Case 2。
                    </p>
                    <p data-nodeid="8553">
                      <strong data-nodeid="9646">其二</strong
                      >：采用这种分治算法，包含 heights[mid]
                      的时候，采用了双指针的做法，left 和 right
                      分别向两边推进。但是你需要格外注意，推进的时候，哪边大，则移动哪边的指针。
                    </p>
                    <p data-nodeid="8554">
                      你能想想为什么吗？请你完成下面的练习题
                      4，期待看到你理解与思考。
                    </p>
                    <p data-nodeid="8555">
                      <strong data-nodeid="9658">练习题 4</strong
                      >：这里的分治算法在往左右两边推进的时候，为什么哪边大就往哪边移动呢？你能再想一下，这与“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="9656"
                        >11 | 贪心：这种思想，没有模板，如何才能掌握它？</a
                      >”介绍的贪心算法的例 1 有什么异同吗？
                    </p>
                    <h3 data-nodeid="8556">特点 3：左右两边较小的数</h3>
                    <p data-nodeid="8557">
                      构成一个矩形的面积的时候，有宽和高。无论是特点 1，还是特点
                      2，它们都有一个共同点：先固定矩形的宽，再去选择高。
                    </p>
                    <p data-nodeid="8558">
                      有没有可能反过来呢？我们先去固定高度，再去决定宽度。当我们选择数组中的元素
                      heights[i]
                      作为矩形的高度时。寻找宽度需要满足以下两个条件：
                    </p>
                    <ul data-nodeid="8559">
                      <li data-nodeid="8560">
                        <p data-nodeid="8561">i 元素必须要在这个范围内；</p>
                      </li>
                      <li data-nodeid="8562">
                        <p data-nodeid="8563">
                          这个范围内的元素都必须要大于等于 heights[i]。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8564">
                      那么我们就可以称 heights[i] 决定了这个最大范围的面积。
                    </p>
                    <h4 data-nodeid="8565">小于我的位置</h4>
                    <p data-nodeid="8566">
                      那么这也就意味着，我们需要解决如下的问题。
                    </p>
                    <ul data-nodeid="8567">
                      <li data-nodeid="8568">
                        <p data-nodeid="8569">
                          数组中元素右边离我最近且比我小的元素的位置
                        </p>
                      </li>
                    </ul>
                    <blockquote data-nodeid="8570">
                      <p data-nodeid="8571">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9683"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9687"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9691"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <ul data-nodeid="8572">
                      <li data-nodeid="8573">
                        <p data-nodeid="8574">
                          数组中元素左边离我最近且比我小的元素的位置
                        </p>
                      </li>
                    </ul>
                    <blockquote data-nodeid="8575">
                      <p data-nodeid="8576">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9696"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9700"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9704"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8577">
                      实际上，这两个问题，我们已经在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="9710"
                        >01 | 栈：从简单栈到单调栈，解决经典栈问题</a
                      >”介绍单调栈时学过了。那么你现在解决起来，应该是很容易了吧。本讲不再过多叙述，直接给出如下代码（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftSmall</span>
</span></div></li><li><div class="code-word">{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 当我们要找左边比我小的元素的时候，需要用递增栈</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] findLeftSmall(<span class="hljs-keyword">int</span>[] A)
</div></li><li><div class="code-word">  {
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || A.length == <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 结果数组</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];
</div></li><li><div class="code-word">    <span class="hljs-comment">// 注意，栈中的元素记录的是下标</span>
</div></li><li><div class="code-word">    Stack&lt;Integer&gt; t = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
</div></li><li><div class="code-word">    <span class="hljs-comment">// 注意这里的遍历方向发生了变化，因为我们是要找到左边比我小的元素的位置</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = A[i];
</div></li><li><div class="code-word">      <span class="hljs-comment">// 每个元素都遍历栈中的元素完成消除动作</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 这里是递减栈</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 如果发现进来的元素x与栈中元素相比</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 如果大于栈中的元素，那么要把栈中的元素弹出去</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 消除的时候，记录一下被谁消除了</span>
</div></li><li><div class="code-word">        ans[t.peek()] = i;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 消除时候，值更大的需要从栈中消失</span>
</div></li><li><div class="code-word">        t.pop();
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      <span class="hljs-comment">// 剩下的入栈</span>
</div></li><li><div class="code-word">      t.push(i);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (!t.empty()) {
</div></li><li><div class="code-word">      ans[t.peek()] = -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      t.pop();
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RightSmall</span>
</span></div></li><li><div class="code-word">{
</div></li><li><div class="code-word">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] findRightSmall(<span class="hljs-keyword">int</span>[] A)
</div></li><li><div class="code-word">  {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 结果数组</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];
</div></li><li><div class="code-word">    <span class="hljs-comment">// 注意，栈中的元素记录的是下标</span>
</div></li><li><div class="code-word">    Stack&lt;Integer&gt; t = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = A[i];
</div></li><li><div class="code-word">      <span class="hljs-comment">// 每个元素都向左遍历栈中的元素完成消除动作</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 消除的时候，记录一下被谁消除了</span>
</div></li><li><div class="code-word">        ans[t.peek()] = i;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 消除时候，值更大的需要从栈中消失</span>
</div></li><li><div class="code-word">        t.pop();
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      <span class="hljs-comment">// 剩下的入栈</span>
</div></li><li><div class="code-word">      t.push(i);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (!t.empty()) {
</div></li><li><div class="code-word">      ans[t.peek()] = -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      t.pop();
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>
</span></div></li><li><div class="code-word">{
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span>
</span></div></li><li><div class="code-word">  {
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[] leftSmall = LeftSmall.findLeftSmall(A);
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[] rightSmall = RightSmall.findRightSmall(A);
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = A[i];
</div></li><li><div class="code-word">      <span class="hljs-comment">// 左边比我小的位置</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 右边比我小的位置</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> leftPos = leftSmall[i];
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rightPos = rightSmall[i] == -<span class="hljs-number">1</span> ? N : rightSmall[i];
</div></li><li><div class="code-word">      <span class="hljs-comment">// 现在我们确定区间(leftPos, rightPos)</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 注意两边都是开区间。在这个区间里面，所有的数肯定都是 &gt;= A[i]的。</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 那么底部的宽度就是</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = rightPos - leftPos - <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> area = height * width;
</div></li><li><div class="code-word">      ans = Math.max(ans, area);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8579">
                      <p data-nodeid="8580">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9715"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9719"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9723"
                          >python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8581">
                      <strong data-nodeid="9728">复杂度分析</strong>：时间复杂度
                      O(N)，空间复杂度 O(N)。
                    </p>
                    <p data-nodeid="8582">
                      【<strong data-nodeid="9740">小结</strong
                      >】如果你看到这里，突然感觉代码都很神奇，充满了魔法，就是时候温习一下“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="9738"
                        >01 | 栈：从简单栈到单调栈，解决经典栈问题</a
                      >”中单调栈的“魔法技能”部分了。通过复习有时候也能唤醒你算法的巨龙哦。
                    </p>
                    <h4 data-nodeid="8583">单调栈的性质</h4>
                    <p data-nodeid="8584">
                      我们来看递增栈（不是严格递增），栈中元素存放的是数组 A[]
                      的下标。如下图所示：
                    </p>
                    <p data-nodeid="8585">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__xWAW9DWAAFqqPVJeyA651.png"
                        alt="Drawing 18.png"
                        data-nodeid="9748"
                      />
                    </p>
                    <p data-nodeid="8586">
                      说明：在这个图中，左边是栈底，右边是栈增长的方向。栈中不同的矩形表示相应
                      A[]
                      数组中下标位置相应值的大小。那么，首先基于递增栈的定义，我们可以知道它有如下<strong
                        data-nodeid="9757"
                        >特性</strong
                      >：
                    </p>
                    <blockquote data-nodeid="8587">
                      <p data-nodeid="8588">
                        栈中存放的下标，如果 i 在 j 之前入栈，那么必然满足 A[i]
                        &lt;= A[j]。
                      </p>
                    </blockquote>
                    <p data-nodeid="119325" class="">
                      “<strong data-nodeid="119335">削</strong>”<strong
                        data-nodeid="119336"
                        >的定义</strong
                      >：当需要把一个更小的元素入栈的时候，这个更小的元素就会把栈中大的元素出栈，直到栈为空，或者栈顶元素更小，再入栈。
                    </p>

                    <p data-nodeid="8590">
                      例如：当栈中已经有 &lt;i, j&gt;，现在需要将 A[k]
                      入栈，但是 A[i] &lt; A[k] &amp;&amp; A[k] &lt; A[j]。那么
                      A[k] 就会把 A[j] 削出栈。如下图所示：
                    </p>
                    <p data-nodeid="8591">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__x2AMAmBAAGTLBc-_M4399.png"
                        alt="Drawing 19.png"
                        data-nodeid="9820"
                      />
                    </p>
                    <p data-nodeid="8592">
                      根据这个特性，我们肯定可以得到 A[i] &lt;= A[k] &lt;
                      A[j]。基于这个特性，还可以得出 3 个有用的性质。
                    </p>
                    <p data-nodeid="8593">
                      <strong data-nodeid="9841">性质 1</strong>
                    </p>
                    <p data-nodeid="8594">如下图所示：</p>
                    <p data-nodeid="8595">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__yOANThzAAFyvMYvHNg791.png"
                        alt="Drawing 20.png"
                        data-nodeid="9845"
                      />
                    </p>
                    <blockquote data-nodeid="8596">
                      <p data-nodeid="8597">
                        假设 i, j 这两个下标在单调栈中相邻，那么在原数组 A[]
                        中， (i, j) 这个开区间里面的数都大于 A[j]。
                      </p>
                    </blockquote>
                    <p data-nodeid="8598">
                      这里我们采用反证法来证明这个性质。首先给出反证法的条件：
                    </p>
                    <ul data-nodeid="8599">
                      <li data-nodeid="8600">
                        <p data-nodeid="8601">
                          单调栈中连续存放着下标 i, j（但并不代表下标 i,j
                          是连续的，也就是说 i + 1 不一定等于j）；
                        </p>
                      </li>
                      <li data-nodeid="8602">
                        <p data-nodeid="8603">
                          假设 A[] 数组在 (i, j) 范围中存在 1 个下标 k，即 i
                          &lt; k &lt; j，并且使得 A[k] &lt; A[j] 成立。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8604">
                      证明：如果 A[k] &lt; A[j]，那么将 A[k]
                      放入单调队列之后，由于 (k, j) 范围里面的数组都大于
                      A[j]。那么当 A[j] 入栈之后，应该位于 A[k]
                      之后。于是栈中会形成 &lt;i, k, j&gt;
                      三个数。但实际上栈中只存放了 &lt;i, j&gt; 两个数，并且 i
                      &lt; k &lt; j，这里存在矛盾。所以在 (i, j)
                      这个开区间范围里面的数，都必须大于 A[j]。
                    </p>
                    <p data-nodeid="8605">
                      之所以这些大于 A[j] 的元素没有出现在栈中，是因为这些元素在
                      A[j] 入栈时可能都在栈中，但是立马都被 A[j] 削出栈了。
                    </p>
                    <p data-nodeid="8606">
                      <strong data-nodeid="9929">性质 2</strong>
                    </p>
                    <p data-nodeid="8607">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__yuAfVYwAAFqqPVJeyA829.png"
                        alt="Drawing 21.png"
                        data-nodeid="9932"
                      />
                    </p>
                    <p data-nodeid="8608">
                      然后，基于性质 1，当单调栈中有 &lt;i, j, k&gt;3
                      个原数组的下标。那么可以得到性质 2：
                    </p>
                    <blockquote data-nodeid="8609">
                      <p data-nodeid="8610">
                        当单调栈中有 &lt;i, j, k&gt; 3 个数组下标时，其中 (i, k]
                        这个范围里面的元素，肯定 &gt;= A[j]。
                      </p>
                    </blockquote>
                    <p data-nodeid="8611">证明如下：</p>
                    <ul data-nodeid="8612">
                      <li data-nodeid="8613">
                        <p data-nodeid="8614">
                          根据性质 1，可以得到 (i, j) 里面的元素都大于 A[j]，即
                          A[(i,j)] &gt; A[j]；
                        </p>
                      </li>
                      <li data-nodeid="8615">
                        <p data-nodeid="8616">
                          根据性质 1，还可以得到 (j, k) 里面的元素都大于
                          A[k]，即 A[(j,k)] &gt; A[k]；
                        </p>
                      </li>
                      <li data-nodeid="8617">
                        <p data-nodeid="8618">
                          由于 j 在 k 之前入栈，所以可以肯定 A[j] &lt;= A[k]。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8619">
                      综上，A[(j,k)] &gt; A[k] &gt;= A[j]，所以可以得出结论 (i,
                      k] 里面的元素肯定 &gt;= A[j]。
                    </p>
                    <p data-nodeid="8620">
                      <strong data-nodeid="10005">性质 3</strong>
                    </p>
                    <p data-nodeid="8621">
                      现在我们遇到下面这种场景。在单调栈中，已经存放了原数组的两个下标
                      &lt;i, j&gt;，其中 j 是栈顶元素，现在要把一个更小的值 A[k]
                      对应的下标 k 入栈。如下图所示：
                    </p>
                    <p data-nodeid="8622">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__zSAIgpuAAGDndzxWPI670.png"
                        alt="Drawing 22.png"
                        data-nodeid="10015"
                      />
                    </p>
                    <p data-nodeid="8623">
                      此时，根据单调栈的性质，需要将 A[j] 弹出栈（有可能 A[k]
                      已经削除了栈中的很多元素，现在轮到削除 A[j]
                      了）。那么此时我们可以得到一个<strong data-nodeid="10033"
                        >性质 3</strong
                      >：
                    </p>
                    <blockquote data-nodeid="8624">
                      <p data-nodeid="8625">
                        原数组 (j, k) 范围里面的数，都大于 A[j]。
                      </p>
                    </blockquote>
                    <p data-nodeid="8626">
                      同样，我们可以采用反证法。先给出反证法的条件：
                    </p>
                    <ul data-nodeid="8627">
                      <li data-nodeid="8628">
                        <p data-nodeid="8629">
                          当 k 要入栈时，单调栈中连续存放着下标 i,
                          j（但并不代表下标 i,j 是连续的，也就是说 i + 1
                          不一定等于 j）；
                        </p>
                      </li>
                      <li data-nodeid="8630">
                        <p data-nodeid="8631">
                          假设范围 (j, k) 中存在<strong data-nodeid="10046"
                            >1 个</strong
                          >下标 x；
                        </p>
                      </li>
                      <li data-nodeid="8632">
                        <p data-nodeid="8633">使得 A[x] &lt;= A[j] 成立。</p>
                      </li>
                    </ul>
                    <p data-nodeid="8634">
                      如果有 j &lt; x &lt; k，并且 A[x] &lt;= A[j]
                      成立，那么单调栈中现在必然存在 A[x]
                      元素。但是现在栈中存放着 A[j]，并且没有 A[x]
                      元素。所以得出矛盾。所以性质 3 成立。
                    </p>
                    <p data-nodeid="8635">
                      其实性质 2 和性质 3 有个比较好记的地方。如果你将范围
                      (i,j), (j, k) 看成两个“空档”。那么 A[j]
                      就好像总是挑着两座大山，如下图所示：
                    </p>
                    <p data-nodeid="8636">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__zuAUKHIAAGwv8-dDjM339.png"
                        alt="Drawing 23.png"
                        data-nodeid="10092"
                      />
                    </p>
                    <p data-nodeid="8637">
                      至于 A[j] 和 A[k] 值的大小，当然是比较容易判断的：
                    </p>
                    <ul data-nodeid="8638">
                      <li data-nodeid="8639">
                        <p data-nodeid="8640">
                          如果栈中 j 在 k 之前（且相邻），那么 A[j] &lt; A[k]；
                        </p>
                      </li>
                      <li data-nodeid="8641">
                        <p data-nodeid="8642">
                          如果 A[k] 要削 A[j] 出栈，那么 A[k] &lt; A[j]。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8643">
                      到这里，我们就可以写出代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 虽然可以用Stack&lt;Integer&gt;，但是这里我们为了更快地操作，我们用</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 数组模拟栈来运行，因为我们知道最多存放的内容实际上就是N个</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-comment">// s[top-1]表示栈顶元素</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 注意，这里我们取到了i == N</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 按理说，不应该取到i == N的。但是这时候，主要是为了处理这种数组</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// A = [1, 2, 3]</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 没有任何元素会出栈。</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 那么最后我们用一个0元素，把所有的元素都削出栈。</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 这样代码就可以统一处理掉。</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 注意：当i == N的时候，x = -1;</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 比数组中的元素都要小。</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = i == N ? -<span class="hljs-number">1</span> : A[i];
</div></li><li><div class="code-word">            <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">0</span> &amp;&amp; A[s[top - <span class="hljs-number">1</span>]] &gt; x) {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 计算以A[s[top]]的元素的高度的矩形。</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = A[s[--top]];
</div></li><li><div class="code-word">                <span class="hljs-comment">// i元素要将index = s[top-1]的元素出栈。</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 那么根据性质2/3：</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 此时A[s[top-1] .... i) 这个区间里面的元素都是</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 大于A[s[top-1]]的</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rightPos = i;
</div></li><li><div class="code-word">                <span class="hljs-comment">// 这里需要使用性质1.</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 注意：当栈中一个元素都没有的时候，要取-1</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> leftPos = top &gt; <span class="hljs-number">0</span> ? s[top - <span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = rightPos - leftPos - <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> area = height * width;
</div></li><li><div class="code-word">                ans = Math.max(ans, area);
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            s[top++] = i;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8645">
                      <p data-nodeid="8646">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10136"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10140"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10144"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8647">
                      <strong data-nodeid="10149">复杂度分析</strong
                      >：时间复杂度 O(N)，空间复杂度 O(N)。
                    </p>
                    <h4 data-nodeid="8648">DP</h4>
                    <p data-nodeid="8649">
                      前面我们使用单调栈来求解一个左右两边第一个较小的元素的位置。现在我们重新来考虑一下这个问题。
                    </p>
                    <p data-nodeid="8650">
                      <strong data-nodeid="10156">题目</strong
                      >：数组中左边离我最近且比我小的元素的位置。
                    </p>
                    <p data-nodeid="8651">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__0WATqoPAACmXg-WF6E452.png"
                        alt="Drawing 24.png"
                        data-nodeid="10159"
                      />
                    </p>
                    <p data-nodeid="8652" class="">
                      我们在考虑的时候，直接考虑最后一个元素的情况（不知道你是否还记得我们<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6703&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="10163"
                        >DP 的最后一步</a
                      >），也就是求解 A[k+1] 左边第一个比较小元素的位置。假设
                      [0, k] 这个范围元素的解都放在 dp[] 数组里面。如果我们要求
                      A[k+1] 左边第一个比较小元素的位置。通常的写法如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pre = k; pre &gt;= <span class="hljs-number">0</span>; pre--) {
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A[pre] &lt; A[k+<span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">    dp[k+<span class="hljs-number">1</span>] = pre;
</div></li><li><div class="code-word">    <span class="hljs-keyword">break</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8654">
                      但是这么写，时间复杂度就变成
                      O(N)。如果要求解“数组中元素左边离我最近且比我小的元素的位置”，问题就秒变
                      O(N<sup>2</sup>)。而我们知道，如果使用单调栈，是可以在
                      O(N) 时间复杂度解决的。
                    </p>
                    <p data-nodeid="8655">
                      我们立马会发现，求解 A[k+1] 的时候，还没有用上 dp[]
                      数组。那么我们可以这样操作：
                    </p>
                    <ul data-nodeid="8656">
                      <li data-nodeid="8657">
                        <p data-nodeid="8658">
                          首先 A[k] 与 A[k+1] 比较，如果 A[k] &gt;=
                          A[k+1]，那么直接跳到下标 j = dp[k] 这个位置；
                        </p>
                      </li>
                      <li data-nodeid="8659">
                        <p data-nodeid="8660">
                          重复上述步骤，直到找到一个元素比 A[k+1]
                          小，或者没有任何元素为止。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8661">
                      通过这样的方式，我们可以快速跳过一些元素，使时间复杂度变为
                      O(lgN)。于是代码可以长成这样：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> pre = k + <span class="hljs-number">1</span> - <span class="hljs-number">1</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">while</span> (pre != -<span class="hljs-number">1</span> &amp;&amp; A[pre] &gt;= A[k+<span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">    pre = dp[pre];
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word">dp[k+<span class="hljs-number">1</span>] = pre;
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8663">
                      <p data-nodeid="8664">
                        联想 1：你可以想一下，这和 KMP
                        算法有没有什么相似的地方？<br />
                        联想
                        2：你可以再想一下，这和我们学过的并查集有没有什么相似的地方？
                      </p>
                    </blockquote>
                    <p data-nodeid="8665">
                      那么我们的求解最大矩形的代码，就可以利用这个思想，写出代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] A)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span>[] lm = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N]; <span class="hljs-comment">// left min的位置</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span>[] rm = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N]; <span class="hljs-comment">// right min的位置</span>
</div></li><li><div class="code-word">        lm[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">int</span> idx = i - <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">            <span class="hljs-keyword">while</span> (idx != -<span class="hljs-number">1</span> &amp;&amp; A[idx] &gt;= A[i]) {
</div></li><li><div class="code-word">                idx = lm[idx];
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            lm[i] = idx;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        rm[N - <span class="hljs-number">1</span>] = N;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">int</span> idx = i + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">            <span class="hljs-keyword">while</span> (idx != N &amp;&amp; A[idx] &gt;= A[i]) {
</div></li><li><div class="code-word">                idx = rm[idx];
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            rm[i] = idx;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">            ans = Math.max(ans, A[i] * (rm[i] - lm[i] - <span class="hljs-number">1</span>));
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8667">
                      <p data-nodeid="8668">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10227"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10231"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10235"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8669">
                      <strong data-nodeid="10240">复杂度分析</strong
                      >：时间复杂度
                      O(NlgN)，时间复杂度可以类比并查集的跳跃方式，空间复杂度
                      O(N)。
                    </p>
                    <h3 data-nodeid="8670">总结</h3>
                    <p data-nodeid="8671">在这一讲里面，我们采用的总方针是：</p>
                    <ul data-nodeid="8672">
                      <li data-nodeid="8673">
                        <p data-nodeid="8674">深挖题目的特点；</p>
                      </li>
                      <li data-nodeid="8675">
                        <p data-nodeid="8676">对标数据结构/算法特点；</p>
                      </li>
                      <li data-nodeid="8677">
                        <p data-nodeid="8678">
                          将特点进行结合，创造出新的解法。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8679">
                      我们再将本讲介绍的题目进行一个总结和归纳，如下图所示：
                    </p>
                    <p data-nodeid="8680">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__1KAJ88RAAEz0wn26MU790.png"
                        alt="Drawing 25.png"
                        data-nodeid="10249"
                      />
                    </p>
                    <h3 data-nodeid="8681">思考题</h3>
                    <p data-nodeid="8682">
                      这里我再给你留了一下思考题：给定一个仅包含<code
                        data-backticks="1"
                        data-nodeid="10252"
                        >0</code
                      >和<code data-backticks="1" data-nodeid="10254">1</code
                      >、大小为<code data-backticks="1" data-nodeid="10256"
                        >rows x cols</code
                      >的二维二进制矩阵，找出只包含<code
                        data-backticks="1"
                        data-nodeid="10258"
                        >1</code
                      >的最大矩形，并返回其面积。
                    </p>
                    <blockquote data-nodeid="8683">
                      <p data-nodeid="8684">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10263"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10267"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="10271"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="127549" class="te-preview-highlight">
                      关于最大矩形这一道题，我们就介绍到这里。如果你发现这个题目还有新的特点，还能匹配到新的算法，那么有可能你还会发现新的解法哦。接下来我们将进入
                      17 | 深度思考子集：如何掌握 5 种通用解法？记得按时来探险。
                    </p>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >数据结构与算法面试宝典</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <!---->
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **阳
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      好难，有多少人看到这里了
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 685,
      courseCId: "",
      courseName: "数据结构与算法面试宝典",
      teachers: [
        {
          id: 630,
          teacherName: "德鲁伊",
          position: "前微软资深软件工程师",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span class="ql-author-13568064 ql-font-microsoftyahei" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto; background-color: rgb(255, 255, 255);">9&nbsp;年技术研发经验，主导过&nbsp;40PB&nbsp;级别的分布式存储系统架构设计与实现。带领团队实现核心模块，如用户态文件系统、存储引擎、分布式&nbsp;KV&nbsp;缓存。负责部门技术面试，有丰富的技术面试经验。此外，曾</span><span class="ql-font-microsoftyahei ql-author-13568064" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto;">作为复旦大学特聘讲师，面向研究生学院开展 IT 类课程，拥有多年授课经验。擅长架构设计、机器学习、云计算、大数据等领域。</span></span></p>',
        },
      ],
      totalCourseTime: 23,
      totalDuration: 340,
      sales: 18623,
      price: "98",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
      sellGoodsId: 748,
      sellGoodsPriceId: 73322,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。",
      seoKeywords:
        "数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季",
      seoTitle: "数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育",
      shareTitle: "这15种题型，算法面试肯定会问！",
      shareDescription: "300+高频真题详解，一题多解攻克算法面试",
      brief: "300+大厂高频真题，一题多解攻克算法面试",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png",
      courseType: 1,
      previewFirstField: "共23讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 638,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 638,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "83ec46930d5245bcae30be7a5f7786a2"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
</body>
