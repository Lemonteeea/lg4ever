<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">数据结构与算法面试宝典 - 拉勾教育</h1>

  <meta
    content="数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季"
    name="keywords"
  />

  <meta
    content="数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。"
    name="description"
  />

  <title>数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  数据结构与算法面试宝典
                </div>
                <div data-v-5f686215="" class="name">
                  德鲁伊
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  前微软资深软件工程师
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 |&nbsp;告别盲目刷题，击破算法面试
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 759px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：数据结构之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 栈：从简单栈到单调栈，解决经典栈问题
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 队列：FIFO 队列与单调队列的深挖与扩展
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 优先级队列：堆与优先级队列，筛选最优元素
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 树：如何深度运用树的遍历？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 并查集：如何利用两行代码写并查集？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          加餐与答疑 | 第一期 ：一问一答
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：算法之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08&nbsp;|
                          排序：如何利用合并与快排的小技巧，解决算法难题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10&nbsp;|
                          双指针：如何掌握最长、定长、最短区间问题的解题决窍？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12&nbsp;|
                          回溯：我把回溯总结成一个公式，回溯题一出就用它
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | DP：我是怎么治好“DP&nbsp;头痛症”的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：一题多解篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19&nbsp;|
                          最小体力消耗路径：如何突破经典题型，掌握解题模板？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20&nbsp;| 5
                          种解法，如何利用常量空间求解最长有效括号长度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21&nbsp;| 安排会议室：如何利用多种方法安排会议室？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：代码模板篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 |&nbsp;数据结构模板：如何让解题变成搭积木？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    彩蛋
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 |&nbsp;算法的精进之路
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 146px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/04/29
                  <span data-v-1605a430="" class="auth">德鲁伊</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/16:30"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="990"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/16:30</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">
                            43.06M
                          </div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/16:30
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="117342" class="">
                      今天，我们继续尝试从不同的角度（方法）来求解一个题目，通过“一题多解”的训练，拓展我们的思维。“<strong
                        data-nodeid="117595"
                        >搜索类型</strong
                      >”的题目一直是面试考察的重点，其变形非常广，不过万变不离其宗，大部分解题方法仍然逃不开
                      BFS/DFS 这两个框架。
                    </p>
                    <p data-nodeid="117343">
                      所以在本讲，我们将以一道经典的搜索题目为引，串联和使用前面学习过的各种知识点，比如：
                    </p>
                    <ul data-nodeid="117344">
                      <li data-nodeid="117345">
                        <p data-nodeid="117346">BFS/双向 BFS</p>
                      </li>
                      <li data-nodeid="117347">
                        <p data-nodeid="117348">DFS</p>
                      </li>
                      <li data-nodeid="117349">
                        <p data-nodeid="117350">Dijkstra</p>
                      </li>
                    </ul>
                    <p data-nodeid="117351">
                      具体介绍这类题目的分析和处理技巧，让你的面试得心应手。让我们马上开始。
                    </p>
                    <h3 data-nodeid="117352">题目</h3>
                    <p data-nodeid="117353">
                      字典 wordList 中单词 beginWord 和 endWord
                      的转换序列是一个按下述规则形成的序列：
                    </p>
                    <ul data-nodeid="117354">
                      <li data-nodeid="117355">
                        <p data-nodeid="117356">
                          序列中第一个单词是 beginWord ；
                        </p>
                      </li>
                      <li data-nodeid="117357">
                        <p data-nodeid="117358">
                          序列中最后一个单词是 endWord，endWord 需要在 wordList
                          中；
                        </p>
                      </li>
                      <li data-nodeid="117359">
                        <p data-nodeid="117360">每次转换只能改变一个字母；</p>
                      </li>
                      <li data-nodeid="117361">
                        <p data-nodeid="117362">
                          转换过程中的中间单词必须是字典 wordList 中的单词。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117363">
                      给你两个单词 beginWord 和 endWord 和一个字典 wordList
                      ，找到从 beginWord 到 endWord 的最短转换序列中的单词数目
                      。如果不存在这样的转换序列，返回 0。
                    </p>
                    <p data-nodeid="117364">
                      输入：beginWord = "hit", endWord = "cog", wordList =
                      ["hot","dot","dog","lot","log","cog"]
                    </p>
                    <p data-nodeid="117365">输出：5</p>
                    <p data-nodeid="117366">
                      解释：一个最短转换序列是 "hit" → "hot" → "dot" → "dog" →
                      "cog"，返回它的长度 5。
                    </p>
                    <p data-nodeid="117367">首先，这里需要重点说一下条件：</p>
                    <ul data-nodeid="117368">
                      <li data-nodeid="117369">
                        <p data-nodeid="117370">beginWord != endWord；</p>
                      </li>
                      <li data-nodeid="117371">
                        <p data-nodeid="117372">
                          beginWord 可以不在 wordList 中；
                        </p>
                      </li>
                      <li data-nodeid="117373">
                        <p data-nodeid="117374">
                          endWord 必须要在 wordList 中，如果不在 wordList
                          中，那么需要返回 0；
                        </p>
                      </li>
                      <li data-nodeid="117375">
                        <p data-nodeid="117376">所有的单词长度都一样。</p>
                      </li>
                    </ul>
                    <h3 data-nodeid="117377">预处理</h3>
                    <p data-nodeid="117378">
                      拿到题目，我们要做的第一件事，应该是去<strong
                        data-nodeid="117677"
                        >挖掘题目中的隐含条件</strong
                      >。我们看到题目中有如下条件：
                    </p>
                    <ul data-nodeid="117379">
                      <li data-nodeid="117380">
                        <p data-nodeid="117381">每次转换只能改变一个字母；</p>
                      </li>
                      <li data-nodeid="117382">
                        <p data-nodeid="117383">
                          转换过程中的中间单词必须是 wordList 里面的单词。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117384">
                      如果将每一次的转换，看成是图中两个点的连接，题目的最终问题就是希望我们找到图中给定两个点的<strong
                        data-nodeid="117685"
                        >最短距离</strong
                      >。
                    </p>
                    <p data-nodeid="117385">
                      如果把单词看成图的点，那么对应图的边又是什么呢？
                    </p>
                    <blockquote data-nodeid="117386">
                      <p data-nodeid="117387">
                        注意：这里提到的图，都是指算法中的图 Graph，而不是图画
                        Picture。
                      </p>
                    </blockquote>
                    <h4 data-nodeid="117388">边的由来</h4>
                    <p data-nodeid="117389">
                      当我们有 word = "hit"，如果改变其中一个字母，就可以生成
                      "hat"。但是，我们立马发现 wordList =
                      ["hot","dot","dog","lot","log","cog"] 并不存在单词 "hat"。
                    </p>
                    <p data-nodeid="117390">
                      如果从图的角度来看，可以认为 &lt;"hit", "hat"&gt;
                      这条边不存在。那么接下来，我们再看一下成功的情况。
                    </p>
                    <p data-nodeid="117391">
                      当我们有 word = "hit"，如果改变一个字母，生成 "hot"，由于
                      wordList[0] == "hot"，因此，这种转换 "hit" ←→ "hot"
                      是合法的，那么，可以认为边 &lt;"hit", "hot"&gt; 是存在的。
                    </p>
                    <h4 data-nodeid="117392">边的无向性</h4>
                    <p data-nodeid="117393">
                      对于单词转换来说，当 word="hit" 可以转换成 "hot"
                      的时候，那么反过来 "hot" 也可以转换为
                      "hit"。因此，当我们得到一条边的时候，这条边就是一条无向边。
                    </p>
                    <p data-nodeid="117394">
                      接下来我们再分析一下这类题的考点。
                    </p>
                    <h4 data-nodeid="117395">考点</h4>
                    <p data-nodeid="117396">
                      在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="117795"
                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a
                      >”中，我们学习的大部分关于“<strong data-nodeid="117801"
                        >图</strong
                      >”的题目，都是明确地知道图的边，或者题目中给出了图的边。
                    </p>
                    <p data-nodeid="117397">
                      但是，在这个题中，并没有明确地给出图的边。所有的边都需要依赖一定的条件动态生成。我们可以利用伪代码，表示边的生成，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">for</span> word in Graph:
</div></li><li><div class="code-word">    startPoint = word <span class="hljs-comment">// 图中边起始点</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> c in word:
</div></li><li><div class="code-word">        oldChar = c
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> toChar in <span class="hljs-string">'a'</span>~<span class="hljs-string">'z'</span>:
</div></li><li><div class="code-word">             c = toChar
</div></li><li><div class="code-word">             endPoint = word
</div></li><li><div class="code-word">             <span class="hljs-keyword">if</span> endPoint in wordList:
</div></li><li><div class="code-word">                 <span class="hljs-comment">// 于是得到一条无向边 &lt;startPoint, endPoint&gt;</span>
</div></li><li><div class="code-word">        c = oldChar
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="117399">
                      有了图的重建，再给定输入，代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">beginWord = <span class="hljs-string">"hit"</span>
</div></li><li><div class="code-word">endWord = <span class="hljs-string">"cog"</span>
</div></li><li><div class="code-word">wordList = [<span class="hljs-string">"hot"</span>,<span class="hljs-string">"dot"</span>,<span class="hljs-string">"dog"</span>,<span class="hljs-string">"lot"</span>,<span class="hljs-string">"log"</span>,<span class="hljs-string">"cog"</span>]
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="117401">
                      经过上述操作，就可以得到题目中图的表示：
                    </p>
                    <p data-nodeid="127862">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3B/FB/Cgp9HWCHz-KAVAogAADx9Asf9G0216.png"
                        alt="Drawing 0.png"
                        data-nodeid="127865"
                      />
                    </p>

                    <h4 data-nodeid="117404">转换</h4>
                    <p data-nodeid="117405">
                      如何利用字符串表示图中的点，就需要两个字符串来表示一条边。为了压缩这部分信息，我们采用整数来表示字符串。优点有以下几个方面。
                    </p>
                    <ul data-nodeid="117406">
                      <li data-nodeid="117407">
                        <p data-nodeid="117408">
                          字符串的处理不方便，必须使用哈希表。如果是整数表示图中的点，那么我们可以使用数组记录点的信息。
                        </p>
                      </li>
                      <li data-nodeid="117409">
                        <p data-nodeid="117410">字符串的运算速度没有整数快。</p>
                      </li>
                      <li data-nodeid="117411">
                        <p data-nodeid="117412">
                          我们在学习图算法的时候，大部分时候都是使用整数来表示图中的点，相对来说，对代码更加熟悉。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117413">
                      基于以上三个原因，我们决定将 String
                      表示一个点，转换为用整数表示一个点。转换的思想也比较简单：<strong
                        data-nodeid="117818"
                        >利用哈希表将不同的字符串映射到不同的整数上即可</strong
                      >。
                    </p>
                    <p data-nodeid="117414">
                      这里我们直接给出“建图”+“转换”的代码，如下所示（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; wordID = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">private</span> List&lt;Integer&gt; Graph[] = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(String beginWord,
</span></span></div></li><li><div class="code-word">                       String endWord,
</div></li><li><div class="code-word">                       List&lt;String&gt; wordList) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 首先如果单词一样：题目中给出了条件，这两个单词必须不一样</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (beginWord.compareTo(endWord) == <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-comment">// 需要记录每个单词的ID</span>
</div></li><li><div class="code-word">        wordID = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (String word: wordList) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (!wordID.containsKey(word)) {
</div></li><li><div class="code-word">                wordID.put(word, id++);
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-comment">// 根据题意：如果我们在wordList中找不到endWord必须要</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 返回0</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (!wordID.containsKey(endWord)) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果wordID中没有beginWord</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 那么把beginWord添加到wordID &amp; wordList中</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (!wordID.containsKey(beginWord)) {
</div></li><li><div class="code-word">            wordID.put(beginWord, id++);
</div></li><li><div class="code-word">            wordList.add(beginWord);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-comment">// 构建图</span>
</div></li><li><div class="code-word">        Graph = <span class="hljs-keyword">new</span> ArrayList[wordID.size()];
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordID.size(); i++) {
</div></li><li><div class="code-word">            Graph[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (String word: wordList) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 边的起始点 from</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> from = wordID.get(word);
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">            <span class="hljs-comment">// 看一下from能转变成什么</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">byte</span>[] wordBytes = word.getBytes();
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordBytes.length; i++) {
</div></li><li><div class="code-word">                <span class="hljs-keyword">byte</span> old = wordBytes[i];
</div></li><li><div class="code-word">                
</div></li><li><div class="code-word">                <span class="hljs-comment">// 改变成其他byte</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> toByte = <span class="hljs-string">'a'</span>; toByte &lt;= <span class="hljs-string">'z'</span>; toByte++) {
</div></li><li><div class="code-word">                    wordBytes[i] = toByte;
</div></li><li><div class="code-word">                    String toWord = <span class="hljs-keyword">new</span> String(wordBytes);
</div></li><li><div class="code-word">                    
</div></li><li><div class="code-word">                    <span class="hljs-keyword">if</span> (wordID.containsKey(toWord)) {
</div></li><li><div class="code-word">                        <span class="hljs-comment">// 边的终点to</span>
</div></li><li><div class="code-word">                        <span class="hljs-keyword">int</span> to = wordID.get(toWord);
</div></li><li><div class="code-word">                        <span class="hljs-comment">// 把这条边加到Graph中</span>
</div></li><li><div class="code-word">                        Graph[from].add(to);
</div></li><li><div class="code-word">                    }
</div></li><li><div class="code-word">                }
</div></li><li><div class="code-word">                
</div></li><li><div class="code-word">                wordBytes[i] = old;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord,
</span></span></div></li><li><div class="code-word">                            String endWord,
</div></li><li><div class="code-word">                            List&lt;String&gt; wordList) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 我们要写的核心代码在这里。</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果建图失败，说明无法找到有效解，依照题意，无解的时候</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 我们需要返回0</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (!buildGraph(beginWord, endWord, wordList)) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 接下来我们要讨论的重点代码，还没有写!</span>
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="117416">
                      <p data-nodeid="117417">
                        注意：在后文的代码中，我不再罗列 buildGraph
                        函数的详细代码，所有引用到 buildGraph
                        代码的地方，都是指这里的 buildGraph() 函数。
                      </p>
                    </blockquote>
                    <p data-nodeid="117418">当我们建好图之后，问题就变成：</p>
                    <ul data-nodeid="117419">
                      <li data-nodeid="117420">
                        <p data-nodeid="117421">给定一个无向图；</p>
                      </li>
                      <li data-nodeid="117422">
                        <p data-nodeid="117423">如何求图中两个点的最短距离。</p>
                      </li>
                    </ul>
                    <p data-nodeid="117424">
                      不过，根据题意，还需要注意题目要求输出的是“最短转换序列”：
                    </p>
                    <blockquote data-nodeid="117425">
                      <p data-nodeid="117426">
                        一个最短转换序列是 "hit" → "hot" → "dot" → "dog" →
                        "cog"，返回它的长度 5。
                      </p>
                    </blockquote>
                    <p data-nodeid="117427">
                      因此，最短序列等价于<strong data-nodeid="117856"
                        >最短路径上的点的个数。<strong data-nodeid="117855"
                          >而我们平时求的最短路径实际上是最短路径上</strong
                        >边的数目</strong
                      >。因此：
                    </p>
                    <blockquote data-nodeid="117428">
                      <p data-nodeid="117429">
                        最短转换序列长度 = 最短路径长度 + 1
                      </p>
                    </blockquote>
                    <p data-nodeid="117430">
                      那么，到这里，我们已经将陌生的题目成功转变成非常熟悉的问题：<strong
                        data-nodeid="117863"
                        >求图中两个点的最短距离</strong
                      >。
                    </p>
                    <p data-nodeid="117431">
                      接下来，我们看一下具体如何破解“最短路径”问题，其实我们在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="117867"
                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a
                      >”的“例 2 和例
                      4”都学习过，你可以返回去再复习一下，以便加深对这个经典问题的理解。
                    </p>
                    <h3 data-nodeid="117432">BFS 算法</h3>
                    <p data-nodeid="117433">
                      求两个点的最短路径的时候，我们可以直接用 BFS。为什么呢？
                    </p>
                    <p data-nodeid="117434">
                      你应该还记得，我们在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="117874"
                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a
                      >”中提到过 BFS 的特点：
                    </p>
                    <blockquote data-nodeid="117435">
                      <p data-nodeid="117436">
                        在搜索的时候，若想知道一些关于“最近/最快/最少”之类问题的答案，往往采用
                        BFS 更加适合。
                      </p>
                    </blockquote>
                    <p data-nodeid="117437">
                      因此，在这里，我们直接使用 BFS 算法。如果从 beginWord
                      开始搜索，那么 BFS
                      的搜索过程可以表达成一个“雷达波搜索”的样子——每一轮搜索都会往外扩散一圈。
                    </p>
                    <p data-nodeid="133148">
                      你可以结合下图展示的BFS 的搜索过程示意图进一步思考，我们从
                      beginWord = "hit" 开始搜索，直接到找到 endWord = "cog"
                      时停止。
                    </p>
                    <p data-nodeid="133149" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3B/FB/Cgp9HWCHz_6AAxR5AAE6U53LZ3U453.png"
                        alt="Drawing 1.png"
                        data-nodeid="133161"
                      />
                    </p>

                    <blockquote data-nodeid="117440">
                      <p data-nodeid="117441">
                        注：这里第 1 圈就是 hit 自身，蓝色圈表示 1 次搜索。
                      </p>
                    </blockquote>
                    <p data-nodeid="117442">
                      那么在写代码的时候，我们可以使用类似的技巧进行
                      BFS。在每一层，我们都使用一个 ArrayList
                      来表示。那么，可以写出基于 BFS
                      的代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// buildGraph的代码 ... 略...</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord,
</span></span></div></li><li><div class="code-word">                          String endWord,
</div></li><li><div class="code-word">                          List&lt;String&gt; wordList) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果建图失败，那么返回0</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (!buildGraph(beginWord, endWord, wordList)) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 接下来，我们就是在一个图中找到两个点的最近距离</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里采用BFS的方法</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> src = wordID.get(beginWord);
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dst = wordID.get(endWord);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里我们采用“两段击”的BFS的方式进行处理</span>
</div></li><li><div class="code-word">    List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">    cur.add(src);
</div></li><li><div class="code-word">    List&lt;Integer&gt; next = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 记录哪些点被访问过了</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[wordID.size()];
</div></li><li><div class="code-word">    vis[src] = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 初始步数</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (!cur.isEmpty()) {
</div></li><li><div class="code-word">      next.clear();
</div></li><li><div class="code-word">      step++;
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// 遍历当前层的点，然后放到next中</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (Integer curNode : cur) {
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果走到终点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (curNode == dst) {
</div></li><li><div class="code-word">          <span class="hljs-keyword">return</span> step;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (Integer nextNode : Graph[curNode]) {
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">          <span class="hljs-comment">// 遍历边curNode -&gt; nextNode</span>
</div></li><li><div class="code-word">          <span class="hljs-comment">// 如果这个点还没有被访问过</span>
</div></li><li><div class="code-word">          <span class="hljs-keyword">if</span> (!vis[nextNode]) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 那么放到next中</span>
</div></li><li><div class="code-word">            next.add(nextNode);
</div></li><li><div class="code-word">            vis[nextNode] = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">          }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// swap the 2 list</span>
</div></li><li><div class="code-word">      List&lt;Integer&gt; tmp = cur;
</div></li><li><div class="code-word">      cur = next;
</div></li><li><div class="code-word">      next = tmp;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="117444">
                      <p data-nodeid="117445">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="117895"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="117899"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="117903"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="117446">
                      <strong data-nodeid="117908">复杂度分析</strong
                      >：（假设我们有 N 个单词，每个单词的长度为
                      M。每个单词需要更改每个位置的字母来生成新的单词）这里时间复杂度需要分为两步。
                    </p>
                    <p data-nodeid="117447">
                      <strong data-nodeid="117912">第一步：预处理建图</strong>
                    </p>
                    <h4 data-nodeid="137370" class="">1. 时间复杂度</h4>

                    <p data-nodeid="117451">
                      1）一共需要处理 N * M 个字母，每个字母要替换 26
                      次。替换之后生成的长度为 M
                      的新单词需要去哈希表中检验，每次去哈希表中检查一个单词需要的时间复杂度为
                      O(M)。
                    </p>
                    <p data-nodeid="117452">
                      2）建图<strong data-nodeid="117932">时间复杂度</strong>为
                      O(N * M * M * 26)，我们可以把常数 26
                      去掉，因此时间复杂度为 O(N * M * M)。
                    </p>
                    <h4 data-nodeid="139468" class="">2. 空间复杂度</h4>

                    <p data-nodeid="117456">
                      1）建图时需要建立一个有 N 个 Item，并且每个 Item 长度为 M
                      的哈希表。因此，哈希表空间复杂度为 O(N * M)。
                    </p>
                    <p data-nodeid="117457">
                      2）Graph 需要占用 O(N * N) 的空间。
                    </p>
                    <p data-nodeid="117458">
                      <strong data-nodeid="117943">第二步：BFS</strong>
                    </p>
                    <h4 data-nodeid="141562" class="">1. 时间复杂度</h4>

                    <p data-nodeid="117462">
                      在后面 BFS 搜索的过程中，由于<strong data-nodeid="117950"
                        >不会访问</strong
                      >已访问过的点，相当于所有的点被遍历一遍，所以时间复杂度为
                      O(N)。
                    </p>
                    <h4 data-nodeid="143652" class="">2. 空间复杂度</h4>

                    <p data-nodeid="117466">
                      最差情况下，需要把所有的点都放到 Array
                      中，此时空间复杂度为 O(N)。
                    </p>
                    <p data-nodeid="117467">
                      综上，整个问题的时间复杂度为 O(N * M * M)，空间复杂度为
                      O(max(N<sup>2</sup>, N * M))。
                    </p>
                    <h3 data-nodeid="117468">双向 BFS</h3>
                    <p data-nodeid="117469">
                      如果说前面的 BFS
                      是“一个人”苦苦地用雷达搜索（后文中称为单向
                      BFS），那么会不会存在从两个方向进行搜索的情况呢？我们尝试分析一下。如果要找的目标也用雷达开启搜索，那么当两者有交互的时候，就可以认为找到了最短路径。
                    </p>
                    <p data-nodeid="117470">
                      这种方法我们称为<strong data-nodeid="117971"
                        >双向 BFS</strong
                      >。两者的搜索过程如下图所示：
                    </p>
                    <p data-nodeid="145738">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/03/CioPOWCHz_iAeJHUAAE70Bz7hFs200.png"
                        alt="Drawing 2.png"
                        data-nodeid="145741"
                      />
                    </p>

                    <p data-nodeid="117472">
                      实际上，我们在写双向 BFS
                      的时候，两边不会同时开启搜索。而是<strong
                        data-nodeid="117980"
                        >采用一种策略：优先搜索范围更小的</strong
                      >。
                    </p>
                    <p data-nodeid="117473">主要原因在于：</p>
                    <ul data-nodeid="117474">
                      <li data-nodeid="117475">
                        <p data-nodeid="117476">
                          我们写算法的时候，往往不需要多线程；
                        </p>
                      </li>
                      <li data-nodeid="117477">
                        <p data-nodeid="117478">
                          优先搜索范围更小的，可以节省更多的内存，因为要存放的信息变少了。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117479">
                      基于这种双向 BFS
                      的想法，可以写出代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">
</div></li><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 省略 buildGraph的代码 ... </span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord,
</span></span></div></li><li><div class="code-word">                          String endWord,
</div></li><li><div class="code-word">                          List&lt;String&gt; wordList){
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果建图失败，那么返回0</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (!buildGraph(beginWord, endWord, wordList)) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 接下来，我们就是在一个图中找到两个点的最近距离</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里采用BFS的方法</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> srcNode = wordID.get(beginWord);
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dstNode = wordID.get(endWord);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里我们采用“两段击”的</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 双向BFS的方式来进行处理</span>
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里正向出发</span>
</div></li><li><div class="code-word">    Set&lt;Integer&gt; src = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
</div></li><li><div class="code-word">    src.add(srcNode);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里逆向出发</span>
</div></li><li><div class="code-word">    Set&lt;Integer&gt; dst = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
</div></li><li><div class="code-word">    dst.add(dstNode);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> srcVisTag = <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dstVisTag = <span class="hljs-number">2</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 记录哪些点被访问过了</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[wordID.size()];
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 通过不同的标号来标记点是被前序遍历过</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 还是被后序遍历过</span>
</div></li><li><div class="code-word">    vis[srcNode] = srcVisTag;
</div></li><li><div class="code-word">    vis[dstNode] = dstVisTag;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 初始步数</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (!src.isEmpty() &amp;&amp; !dst.isEmpty()) {
</div></li><li><div class="code-word">      step++;
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// 查看src与set是否相遇</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (Integer node : dst) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (src.contains(node)) {
</div></li><li><div class="code-word">          <span class="hljs-keyword">return</span> step;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// 哪边点更少，就更新哪一边</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> visTag = src.size() &lt; dst.size() ?
</div></li><li><div class="code-word">            srcVisTag : dstVisTag;
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">      Set&lt;Integer&gt; tmp = src.size() &lt; dst.size() ? src : dst;
</div></li><li><div class="code-word">      Set&lt;Integer&gt; next = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> startNode : tmp) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nextNode : Graph[startNode]) {
</div></li><li><div class="code-word">          <span class="hljs-keyword">if</span> (vis[nextNode] != visTag) {
</div></li><li><div class="code-word">            vis[nextNode] = visTag;
</div></li><li><div class="code-word">            next.add(nextNode);
</div></li><li><div class="code-word">          }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (src.size() &lt; dst.size()) {
</div></li><li><div class="code-word">        src = next;
</div></li><li><div class="code-word">      } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        dst = next;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="117481">
                      <p data-nodeid="117482">
                        代码<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="117988"
                          >：Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="117992"
                          >C+</a
                        ><a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="117995"
                          >+/Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="147826">
                      这里，我们将双向 BFS 与单向 BFS 进行一个比较，如下表所示：
                    </p>
                    <p data-nodeid="147827" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/03/CioPOWCH0CuAddFeAABSuMkK5zs509.png"
                        alt="Drawing 3.png"
                        data-nodeid="147831"
                      />
                    </p>

                    <p data-nodeid="117485">那么，双向 BFS 主要的优化在于：</p>
                    <ul data-nodeid="117486">
                      <li data-nodeid="117487">
                        <p data-nodeid="117488">
                          搜索时需要存放的信息更小了（因为搜索范围更小的优先），因此更加<strong
                            data-nodeid="118006"
                            >节省内存</strong
                          >；
                        </p>
                      </li>
                      <li data-nodeid="117489">
                        <p data-nodeid="117490">
                          由于要处理的信息变少了，那么查找起来也会<strong
                            data-nodeid="118012"
                            >更快</strong
                          >一些。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117491">
                      不过双向 BFS 还是在单向 BFS
                      上做常数上的优化。最差情况下，时间复杂度与空间复杂度仍然是在一个数量级的。
                    </p>
                    <h3 data-nodeid="117492">Dijkstra 算法</h3>
                    <p data-nodeid="117493">一般而言，最短路径问题，有三种：</p>
                    <ul data-nodeid="117494">
                      <li data-nodeid="117495">
                        <p data-nodeid="117496">
                          两点之间的最短路径（BFS 算法/Dijkstra 算法/BF
                          算法，即Bellman-Ford 算法）；
                        </p>
                      </li>
                      <li data-nodeid="117497">
                        <p data-nodeid="117498">
                          一个点到其他所有点的最短路径（Dijkstra 算法/BF
                          算法）；
                        </p>
                      </li>
                      <li data-nodeid="117499">
                        <p data-nodeid="117500">
                          <strong data-nodeid="118022">每两点</strong
                          >之间的最短路径（Floyd 算法）。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117501">
                      现在，我们先讨论一下，在计算两点间的最短路径的时候，什么时候应该使用
                      BFS 算法，什么时候应该使用 Dijkstra 算法？
                    </p>
                    <ul data-nodeid="117502">
                      <li data-nodeid="117503">
                        <p data-nodeid="117504">
                          当图中边的权重都是 1 的时候，最好的办法是使用 BFS
                          算法。
                        </p>
                      </li>
                      <li data-nodeid="117505">
                        <p data-nodeid="117506">
                          当图中边的权重非负的时候，最好的办法是使用 Dijkstra
                          算法。
                        </p>
                      </li>
                      <li data-nodeid="117507">
                        <p data-nodeid="117508">
                          当图中的边的权重存在负值的时候，最好的办法是采用 BF
                          算法。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117509">
                      实际上，我们可以将权重为 1
                      的时候，看成权重不同的特例。那么，这里我们应该也可以使用
                      Dijkstra 算法。根据 Dijkstra 算法的思路（“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="118030"
                        >03 | 优先级队列：堆与优先级队列，筛选最优元素</a
                      >”的“练习题 7”用到了 Dijkstra，以及“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="118034"
                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a
                      >”的“例 5”），我们可以写出代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// .. 省略 buildGraph函数代码 ...</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord,
</span></span></div></li><li><div class="code-word">                          String endWord,
</div></li><li><div class="code-word">                          List&lt;String&gt; wordList) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果建图失败，那么返回0</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (!buildGraph(beginWord, endWord, wordList)) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 接下来，我们就是在一个图中找到两个点的最近距离</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里采用BFS的方法</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> src = wordID.get(beginWord);
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> target = wordID.get(endWord);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 记录从src到各个点的距离</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[wordID.size()];
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dist.length; i++) {
</div></li><li><div class="code-word">      dist[i] = wordID.size() * wordID.size() + <span class="hljs-number">100</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    dist[src] = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// java小堆</span>
</div></li><li><div class="code-word">    Queue&lt;Integer&gt; Q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(
</div></li><li><div class="code-word">            (v1, v2) -&gt; dist[v1] - dist[v2]);
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">    Q.add(src);
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (!Q.isEmpty()) {
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startNode = Q.poll();
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startDist = dist[startNode];
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nextNode : Graph[startNode]) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextDist = startDist + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (dist[nextNode] &gt; nextDist) {
</div></li><li><div class="code-word">          dist[nextNode] = nextDist;
</div></li><li><div class="code-word">          Q.add(nextNode);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">   
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> dist[target] &gt; wordID.size() ?
</div></li><li><div class="code-word">        <span class="hljs-number">0</span> : dist[target] + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="117511">
                      <p data-nodeid="117512">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118039"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118043"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118047"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="117513">
                      <strong data-nodeid="118052">复杂度分析</strong
                      >：时间复杂度，由于 Dijkstra 算法的时间复杂度在有 N
                      个点的情况下，复杂度为
                      O(NlgN)。但是，整个题目的时间复杂度与空间复杂度仍然由
                      buildGraph 函数主导。与 BFS 的时间复杂度相同。
                    </p>
                    <p data-nodeid="117514">
                      我们再对 Dijkstra 算法做个小小的总结，在使用 Dijkstra
                      算法的时候，有以下特点：
                    </p>
                    <ul data-nodeid="117515">
                      <li data-nodeid="117516">
                        <p data-nodeid="117517">
                          并没有使用 vis 数组来进行标记；
                        </p>
                      </li>
                      <li data-nodeid="117518">
                        <p data-nodeid="117519">
                          而是当发现一个点的最小距离变得更小的时候，就需要放到优先级队列中，然后重新展开搜索。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117520">
                      本讲中，我们提到了 BF 算法。不过 BF 算法在有 N 个点，E
                      条边的情况下，时间复杂度会达到 O(N x
                      E)。在本题中，当单词长度为 M
                      时，最差情况下，一个单词可以有 M x 26
                      条边。一个图中的边可以达到 N x M x
                      26。此时，时间复杂度达到 O(N x N x M x
                      26)，会出现超时的情况。关于这种情况，你可以自己求解一下下面这道练习题，本讲不再详细讨论。
                    </p>
                    <p data-nodeid="117521">
                      <strong data-nodeid="118065">练习题 1</strong>：有 N
                      个网络结点，标记为 1 到 N。给定一个列表
                      times，表示信号经过有向边的传递时间。 times[i] = (u, v,
                      w)，其中 u 是源结点，v 是目标结点，w
                      是一个信号从源结点传递到目标结点的时间。
                    </p>
                    <p data-nodeid="117522">
                      现在，我们从某个结点 K
                      发出一个信号。需要多久才能使所有结点都收到信号？如果不能使所有结点收到信号，则返回
                      -1。
                    </p>
                    <blockquote data-nodeid="117523">
                      <p data-nodeid="117524">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118070"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118074"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118078"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h3 data-nodeid="117525">DFS 算法</h3>
                    <p data-nodeid="117526">
                      不知道你有没有从 Dijkstra 的算法中找到灵感？<strong
                        data-nodeid="118085"
                        >在遍历的时候，我们不再使用 vis
                        数组来记录一个点是否被访问，而是利用最小距离是否被更新作为条件</strong
                      >。
                    </p>
                    <p data-nodeid="117527">
                      那么在 DFS 的时候，是不是也可以这样操作？比如：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;Integer&gt; G[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span>[] dist)</span>
</span></div></li><li><div class="code-word">  {
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nextNode : G[start]) { <span class="hljs-comment">// 边：&lt;startNode-&gt;nextNode&gt;</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextDist = dist[start] + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (nextDist &lt; dist[nextNode]) { <span class="hljs-comment">// 如果发现距离被更新了</span>
</div></li><li><div class="code-word">        dist[nextNode] = nextDist;
</div></li><li><div class="code-word">        dfs(G, nextNode, dist);        <span class="hljs-comment">// 那么就从nextNode重新展开搜索</span>
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="117529">
                      那么，基于这种距离更新，就重新展开 DFS
                      的搜索方法，我们也可以写出新的 DFS
                      算法来解决这道题，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;Integer&gt; G[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span>[] dist)</span>
</span></div></li><li><div class="code-word">  {
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nextNode : G[start]) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextDist = dist[start] + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (nextDist &lt; dist[nextNode]) {
</div></li><li><div class="code-word">        dist[nextNode] = nextDist;
</div></li><li><div class="code-word">        dfs(G, nextNode, dist);
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// .. 省略 buildGraph函数的代码 ...</span>
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord,
</span></span></div></li><li><div class="code-word">                          String endWord,
</div></li><li><div class="code-word">                          List&lt;String&gt; wordList) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里构图</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (!buildGraph(beginWord, endWord, wordList)) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 分别设置好源点，终点</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> src = wordID.get(beginWord);
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dst = wordID.get(endWord);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 数组记录src点出发到其他点的最短距离</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[wordID.size()];
</div></li><li><div class="code-word">    <span class="hljs-comment">// 设置一个最大距离，表示无解</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> maxPathLength = wordID.size() + <span class="hljs-number">1024</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 初始化dist数组</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dist.length; i++) {
</div></li><li><div class="code-word">      dist[i] = maxPathLength;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    dist[src] = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// dfs搜索最优解</span>
</div></li><li><div class="code-word">    dfs(Graph, src, dist);
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> dist[dst] &gt;= maxPathLength ? <span class="hljs-number">0</span> : dist[dst] + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="117531">
                      <p data-nodeid="117532">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118091"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118095"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118099"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="117533">
                      <strong data-nodeid="118118">复杂度分析</strong
                      >：假设一共有 N
                      个点，那么最差情况下，每个点会被其他点最多更新 N
                      次。因此，最差时间复杂度为
                      O(N<sup>2</sup>)。但是就整个题目而言，时间复杂度由构建图
                      buildGraph 的部分主导。综上，时间复杂度为 O(N * M *
                      M)，空间复杂度为 O(max(N<sup>2</sup>N * M))。
                    </p>
                    <p data-nodeid="117534">
                      那么，接下来，我们考虑一下，Dijkstra 算法与 DFS
                      算法不同的地方。
                    </p>
                    <p data-nodeid="117535">
                      虽然 Dijkstra 与 DFS 都不会再用到 vis 数组，并且都在点
                      nextNode
                      的距离被更新，然后重新展开搜索。但是依然存在不同的地方。
                    </p>
                    <ul data-nodeid="117536">
                      <li data-nodeid="117537">
                        <p data-nodeid="117538">
                          Dijkstra 算法是从<strong data-nodeid="118126"
                            >优先级队列中拿出最优的点重新</strong
                          >展开搜索。而且Dijkstra
                          算法在用一个点更新的时候，会把这个点相邻的所有点更新之后，再重新展开搜索。
                        </p>
                      </li>
                      <li data-nodeid="117539">
                        <p data-nodeid="117540">
                          而 DFS 算法却是立马从点 nextNode 重新展开搜索。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="117541">
                      那么，有没有可能将 DFS
                      也改成Dijkstra这样呢？我们是不是发明了 DFS 也可以实现
                      Dijkstra 算法呢？基于这种思路，对 DFS
                      算法进行一下改写，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// .... 省略了 buildGraph() 函数的代码 ...</span>
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] dist = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 优先级队列</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; Q = 
</div></li><li><div class="code-word">       <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; dist[v1] - dist[v2]);
</div></li><li><div class="code-word">       
</div></li><li><div class="code-word">  <span class="hljs-comment">// DFS + priorityQueue</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (Q.isEmpty()) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startNode = Q.poll();
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nextNode : Graph[startNode]) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextDist = dist[startNode] + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (nextDist &lt; dist[nextNode]) {
</div></li><li><div class="code-word">        dist[nextNode] = nextDist;
</div></li><li><div class="code-word">        Q.add(nextNode);
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    dfs();
</div></li><li><div class="code-word">    <span class="hljs-comment">// 注意：我们要用startNode把所有的点都更新完之后</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 再重新展开DFS</span>
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord,
</span></span></div></li><li><div class="code-word">                          String endWord,
</div></li><li><div class="code-word">                          List&lt;String&gt; wordList) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (!buildGraph(beginWord, endWord, wordList)) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word"> 
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> src = wordID.get(beginWord);
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dst = wordID.get(endWord);
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">    <span class="hljs-comment">// 初始化距离数组</span>
</div></li><li><div class="code-word">    dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[wordID.size()];
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> maxPathLength = wordID.size() + <span class="hljs-number">1024</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dist.length; i++) {
</div></li><li><div class="code-word">      dist[i] = maxPathLength;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    dist[src] = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">    <span class="hljs-comment">// 优先级队列中放入src</span>
</div></li><li><div class="code-word">    Q.add(src);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 进行dfs</span>
</div></li><li><div class="code-word">    dfs();
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> dist[dst] &gt;= maxPathLength ? <span class="hljs-number">0</span> : dist[dst] + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="117543">
                      <p data-nodeid="117544">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118132"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118136"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118140"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="117545">
                      我们发现，经过上述处理的 DFS，本质上与 Dijkstra
                      算法是一样的。在这里，我们将不同的算法的特点加以迁移（从原本是
                      Dijkstra 的特点，迁移到 DFS
                      算法），让不同的算法可以取得同样的效果。
                    </p>
                    <h3 data-nodeid="117546">总结</h3>
                    <p data-nodeid="117547">
                      这一讲中，我们再次通过一个题目，挖掘了题目的信息+考点。
                    </p>
                    <ul data-nodeid="117548">
                      <li data-nodeid="117549">
                        <p data-nodeid="117550">
                          信息：需要通过一定的条件生成边。
                        </p>
                      </li>
                      <li data-nodeid="117551">
                        <p data-nodeid="117552">考点：两点的最短路径。</p>
                      </li>
                    </ul>
                    <p data-nodeid="149916">
                      当拿到这两部分信息之后，我们首先进行<strong
                        data-nodeid="149927"
                        >题目的预处理：建图</strong
                      >。通过建图，让题目回到了一个我们非常熟悉的知识点：两点最短路径。接来下就是<strong
                        data-nodeid="149928"
                        >匹配到了已经学过的各种知识点</strong
                      >，轮番上阵，也就展开了不同的破题方法。最后，我把这个题目中用到的知识点整理在下面这张思维导图中，你可以参考下图梳理一遍今天学到的重点知识。
                    </p>
                    <p data-nodeid="149917" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3B/FB/Cgp9HWCH0ESATdYbAAH54J1eIGc572.png"
                        alt="Drawing 4.png"
                        data-nodeid="149931"
                      />
                    </p>

                    <h3 data-nodeid="158271" class="">思考题</h3>

                    <p data-nodeid="117556">
                      我再给你留一道思考题：在本讲介绍的题目基础上，我们找到<strong
                        data-nodeid="118173"
                        >最短的转换序列的长度</strong
                      >之后。如果要输出<strong data-nodeid="118174">所有</strong
                      >的最短转换序列，应该怎么办呢？
                    </p>
                    <p data-nodeid="117557">
                      输入：beginWord = "hit", endWord = "cog", wordList =
                      ["hot","dot","dog","lot","log","cog"]
                    </p>
                    <p data-nodeid="117558">
                      输出：[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
                    </p>
                    <p data-nodeid="117559">解释：存在 2 种最短的转换序列：</p>
                    <p data-nodeid="117560">
                      "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"
                    </p>
                    <p data-nodeid="117561">
                      "hit" -&gt; "hot" -&gt; "lot" -&gt; "log" -&gt; "cog"
                    </p>
                    <blockquote data-nodeid="117562">
                      <p data-nodeid="117563">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118297"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118301"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="118305"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="117564">
                      你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于单词转换的题目就介绍到这里。接下来，下一讲介绍“19
                      |
                      最小体力消耗路径：如何突破经典题型，掌握解题模板”，让我们继续前进。
                    </p>
                    <h3 data-nodeid="117565">附录：题目出处和代码汇总</h3>
                    <table data-nodeid="160352">
                      <thead data-nodeid="160353">
                        <tr data-nodeid="160354">
                          <th align="center" data-nodeid="160356">题目</th>
                          <th data-nodeid="160357">
                            <a
                              href="https://leetcode-cn.com/problems/word-ladder/?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160374"
                              >测试链接</a
                            >
                          </th>
                          <th align="center" data-nodeid="160358">
                            BFS代码：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160378"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160382"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160386"
                              >Python</a
                            ><br />双向 BFS代码<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160391"
                              >：Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160395"
                              >C+</a
                            ><a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160398"
                              >+/Python</a
                            ><br />Dijkstra代码：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160403"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160407"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160411"
                              >Python</a
                            ><br />DFS + Q代码：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160416"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160420"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160424"
                              >Python</a
                            >
                          </th>
                        </tr>
                      </thead>
                      <tbody data-nodeid="160362">
                        <tr data-nodeid="160363">
                          <td align="center" data-nodeid="160364">练习题 1</td>
                          <td data-nodeid="160365">
                            <a
                              href="https://leetcode-cn.com/problems/network-delay-time/?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160428"
                              >测试链接</a
                            >
                          </td>
                          <td align="center" data-nodeid="160366">
                            代码：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160432"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160436"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160440"
                              >Python</a
                            >
                          </td>
                        </tr>
                        <tr data-nodeid="160367">
                          <td align="center" data-nodeid="160368">思考题</td>
                          <td data-nodeid="160369">
                            <a
                              href="https://leetcode-cn.com/problems/word-ladder-ii/?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160444"
                              >测试链接</a
                            >
                          </td>
                          <td align="center" data-nodeid="160370">
                            代码：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160448"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160452"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="160456"
                              >Python</a
                            >
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >数据结构与算法面试宝典</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <!---->
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **炜
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        1
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      比较了BFS、双向BFS、Dijkstra、DFS几种算法的区别和联系，有助于加深对算法的理解，非常感谢！
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **威
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        1
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      赞👍
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 685,
      courseCId: "",
      courseName: "数据结构与算法面试宝典",
      teachers: [
        {
          id: 630,
          teacherName: "德鲁伊",
          position: "前微软资深软件工程师",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span class="ql-author-13568064 ql-font-microsoftyahei" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto; background-color: rgb(255, 255, 255);">9&nbsp;年技术研发经验，主导过&nbsp;40PB&nbsp;级别的分布式存储系统架构设计与实现。带领团队实现核心模块，如用户态文件系统、存储引擎、分布式&nbsp;KV&nbsp;缓存。负责部门技术面试，有丰富的技术面试经验。此外，曾</span><span class="ql-font-microsoftyahei ql-author-13568064" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto;">作为复旦大学特聘讲师，面向研究生学院开展 IT 类课程，拥有多年授课经验。擅长架构设计、机器学习、云计算、大数据等领域。</span></span></p>',
        },
      ],
      totalCourseTime: 23,
      totalDuration: 340,
      sales: 18623,
      price: "98",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
      sellGoodsId: 748,
      sellGoodsPriceId: 73322,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。",
      seoKeywords:
        "数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季",
      seoTitle: "数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育",
      shareTitle: "这15种题型，算法面试肯定会问！",
      shareDescription: "300+高频真题详解，一题多解攻克算法面试",
      brief: "300+大厂高频真题，一题多解攻克算法面试",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png",
      courseType: 1,
      previewFirstField: "共23讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 638,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 638,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "83ec46930d5245bcae30be7a5f7786a2"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
</body>
