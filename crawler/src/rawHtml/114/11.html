<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">数据结构与算法面试宝典 - 拉勾教育</h1>

  <meta
    content="数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季"
    name="keywords"
  />

  <meta
    content="数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。"
    name="description"
  />

  <title>数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  数据结构与算法面试宝典
                </div>
                <div data-v-5f686215="" class="name">
                  德鲁伊
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  前微软资深软件工程师
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 |&nbsp;告别盲目刷题，击破算法面试
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 759px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：数据结构之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 栈：从简单栈到单调栈，解决经典栈问题
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 队列：FIFO 队列与单调队列的深挖与扩展
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 优先级队列：堆与优先级队列，筛选最优元素
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 树：如何深度运用树的遍历？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 并查集：如何利用两行代码写并查集？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          加餐与答疑 | 第一期 ：一问一答
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：算法之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08&nbsp;|
                          排序：如何利用合并与快排的小技巧，解决算法难题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10&nbsp;|
                          双指针：如何掌握最长、定长、最短区间问题的解题决窍？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12&nbsp;|
                          回溯：我把回溯总结成一个公式，回溯题一出就用它
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | DP：我是怎么治好“DP&nbsp;头痛症”的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：一题多解篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19&nbsp;|
                          最小体力消耗路径：如何突破经典题型，掌握解题模板？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20&nbsp;| 5
                          种解法，如何利用常量空间求解最长有效括号长度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21&nbsp;| 安排会议室：如何利用多种方法安排会议室？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：代码模板篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 |&nbsp;数据结构模板：如何让解题变成搭积木？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    彩蛋
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 |&nbsp;算法的精进之路
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 146px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/03/29
                  <span data-v-1605a430="" class="auth">德鲁伊</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/40:08"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="2408"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/40:08</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">
                            104.66M
                          </div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/40:08
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="323100" class="">
                      二分搜索在工程中有很多的应用，比如：操作系统、MySQL
                      、Hadoop、Spark，查找数据的时候都会用到二分搜索。
                    </p>
                    <p data-nodeid="323101">
                      今天我们主要介绍如何使用两个简单的二分搜索模板，搞定所有的二分题目。你将收获：
                    </p>
                    <ul data-nodeid="323102">
                      <li data-nodeid="323103">
                        <p data-nodeid="323104">二分搜索的两个标准模板</p>
                      </li>
                      <li data-nodeid="323105">
                        <p data-nodeid="323106">二分搜索的提问破题法</p>
                      </li>
                      <li data-nodeid="323107">
                        <p data-nodeid="323108">二分搜索的切分法</p>
                      </li>
                    </ul>
                    <p data-nodeid="323109">
                      掌握这些知识点，足够应对面试中出现的二分搜索题了。Let's
                      GO！
                    </p>
                    <h3 data-nodeid="323110">二分搜索基础</h3>
                    <p data-nodeid="323111">
                      二分搜索的目的是在一个有序的数组 A
                      里面，找到一个给定的数。比如我们想要在下面的数组里面查找
                      target=3。（<strong data-nodeid="323523"
                        >小写字母 l 与 1 不太容易区分，文中都用大写 L
                        来表示。但是在图片和代码中，仍然用小写。</strong
                      >）
                    </p>
                    <p data-nodeid="323112">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdnQ2ADowqABN13BB0LLU138.gif"
                        alt="1.gif"
                        data-nodeid="323526"
                      />
                    </p>
                    <p data-nodeid="323113">
                      【<strong data-nodeid="323532">代码</strong
                      >】这里我们一起来复习一下这段代码（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] A, <span class="hljs-keyword">long</span> target)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || A.length == <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 首先设定初始区间，这里我们采用开闭原则[l, r)</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = A.length;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 循环结束的判断条件是整个区间为空区间，那么运行结束。</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 我们使用的是开闭原则来表示一个区间，所以当l &lt; r的时候</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 我们要查找的区间还不是一个空区间。</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[m] == target) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[m] &lt; target) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 当中点比目标值小时，需要把左边的部分扔掉。即[l, m]</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 这个区间扔掉，由于我们采用的是开闭原则，所以新的区间需要是</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// [m + 1, r), 因引需要将l = m + 1</span>
</div></li><li><div class="code-word">      l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 当中点比目标值大时，需要把右边的部分扔掉，即[m, r)这个区间扔掉。</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 那么新区间变成[l, m)。由于我们使用的是开闭原则，</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 只需要设置r = m即可。</span>
</div></li><li><div class="code-word">      r = m;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323115">
                      <p data-nodeid="323116">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323536"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323540"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323544"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323117">
                      <strong data-nodeid="323549">复杂度分析</strong
                      >：在实行二分查找时，由于每次我们都会扔掉一半的数据，所以总共只需要
                      O(lgn)的时间复杂度，空间复杂度是 O(1)。
                    </p>
                    <p data-nodeid="323118">
                      【<strong data-nodeid="323558">小结</strong
                      >】虽然二分搜索是一个非常基础的题目，但作为面试官，我看到很多候选人一不小心就栽在它上面。因此，这里我需要重点强调一下二分搜索里面的<strong
                        data-nodeid="323559"
                        >几个关键考点。</strong
                      >
                    </p>
                    <p data-nodeid="323119">
                      <strong data-nodeid="323574">1. 开闭原则</strong
                      >，开闭原则是一段区间的表示法。你一定要注意，写二分搜索的时候，每一个区间的表示都是<strong
                        data-nodeid="323575"
                        >严格按照开闭原则进行</strong
                      >的。这是面试中一个<strong data-nodeid="323576"
                        >非常重要的考点</strong
                      >（敲黑板，我待过的几家公司都喜欢考察）。
                    </p>
                    <p data-nodeid="323120">
                      <strong data-nodeid="323583">2. 区间的变化</strong
                      >，要深度理解区间的三种情况：
                    </p>
                    <p data-nodeid="323121">
                      1）扔掉左区间为什么是 L = M + 1，扔掉右区间为什么是 R =
                      M；
                    </p>
                    <p data-nodeid="323122">
                      2）为什么一个 L 要加 1，一个 R 不加 1；
                    </p>
                    <p data-nodeid="323123">
                      3）为什么循环的条件需要是 L &lt; R。
                    </p>
                    <p data-nodeid="323124">
                      <strong data-nodeid="323595">3. 代码流畅度</strong
                      >，这已经是一个非常非常基础的算法了，如果你在写代码的时候还会出现卡壳，那么我建议你思考以下两个问题：
                    </p>
                    <p data-nodeid="323125">
                      1）是否真的深度理解开闭原则在二分搜索里面的体现？
                    </p>
                    <p data-nodeid="323126">2）是否真的记住这个代码模板了？</p>
                    <p data-nodeid="323127">
                      这里请你思考，或者说再联想一下，其他算法是否深度依赖<strong
                        data-nodeid="323603"
                        >开闭原则</strong
                      >呢？
                    </p>
                    <p data-nodeid="323128">
                      根据条件，在运行过程中，不断<strong data-nodeid="323609"
                        >扔掉一半数据</strong
                      >，然后在剩下的一半数据进行查找的算法还有哪些？这里我简单罗列了一下，如下图所示：
                    </p>
                    <p data-nodeid="323129">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdnTWAWu8YAADoiX1uAos462.png"
                        alt="Drawing 1.png"
                        data-nodeid="323612"
                      />
                    </p>
                    <p data-nodeid="323130">
                      你还能做进一步的补充吗？在学习的过程中，一定要有意识地让新的知识与旧的知识产生联系。上图展示的是一种广度拓展，接下来我们来看一下深度拓展。
                    </p>
                    <h4 data-nodeid="323131">例 1：有序数组中最左边的元素</h4>
                    <p data-nodeid="323132">
                      【<strong data-nodeid="323620">题目</strong
                      >】给定一个有序数组，返回指定元素在数组的最左边的位置
                    </p>
                    <p data-nodeid="323133">
                      输入：A = [1, 2, 2, 2, 2, 3, 3], target = 2
                    </p>
                    <p data-nodeid="323134">输出：1</p>
                    <p data-nodeid="323135">
                      解释：第一个出现的 2 位于下标
                      1，是从左往右看时，第一个出现 2 的位置。
                    </p>
                    <p data-nodeid="323136">
                      【<strong data-nodeid="323641">分析</strong
                      >】我曾经在很多公司的电面中遇到过这个题目。其实它并不难，本质上，是一个<strong
                        data-nodeid="323642"
                        >模板题</strong
                      >，是我们解决后续问题的基础，你需要<strong
                        data-nodeid="323643"
                        >非常牢固地理解并且记忆它的代码</strong
                      >。否则你的二分搜索就是“沙上建塔”。
                    </p>
                    <p data-nodeid="323137">
                      这道题目可能会存在一些<strong data-nodeid="323649"
                        >变形</strong
                      >，比如：“找到有序数组中第一个出现的
                      2”，或者“找到数组中最后一个出现的 2”。
                    </p>
                    <p data-nodeid="323138">
                      一个<strong data-nodeid="323655">不正确的回答</strong
                      >是：“先利用二分找到一个
                      2，然后再向左右两边搜索”。但是这么一来，时间复杂度就变成
                      O(N)。
                    </p>
                    <p data-nodeid="323139">
                      那么有没有办法降低复杂度呢？这里我们一起来看一下在二分搜索的基础上，<strong
                        data-nodeid="323661"
                        >如何找到最左边的元素</strong
                      >。我们还是先模拟一把。
                    </p>
                    <p data-nodeid="323140">
                      <strong data-nodeid="323667">1. 模拟</strong>
                    </p>
                    <p data-nodeid="323141">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/B7/CioPOWBdnUqAayqLABLk-NmvXA0875.gif"
                        alt="2.gif"
                        data-nodeid="323670"
                      />
                    </p>
                    <p data-nodeid="323142">
                      <strong data-nodeid="323676">2. 规律</strong>
                    </p>
                    <p data-nodeid="323143">
                      我们看一下上面模拟的目的已经变为：找到一个<strong
                        data-nodeid="323692"
                        >最终切分点 L</strong
                      >，需要满足 [0, L) 区间里面的元素都必须小于 target，而 [L,
                      ~) 右边的元素都 &gt;= target。<strong data-nodeid="323693"
                        >左边界操作原则如下</strong
                      >：
                    </p>
                    <ul data-nodeid="323144">
                      <li data-nodeid="323145">
                        <p data-nodeid="323146">
                          查找的区间一直是一个左开右闭区间 [L, R)；
                        </p>
                      </li>
                      <li data-nodeid="323147">
                        <p data-nodeid="323148">
                          每次总是把 &gt;= target 的区间扔掉，<strong
                            data-nodeid="323702"
                            >大于等于的不要了，然后设置 R = M</strong
                          >；
                        </p>
                      </li>
                      <li data-nodeid="323149">
                        <p data-nodeid="323150">
                          当最后的区间元素都小于 target 的时候，移动 L，<strong
                            data-nodeid="323708"
                            >小于的也不要了，然后设置 L = M + 1</strong
                          >。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323151">
                      可以总结为“<strong data-nodeid="323714"
                        >这也不要，那也不要”</strong
                      >。
                    </p>
                    <p data-nodeid="323152">
                      那么当程序最终执行结束的时候，L 必然处于以下情况之一。
                    </p>
                    <ul data-nodeid="323153">
                      <li data-nodeid="323154">
                        <p data-nodeid="323155">
                          如果有序数组中<strong data-nodeid="323721"
                            >存在 target</strong
                          >，那么必然找到最左边的 target
                          的位置。也就是我们模拟的情况，找到最左边的第一个 2。
                        </p>
                      </li>
                      <li data-nodeid="323156">
                        <p data-nodeid="323157">
                          如果有序数组中<strong data-nodeid="323727"
                            >不存在 target</strong
                          >，那么：
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323158">
                      1）当数组中的元素都比 target 小时，L
                      指向数组的长度，此时访问 A[L] 非法；
                    </p>
                    <p data-nodeid="323159">2）否则，A[L] 必然 &gt; target。</p>
                    <p data-nodeid="323160">
                      可以总结为“<strong data-nodeid="323743"
                        >要么越界，要么大于等于 target</strong
                      >”。
                    </p>
                    <p data-nodeid="323161">
                      <strong data-nodeid="323749">3. 匹配</strong>
                    </p>
                    <p data-nodeid="323162">
                      如果仔细一点，可以发现，这里我们在二分的时候，与传统的二分搜索相比，只是去掉了如下这个条件，最终就可以让
                      L 指到正确的位置。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">if</span> (A[m] == target) {
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323164">
                      <strong data-nodeid="323756">4. 边界</strong>
                    </p>
                    <p data-nodeid="323165">实际上还有几种边界情况需要讨论：</p>
                    <ul data-nodeid="323166">
                      <li data-nodeid="323167">
                        <p data-nodeid="323168">空数组，或长度为 0 的数组；</p>
                      </li>
                      <li data-nodeid="323169">
                        <p data-nodeid="323170">数组中的元素都小于 target；</p>
                      </li>
                      <li data-nodeid="323171">
                        <p data-nodeid="323172">数组中的元素都大于 target；</p>
                      </li>
                      <li data-nodeid="323173">
                        <p data-nodeid="323174">
                          数组中的元素有大有小，但是 target 不存在里面；
                        </p>
                      </li>
                      <li data-nodeid="323175">
                        <p data-nodeid="323176">
                          数组中的元素只有一个 target。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323177">
                      以上这些边界都很重要，由于篇幅的原因，这里我不再详细展开。你可以自己找到一些例子来试一下“<strong
                        data-nodeid="323768"
                        >左边界操作原则</strong
                      >”。
                    </p>
                    <p data-nodeid="323178">
                      <strong data-nodeid="323777">面试官的建议</strong
                      >：<strong data-nodeid="323778">真实的面试中</strong
                      >，很多人写的二分搜索的代码，经常卡在上面这几种边界上。因此，在面试中写完代码之后，主动写上测试用例是一个加分项。
                    </p>
                    <p data-nodeid="323179">
                      【<strong data-nodeid="323788">代码</strong>】<strong
                        data-nodeid="323789"
                        >模板代码</strong
                      >如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] A, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> target)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[m] &lt; target) {
</div></li><li><div class="code-word">      l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      r = m;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> l;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323181">
                      <p data-nodeid="323182">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323793"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323797"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323801"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323183">
                      <strong data-nodeid="323806">复杂度分析</strong
                      >：我们总是利用二分搜索一直进行下去，直接找到目标解。因此，算法的时间复杂度为
                      O(lgn)，空间复杂度为 O(1)。
                    </p>
                    <p data-nodeid="323184">
                      【<strong data-nodeid="323812">小结</strong
                      >】代码虽然短，但是我在面试候选人的时候，发现大家很容易写错这块代码。下面我给你总结一下面试时的考点。
                    </p>
                    <p data-nodeid="323185">
                      <strong data-nodeid="323817">面试考察点</strong>：
                    </p>
                    <ul data-nodeid="323186">
                      <li data-nodeid="323187">
                        <p data-nodeid="323188">
                          循环什么时候终止？（对应代码第 3 行）
                        </p>
                      </li>
                      <li data-nodeid="323189">
                        <p data-nodeid="323190">
                          什么情况下更新左边界？如何更新的？（对应代码第 5~6
                          行）
                        </p>
                      </li>
                      <li data-nodeid="323191">
                        <p data-nodeid="323192">
                          什么情况下更新右边界？如何更新的？（对应代码第 7~8
                          行）
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323193">
                      所有这些问题的本质，都可以归结到一个知识点：<strong
                        data-nodeid="323830"
                        >开闭原则</strong
                      >。
                    </p>
                    <p data-nodeid="323194">
                      <strong data-nodeid="323834">变形与延伸：</strong>
                    </p>
                    <p data-nodeid="323195">
                      如果我们有了 lowerBound 函数，就可以利用 lowerBound
                      函数来写新的 binarySearch 算法了。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] A, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> target)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> l = lowerBound(A, n, target);
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> l &lt; n &amp;&amp; A[l] == target;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323197">
                      实际上，在 C++ 的 STL 库里面的 binary_search
                      函数就是通过这种方式实现的。
                    </p>
                    <p data-nodeid="323198">
                      接下来我们看第二个模板 upperBound，它的要求是：写一个函数
                      upperBound 寻找数组中给定元素的上界。注意，上界是刚好比
                      target 大的那个元素的位置。比如 A = [1, 1, 100,
                      100]，target = 1，那么 upperBound 应该返回下标 2。
                    </p>
                    <p data-nodeid="323199">
                      upperBound 函数是找一个切分点 y，使得：
                    </p>
                    <ul data-nodeid="323200">
                      <li data-nodeid="323201">
                        <p data-nodeid="323202">
                          所有 [0, y) 左区间里面的元素 &lt;= target
                        </p>
                      </li>
                      <li data-nodeid="323203">
                        <p data-nodeid="323204">
                          target &lt; 所有 [y, ~) 右区间里面的元素
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323205">
                      根据 upperBound 的目标，我们需要调整一下二分的策略：
                    </p>
                    <ul data-nodeid="323206">
                      <li data-nodeid="323207">
                        <p data-nodeid="323208">
                          当 A[M] &lt;= target 的时候，需要把 [L, M]
                          区间扔掉。此时需要设置 L = M + 1；
                        </p>
                      </li>
                      <li data-nodeid="323209">
                        <p data-nodeid="323210">
                          当 A[M] &gt; target 的时候，需要把 (M, R)
                          区间扔掉。此时需要设置 R = M。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323211">
                      那么我们可以写出<strong data-nodeid="323879"
                        >模板代码</strong
                      >如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upperBound</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] A, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> target)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[m] &lt;= target) {
</div></li><li><div class="code-word">      l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      r = m;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> l;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323213">
                      <p data-nodeid="323214">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1562.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323883"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1562.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323887"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1562.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323891"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323215">
                      到现在为止，我们已经收获了<strong data-nodeid="323897"
                        >两个模板代码</strong
                      >：
                    </p>
                    <ul data-nodeid="323216">
                      <li data-nodeid="323217">
                        <p data-nodeid="323218">
                          lowerBound，可以用来顺便解决掉 binarySearch；
                        </p>
                      </li>
                      <li data-nodeid="323219">
                        <p data-nodeid="323220">upperBound。</p>
                      </li>
                    </ul>
                    <p data-nodeid="323221">
                      <strong data-nodeid="323916">重要</strong
                      >：在准备面试前，一定要<strong data-nodeid="323917"
                        >理解并且熟记</strong
                      >这两个模板代码。有个小技巧，其实 lowerBound 与 upperBound
                      代码是完全一样的。<strong data-nodeid="323918"
                        >唯一</strong
                      >不一样的是 A[m] 与 target 比较的时候：
                    </p>
                    <ul data-nodeid="323222">
                      <li data-nodeid="323223">
                        <p data-nodeid="323224">
                          lowerBound 是 A[m] &lt; target
                        </p>
                      </li>
                      <li data-nodeid="323225">
                        <p data-nodeid="323226">
                          upperBound 是 A[m] &lt;= target
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323227">
                      如果熟练地掌握了这两个模板，那么已经有一些题目就可以轻松解决了，这里我给你留了
                      2 道练习题，帮你巩固下这个知识点。
                    </p>
                    <p data-nodeid="323228">
                      <strong data-nodeid="323938">练习题 1</strong
                      >：给定一个有序数组和一个数
                      target，请返回起始位置和终止位置。
                    </p>
                    <blockquote data-nodeid="323229">
                      <p data-nodeid="323230">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323942"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323946"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323950"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323231">
                      <strong data-nodeid="323955">练习题 2</strong
                      >：给定一个有序数组，如果要将一个数
                      target，插入到数组中，结果仍然有序。返回插入位置。
                    </p>
                    <blockquote data-nodeid="323232">
                      <p data-nodeid="323233">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323959"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323963"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="323967"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323234">
                      这里我们就这两个模板做个简单的小结：
                    </p>
                    <p data-nodeid="323235">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/27/B8/CioPOWBdnWuAHlaZAACvdO-eOpY916.png"
                        alt="Drawing 3.png"
                        data-nodeid="323971"
                      />
                    </p>
                    <p data-nodeid="323236">
                      接下来我们看一下一些藏得比较“深”，但是可以用二分搜索来破解的题。
                    </p>
                    <h3 data-nodeid="323237">提问破题法</h3>
                    <p data-nodeid="323238">
                      到这里我们已经学习了两个二分的模板，一个 lowerBound，一个
                      upperBound。如果将前面学过的二分搜索进行更高层次的抽象，可以发现，利用二分搜索需要<strong
                        data-nodeid="323979"
                        >2 个条件</strong
                      >：
                    </p>
                    <ul data-nodeid="323239">
                      <li data-nodeid="323240">
                        <p data-nodeid="323241">确定搜索空间</p>
                      </li>
                      <li data-nodeid="323242">
                        <p data-nodeid="323243">搜索空间里面的值有序</p>
                      </li>
                    </ul>
                    <p data-nodeid="323244">
                      这里我们引入两个符号：x 和 f(x)（放心，我们<strong
                        data-nodeid="323987"
                        >不会讲太多数学</strong
                      >的）。
                    </p>
                    <ul data-nodeid="323245">
                      <li data-nodeid="323246">
                        <p data-nodeid="323247">x 表示搜索空间</p>
                      </li>
                      <li data-nodeid="323248">
                        <p data-nodeid="323249">f(x) 表示通过 x 得到的值</p>
                      </li>
                    </ul>
                    <p data-nodeid="323250">对于最原始版本的二分搜索来说：</p>
                    <ul data-nodeid="323251">
                      <li data-nodeid="323252">
                        <p data-nodeid="323253">
                          x 就是下标 i，范围为 [0, N)，其中 N 表示数组的长度；
                        </p>
                      </li>
                      <li data-nodeid="323254">
                        <p data-nodeid="323255">f(x) 就是 A[i]。</p>
                      </li>
                    </ul>
                    <p data-nodeid="323256">
                      不过，有的面试题给的数组 A[]
                      并不是有序的，此时需要寻找新的 x 和 f(x) 来破题。
                    </p>
                    <p data-nodeid="323257">
                      那么如何找到 x 和 f(x)？这里就一句话：<strong
                        data-nodeid="324012"
                        >提问就是关键</strong
                      >。是时候拿出二分搜索比较通用的<strong
                        data-nodeid="324013"
                        >提问破题法</strong
                      >了，不过这个方法需要通过例题才能学会，让我们一起看例题。
                    </p>
                    <h4 data-nodeid="323258">例 2：寻找山峰</h4>
                    <p data-nodeid="323259">
                      【<strong data-nodeid="324020">题目</strong
                      >】数组里的元素组成一个山峰，位于峰顶的元素，总是比它左边和右边的元素大。请把这个下标找出来。
                    </p>
                    <p data-nodeid="323260">输入：A = [1, 2, 3, 2, 1]</p>
                    <p data-nodeid="323261">输出：2</p>
                    <p data-nodeid="323262">
                      <strong data-nodeid="324034">解释</strong>：我们发现 A[2]
                      = 3 大于左边和右边的所有元素，并且数组刚好是个山峰。
                    </p>
                    <p data-nodeid="323263">
                      【<strong data-nodeid="324052">分析</strong
                      >】前面我们说过击破二分搜索题的关键就是<strong
                        data-nodeid="324053"
                        >看提问</strong
                      >。<strong data-nodeid="324054">提问破题法</strong
                      >的<strong data-nodeid="324055">第一步</strong
                      >：要什么，什么就是 x。
                    </p>
                    <blockquote data-nodeid="323264">
                      <p data-nodeid="323265">
                        找到下标，满足比左边和右边的元素都大
                      </p>
                    </blockquote>
                    <p data-nodeid="323266">
                      问题要的是“数组<strong data-nodeid="324068">的下标</strong
                      >”，所以我们可以确定：<strong data-nodeid="324069"
                        >x 就是数组的下标</strong
                      >。范围就是 [1, N-1)，其中 N 表示数组的长度。
                    </p>
                    <p data-nodeid="323267">
                      注意这道题的要求，因为最优解的左边有元素，所以最小下标必然为
                      1。而最优解的右边也有元素，所以最大下标值为
                      N-2。那么范围用开闭原则表示，就应该是 [1,
                      N-1)。此时我们已经可以写出一点草稿代码了：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = N-<span class="hljs-number">1</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r-l)&gt;&gt;<span class="hljs-number">1</span>); <span class="hljs-comment">// 这个m就是我们的x</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mov = f(m); <span class="hljs-comment">// 待定：这里mov表示是中间映射的值，即f(x)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 待定：使用lowerBound还是upperBound?</span>
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323269">
                      那么我们再看一下如何确定 f(x)。<strong
                        data-nodeid="324082"
                        >提问破题法</strong
                      >的<strong data-nodeid="324083">第二步</strong
                      >：满足约束条件的 f(x)=0。
                    </p>
                    <p data-nodeid="323270">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/27/B8/CioPOWBdnXmAS4ZMAABruIWMDas017.png"
                        alt="Drawing 4.png"
                        data-nodeid="324086"
                      />
                    </p>
                    <p data-nodeid="323271">
                      这就得出 f(x) 表示的含义：当给定一个下标 x，如果 A[x - 1]
                      &lt;A[x] &gt;A[x + 1]，那么 f(x) =
                      0。注意，此时我们是把满足条件情况设置为
                      0（实际上，也可以设置为其他值，只是 0
                      在后面操作时更加容易简化代码）。分析到这里，我们可以再加上一点草稿代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A[m-<span class="hljs-number">1</span>] &lt; A[m] &amp;&amp; A[m] &lt; A[m+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 待定：其他情况返回什么？</span>
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = N-<span class="hljs-number">1</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r-l)&gt;&gt;<span class="hljs-number">1</span>); <span class="hljs-comment">// 这个m就是我们的x</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mov = f(m);
</div></li><li><div class="code-word">  <span class="hljs-comment">// 待定：使用lowerBound还是upperBound?</span>
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323273">
                      接下来我们看一下不满足要求的 f(x)。这里需要用<strong
                        data-nodeid="324115"
                        >提问破题法</strong
                      >的<strong data-nodeid="324116">第三步</strong>：<strong
                        data-nodeid="324117"
                        >不满足</strong
                      >约束条件的 f(x) 设置为 -1 或者 1。那么到底是设置为
                      -1，还是 1 呢？这个时候需要回到题目的场景中。
                    </p>
                    <p data-nodeid="323274">
                      由于整个数组形成了一个山峰，山峰的左边是升序，山峰的右边是降序。我们发现f(x)的值空间就只有三种情况：
                    </p>
                    <ul data-nodeid="323275">
                      <li data-nodeid="323276">
                        <p data-nodeid="323277">
                          山峰左边的元素满足 A[i-1] &lt; A[i] &lt;
                          A[i+1]，可以把这种关系记录为 -1；
                        </p>
                      </li>
                      <li data-nodeid="323278">
                        <p data-nodeid="323279">
                          山峰元素满足 A[i-1] &lt; A[i] &amp;&amp; A[i] &gt;
                          A[i+1]，可以把这种关系记录 0；
                        </p>
                      </li>
                      <li data-nodeid="323280">
                        <p data-nodeid="323281">
                          山峰右边的元素满足 A[i-1] &gt; A[i] &gt;
                          A[i+1]，可以把这种关系记录为
                          <strong data-nodeid="324175">1</strong>。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323282">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/27/B8/CioPOWBdnYmAddOFAAETfQMy6vc139.png"
                        alt="Drawing 5.png"
                        data-nodeid="324178"
                      />
                    </p>
                    <p data-nodeid="323283">
                      经过再次映射，就可以得到 C 数组，此时，C
                      数组就是一个有序的数组了。最终确定 f(x)
                      可以映射成一个有序数组 C[] = {-1, -1, 0, 1, 1, 1}。
                    </p>
                    <p data-nodeid="323284">
                      此时我们我们已经可以补全 f(x) 函数了，如下所示：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i] &amp;&amp; A[i] &lt; A[i + <span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i] &amp;&amp; A[i] &gt; A[i + <span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = N-<span class="hljs-number">1</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r-l)&gt;&gt;<span class="hljs-number">1</span>);
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mov = f(m);
</div></li><li><div class="code-word">  <span class="hljs-comment">// 待定：使用lowerBound还是upperBound?</span>
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323286">
                      在写代码时，还有一个问题待定：到底应该使用 lowerBound 还是
                      upperBound？<strong data-nodeid="324196"
                        >提问破题法</strong
                      >的<strong data-nodeid="324197">第四步</strong>：最优解 0
                      在 C[] 的最左边还是最右边，决定使用 lowerBound 还是
                      upperBound。
                    </p>
                    <p data-nodeid="323287">
                      比如在这里 C[] = {-1, -1, 0, 1, 1,
                      1}。山峰元素就只有一个，可以认为是一个最左边的元素，那么只需要用
                      lowerBound 就可以了。
                    </p>
                    <p data-nodeid="323288">
                      转念一想，那么岂不是要先遍历一遍生成 C
                      数组？实际上没有必要，这个映射关系可以通过函数来完成。每次要获取的时候，就生成
                      C[i] 的值好了。
                    </p>
                    <p data-nodeid="323289">
                      【<strong data-nodeid="324212">代码</strong
                      >】到这里我们已经可以写出代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 面试中如果直接写函数名f(int)容易被面试官喷代码规范</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 不过好在我们可以认为我们是把原来的数组A[]映射到了一个</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 新的数组C[]，f(int x)可以认为是在读取C[]数组中的值。</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> i)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 利用函数的方式拿到C数组的值</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i] &amp;&amp; A[i] &lt; A[i + <span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] &lt; A[i] &amp;&amp; A[i] &gt; A[i + <span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || A.length &lt; <span class="hljs-number">3</span>) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 在C数组上进行二分，这里直接用lowerBound就可以了。</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = A.length - <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mov = getC(A, m);
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (mov &lt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">      l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      r = m;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> l;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323291">
                      <p data-nodeid="323292">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/852.%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324216"
                          >Java/C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/852.%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324220"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323293">
                      <strong data-nodeid="324228">复杂度分析</strong
                      >：时间复杂度 O(lgN)，空间复杂度
                      O(1)。这里比较有趣的是，映射数组 C[]
                      并不需要构建，而是通过一个函数 getC 生成的。
                    </p>
                    <p data-nodeid="323294">
                      【<strong data-nodeid="324238">小结</strong
                      >】这里我们总结一下<strong data-nodeid="324239"
                        >提问破题法</strong
                      >。
                    </p>
                    <ul data-nodeid="323295">
                      <li data-nodeid="323296">
                        <p data-nodeid="323297">
                          <strong data-nodeid="324244">第一步</strong
                          >：要什么，什么就是 x。
                        </p>
                      </li>
                      <li data-nodeid="323298">
                        <p data-nodeid="323299">
                          <strong data-nodeid="324249">第二步</strong
                          >：满足约束条件的 f(x) = 0。
                        </p>
                      </li>
                      <li data-nodeid="323300">
                        <p data-nodeid="323301">
                          <strong data-nodeid="324258">第三步</strong>：<strong
                            data-nodeid="324259"
                            >不满足</strong
                          >约束条件的 f(x) 设置为 -1 或者 1。
                        </p>
                      </li>
                      <li data-nodeid="323302">
                        <p data-nodeid="323303">
                          <strong data-nodeid="324267">第四步</strong>：最优解 0
                          在 C[] 的最左边还是最右边，决定使用 lowerBound 还是
                          upperBound。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323304">
                      接下来，我们看一些练习题，在<strong data-nodeid="324277"
                        >头条</strong
                      >和<strong data-nodeid="324278">美团</strong
                      >的面试中都遇到过这个题目。希望你可以在课下尝试解答一下，如果有什么疑问，也可以写在留言区，我们一起讨论。
                    </p>
                    <p data-nodeid="323305">
                      <strong data-nodeid="324283">练习题 3</strong
                      >：给定一个有序数组，找出数组中下标与值相等的那些数。
                    </p>
                    <blockquote data-nodeid="323306">
                      <p data-nodeid="323307">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/69.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324287"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/69.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324291"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/69.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324295"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323308">
                      <strong data-nodeid="324300">练习题 4</strong
                      >：给定一个有序数组，找出数组中下标与值相等的数的范围。
                    </p>
                    <blockquote data-nodeid="323309">
                      <p data-nodeid="323310">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/69.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324304"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/69.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324308"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/69.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324312"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323311">
                      如果从<strong data-nodeid="324318">考点</strong>上来说，x
                      和 f(x)
                      还可以进行一些变化。我们还需要进一步深挖这个考点，以应对面试中可能出现的变形。
                    </p>
                    <h4 data-nodeid="323312">例 3：最小长度连续子数组</h4>
                    <p data-nodeid="323313">
                      【<strong data-nodeid="324325">题目</strong
                      >】一个正整数数组 A，以及正数
                      s，找出最小长度的连续子数组，使得子数组和 &gt;= s。
                    </p>
                    <p data-nodeid="323314">输入：A = [5, 2], s = 3</p>
                    <p data-nodeid="323315">输出：1</p>
                    <p data-nodeid="323316">
                      解释：数组中存在长度为1的子数组 [5]，其和大于给定数 3。
                    </p>
                    <p data-nodeid="323317">
                      【<strong data-nodeid="324346">分析</strong>】<strong
                        data-nodeid="324347"
                        >提问破题法</strong
                      >的四步法我们依次使用出来。
                    </p>
                    <p data-nodeid="323318">
                      <strong data-nodeid="324352">1</strong>.
                      第一步：要什么，什么就是 x。
                    </p>
                    <blockquote data-nodeid="323319">
                      <p data-nodeid="323320">
                        最小长度的连续子数组，使得子数组和 &gt;= s
                      </p>
                    </blockquote>
                    <p data-nodeid="323321">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/27/B8/CioPOWBdnb-ABFgaAABqYrb0MiY105.png"
                        alt="Drawing 6.png"
                        data-nodeid="324356"
                      />
                    </p>
                    <p data-nodeid="323322">
                      我们要求的是“最小长度的连续子数组”。不过在实施的时候，需要<strong
                        data-nodeid="324362"
                        >把“最小，最大”这种字样去掉</strong
                      >，然后变为 x。
                    </p>
                    <p data-nodeid="323323">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/27/B8/CioPOWBdnamADeEOAABqG8sccSs175.png"
                        alt="Drawing 7.png"
                        data-nodeid="324365"
                      />
                    </p>
                    <p data-nodeid="323324">
                      确定了 x 之后，我们还需要确定 x
                      的范围。连续子数组的长度，在这个题里面只能可能是 [1, N +
                      1)。因为 A[] 数组和 s
                      都是正数。所以最短的连续子数组不可能为 0。
                      而最长可以是整个数组 N。那么用开闭原则表示就应该是 [0, N +
                      1)。
                    </p>
                    <p data-nodeid="323325">
                      <strong data-nodeid="324378">2</strong>.
                      第二步：满足约束条件的 f(x) = 0。
                    </p>
                    <p data-nodeid="323326">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdncyAQiAyAABi-zz0PQo044.png"
                        alt="Drawing 8.png"
                        data-nodeid="324381"
                      />
                    </p>
                    <p data-nodeid="323327">
                      对于一个给定的子数组长度 x，f(x)
                      表示的含义：满足约束条件（长度为 x
                      的连续子数组的和的最大值 &gt;= s），f(x) = 0。
                    </p>
                    <p data-nodeid="323328">
                      <strong data-nodeid="324391">3</strong>.
                      <strong data-nodeid="324392">不满足</strong>约束条件的
                      f(x) 设置为 -1 或者 1。
                    </p>
                    <p data-nodeid="323329">
                      那么到底是设置为 -1，还是 1
                      呢？这个时候我们需要回到题目的场景中进一步思考。此时可以确定
                      f(x) = 长度为 x 的子数组最大和。接下来可以得出：f(x +
                      1)≥f(x)
                    </p>
                    <p data-nodeid="323330">
                      <strong data-nodeid="324398">证明</strong>：当已经得到
                      f(x) 之后，只需要在长度为 x
                      的子数组的左边/右边再加延长一下就可以得到
                      f(x+1)。如下图所示：
                    </p>
                    <p data-nodeid="323331">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/B8/CioPOWBdndSAVa20AACc21JFZlk639.png"
                        alt="Drawing 9.png"
                        data-nodeid="324401"
                      />
                    </p>
                    <p data-nodeid="323332">
                      由于数组中的元素都是正数，那么可以肯定的是 f(x + 1) ≥
                      f(x)。那么我们可以得到一个单调递增的函数，那就是：
                    </p>
                    <p data-nodeid="323333">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdndqAIWGAAABwzAeOXWE704.png"
                        alt="Drawing 10.png"
                        data-nodeid="324405"
                      />
                    </p>
                    <p data-nodeid="323334">
                      那么子数组的和实际上只有 2 种情况：
                    </p>
                    <ul data-nodeid="323335">
                      <li data-nodeid="323336">
                        <p data-nodeid="323337">
                          小于 s，此时可以设置 f(x) = -1；
                        </p>
                      </li>
                      <li data-nodeid="323338">
                        <p data-nodeid="323339">
                          大于等于
                          s（这道题只需要求大于等于，所以这里把等于和大于合在一起）f(x)
                          = 0。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323340">
                      如果把 f(x) 看成一个映射，那么映射之后的数组 C[] = {-1,
                      -1, 0, 0, 0}。
                    </p>
                    <p data-nodeid="323341">
                      <strong data-nodeid="324420">4</strong>. 最优解 0 在 C[]
                      的最左边还是最右边，决定使用 lowerBound 还是 upperBound。
                    </p>
                    <p data-nodeid="323342">
                      按照题目要求，需要找到的是长度最小的连续子数组，实际上就是在
                      C[] 数组中找到最左边的 0，所以应该用 lowerBound。
                    </p>
                    <p data-nodeid="323343">
                      【<strong data-nodeid="324430">代码</strong
                      >】到此为止，我们已经能够写出代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 参数：数组A[], 子数组长度len</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// return: 是否存在长度为len的子数组的和 &gt;= s</span>
</div></li><li><div class="code-word"><span class="hljs-comment">//      0 has find</span>
</div></li><li><div class="code-word"><span class="hljs-comment">//     -1 not found</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> s)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这里相当于滑动一个固定长度为len的窗口，并求出这个窗口的和</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    sum += A[i];
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (i &lt; len - <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">continue</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果发现这个固定长度为len的和 &gt;= s</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 那么返回0</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (sum &gt;= s) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    sum -= A[i - (len - <span class="hljs-number">1</span>)];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-comment">// lowerBound的函数模板</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] A)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = N + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mov = getC(A, m, s);
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (mov &lt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">      l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      r = m;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> l &gt; N ? <span class="hljs-number">0</span> : l;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323345">
                      <p data-nodeid="323346">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324434"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324438"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324442"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323347">
                      <strong data-nodeid="324447">复杂度分析</strong
                      >：搜索空间长度为 N 并且有序，在里面二分的时候，只需要运行
                      O(lgN) 次。而在每次 getC 获取映射值的时候，复杂度为
                      O(N)。那么时间复杂度为 O(NlgN)，空间复杂度为 O(1)。
                    </p>
                    <p data-nodeid="323348">
                      【<strong data-nodeid="324457">小结</strong
                      >】到这里，我们已经可以总结出二分搜索比较<strong
                        data-nodeid="324458"
                        >通用的提问破题法</strong
                      >了，通过提问来确定：
                    </p>
                    <ul data-nodeid="323349">
                      <li data-nodeid="323350">
                        <p data-nodeid="323351">确定搜索空间，即 x 的范围；</p>
                      </li>
                      <li data-nodeid="323352">
                        <p data-nodeid="323353">
                          确定f(x)是否有序。有可能你还需要一个简单的证明。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323354">
                      这里我们可以再看一下下面这几个练习题。
                    </p>
                    <p data-nodeid="323355">
                      <strong data-nodeid="324466">练习题 5</strong
                      >：包含所有子串的最短子串。给定两个字符串
                      A，B。要求在字符串 A
                      中找到一个最短的子串，在这个子串中包含了所有的 B
                      中的字符。
                    </p>
                    <blockquote data-nodeid="323356">
                      <p data-nodeid="323357">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324470"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324474"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/76.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324478"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323358">
                      注：我们使用了复杂度为 O(NlgN) 的二分搜索来求解例 3
                      和练习题 5，实际上有 O(N)
                      的求解办法，你能想一下吗？（关于这块内容，我们将在“第 10
                      讲”中详细介绍）。
                    </p>
                    <h4 data-nodeid="323359">例 4：最大平均值</h4>
                    <p data-nodeid="323360">
                      【<strong data-nodeid="324486">题目</strong
                      >】给定一个正整数数组 A 和
                      k，要求找到子数组，输出其最大平均值，并且子数组长度要满足大于等于
                      k。
                    </p>
                    <p data-nodeid="323361">
                      输入：A = [1,12,-5,-6,50,3], k = 3
                    </p>
                    <p data-nodeid="323362">输出：15.667</p>
                    <p data-nodeid="323363">
                      解释：在所有长度大于等于 3 的子数组中，(-6 + 50 + 3) / 3 =
                      15.667 是最大的。
                    </p>
                    <p data-nodeid="323364">
                      【<strong data-nodeid="324499">分析】提问破题法</strong
                      >的四步法我们依次使用出来。
                    </p>
                    <p data-nodeid="323365">
                      <strong data-nodeid="324504">1</strong>.
                      第一步：要什么，什么就是 x
                    </p>
                    <blockquote data-nodeid="323366">
                      <p data-nodeid="323367">
                        输出子数组最大平均值，并且子数组长度 &gt;= k。
                      </p>
                    </blockquote>
                    <p data-nodeid="323368">
                      要输出的是子数组的最大平均值，所以搜索空间 x
                      就是连续子数组的平均值，如下图所示：
                    </p>
                    <p data-nodeid="323369">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/B8/CioPOWBdnfCAfgTUAABrY1hyi1k406.png"
                        alt="Drawing 11.png"
                        data-nodeid="324509"
                      />
                    </p>
                    <p data-nodeid="323370">
                      再看一下范围：x 的最小值，就是数组的最小值。而 x
                      的最大值，就是数组的最大值。
                    </p>
                    <p data-nodeid="323371">
                      如果是在面试时，那么我们已经可以写出如下代码框架了：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> small = Integer.INT_MIN;
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> large = Integer.INT_MAX;
</div></li><li><div class="code-word"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">  small = Math.min(small, A[i]);
</div></li><li><div class="code-word">  large = Math.max(large, A[i]);
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-keyword">double</span> l = small, r = large + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span> m = (l + r) / <span class="hljs-number">2.0</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span> mov = ? ? <span class="hljs-comment">// 待定</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (mov &lt; ? ?) {<span class="hljs-comment">// 待定</span>
</div></li><li><div class="code-word">    l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">    r = m;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323373">剩下的就是需要找到 f(x)。</p>
                    <p data-nodeid="323374">
                      <strong data-nodeid="324517">2</strong>.
                      第二步：满足约束条件的 f(x) = 0。
                    </p>
                    <p data-nodeid="323375">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdngWALZ9zAABhy_ZI9lg598.png"
                        alt="Drawing 12.png"
                        data-nodeid="324520"
                      />
                    </p>
                    <p data-nodeid="323376">
                      对于 f(x) 来说，其含义为：给定的平均值 x，如果存在：
                    </p>
                    <p data-nodeid="323377">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdnieAbr7hAABBUtXsXLI943.png"
                        alt="Drawing 17.png"
                        data-nodeid="324524"
                      />
                    </p>
                    <p data-nodeid="323378">
                      <strong data-nodeid="324533">3</strong>.
                      <strong data-nodeid="324534">不满足</strong>约束条件的
                      f(x) 设置为 -1 或者 1。
                    </p>
                    <p data-nodeid="323379">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/B8/CioPOWBdnhGADWo8AABejsjHA-g049.png"
                        alt="Drawing 20.png"
                        data-nodeid="324537"
                      />
                    </p>
                    <p data-nodeid="323380">
                      <strong data-nodeid="324545">4</strong>. 最优解 0 在 C[]
                      的最左边还是最右边，决定使用 lowerBound 还是 upperBound。
                    </p>
                    <p data-nodeid="323381">
                      由于我们求解最大平均值，就是找到满足条件的最大的 x。也就是
                      C[] 数组里面的最右边的 0。此时应该使用 upperBound 的模板。
                    </p>
                    <p data-nodeid="323382">
                      <strong data-nodeid="324554">难点</strong>：f(x)
                      函数的代码。
                    </p>
                    <p data-nodeid="323383">
                      我们之前写过的代码里面，f(x)
                      都比较直观，比较容易写。但是这道题里面。你先弄懂如下问题
                      1，才能继续往后思考。
                    </p>
                    <blockquote data-nodeid="323384">
                      <p data-nodeid="323385">
                        问题 1：给定的平均值 x，是否存在连续子数组平均值 &gt;=
                        x，并且长度 &gt;= k
                      </p>
                    </blockquote>
                    <p data-nodeid="323386">
                      要解决这个问题，我们不妨把问题化简一下。把子数组长度 &gt;=
                      k
                      去掉，看看可不可以简单一点，如果可以，那么我们就可以从简单一点的问题入手。问题就变成如下问题
                      2。
                    </p>
                    <blockquote data-nodeid="323387">
                      <p data-nodeid="323388">
                        问题 2：给定的平均值，是否存在连续的子数组平均值 &gt;= x
                      </p>
                    </blockquote>
                    <p data-nodeid="323389">
                      平均值最后是平均到每个元素身上的。那么我们事先从数组 A[]
                      中将这个平均值 x 减掉。用代码可以表示如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> B[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];
</div></li><li><div class="code-word"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) {
</div></li><li><div class="code-word">  B[i] = A[i] - x;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323391">
                      如果要找到“连续的子数组的平均值 &gt;= x”，实际上就变成在
                      B[] 数组上找到一个连续的子数组，要求其和 &gt;=
                      0。如果我们能找到 B[]
                      数组上的连续子数组的最大和，再看一下这个最大和是否 &gt;= 0
                      就可以了。这样问题已经变成求一个数组的最大子数组和，如下问题
                      3。
                    </p>
                    <blockquote data-nodeid="323392">
                      <p data-nodeid="323393">
                        问题 3: 给定一个数组 B[]，求这个数组上的最大子数组和。
                      </p>
                    </blockquote>
                    <p data-nodeid="323394">
                      在解决问题 3 时，我们采用一种<strong data-nodeid="324620"
                        >落差法</strong
                      >，求出 B[] 数组的前缀和数组 C[]，所以说前缀和数组，即
                      C[i] = B[0] + B[1] + .. + B[i]。当得到 C[] 数组之后，C[i]
                      与 min(C[0], .... , C[i-1]) 的差就是以 B[i]
                      结尾的连续子数组的最大和。用图表示如下：
                    </p>
                    <p data-nodeid="323395">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/B8/CioPOWBdnj6AXSEoAABxSRrShKU892.png"
                        alt="Drawing 21.png"
                        data-nodeid="324623"
                      />
                    </p>
                    <p data-nodeid="323396">
                      那么问题 3 可以求解如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Q3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] B)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = B == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : B.length;
</div></li><li><div class="code-word">  <span class="hljs-comment">// pre表示C[i]的值</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">long</span> pre = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// pre_min表示C[0] ... C[i-1]的最小值</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// pre - pre_min就是落差，也就是B[]数组的连续子数组和</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">long</span> pre_min = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">long</span> ans = Integer.MIN_VALUE;
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// pre表示的是C[i]的值</span>
</div></li><li><div class="code-word">    pre += B[i];
</div></li><li><div class="code-word">    ans = Math.max(ans, pre - pre_min);
</div></li><li><div class="code-word">    pre_min = Math.min(pre_min, pre);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ans;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323398">
                      <p data-nodeid="323399">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324628"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324632"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324636"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323400">
                      有了问题 3 的求解，我们就可以返回去求解问题
                      2。只需要在问题 3 的基础上做如下操作即可。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">Q2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
</div></li><li><div class="code-word"> <span class="hljs-keyword">if</span> (Q3(A) &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word"> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323402">
                      接下来，我们再返回去看问题 1。当我们仍然利用 A[]
                      数组中的每个元素减去 x 得到 B[] 数组之后，问题 1
                      等价于以下问题 4。
                    </p>
                    <blockquote data-nodeid="323403">
                      <p data-nodeid="323404">
                        问题 4: 给定一个数组 B[]，是否存在长度 &gt;= k
                        的连续子数组，其和 &gt;= 0。
                      </p>
                    </blockquote>
                    <p data-nodeid="323405">
                      这里多加的一个条件“长度 &gt;= k"，实际上是要求：
                    </p>
                    <p data-nodeid="323406">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/B8/CioPOWBdnkeACjFwAAB2QUb2OP8106.png"
                        alt="Drawing 22.png"
                        data-nodeid="324654"
                      />
                    </p>
                    <p data-nodeid="323407">
                      也就是 j 和 i 的距离要 &gt;= k。这里就需要用到<strong
                        data-nodeid="324660"
                        >滑动窗口</strong
                      >的方法了。可以将代码写为如下的样子（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 问题1与问题4都是同样的代码。</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Q4</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">double</span> m, <span class="hljs-keyword">int</span> k)</span> </span>{ 
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span>[] B = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span>[] C = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
</div></li><li><div class="code-word">  <span class="hljs-comment">// 给定平均值m (也就是文中描述的x)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 利用A[]数组减去它，得到B[]</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    B[i] = (<span class="hljs-keyword">double</span>)A[i] - m;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 再利用B[]数组得到C[]数组。</span>
</div></li><li><div class="code-word">  C[<span class="hljs-number">0</span>] = B[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    C[i] = C[i - <span class="hljs-number">1</span>] + B[i];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这里利用落差法来求解</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span> pre_min = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// i &gt;= k - 1</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 才有可能形成长度 &gt;= k的子数组</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 形成的子数组是[i + 1 - k, i + 1)</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (C[i] &gt;= pre_min) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 滑动窗口要移出去的时候</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 要把B[i + 1 - k]移出去了</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 注意，这里不是直接取min(pre_min, C[i])</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 因为要保证子数组长度 &gt;= k，所以只能取滑动窗口中</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 将要移出去的元素。</span>
</div></li><li><div class="code-word">    pre_min = Math.min(pre_min, C[i + <span class="hljs-number">1</span> - k]);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323409">到这里，我们已经求解出 f(x)。</p>
                    <p data-nodeid="323410">
                      【<strong data-nodeid="324667">代码</strong
                      >】根据前面的分析，相信你已经可以根据思路写出代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">double</span>[] B, <span class="hljs-keyword">double</span> m, <span class="hljs-keyword">int</span> k)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    B[i] = (<span class="hljs-keyword">double</span>)A[i] - m;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 再把B[]数组变成自身的前缀和数组C[]</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这样可以省去申请C[]数组的空间</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    B[i] += B[i - <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// pre_min用来记录滑动窗口之前的最小值。</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span> pre_min = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// i &gt;= k - 1</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 才有可能形成长度 &gt;= k的子数组</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 形成的子数组是[i + 1 - k, i + 1)</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (B[i] &gt;= pre_min) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 滑动窗口要移出去的时候</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 要把B[i + 1 - k]移出去了</span>
</div></li><li><div class="code-word">    pre_min = Math.min(pre_min, B[i + <span class="hljs-number">1</span> - k]);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">maxAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> k)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> small = Integer.MAX_VALUE;
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> large = Integer.MIN_VALUE;
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">    small = Math.min(small, A[i]);
</div></li><li><div class="code-word">    large = Math.max(large, A[i]);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span>[] B = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[N];
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span> l = small;
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span> r = (<span class="hljs-keyword">double</span>)large + <span class="hljs-number">1.0</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 注意浮点数的循环处理，要求这两个数不要相等</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1e-6</span>) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">double</span> m = (l + r) / <span class="hljs-number">2.0</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> mov = getC(A, B, m, k);
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (mov &lt;= <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 移动左边界时，对于double类型的数来说</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 直接取l = m即可。</span>
</div></li><li><div class="code-word">      l = m;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      r = m;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 如果l已经是0，那么直接返回0，不要返回-0.00</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> Math.abs(l) &lt; <span class="hljs-number">1e-6</span> ? <span class="hljs-number">0</span> : l;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323412">
                      <p data-nodeid="323413">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/617._%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC_II.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324671"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/617._%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC_II.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324675"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/617._%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC_II.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324679"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323414">
                      <strong data-nodeid="324684">复杂度分析</strong
                      >：upperBound 主循环部分为 O(lgN)，但是在每次 getC
                      函数执行时，其复杂度为 O(N)。所以时间复杂度为
                      O(NlgN)，空间复杂度为 O(N)。
                    </p>
                    <p data-nodeid="323415">
                      【<strong data-nodeid="324690">小结</strong
                      >】写出这道题之后，这里我们再总结一下这道题的考点，如下图所示：
                    </p>
                    <p data-nodeid="323416">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdnmyAMTEQAAHbOIJo-JU000.png"
                        alt="Drawing 23.png"
                        data-nodeid="324693"
                      />
                    </p>
                    <p data-nodeid="323417">
                      这道题的考点无非就是将<strong data-nodeid="324703"
                        >连续子数组和</strong
                      >与<strong data-nodeid="324704">二分搜索</strong
                      >组合了一下，只要你熟练地掌握这 2
                      个关键技能，击破这类面试题就不难了。
                    </p>
                    <p data-nodeid="323418">
                      关于二分搜索的扩展，我们已经讲了很多，那么就这道题而言，是否还有可以深挖的点呢？比如：连续子数组求最大平均值的小技巧就是每个元素减去平均值。我们可以将题目变成连续子数组的最大和问题。而连续子数组的<strong
                        data-nodeid="324710"
                        >最大和</strong
                      >问题又可以分出 4 种情况。
                    </p>
                    <p data-nodeid="323419">
                      <strong data-nodeid="324723">1</strong>.
                      长度无限制，是最常见的<strong data-nodeid="324724"
                        >连续最大子数组和</strong
                      >问题。这里我们采用<strong data-nodeid="324725"
                        >落差法</strong
                      >来求解，也可以利用双指针或者 DP
                      来进行求解（这两种解法分别会在“第 10 讲”和“第 14
                      讲”详细讲解）。
                    </p>
                    <blockquote data-nodeid="323420">
                      <p data-nodeid="323421">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324729"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324733"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324737"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323422">
                      <strong data-nodeid="324746">2</strong>.
                      连续子数组的长度必须等于 k。采用<strong
                        data-nodeid="324747"
                        >滑动窗口法</strong
                      >来求解。
                    </p>
                    <blockquote data-nodeid="323423">
                      <p data-nodeid="323424">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/868._%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324751"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/868._%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324755"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/868._%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324759"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323425">
                      <strong data-nodeid="324768">3</strong>. 长度 &gt;= k
                      的连续子数组，采用<strong data-nodeid="324769"
                        >滑动窗口 + 落差法</strong
                      >来求解。代码参考前面例题 4 的代码。
                    </p>
                    <p data-nodeid="323426">
                      <strong data-nodeid="324776">4</strong>.
                      如果限制长度必须要 &lt;= k
                      的连续子数组的最大和，这个时候应该怎么办？
                    </p>
                    <blockquote data-nodeid="323427">
                      <p data-nodeid="323428">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/MaxSumLengthSmallerK.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324780"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/MaxSumLengthSmallerK.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324784"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/MaxSumLengthSmallerK.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="324788"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h3 data-nodeid="323429">三步切分法</h3>
                    <p data-nodeid="323430">
                      前面介绍的提问破题法已经能够解决相当一部分问题了，下面我们再来看一下二分搜索的最后一种面试中的常考题型——<strong
                        data-nodeid="324795"
                        >切分题</strong
                      >，这种题目比较适合使用切分法。
                    </p>
                    <p data-nodeid="323431">
                      所谓<strong data-nodeid="324813">切分法</strong
                      >，顾名思义就是把搜索范围<strong data-nodeid="324814"
                        >分</strong
                      >为两半，然后把我们不想要的那部分搜索区域<strong
                        data-nodeid="324815"
                        >切</strong
                      >掉（扔掉），也可以叫<strong data-nodeid="324816"
                        >三步切分法</strong
                      >：
                    </p>
                    <ol data-nodeid="323432">
                      <li data-nodeid="323433">
                        <p data-nodeid="323434">找出一个分界元素；</p>
                      </li>
                      <li data-nodeid="323435">
                        <p data-nodeid="323436">
                          将<strong data-nodeid="324827">有序的</strong
                          >搜索空间分为两半（复杂度为 O(1)），<strong
                            data-nodeid="324828"
                            >扔掉</strong
                          >不需要的那一半；
                        </p>
                      </li>
                      <li data-nodeid="323437">
                        <p data-nodeid="323438">
                          在<strong data-nodeid="324834">剩下的空间</strong
                          >中递归使用切分法。
                        </p>
                      </li>
                    </ol>
                    <p data-nodeid="323439">
                      实际上在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6697&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="324838"
                        >第 08 讲</a
                      >”里面，我们介绍<strong data-nodeid="324844"
                        >三路切分</strong
                      >的时候，也用到了切分法的思路。这里我们将两者做个对比。
                    </p>
                    <p data-nodeid="323440">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdnpuAJXhnAAEBs7isOFc504.png"
                        alt="Drawing 24.png"
                        data-nodeid="324847"
                      />
                    </p>
                    <p data-nodeid="323441">
                      二分搜索和三路切分都可以不停地缩小搜索空间，但是两者的使用条件也不太一样：
                    </p>
                    <ul data-nodeid="323442">
                      <li data-nodeid="323443">
                        <p data-nodeid="323444">
                          二分搜索<strong data-nodeid="324854"
                            >需要有序性</strong
                          >，复杂度为 O(lgN)；
                        </p>
                      </li>
                      <li data-nodeid="323445">
                        <p data-nodeid="323446">
                          三路切分<strong data-nodeid="324860">不需要</strong
                          >有序性，复杂度为 O(N)。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323447">
                      在标准的模板代码 lowerBound 和 upperBound
                      里面，我们在查找时，都使用了切分法切掉我们不想要的搜索空间，只在剩下的搜索空间里面继续搜索。
                    </p>
                    <p data-nodeid="323448">
                      不过，对于有的面试题来说，有序性并不会给得那么赤祼祼，此时就需要利用三步切分法的帮助。下面我们一起通过例题看看怎么运用切分法。
                    </p>
                    <h4 data-nodeid="323449">例 5：旋转数组的查找</h4>
                    <p data-nodeid="323450">
                      【<strong data-nodeid="324869">题目</strong
                      >】给定一有序数组
                      A（没有重复元素），某个位置发生了旋转，给定元素 x，请输出
                      x 在数组 A 中的下标。如果不存在，输出 -1。
                    </p>
                    <p data-nodeid="323451">
                      输入：A = [1, 2, 3, -1, 0], x = 3
                    </p>
                    <p data-nodeid="323452">输出：2</p>
                    <p data-nodeid="323453">
                      <strong data-nodeid="324884">解释</strong>：因为 A[2] == 3
                      所以返回下标 2
                    </p>
                    <p data-nodeid="323454">
                      【<strong data-nodeid="324890">分析</strong
                      >】这里如果我们要使用二分搜索来解决这个问题。面临的最大问题是，数组并不是有序的。如果将数组的值画在坐标轴上，那么形成的效果可能是：
                    </p>
                    <p data-nodeid="323455">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdnqWAGZStAABeKdrevNw727.png"
                        alt="Drawing 25.png"
                        data-nodeid="324893"
                      />
                    </p>
                    <p data-nodeid="323456">
                      但是，我们很快可以发现，虽然整个数组不是有序的，但是数组的两个部分分别是有序的。这个信息很关键，如果能够利用上，就一定能够破题。
                    </p>
                    <p data-nodeid="323457">
                      在进行二分搜索的时候，我们首先是需要取中间值。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r-l)&gt;&gt;<span class="hljs-number">1</span>);
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323459">
                      那么此时我们已经知道了 A[L]、A[M]、A[R]
                      三个值，可以在进一步二分之前加一个处理。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">if</span> (A[l] == x) <span class="hljs-keyword">return</span> l;
</div></li><li><div class="code-word"><span class="hljs-keyword">if</span> (A[m] == x) <span class="hljs-keyword">return</span> m;
</div></li><li><div class="code-word"><span class="hljs-keyword">if</span> (A[r-<span class="hljs-number">1</span>] == x) <span class="hljs-keyword">return</span> r-<span class="hljs-number">1</span>;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323461">
                      通过这样的处理之后，后面我们在进行二分操作的时候，会更加简单一点。接下来我们再看
                      A[M] 的值，A[M]
                      有两种可能：一种是掉落在左边，一种是掉落在右边区域。
                    </p>
                    <p data-nodeid="323462">
                      <strong data-nodeid="324926">1</strong>. A[m]
                      掉落在左边区域。如下图所示：
                    </p>
                    <p data-nodeid="323463">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BB/Cgp9HWBdnrKAAUj2AABniw2Zc2k297.png"
                        alt="Drawing 26.png"
                        data-nodeid="324929"
                      />
                    </p>
                    <p data-nodeid="323464">
                      当 A[L] &lt; A[M]
                      的时候，中间值肯定是掉落在左边的。在这种情况下，我们需要再分
                      （a）、（b） 两种情况。
                    </p>
                    <p data-nodeid="323465">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/B8/CioPOWBdnr2AT9D1AABp_yYk9aA263.png"
                        alt="Drawing 27.png"
                        data-nodeid="324943"
                      />
                    </p>
                    <p data-nodeid="323466">
                      （a）x 位于 A[m] 的左边。此时需要满足条件：A[L] &lt; x
                      &lt;
                      A[M]。在这种情况下，右边的区域是没有必要保留的。可以通过 R
                      = M 来扔掉。
                    </p>
                    <p data-nodeid="323467">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BC/Cgp9HWBdnsWABOwBAABuoIxhu84288.png"
                        alt="Drawing 28.png"
                        data-nodeid="324963"
                      />
                    </p>
                    <p data-nodeid="323468">
                      （b）x 位于 A[m]
                      的右边。此时左边的部分是没有必要保留的，把左边切掉，让 L =
                      M+ 1。
                    </p>
                    <p data-nodeid="323469">
                      <strong data-nodeid="324987">2</strong>. A[m]
                      掉落在右边区域。需要满足条件 A[M] &lt; A[R]。如下图所示：
                    </p>
                    <p data-nodeid="323470">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/27/B8/CioPOWBdntCAT8kvAABlgSswVU8127.png"
                        alt="Drawing 29.png"
                        data-nodeid="324990"
                      />
                    </p>
                    <p data-nodeid="323471">
                      此时我们要找的值 x 可以分成（c）、（d）两种情况：
                    </p>
                    <p data-nodeid="323472">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BC/Cgp9HWBdnteAAYFWAABom4eopCw440.png"
                        alt="Drawing 30.png"
                        data-nodeid="324994"
                      />
                    </p>
                    <p data-nodeid="323473">
                      （c）位于最右边区域。此时需要满足条件，A[M] &lt; x &lt;
                      A[R]。那么可以直接把左边区域扔掉，设置 L = M + 1 即可。
                    </p>
                    <p data-nodeid="323474">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/27/BC/Cgp9HWBdnt2AYcGmAABpvhp8n8M685.png"
                        alt="Drawing 31.png"
                        data-nodeid="325010"
                      />
                    </p>
                    <p data-nodeid="323475">
                      （d）位于左边区域，此时只需要把右边区域扔掉即可。即设置 R
                      = M。
                    </p>
                    <p data-nodeid="323476">
                      【<strong data-nodeid="325017">代码</strong
                      >】经过详细的分析，我们已经可以写代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = N;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 先处理掉能够取到的3个值。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[l] == x)
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> l;
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[m] == x)
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> m;
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里不能用A[r]，因为我们使用的是</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 开闭原则，右边始终是不能取到的。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[r - <span class="hljs-number">1</span>] == x)
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> r - <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这里开始把不要的区间切掉</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (A[m] &gt; A[l]) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (A[l] &lt; x &amp;&amp; x &lt; A[m]) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// case (a)</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 到这里，A[m]已经不可能等于x</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 所以需要将[m, ...., r)</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 这段区间一起扔掉</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 留下[l, m)这段区间，续断查找</span>
</div></li><li><div class="code-word">        r = m;
</div></li><li><div class="code-word">      } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        <span class="hljs-comment">// case (b)</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// A[m]已经不可能等于x</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 所以这里将[l, ..., m]这个区间切掉</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 留下[m + 1, r)</span>
</div></li><li><div class="code-word">        l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (A[m] &lt; x &amp;&amp; x &lt; A[r - <span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// case (c)</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 到这里，左边的区间[l, ... , m]已经不需要了</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 只需要留下[m + 1, r)</span>
</div></li><li><div class="code-word">        l = m + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        <span class="hljs-comment">// case (d)</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 到这里，右边的区间[m, ... , r)</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 已经不需要了，只需要留下区间[l, ... , m)</span>
</div></li><li><div class="code-word">        r = m;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="323478">
                      <p data-nodeid="323479">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325021"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325025"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325029"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323480">
                      <strong data-nodeid="325034">复杂度分析</strong
                      >：时间复杂度为 O(lgN)，空间复杂度 O(1)。
                    </p>
                    <p data-nodeid="323481">
                      【<strong data-nodeid="325040">小结</strong
                      >】虽然整个数组不是有序的，但是我们可以每次都在一个小范围里面利用二分进行搜索。
                    </p>
                    <p data-nodeid="323482">
                      <strong data-nodeid="325049">考点</strong>：
                      这道题的考点就是分清楚
                      （a）、(b）、（c）、（d）四种情况。要特别注意的是，在处理（a）、(b）两种情况的时候，<strong
                        data-nodeid="325050"
                        >要用 if 判断有序的部分，else 处理无序的部分</strong
                      >。比如：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">if</span> (A[l] &lt; x &amp;&amp; x &lt; A[m]) { <span class="hljs-comment">/*case (a)*/</span>} <span class="hljs-comment">// if处理有序的部分。</span>
</div></li><li><div class="code-word"><span class="hljs-keyword">else</span> { <span class="hljs-comment">/*case (b)*/</span>};
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323484">
                      （c）、（d）两个条件的处理也是如此。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">if</span> (A[m] &lt; x &amp;&amp; x &lt; A[r-<span class="hljs-number">1</span>]) { <span class="hljs-comment">/* case (c)*/</span>} <span class="hljs-comment">// if处理有序的部分 </span>
</div></li><li><div class="code-word"><span class="hljs-keyword">else</span> { <span class="hljs-comment">/*case (d)*/</span>}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="323486">
                      我在面试时，曾经遇到不少候选人在处理这四情况的时候没有想到上面这个小技巧，因此浪费了很长时间。
                    </p>
                    <p data-nodeid="323487">
                      <strong data-nodeid="325061">练习题 6</strong>：例 5
                      还可以利用前面我们介绍过的<strong data-nodeid="325062"
                        >提问破题法</strong
                      >来进行求解。你能想一下吗？
                    </p>
                    <blockquote data-nodeid="323488">
                      <p data-nodeid="323489">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325066"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325070"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325074"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323490">
                      <strong data-nodeid="325079">练习题 7</strong
                      >：题目限制了没有重复元素，如果有重复元素，如何进行查找呢？
                    </p>
                    <blockquote data-nodeid="323491">
                      <p data-nodeid="323492">
                        解法 1:<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325083"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325087"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325091"
                          >Python</a
                        ><br />
                        解法 2:<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii.2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325096"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii.2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325100"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii.2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325104"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="323493">
                      <strong data-nodeid="325109">练习题 8</strong
                      >：一个有序数组经过了旋转，请找出这里面最小的元素（有重复元素）。
                    </p>
                    <blockquote data-nodeid="323494">
                      <p data-nodeid="323495">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-ii.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325113"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325117"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/154.%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-ii.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="325121"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h3 data-nodeid="323496">总结</h3>
                    <p data-nodeid="323497">
                      到这里我们已经可以总结一下二分搜索涉及的知识点了，如下图所示：
                    </p>
                    <p data-nodeid="323498">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/27/B8/CioPOWBdnvmAHabcAAJ_yPY2KLM697.png"
                        alt="Drawing 32.png"
                        data-nodeid="325126"
                      />
                    </p>
                    <p data-nodeid="323499">如果要顺利地解决二分搜索，那么：</p>
                    <ul data-nodeid="323500">
                      <li data-nodeid="323501">
                        <p data-nodeid="323502">
                          首先你需要熟练地写出两个 lowerBound 和 upperBound
                          的模板
                        </p>
                      </li>
                      <li data-nodeid="323503">
                        <p data-nodeid="323504">
                          然后你需要学会应用提问破题法和切分法
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="323505">
                      掌握以上两个技巧，那么绝大部分涉及二分搜索的面试题就再也难不住你了。
                    </p>
                    <h3 data-nodeid="323506">思考题</h3>
                    <p data-nodeid="323507">
                      我再给你留一道<strong data-nodeid="325141">思考题</strong
                      >：给定两个有序数组，请找出这两个有序数组的中位数。(是的，这是“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6697&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="325139"
                        >第 08 讲</a
                      >”例 2）。不过我希望你能够用二分搜索的办法来进行求解。
                    </p>
                    <p data-nodeid="323508" class="te-preview-highlight">
                      接下来请和我一起踏上更加奇妙的算法旅程。让我们继续前进。下一讲将介绍
                      10 |双指针：如何掌握解决最长，定长，最短区间问题的决窍。
                    </p>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >数据结构与算法面试宝典</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <!---->
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *飞
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        2
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      例题4问题3的落差法好像有点问题，当B[]所有值都大于0的时候，c[i]-min(c[0],....,c[i-1])就不对了，想解决的话可以加个c[-1]=0,c[i]-min(c[-1],....,c[i-1])就可以了
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    你可以看一下落差法的代码。在代码里面设置了int64_t
                    pre_min_value = 0;实际上相当于C[-1] = 0
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *琪
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      练习题
                      3：给定一个有序数组，找出数组中下标与值相等的那些数；这个题目中的代码
                      不对吧，[1,2,3,3,4,5]这样的数组，就拿不到结果，[0,1,2,2,4,5]也只返回某个元素，没返回所有的符合条件的元素。
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    练习题3并不要求返回所有符合条件的元素。练习题4才是返回所有满足条件的数的范围。
                    练习题3当找不到的时候，参考代码中会返回-1.表示没有找到。这个也是测试平台的要求。练习题3的参考代码是通过了测试平台的，正确无误。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **方
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      左开右闭：原因很简单，这个和编程当中的数组定义的情况一致。
                      我们都知道，在代码的世界里，数组是从0开始的，一个长度为10的数组，最后一个元素的下标是9。
                      如果使用左闭右开区间，我们将l=0，r=数组长度，就完成了初始化，如果用闭区间，r=长度-1，不免显得有些多余。
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    赞！我以前学C语言的时候还在想，为什么下标不从1开始。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **0035
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      练习题8（LeetCode.154）判断语句里为什么一定要找右边界，试了下找左边界好像怎么也调不通。。。
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    这里我用左边界面进行了尝试。需要判断的条件比较多。代码在这里：
                    https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/154.寻找旋转排序数组中的最小值-ii.left.java
                    左边界处理起来很烦的原因是，如果最后只有两个数A[L],
                    A[L+1](即r=L+1)。那么当你取中间的数。m = 0，此时m会与L重合。
                  </div>
                  <!---->
                  <!---->
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 685,
      courseCId: "",
      courseName: "数据结构与算法面试宝典",
      teachers: [
        {
          id: 630,
          teacherName: "德鲁伊",
          position: "前微软资深软件工程师",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span class="ql-author-13568064 ql-font-microsoftyahei" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto; background-color: rgb(255, 255, 255);">9&nbsp;年技术研发经验，主导过&nbsp;40PB&nbsp;级别的分布式存储系统架构设计与实现。带领团队实现核心模块，如用户态文件系统、存储引擎、分布式&nbsp;KV&nbsp;缓存。负责部门技术面试，有丰富的技术面试经验。此外，曾</span><span class="ql-font-microsoftyahei ql-author-13568064" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto;">作为复旦大学特聘讲师，面向研究生学院开展 IT 类课程，拥有多年授课经验。擅长架构设计、机器学习、云计算、大数据等领域。</span></span></p>',
        },
      ],
      totalCourseTime: 23,
      totalDuration: 340,
      sales: 18623,
      price: "98",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
      sellGoodsId: 748,
      sellGoodsPriceId: 73322,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。",
      seoKeywords:
        "数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季",
      seoTitle: "数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育",
      shareTitle: "这15种题型，算法面试肯定会问！",
      shareDescription: "300+高频真题详解，一题多解攻克算法面试",
      brief: "300+大厂高频真题，一题多解攻克算法面试",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png",
      courseType: 1,
      previewFirstField: "共23讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 638,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 638,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "83ec46930d5245bcae30be7a5f7786a2"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
</body>
