<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">数据结构与算法面试宝典 - 拉勾教育</h1>

  <meta
    content="数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季"
    name="keywords"
  />

  <meta
    content="数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。"
    name="description"
  />

  <title>数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  数据结构与算法面试宝典
                </div>
                <div data-v-5f686215="" class="name">
                  德鲁伊
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  前微软资深软件工程师
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 |&nbsp;告别盲目刷题，击破算法面试
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 759px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：数据结构之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 栈：从简单栈到单调栈，解决经典栈问题
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 队列：FIFO 队列与单调队列的深挖与扩展
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 优先级队列：堆与优先级队列，筛选最优元素
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 树：如何深度运用树的遍历？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 并查集：如何利用两行代码写并查集？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          加餐与答疑 | 第一期 ：一问一答
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：算法之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08&nbsp;|
                          排序：如何利用合并与快排的小技巧，解决算法难题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10&nbsp;|
                          双指针：如何掌握最长、定长、最短区间问题的解题决窍？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12&nbsp;|
                          回溯：我把回溯总结成一个公式，回溯题一出就用它
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | DP：我是怎么治好“DP&nbsp;头痛症”的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：一题多解篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19&nbsp;|
                          最小体力消耗路径：如何突破经典题型，掌握解题模板？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20&nbsp;| 5
                          种解法，如何利用常量空间求解最长有效括号长度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21&nbsp;| 安排会议室：如何利用多种方法安排会议室？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：代码模板篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 |&nbsp;数据结构模板：如何让解题变成搭积木？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    彩蛋
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 |&nbsp;算法的精进之路
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 146px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  19&nbsp;| 最小体力消耗路径：如何突破经典题型，掌握解题模板？
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/05/03
                  <span data-v-1605a430="" class="auth">德鲁伊</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/21:58"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="1318"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/21:58</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">
                            57.32M
                          </div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/21:58
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="4">
                      今天我们继续从多个角度去求解一个题目，尝试运用丰富的解题工具，比如我们的“老熟人”BFS/DFS/Dijkstra
                      算法，帮助你巩固和应用已经学习过的知识点。除此之外，本讲还会重点介绍一些在“一题多解”中尚未覆盖到的算法：
                    </p>
                    <ul data-nodeid="5">
                      <li data-nodeid="6">
                        <p data-nodeid="7">并查集</p>
                      </li>
                      <li data-nodeid="8">
                        <p data-nodeid="9">二分搜索</p>
                      </li>
                      <li data-nodeid="10">
                        <p data-nodeid="11">动态规划（Bellman-Ford 算法）</p>
                      </li>
                    </ul>
                    <p data-nodeid="12">
                      通过“一题多解”的训练，拓展我们的思维，一起去探索“五彩缤纷”的解题技巧。让我们马上开始。
                    </p>
                    <h3 data-nodeid="13">题目</h3>
                    <p data-nodeid="14">
                      你准备参加一场远足活动。给你一个二维 rows x columns 的地图
                      heights ，其中 heights[row][col] 表示格子 (row, col)
                      的高度。
                    </p>
                    <ul data-nodeid="15">
                      <li data-nodeid="16">
                        <p data-nodeid="17">
                          一开始你在最左上角的格子 (0, 0)
                          ，且你希望去最右下角的格子 (rows-1, columns-1)
                          （注意下标从 0 开始编号）。
                        </p>
                      </li>
                      <li data-nodeid="18">
                        <p data-nodeid="19">
                          你每次可以往 上、下、左、右<strong data-nodeid="306"
                            >四个方向</strong
                          >之一移动，你想要找到耗费体力最小的一条路径。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="20">
                      <strong data-nodeid="323">一条路径耗费的体力值</strong
                      >是由路径上相邻格子之间<strong data-nodeid="324"
                        >高度差绝对值</strong
                      >的<strong data-nodeid="325">最大值</strong
                      >决定的。请你返回从左上角走到右下角的最小体力消耗值
                      。矩阵中最大值不超过 10<sup>6</sup>。
                    </p>
                    <p data-nodeid="21">例如给定如下地图：</p>
                    <p data-nodeid="5191" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbuSAJ2gJAAPuzNBJ23A021.png"
                        alt="Drawing 0.png"
                        data-nodeid="5194"
                      />
                    </p>

                    <p data-nodeid="23">
                      <strong data-nodeid="347">输入</strong>：heights =
                      [[1,2,2],[3,8,2],[5,3,5]]
                    </p>
                    <p data-nodeid="24">
                      <strong data-nodeid="352">输出</strong>：2
                    </p>
                    <p data-nodeid="25">
                      <strong data-nodeid="365">解释</strong>：路径 [1,3,5,3,5]
                      连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5]
                      更优，因为另一条路径差值最大值为 3 。
                    </p>
                    <p data-nodeid="26">
                      注意：我们在处理这个题目的时候，一定要注意题目要求的结果是：
                    </p>
                    <blockquote data-nodeid="27">
                      <p data-nodeid="28">
                        从左上角走到右下，路径上<strong data-nodeid="380"
                          >高度差绝对值</strong
                        >的<strong data-nodeid="381">最大值</strong>要<strong
                          data-nodeid="382"
                          >最小</strong
                        >。
                      </p>
                    </blockquote>
                    <p data-nodeid="29">即不是求路径和，也不是求最短路径。</p>
                    <h3 data-nodeid="30">预处理</h3>
                    <p data-nodeid="31">
                      当拿到这个题之后，我们发现，与脑海里熟悉的题目还是有点差异的。因此需要对题目进行一些预处理，尽量将题目转换成为我们熟悉的题目。
                    </p>
                    <h4 data-nodeid="32">点的处理</h4>
                    <p data-nodeid="33">
                      首先，如果我们把矩阵中的每个位置都当成一个图（算法中的图
                      Graph）中的一个点。那么可以将点表示如下：
                    </p>
                    <p data-nodeid="7265" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbuuAUw3wAABvcGwSSqs667.png"
                        alt="Drawing 1.png"
                        data-nodeid="7268"
                      />
                    </p>

                    <p data-nodeid="35">
                      这里，为了表示方便，我们将每个点独立进行编号。当然，这种编号只是为了方便我们索引每个点的具体信息。
                    </p>
                    <blockquote data-nodeid="36">
                      <p data-nodeid="37">
                        如果我们想用一维数组存放点的信息，就需要将点编号为一维的整数。<br />
                        如果我们想用二维数组存放点的信息，就需要用 &lt;row,
                        col&gt; 来表示一个点的编号。
                      </p>
                    </blockquote>
                    <p data-nodeid="38">
                      至于使用一维数组还是二维数组，要根据具体的算法和题目进行分析。我们来看下面两种情况。
                    </p>
                    <ul data-nodeid="39">
                      <li data-nodeid="40">
                        <p data-nodeid="41">
                          因为我们平常使用的并查集便是在一维数组上操作，那么把点编号为一维的整数无疑更方便。
                        </p>
                      </li>
                      <li data-nodeid="42">
                        <p data-nodeid="43">
                          DFS/BFS
                          遍历的时候，对于矩阵而言，二维的信息遍历时更方便，因此搜索时，我们经常使用
                          &lt;row, col&gt; 来表示一个点的编号。
                        </p>
                      </li>
                    </ul>
                    <h4 data-nodeid="44">边的处理</h4>
                    <p data-nodeid="45">
                      通常图的题目，都会直接给出边的
                      &lt;出发点，终点，权重&gt;，但是这道题却没有直接给出来。当然，在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="408"
                        >18 | 单词接龙：如何巧用深搜与广搜的变形？</a
                      >”中，我们也遇到过没有直接给出边的信息的情况。当时的处理方式是采用“预处理”挖掘出图中边的信息。
                    </p>
                    <p data-nodeid="46">
                      于是，需要我们把这边的信息给挖掘出来。那么，在这个题中，边的信息是什么？根据题目的定义，当我们从结点
                      A&lt;r 行,c 列&gt; 走到结点 B&lt;nr 行, nc 列&gt;
                      的时候，消耗的体力值是：
                    </p>
                    <blockquote data-nodeid="47">
                      <p data-nodeid="48">
                        Math.abs(heights[r][c] - heights[nr][nc])
                      </p>
                    </blockquote>
                    <p data-nodeid="49">因此，边可以表示为：</p>
                    <blockquote data-nodeid="50">
                      <p data-nodeid="51">
                        edge = [&lt;r,c&gt; &lt;nr,nc&gt;, cost]<br />
                        cost = Math.abs(heights[r][c] - heights[nr][nc])
                      </p>
                    </blockquote>
                    <p data-nodeid="52">加上边之后，图问题就可以表示如下：</p>
                    <p data-nodeid="9339" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbvSAD3NzAAB-KL3zX7g895.png"
                        alt="Drawing 2.png"
                        data-nodeid="9342"
                      />
                    </p>

                    <p data-nodeid="54">
                      根据上述分析，题目就可以转换成我们非常熟悉的题目：
                    </p>
                    <blockquote data-nodeid="55">
                      <p data-nodeid="56">
                        给定图的点和边，以及出发点和终点，找出一条路径，使得这条路径上边的权重的最大值尽可能最小。输出这个最小值。
                      </p>
                    </blockquote>
                    <h3 data-nodeid="57">特点 1：连通性</h3>
                    <p data-nodeid="58">
                      题目要求找一个最小的值
                      ans，并且出发点和终点必须在一条路径上，这条路径上所有的边的权重都
                      &lt;= ans。
                    </p>
                    <p data-nodeid="59">
                      那么反过来说，如果我们把权重大于 ans
                      的边都删除，出发点与终点的这条路径仍然是存在的。
                    </p>
                    <p data-nodeid="11413" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3C/91/Cgp9HWCLbvuAHbqbAATbsJyOIcc083.png"
                        alt="Drawing 3.png"
                        data-nodeid="11416"
                      />
                    </p>

                    <p data-nodeid="61">
                      既然如此，那么我们采用如下动图所示的方式应该也可以工作：
                    </p>
                    <p data-nodeid="13487" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbwOAWL-qAAv2KyBnV5o934.gif"
                        alt="1.gif"
                        data-nodeid="13490"
                      />
                    </p>

                    <p data-nodeid="64">
                      通过这种方式，我们需要解决的问题，可以表示如下：
                    </p>
                    <ol data-nodeid="65">
                      <li data-nodeid="66">
                        <p data-nodeid="67">
                          取出所有的边，并且按权重排序（因为我们要按权重加入图）；
                        </p>
                      </li>
                      <li data-nodeid="68">
                        <p data-nodeid="69">
                          当加入一条边之后，我们需要查看一下图中的两点是否连通。
                        </p>
                      </li>
                    </ol>
                    <p data-nodeid="70">
                      其中第一个问题比较容易处理。现在问题的核心与重点就是需要<strong
                        data-nodeid="481"
                        >尽快判断两个点是否连通</strong
                      >。
                    </p>
                    <p data-nodeid="71">
                      根据我们之前学过的知识，判断图中两个点是否连通，可以使用：
                    </p>
                    <ul data-nodeid="72">
                      <li data-nodeid="73">
                        <p data-nodeid="74">并查集</p>
                      </li>
                      <li data-nodeid="75">
                        <p data-nodeid="76">BFS</p>
                      </li>
                      <li data-nodeid="77">
                        <p data-nodeid="78">DFS</p>
                      </li>
                    </ul>
                    <p data-nodeid="79">
                      但是，BFS/DFS
                      如果需要每加入一条边都进行判断，很明显是不适合的。当有一个
                      N x N 的矩阵，每次 BFS/DFS 的时间复杂度为 O(N x
                      N)，整个算法的时间复杂度就达到 O(E x N x N)。
                    </p>
                    <p data-nodeid="80">
                      那么只能使用并查集，因为我们知道，并查集检查两个点是否连通的时候，时间杂度可以达到
                      O(lgN)。因此，这里我们需要使用并查集来判断出发点与终点的连通性。
                    </p>
                    <p data-nodeid="81">至此，我们可以写出伪代码如下：</p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">edges = getAllEdges();
</div></li><li><div class="code-word">sort(edges);
</div></li><li><div class="code-word"><span class="hljs-keyword">for</span> edge in edges:
</div></li><li><div class="code-word">     addEdge(edge);
</div></li><li><div class="code-word">     <span class="hljs-keyword">if</span> (connected(start, endNode)):
</div></li><li><div class="code-word">       <span class="hljs-keyword">return</span> edge.cost;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="83">
                      有了以上的思路，我们就可以写出并查集的求解代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 并查集类</span>
</div></li><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">    Init(n);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
</div></li><li><div class="code-word">      F[i] = i;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (x == F[x]) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    F[x] = Find(F[x]);
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> F[x];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
</div></li><li><div class="code-word">    F[Find(x)] = Find(y);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>
</span></div></li><li><div class="code-word">{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 行数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 列数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 四个方向</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> },
</div></li><li><div class="code-word">                           { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 由于并查集是一维的，我们需要将二维的点映射到</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 一维的点</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPointMapping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> r * Cols + c;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这个函数并不是把edge加到图中，而是在收集一条边</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// edge: startNode = &lt;r,c&gt;, toNode=&lt;nr,nc&gt;, cost</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 加入边数组中</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] edges,
</span></span></div></li><li><div class="code-word">                       <span class="hljs-keyword">int</span> iter,
</div></li><li><div class="code-word">                       <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c,
</div></li><li><div class="code-word">                       <span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">int</span> nc,
</div></li><li><div class="code-word">                       <span class="hljs-keyword">int</span> cost) {
</div></li><li><div class="code-word">    edges[iter][<span class="hljs-number">0</span>] = getPointMapping(r, c);
</div></li><li><div class="code-word">    edges[iter][<span class="hljs-number">1</span>] = getPointMapping(nr, nc);
</div></li><li><div class="code-word">    edges[iter][<span class="hljs-number">2</span>] = cost;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 处理的主函数</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 收集行数</span>
</div></li><li><div class="code-word">    Rows = heights.length;
</div></li><li><div class="code-word">    <span class="hljs-comment">// 收集列数</span>
</div></li><li><div class="code-word">    Cols = heights[<span class="hljs-number">0</span>].length;
</div></li><li><div class="code-word">   
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果只有一个点</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (Rows == <span class="hljs-number">1</span> &amp;&amp; Cols == <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">   
</div></li><li><div class="code-word">    <span class="hljs-comment">// 采用并查集的做法</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 横向的无向边的数目</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hNumber = Rows * (Cols - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 纵向的无向边的数目</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> vNumber = Cols * (Rows - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 无向边</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 记录起点，终点，权重</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[hNumber + vNumber][<span class="hljs-number">3</span>];
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 得到所有的边</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> edgeIter = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 看一下 右边的点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; Cols) {
</div></li><li><div class="code-word">          <span class="hljs-comment">// 得到边的权重</span>
</div></li><li><div class="code-word">          <span class="hljs-keyword">int</span> edgeCost =
</div></li><li><div class="code-word">            Math.abs(heights[r][c] - heights[r][c + <span class="hljs-number">1</span>]);
</div></li><li><div class="code-word">          <span class="hljs-comment">// 将边放到边集中</span>
</div></li><li><div class="code-word">          putEdge(edges, edgeIter,
</div></li><li><div class="code-word">            r, c, r, c + <span class="hljs-number">1</span>, edgeCost);
</div></li><li><div class="code-word">          
</div></li><li><div class="code-word">          edgeIter++;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; Rows) {
</div></li><li><div class="code-word">          <span class="hljs-comment">// 得到一条向下的边的权重</span>
</div></li><li><div class="code-word">          <span class="hljs-keyword">int</span> edgeCost =
</div></li><li><div class="code-word">            Math.abs(heights[r][c] - heights[r + <span class="hljs-number">1</span>][c]);
</div></li><li><div class="code-word">          <span class="hljs-comment">// 将边放到边集中</span>
</div></li><li><div class="code-word">          putEdge(edges, edgeIter,
</div></li><li><div class="code-word">            r, c, r + <span class="hljs-number">1</span>, c, edgeCost);
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">          edgeIter++;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 再将边进行排序</span>
</div></li><li><div class="code-word">    Arrays.sort(edges, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
</div></li><li><div class="code-word">      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    });
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 排序结束之后，再使用并查集，依次加入边</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalNodes = Rows * Cols;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 并查集</span>
</div></li><li><div class="code-word">    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(totalNodes);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> src = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dst = getPointMapping(Rows - <span class="hljs-number">1</span>, Cols - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) {
</div></li><li><div class="code-word">      uf.Union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);
</div></li><li><div class="code-word">      <span class="hljs-comment">// 如果能让 src dst连通</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 那么就是当前的cost</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (uf.Find(src) == uf.Find(dst)) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> edge[<span class="hljs-number">2</span>];
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &gt; -<span class="hljs-number">1</span>; <span class="hljs-comment">// Should not reach here!</span>
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="85">
                      <p data-nodeid="86">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="493"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="497"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="501"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="87">
                      <strong data-nodeid="506">复杂度分析</strong>：一个 N x M
                      的数组，可以认为一共有 O(N x M)
                      条边，收集到这些边之后，然后进行排序，排序的时间复杂度为
                      O(N x M x lg(N x M))，存放边的空间复杂度为 O(N x
                      M)。接下来，我们需要利用并查集进行处理，一共有 O(N x M)
                      个点，O(N x M) 条边。那么并查集处理的时间复杂度为 O(N x M
                      x lg(N x M))。所以，整个问题时间复杂度为 O(N x M x lg(N x
                      M))，空间复杂度为 O(N x M)。
                    </p>
                    <p data-nodeid="88">
                      当你看完这个题，你还可以回过头去看看“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6696&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="510"
                        >07 | 并查集：如何利用两行代码写并查集？</a
                      >”里面的例
                      1，在那里，我们同样用到了相同的方法进行处理——最小生成树的思想。通过这些比较，可以发现我们可以通过掌握一种算法思想，在不同的题目中游刃有余。
                    </p>
                    <h3 data-nodeid="89">特点 2：最小值</h3>
                    <p data-nodeid="90">
                      我们再回到题目，题目要求的是最小值。那么我们想一想：最小值
                      ans 肯定是一个分界，这个分界体现在两个方向：
                    </p>
                    <ul data-nodeid="91">
                      <li data-nodeid="92">
                        <p data-nodeid="93">
                          比 ans 更小的值，不会让出发点和终点之间可以连通；
                        </p>
                      </li>
                      <li data-nodeid="94">
                        <p data-nodeid="95">
                          大于等于 ans
                          的值，那么肯定可以让出发点与终点可以连通。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="96">
                      如果我们用数组进行表示，那么可以达到如下图所示的效果：
                    </p>
                    <p data-nodeid="15557" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3C/91/Cgp9HWCLbxKAEgdXAAA4xI3NFuI649.png"
                        alt="Drawing 5.png"
                        data-nodeid="15560"
                      />
                    </p>

                    <p data-nodeid="98">
                      如果我们分别用 -1 表示 NO，0 表示
                      OK。那么问题转变成下面这样：
                    </p>
                    <p data-nodeid="17627" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbyKAejCRAAA2P_x4DC8327.png"
                        alt="Drawing 6.png"
                        data-nodeid="17630"
                      />
                    </p>

                    <p data-nodeid="100">
                      我们需要在一个左边为 -1，右边为 0 的数组中，找到第一个为 0
                      的下标的位置。那么，最适合解决这个问题的算法就是<strong
                        data-nodeid="529"
                        >二分搜索</strong
                      >了。
                    </p>
                    <h4 data-nodeid="101">四步法</h4>
                    <p data-nodeid="102">
                      现在算法方向已经确定了，是时候拿出我们的“二分搜索四步法”了。如果你对这个方法还不太熟悉，可以先回到“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6698&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="534"
                        >09 | 二分搜索：为什么说有序皆可用二分？</a
                      >”复习一下二分搜索的内容，再来看接下来的分析。
                    </p>
                    <ul data-nodeid="103">
                      <li data-nodeid="104">
                        <p data-nodeid="105">
                          <strong data-nodeid="540">第一步</strong
                          >：要什么，什么就是 x。
                        </p>
                      </li>
                      <li data-nodeid="106">
                        <p data-nodeid="107">
                          <strong data-nodeid="545">第二步</strong
                          >：满足约束条件的 f(x) = 0。
                        </p>
                      </li>
                      <li data-nodeid="108">
                        <p data-nodeid="109">
                          <strong data-nodeid="554">第三步</strong>：<strong
                            data-nodeid="555"
                            >不满足</strong
                          >约束条件的 f(x) 设置为 -1 或者 1。
                        </p>
                      </li>
                      <li data-nodeid="110">
                        <p data-nodeid="111">
                          <strong data-nodeid="563">第四步</strong>：最优解 0 在
                          C[] 的最左边还是最右边，决定使用 lowerBound 还是
                          upperBound。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="112">接下来，我们一步一步展开。</p>
                    <p data-nodeid="113">
                      <strong data-nodeid="568">第一步</strong>
                    </p>
                    <p data-nodeid="114">
                      我们的问题是要输出一个最小体力消耗值，也就是 x。确定 x
                      之后，我们还需要确定 x
                      的范围。在这个题中，所有的边都加上之后，出发点与终点是肯定有路径的。所以
                      x 的范围就确定了：
                    </p>
                    <ul data-nodeid="115">
                      <li data-nodeid="116">
                        <p data-nodeid="117">
                          x 的最小值，就是图中边的权重的最小值
                        </p>
                      </li>
                      <li data-nodeid="118">
                        <p data-nodeid="119">
                          x 的最大值，就是图中边的权重的最大值
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="120">
                      <strong data-nodeid="575">第二步</strong>
                    </p>
                    <p data-nodeid="121">
                      这里需要确定 f(x) =
                      0。根据题意，当我们得到最小消耗的体力值 x
                      之后，在遍历图的时候，当发现边的权重大于
                      x，直接把这条边禁用即可。当发现出发点与终点之间存在通路，我们就可以认为
                      f(x) = 0。
                    </p>
                    <p data-nodeid="122">
                      <strong data-nodeid="580">第三步</strong>
                    </p>
                    <p data-nodeid="123">
                      得到最小消耗体力值 x 之后，在遍历时，把权重大于 x
                      的边禁用，如果发现出发点与终点之间不存在通路，此时设置
                      f(x) = -1。
                    </p>
                    <p data-nodeid="124">
                      在这个题中，由于出发点与终点只有连通与不连通两种情况。所以我们“二分搜索”映射之后的数组里面只会有
                      -1 和 0。
                    </p>
                    <p data-nodeid="125">
                      <strong data-nodeid="586">第四步</strong>
                    </p>
                    <p data-nodeid="19697">
                      在本题中，当映射到一个数组之后，我们要求的是满足 f(x) = 0
                      的最小值。
                    </p>
                    <p data-nodeid="19698" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbyyALJXRAAA2NUdivXw497.png"
                        alt="Drawing 7.png"
                        data-nodeid="19702"
                      />
                    </p>

                    <p data-nodeid="128">
                      也就是求数组中值为 0 的第一个下标，那么肯定应该使用
                      lowerBound。
                    </p>
                    <h4 data-nodeid="129">f 函数</h4>
                    <p data-nodeid="130">
                      根据前面四步分析法，我们已经可以写出二分搜索的伪代码了：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">l = minCost
</div></li><li><div class="code-word">r = maxCost
</div></li><li><div class="code-word"><span class="hljs-keyword">while</span> l &lt; r:
</div></li><li><div class="code-word">    mid = l + ((r-l)&gt;&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">// mid表示x</span>
</div></li><li><div class="code-word">    mv = f(mid) <span class="hljs-comment">// 调用f(x)</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (mv &lt; <span class="hljs-number">0</span>):
</div></li><li><div class="code-word">        l = mid + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">else</span>:
</div></li><li><div class="code-word">        r = mid
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="132">
                      不过在正式写代码之前，还是要想一下 f
                      函数如何写。我们可以先回想一下 f(x) 要解决的问题：
                    </p>
                    <blockquote data-nodeid="133">
                      <p data-nodeid="134">
                        禁用所有权重大于 x
                        的边之后，图中出发点与终点之间是否还有路径。
                      </p>
                    </blockquote>
                    <p data-nodeid="135">
                      我们可以把禁用权重大于 x
                      的边，看成是利用一个旧图，生成了一张新图。比如：
                    </p>
                    <p data-nodeid="21769" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbzOAbNdGAACu5sMfhbM647.png"
                        alt="Drawing 8.png"
                        data-nodeid="21772"
                      />
                    </p>

                    <p data-nodeid="137">
                      <strong data-nodeid="604"
                        >那么 f(x)
                        的本质就是在一个新图上判断两点之间的连通性</strong
                      >。关于连通性的判定，我们前面提到过，有 3 种办法：
                    </p>
                    <ul data-nodeid="138">
                      <li data-nodeid="139">
                        <p data-nodeid="140">并查集</p>
                      </li>
                      <li data-nodeid="141">
                        <p data-nodeid="142">BFS</p>
                      </li>
                      <li data-nodeid="143">
                        <p data-nodeid="144">DFS</p>
                      </li>
                    </ul>
                    <p data-nodeid="145">
                      在特点 1 中，我们说明了只能选用并查集，不能使用 BFS 与
                      DFS，还给出了时间复杂度上的证明。在这里，恰恰相反，三种办法都是可以使用的。下面我们一起证明一下。
                    </p>
                    <p data-nodeid="146">假设给定了 N x M 大小的矩阵。</p>
                    <ul data-nodeid="147">
                      <li data-nodeid="148">
                        <p data-nodeid="149">
                          并查集：一共有 O(N x M) 条边，时间复杂度主要由并查集的
                          Union 决定，一共需要 Union O(N x M) 次，每次 Union
                          时间复杂度为 O(lg(N x M)（因为一共有 O(N x M)
                          个点）。所以总共的时间复杂度为 O(N x M lg(N x M))。
                        </p>
                      </li>
                      <li data-nodeid="150">
                        <p data-nodeid="151">
                          BFS：一共有 O(N x M)
                          个点，最差情况下，每个点都会遍历，所以时间复杂度为 O(N
                          x M)。
                        </p>
                      </li>
                      <li data-nodeid="152">
                        <p data-nodeid="153">
                          DFS：一共有 O(N x M)
                          个点，最差情况下，每个点都会遍历，所以时间复杂度为 O(N
                          x M)。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="154">
                      也就是说，f(x) 函数的时间复杂度都差不多（并查集多了一个
                      O(lg)）。
                    </p>
                    <p data-nodeid="155">
                      如果再算上最外层二分搜索的时间复杂度，由于最大的数为
                      10<sup>6</sup>，所以整个二分搜索的时间复杂度为：
                    </p>
                    <ul data-nodeid="156">
                      <li data-nodeid="157">
                        <p data-nodeid="158">
                          O(lg(10<sup>6</sup>) N x M) ← 二分 + BFS/DFS；
                        </p>
                      </li>
                      <li data-nodeid="159">
                        <p data-nodeid="160">
                          或者 O(lg(10<sup>6</sup>) N x M x lg (N x M)) ← 二分 +
                          并查集。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="161">
                      基于这样的思路，我们就可以写出二分搜索的代码了（二分搜索 +
                      DFS）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">//  二分搜索</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 行数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 列数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 一个点周围的四个方向</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> }, { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-keyword">boolean</span>[][] vis = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearVisRecord</span><span class="hljs-params">()</span>
</span></div></li><li><div class="code-word">  {
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
</div></li><li><div class="code-word">        vis[r][c] = <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这里采用DFS来寻路</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// &lt;r,c&gt;是当前的出发点</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights, <span class="hljs-keyword">int</span> maxValue,
</span></span></div></li><li><div class="code-word">                      <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果已经走到了目标点&lt;rows-1, cols-1&gt;</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (r == Rows - <span class="hljs-number">1</span> &amp;&amp; c == Cols - <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 查看 &lt;r,c&gt;点的四周</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// 如果周边的点有效，并且没有被访问过</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> ((!(nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> || nr &gt;= Rows || nc &gt;= Cols))
</div></li><li><div class="code-word">           &amp;&amp; !vis[nr][nc]) {
</div></li><li><div class="code-word">           
</div></li><li><div class="code-word">        <span class="hljs-comment">// 获取边的代价</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cost =
</div></li><li><div class="code-word">            Math.abs(heights[r][c] - heights[nr][nc]);
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">        <span class="hljs-comment">// 在走的时候，如果比midValue大，那么这条路就不能走了</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (cost &lt;= maxValue) {
</div></li><li><div class="code-word">          vis[nr][nc] = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">          <span class="hljs-keyword">if</span> (dfs(heights, maxValue, nr, nc)) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">          }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// f(x)函数</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 重新映射之的一维数组</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// midValue是在二分的时候给定的值</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 我们在进行搜索的时候，路径上的绝对值不能比这个大</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 只能是 &lt;= midValue.</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 此时我们只需要寻找看看是否存在一条路径即可</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 如果存在一条路径，上面的绝对值 &lt;= midValue</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 那么满足条件-&gt; 返回0</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 如果没有这样的路径，那么返回-1</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights, <span class="hljs-keyword">int</span> midValue)</span> </span>{
</div></li><li><div class="code-word">    clearVisRecord();
</div></li><li><div class="code-word">    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> dfs(heights, midValue, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    Rows = heights.length;
</div></li><li><div class="code-word">    Cols = heights[<span class="hljs-number">0</span>].length;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// if just one node</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (Rows == <span class="hljs-number">1</span> &amp;&amp; Cols == <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 生成vis数组</span>
</div></li><li><div class="code-word">    vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[Rows][Cols];
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 二分搜索</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 找到搜索范围里：最大值/最小值</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> minCost = Integer.MAX_VALUE;
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> maxCost = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 看一下 右边的点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; Cols) {
</div></li><li><div class="code-word">          <span class="hljs-keyword">int</span> rightValue =
</div></li><li><div class="code-word">              Math.abs(heights[r][c] - heights[r][c + <span class="hljs-number">1</span>]);
</div></li><li><div class="code-word">          minCost = Math.min(minCost, rightValue);
</div></li><li><div class="code-word">          maxCost = Math.max(maxCost, rightValue);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; Rows) {
</div></li><li><div class="code-word">          <span class="hljs-keyword">int</span> downValue =
</div></li><li><div class="code-word">              Math.abs(heights[r][c] - heights[r + <span class="hljs-number">1</span>][c]);
</div></li><li><div class="code-word">          minCost = Math.min(minCost, downValue);
</div></li><li><div class="code-word">          maxCost = Math.max(maxCost, downValue);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 那么应该有一个值 target</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 当 路径的最大绝对值差为 x</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 并且 x &gt;= target的时候</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 总是可以走通的</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 所以我们二分搜索的范围就为[minCost, maxCost + 1)</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 我们定义-1: 表示左上角与右下有没有通路</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">//        0: 表示左上角与右下角有通路</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 那么形成的C数组就是[-1,-1,-1,-1, 0, 0, 0, 0]</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 这样的结构</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 因此，我们在利用二分搜索的时候，只需要找到最左边的</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 0的位置就可以了。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> l = minCost, r = maxCost + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (l &lt; r) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mv = getC(heights, mid);
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (mv &lt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">        l = mid + <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        r = mid;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> l;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="163">
                      <p data-nodeid="164">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="633"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="637"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="641"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="165">
                      <strong data-nodeid="650">复杂度分析</strong
                      >：时间复杂度O(lg(10<sup>6</sup>) N x M)，空间复杂度为O(N
                      x M)。
                    </p>
                    <p data-nodeid="166">
                      <strong data-nodeid="655">练习题 1</strong
                      >：在文中，我们已经证明了这道题还可以使用二分搜索 + BFS /
                      并查集来解决。你能写一下代码吗？
                    </p>
                    <blockquote data-nodeid="167">
                      <p data-nodeid="168">
                        二分 + BFS：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="659"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="663"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="667"
                          >Python</a
                        ><br />
                        二分 + 并查集：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="672"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="676"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="680"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h3 data-nodeid="169">特点 3：再看最小值</h3>
                    <p data-nodeid="170">
                      谈到图中两点之间路径的最小值，有没有觉得很熟悉？我们在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="685"
                        >18 | 单词接龙：如何巧用深搜与广搜的变形？</a
                      >”中刚刚介绍过“<strong data-nodeid="691"
                        >求解两个点的最短路径</strong
                      >”的方法：
                    </p>
                    <ul data-nodeid="171">
                      <li data-nodeid="172">
                        <p data-nodeid="173">
                          两点之间的最短路径（BFS 算法/Dijkstra 算法/BF 算法，即
                          Bellman-Ford 算法）；
                        </p>
                      </li>
                      <li data-nodeid="174">
                        <p data-nodeid="175">
                          一个点到其他所有点的最短路径（Dijkstra 算法/BF
                          算法）；
                        </p>
                      </li>
                      <li data-nodeid="176">
                        <p data-nodeid="177">
                          <strong data-nodeid="698">每两点</strong
                          >之间的最短路径（Floyd 算法）。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="23839" class="">
                      在这里，<strong data-nodeid="23849"
                        >一个点到其他所有点的最短路径</strong
                      >当然是包含了“两点之间的最短路径”的情况。所以后面我们在讨论的时候，都是<strong
                        data-nodeid="23850"
                        >一个点到其他所有点的最短路径</strong
                      >场景下的 BF 算法。
                    </p>

                    <p data-nodeid="179">
                      下面尝试一下 BF 算法（我们讲的场）。在“1<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="716"
                        >8 | 单词接龙：如何巧用深搜与广搜的变形？</a
                      >”的“练习题 1”里提到了可以用 BF
                      算法进行求解，但是没有详细介绍如何用 BF
                      算法。这里我们详细介绍一下。
                    </p>
                    <p data-nodeid="180">
                      如果直接看BF
                      算法的代码，容易看得一头雾水，但其实这是一种比较容易理解的算法。在拿出BF算法的模板代码前，我们先讲一下这个算法的本质（下图中橙色点表示出发点）。注意：是<strong
                        data-nodeid="723"
                        >本质</strong
                      >！并不完全是一个计算过程的模拟。
                    </p>
                    <p data-nodeid="25911" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLclCAcTHPAACthA1b_fY994.png"
                        alt="Drawing 9.png"
                        data-nodeid="25914"
                      />
                    </p>

                    <p data-nodeid="182">
                      Step 0. 首先我们有一些离散的点， 此时还没有加入任何边。
                    </p>
                    <p data-nodeid="27975" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcluAc9DMAADTk0wp1dQ877.png"
                        alt="Drawing 10.png"
                        data-nodeid="27978"
                      />
                    </p>

                    <p data-nodeid="184">
                      Step 1. 把<strong data-nodeid="740">所有的边</strong
                      >加入图中。只有一部分点（绿色）会在这一轮迭代中得到<strong
                        data-nodeid="741"
                        >最终的</strong
                      >src 出发的最短路径。
                    </p>
                    <blockquote data-nodeid="185">
                      <p data-nodeid="186">
                        注意：有一些点，经过这一轮的操作之后，虽然会与出发点 src
                        连通，但并没有得到<strong data-nodeid="747">最终</strong
                        >最短路径，在图中我们就没有画出这些点与 src 的连线。
                      </p>
                    </blockquote>
                    <p data-nodeid="187">
                      此时，我们可以再次从绿色点（因为它们已经是<strong
                        data-nodeid="753"
                        >最终的</strong
                      >最短路径了）出发，如果再次利用所有的边，应该可以再更新一波，得到一些新的最短路径的点。
                    </p>
                    <p data-nodeid="30039" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3C/92/Cgp9HWCLcmKAARFYAADrQRM28nQ863.png"
                        alt="Drawing 11.png"
                        data-nodeid="30042"
                      />
                    </p>

                    <p data-nodeid="189">
                      Step 2.
                      再次把所有的边加入图中，得到第二波最短路径的点（紫色）。
                    </p>
                    <p data-nodeid="32103" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcmmAPC1XAAD3iedUdk4707.png"
                        alt="Drawing 12.png"
                        data-nodeid="32106"
                      />
                    </p>

                    <p data-nodeid="191">
                      Step 3:
                      如果我们再从紫色点出发，把所有的边加到图中，那么可以得到最后一波最短路径的点（红色）。
                    </p>
                    <p data-nodeid="192">
                      这里只是假设更新 3
                      次就结束了，实际上有可能更多。那么问题来了，到底要把所有的边用来更新多少次呢？
                    </p>
                    <p data-nodeid="193">这里可以有两种办法。</p>
                    <ul data-nodeid="194">
                      <li data-nodeid="195">
                        <p data-nodeid="196">
                          积极的办法：当发现不能更新出一波新的最短路径的点的时候，就应该停止了。
                        </p>
                      </li>
                      <li data-nodeid="197">
                        <p data-nodeid="198">
                          消极的办法：假设每一波最差情况下只有一个点得到了最终的最短路径，那么一共需要更新
                          N-1 轮（在有 N 个点的情况下）。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="199">
                      那么问题的时间复杂度为 O(E x N)，其中 E 为边的数目，N
                      表示最差情况下更新的次数。
                    </p>
                    <p data-nodeid="200">
                      基于这种思想，我们就可以写出 BF
                      算法的代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {
</div></li><li><div class="code-word">        <span class="hljs-comment">//对m条边进行循环</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">var</span> edge = edges[j];
</div></li><li><div class="code-word">        <span class="hljs-comment">// 松弛操作</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span>(distance[edge.to] &gt;
</div></li><li><div class="code-word">          distance[edge.from] + edge.weight ) {
</div></li><li><div class="code-word">            distance[edge.to] = distance[edge.from] + edge.weight;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">   }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="202">
                      不过，要解决本题，还需要注意，<strong data-nodeid="778"
                        >经典的 BF 算法的最短路径是最小路径和为度量的，<strong
                          data-nodeid="777"
                          >而在本题中，是以</strong
                        >一条路径上的最大权重</strong
                      >进行度量的，所以我们还需要对 BF
                      算法做度量函数的微调，调整之后的代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 行数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 列数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 一个点周围的四个方向</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> },
</div></li><li><div class="code-word">                  { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
</div></li><li><div class="code-word">                  
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    Rows = heights.length;
</div></li><li><div class="code-word">    Cols = heights[<span class="hljs-number">0</span>].length;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果只有一个结点</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (Rows == <span class="hljs-number">1</span> &amp;&amp; Cols == <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 采用BF算法</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 从左上角走到右下角，最多只需要走Rows + Cols次</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 所以我们在更新的时候，最多只需要更新Rows + Cols次</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 并且，在更新的过程中，如果我们发现，没有任何一个点被更新的时候</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 我们就可以退出来了</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxDist = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">4</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Rows][Cols];
</div></li><li><div class="code-word">    <span class="hljs-comment">// 初始化整个距离</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
</div></li><li><div class="code-word">        dist[r][c] = maxDist;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxUpdateTimes = Rows + Cols;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 用BF算法来更新</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> updateTimes = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        updateTimes &lt; maxUpdateTimes; updateTimes++) {
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">      <span class="hljs-keyword">boolean</span> hasUpdateItem = <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// 用所有的边来进行更新</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
</div></li><li><div class="code-word">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">            <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (!(nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> ||
</div></li><li><div class="code-word">                  nr &gt;= Rows || nc &gt;= Cols)) {
</div></li><li><div class="code-word">                  
</div></li><li><div class="code-word">              <span class="hljs-comment">// 拿到边的代价</span>
</div></li><li><div class="code-word">              <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cost =
</div></li><li><div class="code-word">                  Math.abs(heights[r][c] - heights[nr][nc]);
</div></li><li><div class="code-word">                  
</div></li><li><div class="code-word">              <span class="hljs-comment">// 这条路径走过来的最大代价</span>
</div></li><li><div class="code-word">              <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextCost = Math.max(dist[r][c], cost);
</div></li><li><div class="code-word">              <span class="hljs-keyword">if</span> (nextCost &lt; dist[nr][nc]) {
</div></li><li><div class="code-word">                dist[nr][nc] = nextCost;
</div></li><li><div class="code-word">                hasUpdateItem = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">              }
</div></li><li><div class="code-word">              
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">          }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// 如果没有更新</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (!hasUpdateItem) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">break</span>;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> dist[Rows - <span class="hljs-number">1</span>][Cols - <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="204">
                      <p data-nodeid="205">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="782"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="786"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="790"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="206">
                      写完代码之后，我们再考虑一下 BF 算法与 Dijkstra
                      算法的联系与区别。
                    </p>
                    <ol data-nodeid="207">
                      <li data-nodeid="208">
                        <p data-nodeid="209">
                          <strong data-nodeid="796">联系</strong>：BF 算法与
                          Dijkstra 算法都会用更小的“最短路径”来更新。
                        </p>
                      </li>
                      <li data-nodeid="210">
                        <p data-nodeid="211">
                          <strong data-nodeid="801">区别</strong>：BF
                          算法属于动态规划算法，而 Dijkstra
                          算法则是属于贪心算法。
                        </p>
                      </li>
                    </ol>
                    <p data-nodeid="212">
                      1）相对来说，BF
                      算法在每一轮的更新中，都会得到一波点，这些点有最终的最短路径。但是更新的时候，需要用到所有的边。
                    </p>
                    <p data-nodeid="213">
                      2）Dijkstra
                      算法在更新点的距离时，则是从点的角度出发。既然每一波点都会得到最短距离，那么我就利用这波点去更新别的点的最短距离。
                    </p>
                    <h3 data-nodeid="214">特点 4: 又看最小值</h3>
                    <p data-nodeid="215">
                      谈到图中两点之间关于路径的最小值。在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="808"
                        >第 18 讲</a
                      >”中我们讲过，在求两个点的最短路径的时候，可以有 3
                      种情况：两点最短、点与其他点最短路径、每两点之间的最短路径。我们接触的最短路径的题目中，很多题目都是将“<strong
                        data-nodeid="814"
                        >最短</strong
                      >”定义为：
                    </p>
                    <blockquote data-nodeid="216">
                      <p data-nodeid="217">
                        一条路径上所有边的权重之和，要最小！
                      </p>
                    </blockquote>
                    <p data-nodeid="218">
                      但是，在<strong data-nodeid="821">本题</strong
                      >中却不是这样，我们要求的是：
                    </p>
                    <blockquote data-nodeid="219">
                      <p data-nodeid="220">
                        一条路径上所有边的权重的最大值，要最小！
                      </p>
                    </blockquote>
                    <p data-nodeid="221">
                      那么，当这个“<strong data-nodeid="828">最短</strong
                      >”定义发生变化的时候，我们是否还可以使用 BFS/Dijkstra/BF
                      算法呢？
                    </p>
                    <p data-nodeid="222">
                      这里我们先回顾一下原始 Dijkstra 算法。
                    </p>
                    <ul data-nodeid="223">
                      <li data-nodeid="224">
                        <p data-nodeid="225">
                          在 Dijkstra 算法中，我们需要用一个 dist
                          数组来记录“最短路径”和。
                        </p>
                      </li>
                      <li data-nodeid="226">
                        <p data-nodeid="227">
                          当出发点 src 走到点 x，导致 dist[x] 有<strong
                            data-nodeid="840"
                            >更新</strong
                          >的时候，那么点 x
                          还可以走到它周围的点，进一步更新周围的点。因此，需要将点
                          x 放到一个优先级队列中。
                        </p>
                      </li>
                      <li data-nodeid="228">
                        <p data-nodeid="229">
                          每次从优先级队列中取出最值得更新的点，作为出发点，用来<strong
                            data-nodeid="846"
                            >更新</strong
                          >其周围的点。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="230">
                      如果将 Dijkstra 算法迁移到这个题目，我们只需要改变 dist[]
                      数组的含义就可以了。
                    </p>
                    <ul data-nodeid="231">
                      <li data-nodeid="232">
                        <p data-nodeid="233">
                          原始的 Dijkstra 算法的 dist[x] 表示：从出发点 src
                          走到点 x 的最小路径和。
                        </p>
                      </li>
                      <li data-nodeid="234">
                        <p data-nodeid="235">
                          本题的 Dijkstra 中的 dist[x] 的含义：从出发点 src
                          走到点 x 路径上<strong data-nodeid="865"
                            >边的权重的最大值</strong
                          >。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="236">
                      基于这个微小的改动，我们就可以利用 Dijkstra
                      算法解决这道题目了。代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 行数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 列数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  
</div></li><li><div class="code-word">  <span class="hljs-comment">// 四个方向</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> },
</div></li><li><div class="code-word">                           { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
</div></li><li><div class="code-word">                           
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    Rows = heights.length;
</div></li><li><div class="code-word">    Cols = heights[<span class="hljs-number">0</span>].length;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// 设置矩阵的最大距离</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxDist = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">4</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Rows][Cols];
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
</div></li><li><div class="code-word">        dist[r][c] = maxDist;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-comment">// java小堆</span>
</div></li><li><div class="code-word">    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; Q =
</div></li><li><div class="code-word">      <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt;
</div></li><li><div class="code-word">            dist[v1[<span class="hljs-number">0</span>]][v1[<span class="hljs-number">1</span>]] - dist[v2[<span class="hljs-number">0</span>]][v2[<span class="hljs-number">1</span>]]);
</div></li><li><div class="code-word">            
</div></li><li><div class="code-word">    <span class="hljs-comment">// 放入出发点</span>
</div></li><li><div class="code-word">    Q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { <span class="hljs-number">0</span>, <span class="hljs-number">0</span> });
</div></li><li><div class="code-word">    
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (!Q.isEmpty()) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 取出最近的点</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">int</span>[] topNode = Q.poll();
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> r = topNode[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> c = topNode[<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">      
</div></li><li><div class="code-word">      <span class="hljs-comment">// 我们看一下这个点四周的点</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) {
</div></li><li><div class="code-word">        <span class="hljs-comment">//  找到周边的下一个点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">        <span class="hljs-comment">// 看一下这个点的权重是否会更新</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (!(nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> || nr &gt;= Rows || nc &gt;= Cols)) {
</div></li><li><div class="code-word">        
</div></li><li><div class="code-word">          <span class="hljs-comment">// 如果要走过去的点是合法的点</span>
</div></li><li><div class="code-word">          <span class="hljs-comment">// 点之间的边上的权重</span>
</div></li><li><div class="code-word">          <span class="hljs-comment">// 是由点与点之间的abs()决定的</span>
</div></li><li><div class="code-word">          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> weight =
</div></li><li><div class="code-word">              Math.abs(heights[r][c] - heights[nr][nc]);
</div></li><li><div class="code-word">              
</div></li><li><div class="code-word">          <span class="hljs-comment">// 注意，题目要求是取整条路径上的绝对值的最大值</span>
</div></li><li><div class="code-word">          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextDist = Math.max(dist[r][c], weight);
</div></li><li><div class="code-word">          
</div></li><li><div class="code-word">          <span class="hljs-keyword">if</span> (nextDist &lt; dist[nr][nc]) {
</div></li><li><div class="code-word">            dist[nr][nc] = nextDist;
</div></li><li><div class="code-word">            Q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { nr, nc });
</div></li><li><div class="code-word">          }
</div></li><li><div class="code-word">          
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> dist[Rows - <span class="hljs-number">1</span>][Cols - <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="238">
                      <p data-nodeid="239">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="870"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="874"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="878"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="240">
                      <strong data-nodeid="883">复杂度分析</strong>：当给定图为
                      N x M 时，时间复杂度为 O(N x M x lg(N x
                      M))，空间复杂度最差情况下，所有的元素都在队列中 O(N x M)。
                    </p>
                    <h3 data-nodeid="241">总结</h3>
                    <p data-nodeid="242">
                      在这一讲中，我们通过题目<strong data-nodeid="890"
                        >两方面的特点：连通性、最小值</strong
                      >展开，介绍了以下算法：
                    </p>
                    <ul data-nodeid="243">
                      <li data-nodeid="244">
                        <p data-nodeid="245">并查集</p>
                      </li>
                      <li data-nodeid="246">
                        <p data-nodeid="247">二分搜索</p>
                      </li>
                      <li data-nodeid="248">
                        <p data-nodeid="249">动态规划</p>
                      </li>
                      <li data-nodeid="250">
                        <p data-nodeid="251">Dijkstra 算法</p>
                      </li>
                    </ul>
                    <p data-nodeid="34167">
                      这里我将这些知识点浓缩在一张思维导图里面，有助于帮助你总结和复习。
                    </p>
                    <p data-nodeid="34168" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/3C/92/Cgp9HWCLcnuABwKAAADpTh1CXZI925.png"
                        alt="Drawing 13.png"
                        data-nodeid="34172"
                      />
                    </p>

                    <h3 data-nodeid="254">思考题</h3>
                    <p data-nodeid="255">
                      给定一个包含非负整数的<code
                        data-backticks="1"
                        data-nodeid="901"
                        >m x n</code
                      >网格<code data-backticks="1" data-nodeid="903">grid</code
                      >，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
                    </p>
                    <p data-nodeid="36233" class="">
                      <strong data-nodeid="36238">说明：</strong>
                      每次只能向下或者向右移动一步。
                    </p>

                    <p data-nodeid="38301" class="">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcoSATajPAAEcd1cL5m8325.png"
                        alt="Drawing 14.png"
                        data-nodeid="38304"
                      />
                    </p>

                    <p data-nodeid="258">
                      输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
                    </p>
                    <p data-nodeid="259">输出：7</p>
                    <p data-nodeid="260">
                      解释：因为路径 1→3→1→1→1 的总和最小。
                    </p>
                    <blockquote data-nodeid="261">
                      <p data-nodeid="262">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="931"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="935"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="939"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="263">
                      你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于最小体力消耗题目就介绍到这里。接下来，下一讲介绍“20
                      | 5
                      种解法，如何利用常量空间求解最长有效括号长度？”，让我们继续前进。
                    </p>
                    <h3 data-nodeid="264">附录：题目出处和代码汇总</h3>
                    <table data-nodeid="40368">
                      <thead data-nodeid="40369">
                        <tr data-nodeid="40370">
                          <th data-nodeid="40372">题目</th>
                          <th data-nodeid="40373">
                            <a
                              href="https://leetcode-cn.com/problems/path-with-minimum-effort/description/?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40386"
                              >测试平台</a
                            >
                          </th>
                          <th data-nodeid="40374">
                            并查集：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40390"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40394"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40398"
                              >Python</a
                            ><br />二分 + DFS：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40403"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40407"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40411"
                              >Python</a
                            ><br />二分 + BFS：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40416"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40420"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40424"
                              >Python</a
                            ><br />二分 + 并查集：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40429"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40433"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40437"
                              >Python</a
                            ><br /><br />BF 算法：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40443"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40447"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40451"
                              >Python</a
                            ><br /><br />Dijkstra 算法：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40457"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40461"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40465"
                              >Python</a
                            >
                          </th>
                        </tr>
                      </thead>
                      <tbody data-nodeid="40378">
                        <tr data-nodeid="40379">
                          <td data-nodeid="40380">思考题</td>
                          <td data-nodeid="40381">
                            <a
                              href="https://leetcode-cn.com/problems/minimum-path-sum/description/?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40469"
                              >测试平台</a
                            >
                          </td>
                          <td data-nodeid="40382">
                            代码：<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40473"
                              >Java</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40477"
                              >C++</a
                            >/<a
                              href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8"
                              data-nodeid="40481"
                              >Python</a
                            >
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >数据结构与算法面试宝典</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <div data-v-4bc80e00="" class="message-edit-empty">
                  学习知识要善于思考，思考，再思考。—爱因斯坦
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 685,
      courseCId: "",
      courseName: "数据结构与算法面试宝典",
      teachers: [
        {
          id: 630,
          teacherName: "德鲁伊",
          position: "前微软资深软件工程师",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span class="ql-author-13568064 ql-font-microsoftyahei" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto; background-color: rgb(255, 255, 255);">9&nbsp;年技术研发经验，主导过&nbsp;40PB&nbsp;级别的分布式存储系统架构设计与实现。带领团队实现核心模块，如用户态文件系统、存储引擎、分布式&nbsp;KV&nbsp;缓存。负责部门技术面试，有丰富的技术面试经验。此外，曾</span><span class="ql-font-microsoftyahei ql-author-13568064" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto;">作为复旦大学特聘讲师，面向研究生学院开展 IT 类课程，拥有多年授课经验。擅长架构设计、机器学习、云计算、大数据等领域。</span></span></p>',
        },
      ],
      totalCourseTime: 23,
      totalDuration: 340,
      sales: 18623,
      price: "98",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
      sellGoodsId: 748,
      sellGoodsPriceId: 73322,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。",
      seoKeywords:
        "数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季",
      seoTitle: "数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育",
      shareTitle: "这15种题型，算法面试肯定会问！",
      shareDescription: "300+高频真题详解，一题多解攻克算法面试",
      brief: "300+大厂高频真题，一题多解攻克算法面试",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png",
      courseType: 1,
      previewFirstField: "共23讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 638,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 638,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "83ec46930d5245bcae30be7a5f7786a2"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
</body>
