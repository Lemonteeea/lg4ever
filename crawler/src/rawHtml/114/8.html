<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">数据结构与算法面试宝典 - 拉勾教育</h1>

  <meta
    content="数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季"
    name="keywords"
  />

  <meta
    content="数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。"
    name="description"
  />

  <title>数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  数据结构与算法面试宝典
                </div>
                <div data-v-5f686215="" class="name">
                  德鲁伊
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  前微软资深软件工程师
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 |&nbsp;告别盲目刷题，击破算法面试
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 759px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：数据结构之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 栈：从简单栈到单调栈，解决经典栈问题
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 队列：FIFO 队列与单调队列的深挖与扩展
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 优先级队列：堆与优先级队列，筛选最优元素
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 树：如何深度运用树的遍历？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 并查集：如何利用两行代码写并查集？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          加餐与答疑 | 第一期 ：一问一答
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：算法之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08&nbsp;|
                          排序：如何利用合并与快排的小技巧，解决算法难题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10&nbsp;|
                          双指针：如何掌握最长、定长、最短区间问题的解题决窍？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12&nbsp;|
                          回溯：我把回溯总结成一个公式，回溯题一出就用它
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | DP：我是怎么治好“DP&nbsp;头痛症”的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：一题多解篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19&nbsp;|
                          最小体力消耗路径：如何突破经典题型，掌握解题模板？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20&nbsp;| 5
                          种解法，如何利用常量空间求解最长有效括号长度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21&nbsp;| 安排会议室：如何利用多种方法安排会议室？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：代码模板篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 |&nbsp;数据结构模板：如何让解题变成搭积木？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    彩蛋
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 |&nbsp;算法的精进之路
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 146px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  07 | 并查集：如何利用两行代码写并查集？
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/03/22
                  <span data-v-1605a430="" class="auth">德鲁伊</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/37:13"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="2233"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/37:13</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">
                            97.12M
                          </div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/37:13
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="35077" class="">
                      <strong data-nodeid="35440">并查集</strong
                      >是一种树型的数据结构，用于处理一些<strong
                        data-nodeid="35441"
                        >不交集（Disjoint Sets）的合并及查询问题</strong
                      >。通常会用到两种操作。
                    </p>
                    <ul data-nodeid="35078">
                      <li data-nodeid="35079">
                        <p data-nodeid="35080">
                          Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。
                        </p>
                      </li>
                      <li data-nodeid="35081">
                        <p data-nodeid="35082">
                          Union：将两个子集合并成同一个集合。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35083">
                      因此，这种数据结构称为<strong data-nodeid="35449"
                        >并查集</strong
                      >。
                    </p>
                    <p data-nodeid="35084">
                      在工程中，<strong data-nodeid="35455"
                        >并查集往往较多用于数据清理分类等操作</strong
                      >，并且能够以 O(N)
                      的时间复杂度处理较大的数据量，出现在大厂的面试题中也就不奇怪了。
                    </p>
                    <p data-nodeid="35085">学完这一讲，你将会收获：</p>
                    <ul data-nodeid="35086">
                      <li data-nodeid="35087">
                        <p data-nodeid="35088">并查集的模板代码</p>
                      </li>
                      <li data-nodeid="35089">
                        <p data-nodeid="35090">
                          如何利用并查集解决<strong data-nodeid="35463"
                            >连通域</strong
                          >问题
                        </p>
                      </li>
                      <li data-nodeid="35091">
                        <p data-nodeid="35092">如何利用虚拟点与虚拟边</p>
                      </li>
                      <li data-nodeid="35093">
                        <p data-nodeid="35094">如何利用路径压缩的技巧</p>
                      </li>
                    </ul>
                    <h3 data-nodeid="35095">并查集基础</h3>
                    <p data-nodeid="35096">
                      首先来看一下并查集要解决的问题，主要有两个。
                    </p>
                    <ul data-nodeid="35097">
                      <li data-nodeid="35098">
                        <p data-nodeid="35099">
                          Find：查询 item 属于<strong data-nodeid="35472"
                            >哪个集合</strong
                          >
                        </p>
                      </li>
                      <li data-nodeid="35100">
                        <p data-nodeid="35101">
                          Union：将两个集合<strong data-nodeid="35477"
                            >进行合并</strong
                          >
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35102">
                      我们以一个有趣的问题展开。在《倚天屠龙记》这部武侠小说中，有很多帮派，比如：
                    </p>
                    <p data-nodeid="35103">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZN2AGezPAABjCi7FK4I525.png"
                        alt="Drawing 0.png"
                        data-nodeid="35481"
                      />
                    </p>
                    <p data-nodeid="35104">
                      其中张无忌、谢逊、韦一笑属于明教，而张三丰、莫声谷、宋远桥属于武当派。
                    </p>
                    <h4 data-nodeid="35105">方法 1</h4>
                    <p data-nodeid="35106">
                      我们首先设计这样一种方案：采用数组/哈希的方法，记录每个人所在的门派。伪代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 伪代码</span>
</div></li><li><div class="code-word">Map&lt;String, String&gt; = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
</div></li><li><div class="code-word">H[<span class="hljs-string">"谢逊"</span>] = <span class="hljs-string">"明教"</span>
</div></li><li><div class="code-word">H[<span class="hljs-string">"张无忌"</span>] = <span class="hljs-string">"明教"</span>
</div></li><li><div class="code-word">H[<span class="hljs-string">"韦一笑"</span>] = <span class="hljs-string">"明教"</span>
</div></li><li><div class="code-word">H[<span class="hljs-string">"莫声谷"</span>] = <span class="hljs-string">"武当"</span>
</div></li><li><div class="code-word">H[<span class="hljs-string">"张三丰"</span>] = <span class="hljs-string">"武当"</span>
</div></li><li><div class="code-word">H[<span class="hljs-string">"宋远桥"</span>] = <span class="hljs-string">"武当"</span>
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35108">那么就可以这样查询：</p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String person)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> H.get(person);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35110">
                      至此，我们已经完成一个功能了。时间复杂度也很低，可以达到
                      O(1)。
                    </p>
                    <p data-nodeid="35111">
                      那我们再看一下合并。假设某一天，张三丰要闭关修炼，决定将武当派暂时交给张无忌代管理，为了方便管理两个帮派，张无忌号令明教的人前往武当派。那么此时就需要进行一个合并
                      Union 操作，也就是将所有“明教”的人归入“武当”。代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(String A, String B)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (item : H) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> item.value == <span class="hljs-string">"明教"</span>:
</div></li><li><div class="code-word">      item.value = <span class="hljs-string">"武当"</span>
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35113">
                      但是如此一来，整个时间复杂度就上去了，Union
                      的时候，时间复杂度变成 O(N)。如果 Union
                      操作很频繁，那么这种算法就变得不可接受。
                    </p>
                    <h4 data-nodeid="35114">方法 2</h4>
                    <p data-nodeid="35115">
                      在这里我们换一种思路，看看能不能解决 Union
                      复杂度过高的问题。采用江湖中通常的做法，认帮主！当帮主一样的时候，就认为我们是一个帮派的。
                    </p>
                    <p data-nodeid="35116">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZOaADgCUAABGlTOU4Ak099.png"
                        alt="Drawing 1.png"
                        data-nodeid="35493"
                      />
                    </p>
                    <p data-nodeid="35117">
                      每个人都指向自己的大哥，帮主最牛，指向帮主自己。那么要进行
                      Union 操作的时候。直接修改指针就可以了。代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(String A, String B)</span> </span>{
</div></li><li><div class="code-word">  String A帮主 = Find(A);
</div></li><li><div class="code-word">  String B帮主 = Find(B);
</div></li><li><div class="code-word">  H.put(A帮主, B帮主); <span class="hljs-comment">// 成功将A所在帮派归入B帮派</span>
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35119">
                      在 Union 的最后，我们只需要将 A 帮主指向 B
                      帮主就可以了。比如，将明教与武当合并，如下图所示：
                    </p>
                    <p data-nodeid="35120">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZO6APF37AABG3_a_Q6c057.png"
                        alt="Drawing 2.png"
                        data-nodeid="35498"
                      />
                    </p>
                    <p data-nodeid="35121">
                      我们再看一下 Find 函数，代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 返回A的帮主</span>
</div></li><li><div class="code-word"><span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String A)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (A != H.get(A)) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果我还有大哥，那么就顺着大哥一路往上找</span>
</div></li><li><div class="code-word">    A = H.get(A);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 最终找到了帮主</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> A;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35123">
                      虽然这种办法在 Union 时比较方便，但是在 Find
                      时却容易引入较高的复杂度。下面我们一起来看一下为什么 Find
                      起来比较麻烦：
                    </p>
                    <p data-nodeid="35124">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZQSANG0HAAUZirp5p1k748.gif"
                        alt="1 (1).gif"
                        data-nodeid="35503"
                      />
                    </p>
                    <p data-nodeid="35125">
                      在这种情况下，Find 查询时，总是会查询很多次
                      O(N)。也就是说，Union 的时间复杂度较低的时候，Find
                      的时间复杂度又上升了。
                    </p>
                    <p data-nodeid="35126">
                      那么，有没有更好一点的办法呢？能让 Union 和 Find
                      的时间复杂度都低一点。
                    </p>
                    <h4 data-nodeid="35127">路径压缩</h4>
                    <p data-nodeid="35128">
                      办法还是有的，就叫<strong data-nodeid="35512"
                        >路径压缩</strong
                      >，我们发现，在方法 2 中，如果能将层级结构“拍扁”，那么
                      Find 和 Union 的时间复杂度都会特别低。
                    </p>
                    <p data-nodeid="35129">
                      因此，我们还需要在 Find
                      函数里面做一些手脚。当我们找到一帮主之后，就把这条路径上的所有人的大哥都改成帮主。代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String A)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// start记为出发点</span>
</div></li><li><div class="code-word">  String start = A;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (A != H.get(A)) {
</div></li><li><div class="code-word">    A = H.get(A);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 此时A是帮主</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 我们再从出发点开始，把每个人的大哥改成帮主</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 路径压缩的关键代码</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (H.get(start) != A) {
</div></li><li><div class="code-word">    String next = H.get(start);
</div></li><li><div class="code-word">    H.put(start, A);
</div></li><li><div class="code-word">    start = next;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> A;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35131">
                      再看这个例子：经过合并，成立糖葫芦帮之后。如下图所示：
                    </p>
                    <p data-nodeid="35132">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/23/F4/CioPOWBX_4mAPpHfAABECA7Vc3g627.png"
                        alt="image.png"
                        data-nodeid="35517"
                      />
                    </p>
                    <p data-nodeid="35133">
                      如果一旦执行
                      Find("韦一笑")，那么糖葫芦帮派就会变成大饼帮派。
                    </p>
                    <p data-nodeid="35134">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZgaAOFDCAABeZqcuW0s773.png"
                        alt="Drawing 6.png"
                        data-nodeid="35525"
                      />
                    </p>
                    <p data-nodeid="35135">
                      所有人的帮主都会指向张三丰。也就是说，除了第一次 Find
                      复杂度为 O(N)，后面的查询复杂度都是
                      O(1)。至此，我们已经讲清楚带路径压缩的并查集的原理。接下来我们看代码如何实现。
                    </p>
                    <h3 data-nodeid="35136">并查集模板</h3>
                    <p data-nodeid="35137">
                      前面使用的都是比较形式化的语言和伪代码。接下来我们看一下具体如何实现并查集。这里我<strong
                        data-nodeid="35533"
                        >以整数替换前面的人名</strong
                      >，操作起来更加方便。
                    </p>
                    <h4 data-nodeid="35138">初始化</h4>
                    <p data-nodeid="35139">
                      首先假设有 N 个整数，范围为 [0,
                      N)。那么记录每个人的信息，就需要一个长度为 N 的数组。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> F[N]; <span class="hljs-comment">// 记录每个人的大哥是谁</span>
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35141">
                      在初始化的时候，每个人都是自成一派。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
</div></li><li><div class="code-word">  F[i] = i;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <h4 data-nodeid="35143">查询</h4>
                    <p data-nodeid="35144">
                      根据前面所讲，可以得到查询操作的代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// 查找根结点</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> b = x;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (F[x] != x) {
</div></li><li><div class="code-word">    x = F[x];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 路径压缩的实现</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 将路径上的每个点指向根结点x</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (F[b] != x) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> p = F[b];
</div></li><li><div class="code-word">    F[b] = x;
</div></li><li><div class="code-word">    b = p;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <h4 data-nodeid="35146">合并</h4>
                    <p data-nodeid="35147">
                      完成查询操作，我们就要把两个集合进行合并，代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
</div></li><li><div class="code-word">  F[find(x)] = find(y);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35149">
                      这两个函数的代码还是显得有点长，并且不太容易记。我在刷题和面试时，更喜欢，或者说常用一份精简过的代码。下面我将分享给你。
                    </p>
                    <h4 data-nodeid="35150">两行代码</h4>
                    <p data-nodeid="35151">
                      这里我整理了：<strong data-nodeid="35553">两行</strong
                      >并查集核心代码模板（用 C 语言实现，<strong
                        data-nodeid="35554"
                        >方便记忆）：</strong
                      >
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="c++"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> F[N];
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word"> <span class="hljs-keyword">return</span> x == F[x] ? x : F[x] = Find(F[x]); <span class="hljs-comment">// &lt;-- 1. 查找</span>
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
</div></li><li><div class="code-word">  F[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// &lt;- 2. 合并</span>
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35153">
                      注：根据不同的语言，你可能需要修改不同的 Find 函数。
                    </p>
                    <h4 data-nodeid="35154">两个功能</h4>
                    <p data-nodeid="35155">
                      当真正使用并查集的时候，面试官可能会问你两个问题：
                    </p>
                    <ul data-nodeid="35156">
                      <li data-nodeid="35157">
                        <p data-nodeid="35158">有多少个集合？</p>
                      </li>
                      <li data-nodeid="35159">
                        <p data-nodeid="35160">每个集合里面有多少个元素？</p>
                      </li>
                    </ul>
                    <p data-nodeid="35161">下面我们依次回答这两个问题。</p>
                    <p data-nodeid="35162">
                      <strong data-nodeid="35569">1</strong>.
                      <strong data-nodeid="35570">集合数目</strong>：在执行 Find
                      的时候，集合个数不可能有变化。如果发生变化，只可能发生在两个集合合并的时候。
                    </p>
                    <p data-nodeid="35163">再来具体看一下初始化和合并操作。</p>
                    <ul data-nodeid="35164">
                      <li data-nodeid="35165">
                        <p data-nodeid="35166">
                          初始化：在并查集开始初始化的时候，一共有 N
                          个元素，那么一开始集合个数为 N。
                        </p>
                      </li>
                      <li data-nodeid="35167">
                        <p data-nodeid="35168">
                          合并：合并的时候，需要查看合并的两个集合是不是同一个，如果不是，那么集合个数减
                          1。<br />
                          <strong data-nodeid="35583">2</strong>.
                          <strong data-nodeid="35584"
                            >每个集合中元素的个数</strong
                          >：在执行 Find
                          的时候，每个集合中元素的个数不可能发生变化。如果发生变化，只可能是两个集合合并的时候。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35169">
                      下面我们具体看一下初始化和合并操作。
                    </p>
                    <ul data-nodeid="35170">
                      <li data-nodeid="35171">
                        <p data-nodeid="35172">
                          初始化：在并查集开始初始化的时候，每个元素都属于独立的元素，那么一开始每个集合里面的个数都是
                          1。如果我们用 Count[]
                          数组记录每个元素的个数，那么一开始初始化 Count[] = 1。
                        </p>
                      </li>
                      <li data-nodeid="35173">
                        <p data-nodeid="35174">
                          合并：当 A 集合要合并到 B 集合里面的时候，可以认为 A
                          集合里面所有的元素都变成 B 集合里面的元素。当然是 B
                          集合里面的个数增加了，那么 Count[Find(B)] + =
                          Count[Find(A)]。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35175">
                      <strong data-nodeid="35622">注意</strong
                      >：在记录集合中元素个数的时候，<strong data-nodeid="35623"
                        >只有根结点的信息是准确的</strong
                      >。当查询结点i所属集合的信息时，只能使用
                      Count[Find(i)]，而不能使用 Count[i]。因为如果要保证每个点
                      Count[i]
                      的信息都是准确的，那么每次合并的时候，整个集合中的元素的信息都要更新，这样时间复杂度就很高了，Union
                      操作的时间复杂度就不再是O(lgN)，而变成O(N)。
                    </p>
                    <p data-nodeid="35176">
                      为了方便你刷题和应对面试，这里我给出了并查集的完整代码，你可以作为参考。
                    </p>
                    <h4 data-nodeid="35177">完整 Java 代码</h4>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 并查集数组</span>
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-comment">// 记录并查集中集合的个数</span>
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word"><span class="hljs-comment">// 记录集合中点的个数，比如要知道i所在集合的点有多少个: C[Find(i)]</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 注意：这里不能直接使用C[i]</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 因为只有根结点的统计才是正确的</span>
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span>[] Cnt = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-comment">// 并查集的初始化</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
</div></li><li><div class="code-word">  Cnt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
</div></li><li><div class="code-word">    F[i] = i;
</div></li><li><div class="code-word">    Cnt[i] = <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  count = n;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (x == F[x]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  F[x] = Find(F[x]);
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> F[x];
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> xpar = Find(x);
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> ypar = Find(y);
</div></li><li><div class="code-word">  <span class="hljs-comment">// 将x所在集合，合并到y所在集合</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (xpar != ypar) {
</div></li><li><div class="code-word">    F[xpar] = ypar;
</div></li><li><div class="code-word">    <span class="hljs-comment">// y集合里面的个数要增加</span>
</div></li><li><div class="code-word">    Cnt[ypar] += Cnt[xpar];
</div></li><li><div class="code-word">    count--;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> Cnt[Find(i)];
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="35179">
                      注：这里是以<strong data-nodeid="35635">整数</strong
                      >和<strong data-nodeid="35636">数组</strong
                      >为例。如果关键字是
                      String，也可以使用哈希表将字符串映射到整数再进行并查集的操作。
                    </p>
                    <blockquote data-nodeid="35180">
                      <p data-nodeid="35181">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35640"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35644"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35648"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35182">
                      <strong data-nodeid="35653">复杂度分析</strong
                      >：并查集的初始化时间复杂度为 O(N)，而 Find 和 Union
                      的操作时间复杂度都是 O(lgN)，其中 N
                      为点的总数。这里只使用了长度为 N 的数组，所以空间复杂度为
                      O(2N)。
                    </p>
                    <h4 data-nodeid="35183">例 1：最小生成树</h4>
                    <p data-nodeid="35184">
                      【<strong data-nodeid="35660">题目</strong
                      >】给定一个图的点集，边集和权重，返回构建最小生成树的代价。
                    </p>
                    <p data-nodeid="35185">
                      输入：N = 2， conn = [[1, 2, 37], [2, 1, 17], [1, 2, 68]]
                    </p>
                    <p data-nodeid="35186">输出：17</p>
                    <p data-nodeid="35187">
                      <strong data-nodeid="35687">解释</strong>：图中只有两个点
                      [1, 2]，当然是选择最小连接 [2, 1, 17]
                    </p>
                    <p data-nodeid="35188">
                      【<strong data-nodeid="35701">分析</strong>】利用并查集 +
                      贪心算法，可以生成一个图的<strong data-nodeid="35703"
                        >最小生成树，<strong data-nodeid="35702"
                          >这种方法也被称为</strong
                        >
                        Kruskal 算法</strong
                      >。并查集可以用来将两个点进行 Union，不过在并查集的 Union
                      代码中，并没有权重这一项，那我们该怎么办呢？
                    </p>
                    <p data-nodeid="35189">
                      在 Union
                      的时候，就直接根据边的权重来排序，然后再处理，这不就是经典的
                      <strong data-nodeid="35709">Kruskal 算法</strong>。
                    </p>
                    <p data-nodeid="35190">
                      这里我们可以讲一下最小生成树的思路：
                    </p>
                    <ul data-nodeid="35191">
                      <li data-nodeid="35192">
                        <p data-nodeid="35193">首先初始化并查集</p>
                      </li>
                      <li data-nodeid="35194">
                        <p data-nodeid="35195">
                          将边集<strong data-nodeid="35716"
                            >按照权重排序</strong
                          >
                        </p>
                      </li>
                      <li data-nodeid="35196">
                        <p data-nodeid="35197">
                          利用边集将不同的两点进行 Union
                        </p>
                      </li>
                      <li data-nodeid="35198">
                        <p data-nodeid="35199">
                          将不同的集合进行 Union
                          时需要加上新加入的边的代价（即边的权重）。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35200">
                      【<strong data-nodeid="35724">代码</strong
                      >】这里我们可以写出经典的 Kruskal
                      算法，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> cost = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这里直接申请了足够多的内存</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 并查集初始化</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 注意点的编号是从1~n</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
</div></li><li><div class="code-word">      F[i] = i;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    cost = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (x == F[x]) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    F[x] = Find(F[x]);
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> F[x];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 在合并的时候，需要加上代价</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pay)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (Find(x) != Find(y)) cost += pay;
</div></li><li><div class="code-word">    F[Find(x)] = Find(y);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 一共有n个点，编号从1~n</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// conn表示输入的边的集合</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 每一项是一个三元组[点a, 点b, 需要费用c]</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[][] conn)</span> </span>{
</div></li><li><div class="code-word">    Init(n);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 边集的排序</span>
</div></li><li><div class="code-word">    Arrays.sort(conn, <span class="hljs-number">0</span>, m, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
</div></li><li><div class="code-word">      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    });
</div></li><li><div class="code-word">    <span class="hljs-comment">// 顺次将边集添加到集合中</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
</div></li><li><div class="code-word">      Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>], conn[i][<span class="hljs-number">2</span>]);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> cost;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>

                    <blockquote data-nodeid="35202">
                      <p data-nodeid="35203">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35728"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35732"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35736"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35204">
                      <strong data-nodeid="35741">复杂度分析</strong
                      >：程序主要分为两块，一部分为边集 E 的排序，复杂度为
                      O(ElgE)；另外一部分为每条边的 Union 操作，复杂度为
                      O(ElgN)。在大部分时候，边的数目往往比点的数目要多，因此时间复杂度为
                      O(ElgE)。
                    </p>
                    <p data-nodeid="35205">
                      【<strong data-nodeid="35747">小结</strong>】本质上
                      Kruskal 算法就是并查集算法 + 贪心算法。使用 Kruskal
                      算法有一个很重要的前提——题目是假设输入边能将所有的点加到一个连通域中，也就是保证最后必然能够生成一棵树。
                    </p>
                    <p data-nodeid="35206">
                      这里给你留一道练习题，你可以利用它检验和巩固自己的学习成果。
                    </p>
                    <p data-nodeid="35207">
                      <strong data-nodeid="35755">练习题 1</strong
                      >：给定点集和边集，求最小生成树的代价，如果最后不能生成最小生成树，那么返回MAX_INT。
                    </p>
                    <blockquote data-nodeid="35208">
                      <p data-nodeid="35209">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35759"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35763"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35767"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35210">
                      接下来我们一起看一下关于并查集的其他考察形式与考点。
                    </p>
                    <h3 data-nodeid="35211">连通域的数目</h3>
                    <p data-nodeid="35212">
                      我们可以把最小生成树当成一个连通域，只不过需要用最小的代价来生成这么一个连通域。除了求解最小生成树，并查集的另外一个常见的用途是求解连通域的数目。在<strong
                        data-nodeid="35775"
                        >微软和 EMC</strong
                      >
                      的面试中都出现过，但是可能会通过两种方式给出图的结构，比如：
                    </p>
                    <ul data-nodeid="35213">
                      <li data-nodeid="35214">
                        <p data-nodeid="35215">
                          点集和边集，告诉你有哪些点，以及哪些边；
                        </p>
                      </li>
                      <li data-nodeid="35216">
                        <p data-nodeid="35217">矩阵表示。</p>
                      </li>
                    </ul>
                    <p data-nodeid="35218">
                      不管是通过哪一种图表示，利用<strong data-nodeid="35783"
                        >并查集解决连通域数目的步骤都是以下两步</strong
                      >：
                    </p>
                    <ol data-nodeid="35219">
                      <li data-nodeid="35220">
                        <p data-nodeid="35221">用 F[] 数组和点集进行初始化</p>
                      </li>
                      <li data-nodeid="35222">
                        <p data-nodeid="35223">利用边集进行 Union</p>
                      </li>
                    </ol>
                    <p data-nodeid="35224">最后的集合数目就是连通域的数目。</p>
                    <p data-nodeid="35225">
                      利用本讲前面学过的模板和思路，相信你已经可以解决面试中的高频出现的算法题了。
                    </p>
                    <h4 data-nodeid="35226">例 2：帮派的数目</h4>
                    <p data-nodeid="35227">
                      【<strong data-nodeid="35803">题目</strong>】江湖上有 N
                      个人，编号从 [1 ~
                      N]，现在只能告诉你，其中两人是一个帮派的，请你输出帮派的数目。
                    </p>
                    <p data-nodeid="35228">输入：N = 4, [[1, 2], [2,3]]</p>
                    <p data-nodeid="35229">输出：2</p>
                    <p data-nodeid="35230">
                      <strong data-nodeid="35827">解释</strong>：一共有 4
                      个人，[1,2, 3] 成为一个帮派，[4]
                      独自成为一个帮派，那么一共有 2 个帮派。
                    </p>
                    <p data-nodeid="35231">
                      【<strong data-nodeid="35833">分析</strong
                      >】在一开始，你可以认为他们都是独自成为一个帮派，当告诉你每两个人是一个帮派时，相当于要把这两个人合并到一个集合中。问题是一共有多少个帮派，显然这就是一个非常标准的并查集的问题了。我们可以直接套用前面所讲的并查集的模板进行求解。
                    </p>
                    <p data-nodeid="35232">
                      【<strong data-nodeid="35839">代码</strong
                      >】直接利用并查集的代码模板，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
</div></li><li><div class="code-word">    F[i] = i;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  count = n;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (x == F[x]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  F[x] = Find(F[x]);
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> F[x];
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (Find(x) != Find(y))
</div></li><li><div class="code-word">    count--;
</div></li><li><div class="code-word">  F[Find(x)] = Find(y);
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findGangNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] conn)</span> </span>{
</div></li><li><div class="code-word">  Init(n);
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> m = conn.length;
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
</div></li><li><div class="code-word">    Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>]);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 帮派里面帮主的个数</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> count;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="35234">
                      <p data-nodeid="35235">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35843"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35847"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35851"
                          >Python</a
                        ><br />
                        <strong data-nodeid="35857">复杂度分析</strong
                        >：整个算法的时间复杂度为 O(mlogN) ，这里 n
                        表示人的数目，而 m 表示两两成对的输入数目。
                      </p>
                    </blockquote>
                    <p data-nodeid="35236">
                      【<strong data-nodeid="35863">小结</strong
                      >】在这里我们直接利用并查集的模板搞定了一道题目。
                    </p>
                    <p data-nodeid="35237">
                      <strong data-nodeid="35868">延伸</strong
                      >：如果将这里的每个点都当成一个“图”结构中的一个点，将两两成对的输入当成“图”结构中的边。那么问题就变成了求解图的连通域个数。
                    </p>
                    <p data-nodeid="35238">
                      下面我们一起来看一下这个曾经在<strong data-nodeid="35874"
                        >微软</strong
                      >的电面中出现的 2 道题目。
                    </p>
                    <p data-nodeid="35239">
                      <strong data-nodeid="35887">练习题 2</strong
                      >：给定一个黑白图像，其中白色像素用 '1' 表示，黑色像素用
                      '0'
                      表示。如果把上下左右相邻的白色像素看成一个连通域，给定一幅图（用矩阵表示），请问图中有几个连通域。
                    </p>
                    <p data-nodeid="35240">
                      输入：A = [['1', '1', '0'], ['0', '1', '0']]
                    </p>
                    <p data-nodeid="35241">输出：1</p>
                    <p data-nodeid="35242">
                      <strong data-nodeid="35927">解释</strong>：图中所有的 '1'
                      都是连在一起的，所以只有一个连通域。
                    </p>
                    <blockquote data-nodeid="35243">
                      <p data-nodeid="35244">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35931"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35935"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35939"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35245">
                      <strong data-nodeid="35951">练习题 3</strong
                      >：给定一个图（不是图像）的矩阵，A[i][j] = 1 表示点 i 与点
                      j 相连，求这个图里面连通域的数目。
                    </p>
                    <p data-nodeid="35246">
                      输入：A = [[1,0,0],[0,1,0],[0,0,1]]
                    </p>
                    <p data-nodeid="35247">输出：3</p>
                    <p data-nodeid="35248">
                      <strong data-nodeid="35975">解释</strong>：[0, 1, 2]
                      三个点中，每个点都不与其他点相连，所以连通域有 3 个。
                    </p>
                    <blockquote data-nodeid="35249">
                      <p data-nodeid="35250">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35979"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35983"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="35987"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h4 data-nodeid="35251">例 3: 换工位</h4>
                    <p data-nodeid="35252">
                      【<strong data-nodeid="36019">题目</strong
                      >】因为要实施结对编程，想让两个员工的工位挨在一起：要求
                      [0,1] 员工坐在一起，[2, 3]
                      员工坐在一起，以此类推。不过挨着具体坐的位置并不重要，只要能挨在一起就可以了。比如
                      [0, 1, 3, 2] 与 [2, 3, 1, 0]
                      都是满足要求的。现在给定一个数组
                      A[]，求换工位的最少次数，尽量让两个员工坐在一起。（给定 N
                      个员工，他们的编号总是 [0~N-1] ，并且 N 总是偶数）。
                    </p>
                    <p data-nodeid="35253">输入：A[] = [0, 3, 2, 1]</p>
                    <p data-nodeid="35254">输出：1</p>
                    <p data-nodeid="35255">
                      <strong data-nodeid="36032">解释</strong>：只需要换 1
                      次就可以了，比如，将 0 号员工与 2 号员工交换。
                    </p>
                    <p data-nodeid="35256">
                      【<strong data-nodeid="36038">分析</strong
                      >】初看这道题的时候，没有什么思路，那么我们进行一下模拟，看看能不能发现什么规律。
                    </p>
                    <p data-nodeid="35257">
                      <strong data-nodeid="36046">1</strong>.
                      <strong data-nodeid="36047">模拟</strong>
                    </p>
                    <p data-nodeid="35258">
                      当 N = 2 时，无论是 [0, 1] 还是 [1, 0]
                      这两种排列都满足要求，因为我们总是想让 [0, 1]
                      这两个员工坐在一起，而只有两个员工时，他们总是挨在一起的。假设结对成功的两个人坐在一起的时候，就像做在链条上的环一样。
                    </p>
                    <p data-nodeid="35259">
                      由于 N 必须为偶数，所以接下来我们看一下 N = 4
                      时的情况。比如 A = [0, 3, 2, 1]，此时 4
                      个人都没有结对成功，相当于两个环还扣一起。
                    </p>
                    <p data-nodeid="35260">
                      这时我们只需要交换 0, 2 形成
                      [2,3,0,1]，如果按配对划分，那就是 [2, 3] 和 [0,
                      1]。结对成功之后，这两个环就可以拆开了。操作如下图所示：
                    </p>
                    <p data-nodeid="35261">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZpeADOaKAADoS6Y44b0977.png"
                        alt="Drawing 7.png"
                        data-nodeid="36081"
                      />
                    </p>
                    <p data-nodeid="35262">
                      通过这个示例，还可以发现，如果不经过交换，虽然 [3, 2]
                      这两个员工已经坐在一起了，但是不操作，那么 0 号员工和 1
                      号员工是无法结对编程的。
                    </p>
                    <p data-nodeid="35263">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZqCAfrFNAACU4aaiqjc231.png"
                        alt="Drawing 8.png"
                        data-nodeid="36089"
                      />
                    </p>
                    <p data-nodeid="35264">
                      因此，我们可以得到<strong data-nodeid="36111"
                        >结论
                        1：结对的时候，数组中只能偶数下标与奇数下标配比</strong
                      >。比如 A[0] 与 A[1]
                      结对。不能奇数下标与偶数下标结对，比如 A[1] 与 A[2] 结对。
                    </p>
                    <p data-nodeid="35265">
                      接下来我们再看一下 N = 6 的情况， 比如 A = [0, 2, 3, 5, 1,
                      4]：我们在执行交换的时候，可以这样操作：
                    </p>
                    <p data-nodeid="35266">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZqqADNgZAAU5MW4PWoI242.gif"
                        alt="2 (1).gif"
                        data-nodeid="36119"
                      />
                    </p>
                    <p data-nodeid="35267">
                      所以成功切分出三个配对集合 [0, 1], [3, 2], [5, 4]，需要 2
                      步。
                    </p>
                    <p data-nodeid="35268">
                      <strong data-nodeid="36140">2</strong>.
                      <strong data-nodeid="36141">规律</strong>
                    </p>
                    <p data-nodeid="35269">
                      通过前面的模拟，我们还需要进一步的总结规律。将里面没有成功结对的序列看成一条锁链。并且拆分出结对成功的两个元素，独立位于一个环中，并不与别人相扣在一起。
                    </p>
                    <p data-nodeid="35270">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZrSALzFBAADhm_fwnRk393.png"
                        alt="Drawing 10.png"
                        data-nodeid="36145"
                      />
                    </p>
                    <p data-nodeid="35271">
                      每 1
                      次操作，交换两个元素，就相当于从锁链中成功拆一个环下来。
                    </p>
                    <p data-nodeid="35272">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZryASSNEAAEb64nhdKE214.png"
                        alt="Drawing 11.png"
                        data-nodeid="36149"
                      />
                    </p>
                    <p data-nodeid="35273">
                      那么，我们可以得到<strong data-nodeid="36155"
                        >结论 2：有 2x 个元素，也就是 x 个环的锁链，就需要 x-1
                        次操作</strong
                      >。
                    </p>
                    <p data-nodeid="35274">
                      至此，我们就将题目成功变成了：给定一个数组，需要找到里面有几条锁链。比如给定数组
                      A = [6, 4, 5, 2, 3, 7, 0, 1]。
                    </p>
                    <p data-nodeid="35275">
                      此时应该可以分出两条锁链来，如下图所示：
                    </p>
                    <p data-nodeid="35276">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZsWAPW0xAADZQU20JEU856.png"
                        alt="Drawing 12.png"
                        data-nodeid="36164"
                      />
                    </p>
                    <p data-nodeid="35277">
                      我们再看每个锁链中的环的数目就可以得到最少操作次数。比如这里的
                      A[] 数组有 2 条锁链，需要的操作次数是 (3 - 1) + (1-1) =
                      2。也就是最少操作 2 次。
                    </p>
                    <p data-nodeid="35278">
                      那么现在问题的关键就是，如何才能通过数组得到锁链呢？这里我们还发现一个有趣的<strong
                        data-nodeid="36174"
                        >结论 3：本就结对的两个员工必然在同一个链条中</strong
                      >。比如 6 和 5 在没有结对的情况下，也必然在同一条锁链中。
                    </p>
                    <p data-nodeid="35279">
                      <strong data-nodeid="36182">3</strong>.
                      <strong data-nodeid="36183">匹配</strong>
                    </p>
                    <p data-nodeid="35280">
                      如果将锁链当成集合，就可以对应到并查集了。这里再细化一下：
                    </p>
                    <ul data-nodeid="35281">
                      <li data-nodeid="35282">
                        <p data-nodeid="35283">
                          通过结论 3，我们应该将一个偶数 x 以及和它配对的数 x+1
                          先放到同一个集合中；
                        </p>
                      </li>
                      <li data-nodeid="35284">
                        <p data-nodeid="35285">
                          偶数下标 A[i]，需要与 A[i+1] 进行
                          Union，完成放到同一个锁链的操作。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35286">
                      虽然最后我们可以通过去数锁链中环的个数，再通过结论 2
                      得到答案。但是如果你能想到拆环的次数，实际上就是不同集合
                      Union 的次数。那么求解的时候，只需要在并查集模板的基础上对
                      Union 稍做更改就可以了。
                    </p>
                    <p data-nodeid="35287">
                      <strong data-nodeid="36203">4</strong>.
                      <strong data-nodeid="36204">边界</strong>
                    </p>
                    <p data-nodeid="35288">
                      注意处理空数组，注意结对的时候，要满足结论 1。
                    </p>
                    <p data-nodeid="35289">
                      【<strong data-nodeid="36215">画图</strong
                      >】接下来我们画图演示一下使用并查集的过程。这里我们以数组
                      A = [6, 4, 5, 2, 3, 7, 0, 1] 为例。
                    </p>
                    <p data-nodeid="35290">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZteAaZlrABz3L57gQK4855.gif"
                        alt="3.gif"
                        data-nodeid="36218"
                      />
                    </p>
                    <p data-nodeid="35291">
                      我们发现，不同集合的合并次数一共为 2 次，所以只需要 2
                      次操作就可以完成结对编程的要求。
                    </p>
                    <p data-nodeid="35292">
                      【<strong data-nodeid="36225">代码</strong
                      >】接下来我们可以写一下代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> unionCount = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 注意这里在初始化的时候</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// [0, 1]需要处在一个集合里面</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 无论他们在数组里面是不是相邻</span>
</div></li><li><div class="code-word">    F[i] = i - (i &amp; <span class="hljs-number">0x01</span>);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (x == F[x]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  F[x] = Find(F[x]);
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> F[x];
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (Find(x) != Find(y)) {
</div></li><li><div class="code-word">    unionCount++;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  F[Find(x)] = Find(y);
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
</div></li><li><div class="code-word">  Init(N);
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">2</span>) {
</div></li><li><div class="code-word">    Union(A[i], A[i + <span class="hljs-number">1</span>]);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> unionCount;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="35294">
                      <p data-nodeid="35295">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36229"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36233"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36237"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35296">
                      <strong data-nodeid="36242">复杂度分析</strong>：一共有
                      N/2 对元素要合并，每次合并的时间复杂度为
                      O(lgN)。所以时间复杂度为 O(NlgN)。
                    </p>
                    <p data-nodeid="35297">
                      【<strong data-nodeid="36248">小结</strong
                      >】在这里，我们学习了将锁链处理成一个连通域，并且巧妙地通过求解合并次数解决了最小操作次数。
                    </p>
                    <p data-nodeid="35298">
                      我认为这道题目最核心的考点是分析出<strong
                        data-nodeid="36258"
                        >结论 2</strong
                      >：<strong data-nodeid="36259"
                        >有 2x 个元素，也就是 x 个环的锁链，就需要 x-1
                        次操作</strong
                      >。
                    </p>
                    <p data-nodeid="35299">
                      一旦得到了每条锁链中的操作次数，然后利用并查集的模板，这道题目就解决了。我再给你留道练习题，希望你可以尝试做一下。
                    </p>
                    <p data-nodeid="35300">
                      <strong data-nodeid="36265">练习题 4</strong
                      >：给定一个单词数组，如果两个单词相等，或者说其中一个单词
                      A 经过一次字符交换，可以得到单词 B，那么我们说单词 {A, B}
                      是同构的。请问单词数组中，一共有多少组这样的同构集合？
                    </p>
                    <p data-nodeid="35301">
                      输入：{"AB", "BA", "AB", "BC", "CD"}
                    </p>
                    <p data-nodeid="35302">输出：3</p>
                    <p data-nodeid="35303">
                      <strong data-nodeid="36312">解释</strong
                      >：一共有三组同构集合，{"AB", "BA", "AB"}, {"BC"}, {"CD"}
                    </p>
                    <blockquote data-nodeid="35304">
                      <p data-nodeid="35305">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36316"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36320"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36324"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35306">
                      接下来我们讲解并查集的进一步运用。
                    </p>
                    <h3 data-nodeid="35307">虚拟点与虚拟边</h3>
                    <p data-nodeid="35308">
                      在求解连通域的过程中，我们经常利用现有的点与现有的边进行并查集的初始化与合并。
                    </p>
                    <p data-nodeid="35309">
                      但是在有些题目中，需要加入一些<strong data-nodeid="36333"
                        >虚拟的边和虚拟的点</strong
                      >到并查集的点集与边集中。通过这种方式可以极大地方便我们使用并查集。
                    </p>
                    <h4 data-nodeid="35310">例 4: 替换字母</h4>
                    <p data-nodeid="35311">
                      【<strong data-nodeid="36360">题目</strong>】给你一个矩阵
                      A，里面只包含字母 ‘O’ 和 'X'，如果一个 'O'
                      上下左右四周都被 'X' 包围，那么这个 'O' 会被替换成
                      'X'。请你写程序处理一下这个过程。
                    </p>
                    <p data-nodeid="35312">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZumAF_CYAAA1NGN0dU0625.png"
                        alt="Drawing 14.png"
                        data-nodeid="36363"
                      />
                    </p>
                    <p data-nodeid="35313">
                      <strong data-nodeid="36387">解释</strong>：由于中心的 'O'
                      四周都被包围，所以需要被换成 'X'，而第 A[0][0] = 'O'
                      靠着边，所以不能被替换。
                    </p>
                    <p data-nodeid="35314">
                      【<strong data-nodeid="36397">分析</strong
                      >】这道题目曾经在<strong data-nodeid="36398">微软</strong
                      >的面试中出现过。看起来就是一个连通域的问题，所以可以使用并查集来处理。思路如下：
                    </p>
                    <ul data-nodeid="35315">
                      <li data-nodeid="35316">
                        <p data-nodeid="35317">
                          首先用并查集标记所有 'O' 的连通域；
                        </p>
                      </li>
                      <li data-nodeid="35318">
                        <p data-nodeid="35319">
                          将所有在边上的 'O' 的“帮主”放到 set 集合中；
                        </p>
                      </li>
                      <li data-nodeid="35320">
                        <p data-nodeid="35321">
                          遍历每个 'O' 的“帮主”，看看是不是在 set
                          集合中，如果在，那么这个 'O' 不能替换。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35322">
                      可以发现，有一步操作可以优化：将所有在边上的 'O'
                      的“帮主”放到 set 集合中，有两种办法：
                    </p>
                    <ul data-nodeid="35323">
                      <li data-nodeid="35324">
                        <p data-nodeid="35325">
                          随便选择边上的一个点，作为所有边上点的“帮主”；
                        </p>
                      </li>
                      <li data-nodeid="35326">
                        <p data-nodeid="35327">
                          选一个虚拟的点，作为所有边上的点的“帮主”。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35328">
                      你可以根据自己的喜好任选其一，这里我用第 2
                      种“虚拟点”的办法。下面就可以直接套用模板了。
                    </p>
                    <p data-nodeid="35329">
                      【<strong data-nodeid="36431">代码</strong
                      >】采用虚拟点的并查集的代码实现如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span>[][] dir = {{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">0</span>}};
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
</div></li><li><div class="code-word">    F[i] = i;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (x == F[x]) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  F[x] = Find(F[x]);
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> F[x];
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{ F[Find(x)] = Find(y); }
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] A)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || A[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = A.length;
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> C = A[<span class="hljs-number">0</span>].length;
</div></li><li><div class="code-word">  Init(R * C + <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">  <span class="hljs-comment">// 我们将vNode设置为R * C</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这是一个在矩阵中不存在的点</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> vNode = R * C;
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; R; r++) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; C; c++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (A[r][c] == <span class="hljs-string">'O'</span>) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果是边上的点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span> || r == R - <span class="hljs-number">1</span> || c == <span class="hljs-number">0</span> || c == C - <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">          <span class="hljs-comment">// 那么将其与vNode进行Union</span>
</div></li><li><div class="code-word">          Union(r * C + c, vNode);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 将其与四面的点进行Union</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">2</span>; d++) {
</div></li><li><div class="code-word">          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">          <span class="hljs-keyword">if</span> (!(nr &lt; <span class="hljs-number">0</span> || nr &gt;= R || nc &lt; <span class="hljs-number">0</span> || nc &gt;= C)) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (A[nr][nc] == <span class="hljs-string">'O'</span>) {
</div></li><li><div class="code-word">              Union(r * C + c, nr * C + nc);
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">          }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 查看是不是和vNode一个集合，如果不是就要修改成'X'</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; R; r++) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; C; c++) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (A[r][c] == <span class="hljs-string">'O'</span>) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (Find(r * C + c) != Find(vNode)) {
</div></li><li><div class="code-word">          A[r][c] = <span class="hljs-string">'X'</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="35331">
                      <p data-nodeid="35332">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36435"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36439"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36443"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35333">
                      <strong data-nodeid="36452">复杂度分析</strong
                      >：由于每个点只遍历两遍。<strong data-nodeid="36453"
                        >所有点的数目为 N</strong
                      >，所以时间复杂度为
                      O(NlgN)，此外，每个点都记录了所在集合，所以空间复杂度为
                      O(N)。
                    </p>
                    <p data-nodeid="35334">
                      【<strong data-nodeid="36459">小结</strong
                      >】在这里我们学习了一种新的处理技巧，那就是利用并查集 +
                      虚拟结点，将原本不在一起的结点，统一放到了一个虚拟集合中。
                    </p>
                    <p data-nodeid="35335">
                      所以解决这道题目的考点我们可以总结如下：
                    </p>
                    <p data-nodeid="35336">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZvmACQxmAAC2H_g_eZk099.png"
                        alt="Drawing 15.png"
                        data-nodeid="36463"
                      />
                    </p>
                    <p data-nodeid="35337">
                      在面试中，如果你有了并查集的模板，再加上虚拟点的思路，那么快速解决这类问题就轻而易举了。
                    </p>
                    <h4 data-nodeid="35338">例 5：上网的最小费用</h4>
                    <p data-nodeid="35339">
                      【<strong data-nodeid="36481">题目</strong
                      >】园区里面有很多大楼，编号从 1~N。第 i
                      大楼可以自己花钱买路由器上网，费用为
                      cost[i-1]，也可以从别的大楼拉一根网线来上网，比如大楼 a
                      和大楼 b 之间拉网线的费用为 c，表示为一条边 [a, b,
                      c]。输入为每个大楼自己买路由器和拉网线的费用，请问，让所有大楼都能够上网的最小费用是多少？上网具有联通性，只要与能够上网的大楼连通，即可上网。
                    </p>
                    <p data-nodeid="35340">
                      输入：cost = [1, 2, 3], edges = [[1,2,100], [2,3,3]]
                    </p>
                    <p data-nodeid="35341">输出：6</p>
                    <p data-nodeid="35342">
                      <strong data-nodeid="36509">解释</strong>：最优方案是 1
                      号大楼买路由器 cost[0] = 1，2 号楼买路由器 cost[1] =
                      2，然后和 3 号楼之间可拉一根网线，费用为 3，所以一共花费 6
                      元。如图（红色部分标记为费用 ）：
                    </p>
                    <p data-nodeid="35343">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZwOAOXuWAABVP6uBCvA003.png"
                        alt="Drawing 16.png"
                        data-nodeid="36512"
                      />
                    </p>
                    <p data-nodeid="35344">
                      【<strong data-nodeid="36526">分析</strong
                      >】这是一道<strong data-nodeid="36527">头条</strong
                      >面试中出现过的题目。首先如果不考虑自己买路由器的情况，只依赖给定的边集构建这个图，且要求最小费用，这道题目就和最小生成树一模一样了。可是，这里与最小生成树不一样的地方在于：第
                      i 大楼可以自己花钱买路由器上网，费用为 cost[i-1]。
                    </p>
                    <p data-nodeid="35345">
                      在最小生成树里面，可是没有说“自己买路由”这个操作。那怎么办？我们有什么方法可以转化一下吗？
                    </p>
                    <p data-nodeid="35346">
                      可以采用加入虚拟点的方法。首先假设有一个结点 0
                      已经自己买了路由器，花费为 0
                      元。而其他结点要自己买路由器，本质等价于与结点 0
                      进行联通。只不过这个网线的费用，就是你自己买路由器的费用。
                    </p>
                    <p data-nodeid="35347">
                      比如，给定 3 个点，分别自己买路由器的费用为 [1, 2,
                      3]。那么我们可以把图变成下图这样子：
                    </p>
                    <p data-nodeid="35348">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZwyAA5MpAABxWS4ICiA231.png"
                        alt="Drawing 17.png"
                        data-nodeid="36537"
                      />
                    </p>
                    <p data-nodeid="35349">
                      也就是说，我们添加了一个虚拟结点 0，然后也添加了 3
                      条虚拟边。这里虚拟的元素我们都用绿色表示。
                    </p>
                    <p data-nodeid="35350">
                      如果最后生成的连通图里面把 0~3
                      这四个点都包含进去，那么所有的大楼肯定都是可以上网的。此时最小代价问题就可以用最小生成树的方法来解决了。
                    </p>
                    <p data-nodeid="35351">
                      【<strong data-nodeid="36547">代码</strong
                      >】到这里，相信你已经知道可以怎么写代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalCost = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  <span class="hljs-comment">// 注意，编号是从1 ~ n</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
</div></li><li><div class="code-word">      F[i] = i;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    totalCost = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (x == F[x]) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> x;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    F[x] = Find(F[x]);
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> F[x];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pay)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (Find(x) != Find(y)) {
</div></li><li><div class="code-word">      totalCost += pay;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    F[Find(x)] = Find(y);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// N 表示结点数目</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// cost[i-1]表示结点i自己买路由器的代价</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// es[x] = [a, b, c]表示大楼a,b之间拉网线的费用</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 输出所有大楼通网的最小费用</span>
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostToSupplyWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] cost, <span class="hljs-keyword">int</span>[][] es)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-comment">// 初始化并查集</span>
</div></li><li><div class="code-word">    Init(N);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 每个结点都要自己买路由器，那么我们可以认为这样</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 0号楼已经有网络了，可以用0费用上网</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// i号楼与0号楼拉网线，需要的费用是cost[i-1]</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 那么这里就多了N条边</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span>[][] conn = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[es.length + N][<span class="hljs-number">3</span>];
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; es.length; i++) {
</div></li><li><div class="code-word">      conn[i][<span class="hljs-number">0</span>] = es[i][<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">      conn[i][<span class="hljs-number">1</span>] = es[i][<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">      conn[i][<span class="hljs-number">2</span>] = es[i][<span class="hljs-number">2</span>];
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> to = es.length;
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) {
</div></li><li><div class="code-word">      conn[to][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">      conn[to][<span class="hljs-number">1</span>] = i;
</div></li><li><div class="code-word">      conn[to][<span class="hljs-number">2</span>] = cost[i - <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">      to++;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 接下来采用Krukal最小生成树算法</span>
</div></li><li><div class="code-word">    Arrays.sort(conn, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
</div></li><li><div class="code-word">      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    });
</div></li><li><div class="code-word">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; conn.length; i++) {
</div></li><li><div class="code-word">      Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>], conn[i][<span class="hljs-number">2</span>]);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> totalCost;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="35353">
                      <p data-nodeid="35354">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36551"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36555"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36559"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35355">
                      <strong data-nodeid="36564">复杂度分析</strong>： 一共有 N
                      个点，M 条边，N 个点进行 Find/Union 的时间复杂度为
                      O(lgN)，所以总的时间复杂度为 M(lgN)。
                    </p>
                    <p data-nodeid="35356">
                      【<strong data-nodeid="36570">小结</strong
                      >】接下来我们从面试官的角度看一下，这道题的考点是什么：
                    </p>
                    <ul data-nodeid="35357">
                      <li data-nodeid="35358">
                        <p data-nodeid="35359">
                          将特殊条件转化为一般的条件，通过引入一些虚拟点，虚拟边来实现
                        </p>
                      </li>
                      <li data-nodeid="35360">
                        <p data-nodeid="35361">并查集的模板代码</p>
                      </li>
                      <li data-nodeid="35362">
                        <p data-nodeid="35363">最小生成树的 Kruskal 算法</p>
                      </li>
                    </ul>
                    <p data-nodeid="35364">
                      如果在面试中抓住了这 3
                      个点，就很容易击破这道算法题。接下来我们看一下并查集的另外一个的考点。
                    </p>
                    <h3 data-nodeid="35365">路径压缩</h3>
                    <p data-nodeid="35366">
                      并查集除了前面提到了考点之外，还有一个比较不容易出现的考点。那就是关于路径压缩的考点。
                    </p>
                    <p data-nodeid="35367">
                      处理这种题时，需要利用路径压缩同时将节点之间的信息进行层层压缩和汇总。求解过程还是很有趣的。下面让我们通过一个例题学习一下这个知识点。
                    </p>
                    <h4 data-nodeid="35368">例 6: 倍数关系</h4>
                    <p data-nodeid="35369">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZx2AJlAhAAB9L5EmBj8559.png"
                        alt="Drawing 26.png"
                        data-nodeid="36581"
                      />
                    </p>
                    <p data-nodeid="35370">
                      【<strong data-nodeid="36587">分析</strong
                      >】那么首先我们进行一下模拟。
                    </p>
                    <p data-nodeid="35371">
                      <strong data-nodeid="36595">1</strong>.
                      <strong data-nodeid="36596">模拟</strong>
                    </p>
                    <p data-nodeid="35372">
                      变量之间的除法关系，我们需要记录一个链式信息。如果将除法当成一个有向边，然后变量与变量之间的除法就可以看成图结构。比如：<br />
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZziAOXBLAAAF8Wyu_as055.png"
                        alt="Drawing 30.png"
                        data-nodeid="36601"
                      /><br />
                      可以表示为下图：
                    </p>
                    <p data-nodeid="35373">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ0OAaHLpAABvAPNQMEI372.png"
                        alt="Drawing 31.png"
                        data-nodeid="36606"
                      />
                    </p>
                    <p data-nodeid="35374">
                      如果我们将上图进行压缩，那么可以得到下图：
                    </p>
                    <p data-nodeid="35375">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ02AEcbFAABhq26WhTE347.png"
                        alt="Drawing 32.png"
                        data-nodeid="36610"
                      />
                    </p>
                    <p data-nodeid="35376">
                      经过压缩之后，可以发现这几个元素之间的关系就变成了下面这个样子：
                    </p>
                    <ul data-nodeid="35377">
                      <li data-nodeid="35378">
                        <p data-nodeid="35379">a = 8 * c</p>
                      </li>
                      <li data-nodeid="35380">
                        <p data-nodeid="35381">c = 1 * c</p>
                      </li>
                      <li data-nodeid="35382">
                        <p data-nodeid="35383">b = 4 * c</p>
                      </li>
                    </ul>
                    <p data-nodeid="35384">
                      此时，可以得到任意两个变量之间的比值。实际上，这几个数也可以以
                      a 元素为根，如下图所示：
                    </p>
                    <p data-nodeid="35385">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ1qASIekAAC-iYLl5-E217.png"
                        alt="Drawing 33.png"
                        data-nodeid="36624"
                      />
                    </p>
                    <p data-nodeid="35386">几个元素之间的关系就是这样：</p>
                    <ul data-nodeid="35387">
                      <li data-nodeid="35388">
                        <p data-nodeid="35389">b = 0.5 * a</p>
                      </li>
                      <li data-nodeid="35390">
                        <p data-nodeid="35391">a = 1 * a</p>
                      </li>
                      <li data-nodeid="35392">
                        <p data-nodeid="35393">c = 0.125 * a</p>
                      </li>
                    </ul>
                    <p data-nodeid="35394">
                      此时，我们可以得到任意两个变量之间的比值。
                    </p>
                    <p data-nodeid="35395">
                      <strong data-nodeid="36643">2</strong>.
                      <strong data-nodeid="36644">规律</strong>
                    </p>
                    <p data-nodeid="35396">
                      在这里，可以通过模拟找到一个<strong data-nodeid="36650"
                        >规律：只要是相连通的几个元素，可以选择任意一个结点做根结点。连通性好办，重点是：需要记录元素与根元素的比例</strong
                      >。
                    </p>
                    <p data-nodeid="35397">
                      并且我们发现其实哪个点做根结点都一样。但是比例关系怎么办？再回看一下模拟的过程，可以发现：<strong
                        data-nodeid="36656"
                        >比例关系就是顺着图中，有向边的方向乘过去即可</strong
                      >。
                    </p>
                    <p data-nodeid="35398">这里我们画图表示如下：</p>
                    <p data-nodeid="35399">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ2WAYuNmAADbi_WkYTo775.png"
                        alt="Drawing 34.png"
                        data-nodeid="36660"
                      />
                    </p>
                    <p data-nodeid="35400">
                      也就是说，在压缩的时候，需要把路径上边的权重依次乘起来。
                    </p>
                    <p data-nodeid="35401">
                      <strong data-nodeid="36669">3</strong>.
                      <strong data-nodeid="36670">匹配</strong>
                    </p>
                    <p data-nodeid="35402">
                      通过前面的一番分析，可以发现题目具有两个特点：
                    </p>
                    <ul data-nodeid="35403">
                      <li data-nodeid="35404">
                        <p data-nodeid="35405">连通性</p>
                      </li>
                      <li data-nodeid="35406">
                        <p data-nodeid="35407">路径压缩性</p>
                      </li>
                    </ul>
                    <p data-nodeid="35408">
                      能匹配到这两个特点的算法刚好是今天所讲的并查集。
                    </p>
                    <p data-nodeid="35409">
                      <strong data-nodeid="36682">4</strong>.
                      <strong data-nodeid="36683">边界</strong>
                    </p>
                    <p data-nodeid="35410">
                      <strong data-nodeid="36692">面试官提醒</strong>：<strong
                        data-nodeid="36693"
                        >由于涉及除法，在面试中，你一定要主动提出是否可能存在除
                        0
                        的情况。如果给定的输入里面可能有，那么一定要记得处理</strong
                      >。
                    </p>
                    <p data-nodeid="35411">
                      【<strong data-nodeid="36699">代码</strong
                      >】我们已经有了并查集的代码，那么处理路径压缩，应该也不是什么问题，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 小技巧：</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 记录字符串与整数的映射</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 将字符串映射成整数之后，在操作并查集的数组的时候</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 我们就可以使用整数组，速度也更快。</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToMap</span><span class="hljs-params">(String key, Map&lt;String, Integer&gt; H)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id = H.size();
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (!H.containsKey(key)) {
</div></li><li><div class="code-word">    H.put(key, id);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-comment">// 并查集的数组 </span>
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-comment">// 结点与其父结点的比例关系，我们总是用子结点除以父结点</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 当 a / c = 8时，并且当前 a的父结点就是c</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 那么 C[a] = 8</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 当并查集的结构调整之后，a的父结点变成了d</span>
</div></li><li><div class="code-word"><span class="hljs-comment">// 并且a/d=16，那么此时C[a] = 16</span>
</div></li><li><div class="code-word"><span class="hljs-keyword">double</span>[] C = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
</div></li><li><div class="code-word">  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
</div></li><li><div class="code-word">  C = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
</div></li><li><div class="code-word">    F[i] = i;
</div></li><li><div class="code-word">    C[i] = <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> b = x;
</div></li><li><div class="code-word">  <span class="hljs-comment">// base用来保存从x -&gt; .... root</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这条路径上所有的乘积</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 最后保证可以得到</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// x = base * root</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span> base = <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (x != F[x]) {
</div></li><li><div class="code-word">    base *= C[x];
</div></li><li><div class="code-word">    x = F[x];
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这里x就是root</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// base x -&gt; root的映射值</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 把路径上的其他值一并压缩</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> root = x;
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (F[b] != root) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 修改值上的变化</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">double</span> next = base / C[b];
</div></li><li><div class="code-word">    C[b] = base;
</div></li><li><div class="code-word">    base = next;
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> par = F[b];
</div></li><li><div class="code-word">    F[b] = root;
</div></li><li><div class="code-word">    b = par;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> root;
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span> D, <span class="hljs-keyword">double</span> v)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-comment">// T / D = v;</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 给定的输入表示 T = v * D;</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 那么找到T的root</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> tpar = Find(T);
</div></li><li><div class="code-word">  <span class="hljs-comment">// T = C[T] * par</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">int</span> dpar = Find(D);
</div></li><li><div class="code-word">  <span class="hljs-comment">// D = C[D] * dpar;</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// T = v * D = v * C[D] * dpar = C[T] * tpar;</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 如果我们要让tpar 指向dpar</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// tpar = v * C[D] * dpar / C[T]</span>
</div></li><li><div class="code-word">  F[tpar] = dpar;
</div></li><li><div class="code-word">  C[tpar] = v * C[D] / C[T];
</div></li><li><div class="code-word">}
</div></li><li><div class="code-word"><span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations,
</div></li><li><div class="code-word">                       <span class="hljs-keyword">double</span>[] values,
</div></li><li><div class="code-word">                       List&lt;List&lt;String&gt;&gt; queries) {
</div></li><li><div class="code-word">  <span class="hljs-comment">// 为了方便后面操作，我们把所有的字符串都映射成整数</span>
</div></li><li><div class="code-word">  Map&lt;String, Integer&gt; H = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (List&lt;String&gt; l : equations) {
</div></li><li><div class="code-word">    String t = l.get(<span class="hljs-number">0</span>), d = l.get(<span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    addToMap(t, H);
</div></li><li><div class="code-word">    addToMap(d, H);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 初始化并查集</span>
</div></li><li><div class="code-word">  Init(H.size());
</div></li><li><div class="code-word">  <span class="hljs-comment">// 开始执行Union操作</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; equations.size(); i++) {
</div></li><li><div class="code-word">    List&lt;String&gt; l = equations.get(i);
</div></li><li><div class="code-word">    Union(H.get(l.get(<span class="hljs-number">0</span>)), H.get(l.get(<span class="hljs-number">1</span>)), values[i]);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 在进行query之前，对所有的点执行Find操作。让后面的query</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 的Find操作时间复杂度为O(1)</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; H.size(); i++) {
</div></li><li><div class="code-word">    Find(i);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queries.size()];
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.size(); i++) {
</div></li><li><div class="code-word">    List&lt;String&gt; l = queries.get(i);
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> tidx = H.containsKey(l.get(<span class="hljs-number">0</span>)) ? H.get(l.get(<span class="hljs-number">0</span>)) : -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> didx = H.containsKey(l.get(<span class="hljs-number">1</span>)) ? H.get(l.get(<span class="hljs-number">1</span>)) : -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果变量不存在，那么比例关系照题意设置为-1</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (tidx == -<span class="hljs-number">1</span> || didx == -<span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      ans[i] = -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      <span class="hljs-keyword">int</span> troot = Find(tidx);
</div></li><li><div class="code-word">      <span class="hljs-keyword">int</span> droot = Find(didx);
</div></li><li><div class="code-word">      <span class="hljs-comment">// 如果两个变量从来没有过交集 </span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (troot != droot) {
</div></li><li><div class="code-word">        ans[i] = -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">      } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        ans[i] = C[tidx] / C[didx];
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="35413">
                      <p data-nodeid="35414">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36703"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36707"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="36711"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="35415">
                      <strong data-nodeid="36716">复杂度分析</strong>：假设有 N
                      个变量，构建并查集的时间复杂度为 O (NlgN)，如果有 M 个
                      Query，每次在询问为 O(1)，所以总的时间复杂度为
                      max(O(NlgN),M)。
                    </p>
                    <p data-nodeid="35416">
                      【<strong data-nodeid="36722">小结</strong
                      >】如果要解决这道题，那么需要注意掌握以下三点。
                    </p>
                    <ul data-nodeid="35417">
                      <li data-nodeid="35418">
                        <p data-nodeid="35419">
                          连通域里面的所有变量都统一用一个变量表示倍数关系，那么任意的两个变量就可以直接询问倍数关系。
                        </p>
                      </li>
                      <li data-nodeid="35420">
                        <p data-nodeid="35421">
                          倍数关系具有传递性，即：<br />
                          <img
                            src="https://uploader.shimo.im/f/LbdIya2siEFX52pW.png!thumbnail?fileGuid=xxQTRXtVcqtHK6j8"
                            alt="图片"
                            data-nodeid="36728"
                          /><br />
                          这是我们进行路径压缩的关键。
                        </p>
                      </li>
                      <li data-nodeid="35422">
                        <p data-nodeid="35423">
                          Union 操作时，注意变量倍数关系的调整。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="35424">
                      如果想到了这些，再加上我介绍的并查集的代码模板，那么解决这道面试题也就没什么难度了。以后在面试中，你如果发现题目具有<strong
                        data-nodeid="36737"
                        >传递性</strong
                      >的特点，就可以使用并查集进行求解。
                    </p>
                    <h3 data-nodeid="35425">总结</h3>
                    <p data-nodeid="35426" class="">
                      在本讲中，我介绍了并查集面试时常见的考察点，并且给出了并查集的代码模板。最后我还给你准备了并查集的知识树，面试中并查集相关的问题基本上逃不出这个圈。希望你可以尝试自己对本讲的内容进行梳理，然后再对照下图查缺补漏。
                    </p>
                    <p data-nodeid="35427">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ5KACZb3AAEzzay3PAM503.png"
                        alt="Drawing 38.png"
                        data-nodeid="36742"
                      />
                    </p>
                    <h3 data-nodeid="35428">思考题</h3>
                    <p data-nodeid="35429">
                      如果我们把例 5
                      的变量看成图上的点，变量与变量之间的关系看成是边。一旦构建好了并查集，在
                      Query 的时候，就可以 O(1)
                      的时间查询到两个变量之间的代价。那么为什么在图算法中，我们需要用
                      Floyd 算法求解图中两个点之间的最短路径？
                    </p>
                    <p data-nodeid="35430">
                      希望你可以把思考写在留言区，我们一起讨论，如果看到有趣的想法，我也会做成加餐和大家分享。：）
                    </p>
                    <p data-nodeid="35431" class="">
                      到这里，我们就要与并查集说再见了，接下来我们一起学习
                      08｜排序：如何利用合并与快排的小技巧，解决算法难题。记得按时来探险。
                    </p>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >数据结构与算法面试宝典</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <!---->
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **方
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        2
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      假期刷题 走起😅
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **辉
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        2
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      图的点集，边集，权重，最小生成树，代价等，这些概念能给讲下吗
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    你好啊。我大概找了一下关于这些基本术语的介绍：https://zhuanlan.zhihu.com/p/25498681
                    由于这个专栏的重点是《面试》。所以这些知识点可能覆盖得不是全面，多多包涵。
                    讲面试的时候，别的老铁们就是想要又干又硬的货。（最好是别的课或者书上没有的）。拿基础知识点灌水的话，我防不住老铁们的口水
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        JackLi
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        1
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      倍数关系具有传递性，即：这一段落的图片无法加载出来
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *超
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      初学并查集，第一遍完全懵，认真读两遍稍微好一点。
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **正
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      老师有些题在lt上找不到 可以在github上标注一下来源吗？
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    你可以看一下我们github
                    repo的代码。里面每个题目我都在文件开头的注释中提供了题目的来源
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **健
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      老师union方法是不是有问题 private void union(int x, int y)
                      { F[x] = find(y);// F[find(x)] = find(y); }
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    先说答案，有问题。 假设的帮主链条是 1-&gt;2-&gt;3-&gt;4.
                    这4个数{1,2,3,4}都是属于一个帮派。 另外还有一个帮派是5-&gt;6
                    现在要实行Union(1,5)。那么正确的结果是大家都指向6。
                    但是，如果执行F[x] = F[find(y)]导致的后果就是1-&gt;6.
                    2-&gt;3-&gt;4. 5-&gt;6 会导致集合1中的{2,3,4}并没有合并过来
                  </div>
                  <!---->
                  <!---->
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 685,
      courseCId: "",
      courseName: "数据结构与算法面试宝典",
      teachers: [
        {
          id: 630,
          teacherName: "德鲁伊",
          position: "前微软资深软件工程师",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span class="ql-author-13568064 ql-font-microsoftyahei" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto; background-color: rgb(255, 255, 255);">9&nbsp;年技术研发经验，主导过&nbsp;40PB&nbsp;级别的分布式存储系统架构设计与实现。带领团队实现核心模块，如用户态文件系统、存储引擎、分布式&nbsp;KV&nbsp;缓存。负责部门技术面试，有丰富的技术面试经验。此外，曾</span><span class="ql-font-microsoftyahei ql-author-13568064" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto;">作为复旦大学特聘讲师，面向研究生学院开展 IT 类课程，拥有多年授课经验。擅长架构设计、机器学习、云计算、大数据等领域。</span></span></p>',
        },
      ],
      totalCourseTime: 23,
      totalDuration: 340,
      sales: 18623,
      price: "98",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
      sellGoodsId: 748,
      sellGoodsPriceId: 73322,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。",
      seoKeywords:
        "数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季",
      seoTitle: "数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育",
      shareTitle: "这15种题型，算法面试肯定会问！",
      shareDescription: "300+高频真题详解，一题多解攻克算法面试",
      brief: "300+大厂高频真题，一题多解攻克算法面试",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png",
      courseType: 1,
      previewFirstField: "共23讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 638,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 638,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "83ec46930d5245bcae30be7a5f7786a2"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
</body>
