<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">数据结构与算法面试宝典 - 拉勾教育</h1>

  <meta
    content="数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季"
    name="keywords"
  />

  <meta
    content="数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。"
    name="description"
  />

  <title>数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  数据结构与算法面试宝典
                </div>
                <div data-v-5f686215="" class="name">
                  德鲁伊
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  前微软资深软件工程师
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 |&nbsp;告别盲目刷题，击破算法面试
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 759px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：数据结构之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 栈：从简单栈到单调栈，解决经典栈问题
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 队列：FIFO 队列与单调队列的深挖与扩展
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 优先级队列：堆与优先级队列，筛选最优元素
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 树：如何深度运用树的遍历？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 并查集：如何利用两行代码写并查集？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          加餐与答疑 | 第一期 ：一问一答
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：算法之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08&nbsp;|
                          排序：如何利用合并与快排的小技巧，解决算法难题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10&nbsp;|
                          双指针：如何掌握最长、定长、最短区间问题的解题决窍？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12&nbsp;|
                          回溯：我把回溯总结成一个公式，回溯题一出就用它
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | DP：我是怎么治好“DP&nbsp;头痛症”的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：一题多解篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19&nbsp;|
                          最小体力消耗路径：如何突破经典题型，掌握解题模板？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20&nbsp;| 5
                          种解法，如何利用常量空间求解最长有效括号长度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21&nbsp;| 安排会议室：如何利用多种方法安排会议室？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：代码模板篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 |&nbsp;数据结构模板：如何让解题变成搭积木？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    彩蛋
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 |&nbsp;算法的精进之路
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 146px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  06 | 树：如何深度运用树的遍历？
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/03/18
                  <span data-v-1605a430="" class="auth">德鲁伊</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/38:09"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="2289"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/38:09</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">
                            99.55M
                          </div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/38:09
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="7849" class="">
                      树在我们的应用程序中非常常见，大部分语言的 Map
                      数据结构，大多是基于树来实现的。此外还经常会遇到很多其他树结构的变种，比如
                      MySQL 会使用 B+ 树、MongoDB 会使用 B-
                      树。其中二叉树是各种树的基础，相关的题目也是变化多样，因此，各大公司都喜欢通过二叉树，考察面试者对语言底层数据结构的理解。
                    </p>
                    <p data-nodeid="7850">
                      二叉树的结点定义较为简单，一般采用如下方式来定义：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>{
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; TreeNode left = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; TreeNode right = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; TreeNode() {}
</div></li><li><div class="code-word">&nbsp; &nbsp; TreeNode(<span class="hljs-keyword">int</span> val) { <span class="hljs-keyword">this</span>.val = val; }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="7852">一个树的结点里面分别存放着：</p>
                    <ul data-nodeid="7853">
                      <li data-nodeid="7854">
                        <p data-nodeid="7855">值：用 val 表示</p>
                      </li>
                      <li data-nodeid="7856">
                        <p data-nodeid="7857">左子结点：用 left 指针表示</p>
                      </li>
                      <li data-nodeid="7858">
                        <p data-nodeid="7859">右子结点：用 right 指针表示</p>
                      </li>
                    </ul>
                    <p data-nodeid="7860">
                      在我学习二叉树的过程中，发现很多问题实际上都可以通过二叉树的遍历进行求解。
                      二叉树的遍历可以分为以下 4 种：
                    </p>
                    <ul data-nodeid="7861">
                      <li data-nodeid="7862">
                        <p data-nodeid="7863">前序遍历</p>
                      </li>
                      <li data-nodeid="7864">
                        <p data-nodeid="7865">中序遍历</p>
                      </li>
                      <li data-nodeid="7866">
                        <p data-nodeid="7867">后序遍历</p>
                      </li>
                      <li data-nodeid="7868">
                        <p data-nodeid="7869">层次遍历</p>
                      </li>
                    </ul>
                    <p data-nodeid="7870">
                      在“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8"
                        data-nodeid="8307"
                        >第 02 讲</a
                      >”我们已经介绍了层次遍历，因此，本讲会重点介绍前 3
                      种遍历以及它们的深度运用。<strong data-nodeid="8317"
                        >由于二叉树关联的面试题目考察的重点都是在各种遍历上</strong
                      >，所以在讲解时，我会采用更加<strong data-nodeid="8318"
                        >单刀直入</strong
                      >的方式，带你开启一段“爬树”的旅程。
                    </p>
                    <h3 data-nodeid="7871">前序遍历</h3>
                    <p data-nodeid="7872">前序遍历的顺序为：</p>
                    <ol data-nodeid="7873">
                      <li data-nodeid="7874">
                        <p data-nodeid="7875">遍历根结点</p>
                      </li>
                      <li data-nodeid="7876">
                        <p data-nodeid="7877">左子树</p>
                      </li>
                      <li data-nodeid="7878">
                        <p data-nodeid="7879">右子树</p>
                      </li>
                    </ol>
                    <p data-nodeid="7880">
                      这里我们不再按照课本上一步一步演示的方式。将采用<strong
                        data-nodeid="8329"
                        >整体概括处理的方式</strong
                      >，比如把左子树或者右子树作为一个整体来处理，如下图所示：
                    </p>
                    <p data-nodeid="7881">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtI-AItMYAAjasV3sa24039.gif"
                        alt="1.gif"
                        data-nodeid="8332"
                      />
                    </p>
                    <ul data-nodeid="7882">
                      <li data-nodeid="7883">
                        <p data-nodeid="7884">
                          Step 1. 首先遍历根结点，然后<strong data-nodeid="8338"
                            >遍历左子树的时候，就把左子树放到相应的位置；遍历右子树的时候，就把右子树放到相应的位置</strong
                          >。
                        </p>
                      </li>
                      <li data-nodeid="7885">
                        <p data-nodeid="7886">
                          Step 2. 接着再把左子树展开，放到相应位置。
                        </p>
                      </li>
                      <li data-nodeid="7887">
                        <p data-nodeid="7888">
                          Step 3.
                          最后再把右子树展开，放到相应位置。此时就得到了最终前序遍历的结果。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="7889">
                      不过你在处理根结点或者子树的时候，需要注意空树的情况。避免访问空指针！
                    </p>
                    <h4 data-nodeid="7890">递归前序遍历</h4>
                    <p data-nodeid="7891">
                      基于以上思路，可以写出递归的前序遍历的代码（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; ans)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-comment">// 边界处理：如果树为空，那么不需要处理</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 先访问根结点</span>
</div></li><li><div class="code-word">        ans.add(root.val);
</div></li><li><div class="code-word">        <span class="hljs-comment">// 再分别访问左子树</span>
</div></li><li><div class="code-word">        preOrder(root.left, ans);
</div></li><li><div class="code-word">        <span class="hljs-comment">// 再访问右子树</span>
</div></li><li><div class="code-word">        preOrder(root.right, ans);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="7893">
                      <p data-nodeid="7894">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8347"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8351"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8355"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="7895">
                      接下来我们看一下算法的复杂度，在面试中经常有人将时间复杂度与空间复杂度混淆，这里很<strong
                        data-nodeid="8361"
                        >容易出错</strong
                      >，你需要格外注意。
                    </p>
                    <ul data-nodeid="7896">
                      <li data-nodeid="7897">
                        <p data-nodeid="7898">
                          <strong data-nodeid="8366">时间复杂度</strong
                          >，由于树上的每个结点都只访问一次，并且每次访问都只有一次压栈弹栈操作，所以复杂度为
                          O(N)。
                        </p>
                      </li>
                      <li data-nodeid="7899">
                        <p data-nodeid="7900">
                          <strong data-nodeid="8371">空间复杂度</strong
                          >，由于函数调用栈的深度与树的高度有关系，所以使用的空间为
                          O(H)。H 表示树的高度。（注意：一般而言，输出结果存放的
                          List 并不算在空间复杂度里面）。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="7901">
                      <strong data-nodeid="8376">提示</strong
                      >：在面试时候，你需要问清楚面试官：访问每个结点的时候，是需要
                      Print 出来，还是放到一个 List
                      里面返回。搞清楚需求再开始写代码！
                    </p>
                    <h4 data-nodeid="7902">使用栈完成前序遍历</h4>
                    <p data-nodeid="7903">
                      接下来，我们看一下如何将递归的前序代码改成非递归的前序代码，如下所示（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// 用来进行递归的栈</span>
</div></li><li><div class="code-word">        Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
</div></li><li><div class="code-word">        <span class="hljs-comment">// 用来存放遍历的结果，不算在空间复杂度里面 </span>
</div></li><li><div class="code-word">        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">        <span class="hljs-comment">// 开始利用栈来进行遍历</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !s.empty()) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 模拟递归的压栈过程</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">                s.push(root);
</div></li><li><div class="code-word">                ans.add(root.val);
</div></li><li><div class="code-word">                root = root.left;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            <span class="hljs-comment">// 当无法压栈的时候，将root.right进行压栈</span>
</div></li><li><div class="code-word">            root = s.peek();
</div></li><li><div class="code-word">            s.pop();
</div></li><li><div class="code-word">            root = root.right;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="7905">
                      <p data-nodeid="7906">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8382"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8386"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8390"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="7907">
                      <strong data-nodeid="8395">算法复杂度</strong
                      >：每个结点都入栈出栈一次，遍历整棵树的时间复杂度为
                      O(N)，空间复杂度就是栈的最大使用空间，而这个空间是由树的高度决定的，所以空间复杂度就是
                      O(H)。
                    </p>
                    <p data-nodeid="7908">
                      <strong data-nodeid="8400">备注</strong
                      >：虽然面试的时候极难考到 Morris
                      遍历，如果你有时间，可以看看 Morris
                      遍历，这种算法的优点是只需要使用 O(1)
                      的空间（没有函数递归）。
                    </p>
                    <blockquote data-nodeid="7909">
                      <p data-nodeid="7910">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8404"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8408"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8412"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="7911">
                      下面我们通过几道题目还原一下面试场景，看看面试官都给你埋了哪些雷。
                    </p>
                    <h4 data-nodeid="7912">例 1：验证二叉搜索树</h4>
                    <p data-nodeid="7913">
                      【<strong data-nodeid="8420">题目</strong
                      >】二叉搜索树有以下特点：
                    </p>
                    <ul data-nodeid="7914">
                      <li data-nodeid="7915">
                        <p data-nodeid="7916">
                          根结点的值大于所有的左子树结点的值
                        </p>
                      </li>
                      <li data-nodeid="7917">
                        <p data-nodeid="7918">
                          根结点的值小于所有的右子树结点的值
                        </p>
                      </li>
                      <li data-nodeid="7919">
                        <p data-nodeid="7920">左右子树也必须满足以上特性</p>
                      </li>
                    </ul>
                    <p data-nodeid="7921">
                      现给定一棵二叉树，判断是否是二叉搜索树。
                    </p>
                    <p data-nodeid="7922">输入:</p>
                    <p data-nodeid="7923">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/42/Cgp9HWBRtKeAYSGpAACZpTIXfU0084.png"
                        alt="Drawing 1.png"
                        data-nodeid="8428"
                      />
                    </p>
                    <p data-nodeid="7924">输出: true</p>
                    <p data-nodeid="7925">
                      【<strong data-nodeid="8439">分析</strong
                      >】二叉搜索树的定义，<strong data-nodeid="8440"
                        >本质上就是一个前序遍历</strong
                      >。因此，可以利用前序遍历的思路来解决这道题。
                    </p>
                    <p data-nodeid="7926">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/38/CioPOWBUIueAOJfcAAdhS5BAUGo971.gif"
                        alt="11.gif"
                        data-nodeid="8443"
                      />
                    </p>
                    <p data-nodeid="7927">
                      【<strong data-nodeid="8453">模拟</strong
                      >】首先我们在这棵树上进行模拟，效果如下 （用 INT64_MIN
                      表示负无穷大，INT64_MAX 表示正无穷大）：
                    </p>
                    <p data-nodeid="7928">
                      Step 1. 我们假设<strong data-nodeid="8463"
                        >根结点总是对的</strong
                      >。如果总是对的，那么可以认为结点的值总是：处在区间(INT64_MIN,
                      INT64_MAX)以内。由于二叉树结点的值是 int，如果用 int64
                      总是可以保证一定在范围里面。
                    </p>
                    <p data-nodeid="7929">
                      Step 2. 根据二叉搜索树的定义，左子树总是小于根结点
                      5，那么左子树的范围就应该设置为(INT64_MIN, 5)。
                    </p>
                    <p data-nodeid="7930">
                      Step 3. 根据二叉搜索树的定久，右子树总是大于根结点
                      5，那么右子树的范围就应该设置为 (5, INT64_MAX)。
                    </p>
                    <p data-nodeid="7931">
                      Step 4. 然后再看结点 7 的左子树，范围应该是 (5, 7)。
                    </p>
                    <p data-nodeid="7932">
                      【<strong data-nodeid="8476">规律</strong
                      >】经过运行的模拟，我们可以总结出以下特点：
                    </p>
                    <ul data-nodeid="7933">
                      <li data-nodeid="7934">
                        <p data-nodeid="7935">
                          通过原本给出的那棵二叉树，实际上能够构造出一棵“影子”<strong
                            data-nodeid="8482"
                            >区间二叉树</strong
                          >，只不过这个二叉树上的结点是一个区间；
                        </p>
                      </li>
                      <li data-nodeid="7936">
                        <p data-nodeid="7937">
                          原二叉树上的值，需要掉在新二叉树的区间范围里面。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="7938">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtNGAeo22AACebFDJtSc681.png"
                        alt="Drawing 3.png"
                        data-nodeid="8486"
                      />
                    </p>
                    <p data-nodeid="7939">
                      因此，<strong data-nodeid="8492">解题的思路</strong>就是：
                    </p>
                    <ul data-nodeid="7940">
                      <li data-nodeid="7941">
                        <p data-nodeid="7942">
                          如何有效利用右边的“区间”二叉树验证左边二叉树的有效性？
                        </p>
                      </li>
                      <li data-nodeid="7943">
                        <p data-nodeid="7944">
                          当右边的“区间”二叉树不能成功构建，原二叉树就是一棵无效的二叉搜索树。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="7945">
                      <em data-nodeid="8498"
                        >注：我们不是真的要构建“影子”二叉树，这样做的目的是方便思考。</em
                      >
                    </p>
                    <p data-nodeid="7946">
                      “影子”二叉树是通过原二叉树生成的。树上结点就是不停地将区间进行拆分，比如：
                    </p>
                    <ul data-nodeid="7947">
                      <li data-nodeid="7948">
                        <p data-nodeid="7949">
                          (INT64_MIN, INT64_MAX) -&gt; (INT64_MIN, 5) , (5,
                          INT64_MAX)
                        </p>
                      </li>
                      <li data-nodeid="7950">
                        <p data-nodeid="7951">
                          (5, INT64_MAX) -&gt; (5, 7), (7, INT64_MAX)
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="7952">
                      【<strong data-nodeid="8519">匹配</strong
                      >】我们就利用二叉树的前序遍历，同时遍历这两棵二叉树。注意，其中“影子”二叉树是动态生成的，并且我们也不保存其数据结构。
                    </p>
                    <p data-nodeid="7953">
                      【<strong data-nodeid="8525">边界</strong
                      >】关于二叉树的边界，我们需要考虑一种情况：
                    </p>
                    <ul data-nodeid="7954">
                      <li data-nodeid="7955">
                        <p data-nodeid="7956">一棵空二叉树；</p>
                      </li>
                      <li data-nodeid="7957">
                        <p data-nodeid="7958">
                          题目的定义采用的“小于”，“大于”；
                        </p>
                      </li>
                      <li data-nodeid="7959">
                        <p data-nodeid="7960">
                          当任何一个位置不满足二叉树的定义，就可以不用再遍历下去了。因此，我们要注意快速返回。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="7961">
                      <strong data-nodeid="8533">【代码】</strong>
                      有了思路，也有了运行图，此时就可以写出以下核心代码（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ans = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, Long l, Long r)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// 1. 如果为空树</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 2. 如果已经有结点不满足BST的要求了</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !ans) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 检查当前结点是不是在影子二叉树的区间里面</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 这里相当于在检查两棵二叉树相同位置的结点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (!(l &lt; root.val &amp;&amp; root.val &lt; r)) {
</div></li><li><div class="code-word">            ans = <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 这里同时遍历左子树，(l, root.val)就是影子二叉树的左子结点</span>
</div></li><li><div class="code-word">        preOrder(root.left, l, Long.valueOf(root.val));
</div></li><li><div class="code-word">        <span class="hljs-comment">// 这里同时遍历右子树，(root.val, r)就是影子二叉树的右子结点</span>
</div></li><li><div class="code-word">        preOrder(root.right, Long.valueOf(root.val), r);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>{
</div></li><li><div class="code-word">        ans = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">        preOrder(root, Long.MIN_VALUE, Long.MAX_VALUE);
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="7963">
                      <p data-nodeid="7964">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8537"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8541"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8545"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="7965">
                      【<strong data-nodeid="8559">小结</strong
                      >】我们在传统经验的前序遍历基础上，进行了一点扩展，需要创建一棵“影子”二叉树才能进行前序遍历。因此这道题的<strong
                        data-nodeid="8560"
                        >考点</strong
                      >就是：<strong data-nodeid="8561"
                        >找到隐藏的“影子”二叉树</strong
                      >。
                    </p>
                    <p data-nodeid="7966">
                      此外，遍历二叉树的时候，如果可以用递归，那么应该也可以用栈，或者
                      Morris
                      遍历。作为一道思考题，你能用栈来完成“验证二叉搜索树”这道题目吗？
                    </p>
                    <blockquote data-nodeid="7967">
                      <p data-nodeid="7968">
                        代码：<a
                          href="https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8566"
                          >Java</a
                        >/<a
                          href="https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8570"
                          >C++</a
                        >/<a
                          href="https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8574"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="7969">
                      为了巩固我们前面所讲的知识，下面我再给你留两道练习题。
                    </p>
                    <p data-nodeid="7970">
                      <strong data-nodeid="8584">练习题 1</strong
                      >：“影子”二叉树还可以解决“<strong data-nodeid="8585"
                        >是否相同的树</strong
                      >”的问题。比如给定两棵二叉树，要求判断这两棵二叉树是不是一样的？思考的时候，再想一下，“影子”二叉树是怎么样的呢？
                    </p>
                    <blockquote data-nodeid="7971">
                      <p data-nodeid="7972">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8589"
                          >Java</a
                        >,<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8593"
                          >C++</a
                        >,<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8597"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="7973">
                      当然，有时候出题人还会将一些考点进行组合，比如将“相同的子树”与“前序遍历”进行组合，就可以得到一道新的题目。
                    </p>
                    <p data-nodeid="7974">
                      <strong data-nodeid="8607">练习题 2</strong
                      >：当我们写出“判断是否相同的树”的代码之后，可以开始思考另外一个问题——如何判断<strong
                        data-nodeid="8608"
                        >一棵树是不是另外一棵树的子树</strong
                      >？
                    </p>
                    <blockquote data-nodeid="7975">
                      <p data-nodeid="7976">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8612"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8616"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8620"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="7977">
                      你可以把答案或者思考的过程写在评论区，我们一起讨论。
                    </p>
                    <p data-nodeid="7978">
                      到这里，我们可以总结一下解题时用到的知识点和收获。为了方便你理解和复习，我把关于“树的遍历”的考点整理在一张大图里，如下图所示：
                    </p>
                    <p data-nodeid="7979">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtOmAcCa2AADXoM_tlx4996.png"
                        alt="Drawing 4.png"
                        data-nodeid="8625"
                      />
                    </p>
                    <p data-nodeid="7980">
                      然后，我们收获了一种思路——“影子”二叉树；一个模板——如何判断相同的树。
                    </p>
                    <h4 data-nodeid="7981">例 2：目标和的所有路径</h4>
                    <p data-nodeid="7982">
                      【<strong data-nodeid="8633">题目</strong
                      >】给定一棵二叉树，一个目标值。请输出所有路径，需要满足根结点至叶子结点之和等于给定的目标值。
                    </p>
                    <p data-nodeid="7983">输入：target = 9</p>
                    <p data-nodeid="7984">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtPWAR1otAACA-Iu2vmU954.png"
                        alt="Drawing 5.png"
                        data-nodeid="8637"
                      />
                    </p>
                    <p data-nodeid="7985">输出：[[5,4], [5,3,1]]</p>
                    <p data-nodeid="7986">
                      <strong data-nodeid="8672">解释</strong
                      >：从根结点到叶子结点形成的路径有 3 条：[5, 4], [5, 3, 1],
                      [5, 3, 2]，其中只有 [5, 4], [5, 3, 1] 形成的和为 9。
                    </p>
                    <p data-nodeid="7987">
                      【<strong data-nodeid="8682">分析</strong
                      >】这是一道来自<strong data-nodeid="8683">头条</strong
                      >的面试题目。首先题目要求从根结点出发，最后到达叶子结点。因此，从遍历的顺序上来说，符合前序遍历。
                    </p>
                    <p data-nodeid="7988">
                      【<strong data-nodeid="8689">模拟</strong
                      >】那么接下来我们进行一轮模拟，过程如下所示：
                    </p>
                    <p data-nodeid="7989">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/42/Cgp9HWBRtQqAeOlzAA3wDEKa3P4970.gif"
                        alt="3.gif"
                        data-nodeid="8692"
                      />
                    </p>
                    <p data-nodeid="7990">
                      Step 1. 首先从结点 5 出发，此时形成的并不完整的路径为
                      [5]。
                    </p>
                    <p data-nodeid="7991">
                      Step 2. 接着走向左子结点 4，形成一个有效路径 [5, 4]。
                    </p>
                    <p data-nodeid="7992">
                      Step 3. 接下来在换一条路之前，需要把 4 扔掉。
                    </p>
                    <p data-nodeid="7993">
                      Step 4. 按照前序遍历顺序访问 3，形成并不完整的路径 [5,
                      3]。
                    </p>
                    <p data-nodeid="7994">
                      Step 5. 接下来访问结点 1，形成完整的有效路径 [5, 3, 1]。
                    </p>
                    <p data-nodeid="7995">
                      Step 6. 当结点 1 遍历完之后，需要从路径中扔掉。
                    </p>
                    <p data-nodeid="7996">
                      Step 7. 接下来遍历结点 2，形成路径 [5, 3, 2]。总和为
                      10，并不是一个有效解。
                    </p>
                    <p data-nodeid="7997">
                      因此，我们一共找到两个有效解 [5, 4], [5, 3, 1]。
                    </p>
                    <p data-nodeid="7998">
                      【<strong data-nodeid="8734">规律</strong
                      >】经过模拟的过程，可以发现了以下特点：
                    </p>
                    <ul data-nodeid="7999">
                      <li data-nodeid="8000">
                        <p data-nodeid="8001">
                          遇到新结点，路径总是从尾部添加结点；
                        </p>
                      </li>
                      <li data-nodeid="8002">
                        <p data-nodeid="8003">
                          遍历完结点，路径就把它从尾部扔掉；
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8004">
                      路径里面的元素刚好与递归时压栈的元素完全一样。因此，我们需要在递归结束时，把路径里面的元素像“弹栈”一样扔掉。
                    </p>
                    <p data-nodeid="8005">
                      【<strong data-nodeid="8747">匹配</strong
                      >】基于二叉树而言，这里的考点当然是前序遍历。但是我们发现：还需要另外一个信息“<strong
                        data-nodeid="8748"
                        >路径</strong
                      >”：随着参数的压栈、弹栈而变化。
                    </p>
                    <p data-nodeid="8006">
                      【<strong data-nodeid="8754">边界</strong
                      >】按照题意，这里需要注意两点：
                    </p>
                    <ul data-nodeid="8007">
                      <li data-nodeid="8008">
                        <p data-nodeid="8009">题目一定要根结点到叶子结点</p>
                      </li>
                      <li data-nodeid="8010">
                        <p data-nodeid="8011">注意代码要支持空树</p>
                      </li>
                    </ul>
                    <p data-nodeid="8012">
                      【<strong data-nodeid="8762">代码</strong
                      >】此时，我们已经可以写一写代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(TreeNode root, 
</span></span></div></li><li><div class="code-word">      List&lt;Integer&gt; path, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> target) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果已经是空树，那么没有必要看</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 前序遍历，加上累计的和</span>
</div></li><li><div class="code-word">        sum += root.val;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 将结点添加到路径中，相当于压栈一样</span>
</div></li><li><div class="code-word">        path.add(root.val);
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 如果已经形成了一个有效路径!</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (sum == target) {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 添加到ans中</span>
</div></li><li><div class="code-word">                ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 回溯，分别再看子情况。</span>
</div></li><li><div class="code-word">            backtrace(root.left, path, sum, target);
</div></li><li><div class="code-word">            backtrace(root.right, path, sum, target);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 函数结束的时候弹栈，也要把结点从路径最后扔掉!</span>
</div></li><li><div class="code-word">        path.remove(path.size()-<span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 路径</span>
</div></li><li><div class="code-word">        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">        backtrace(root, path, <span class="hljs-number">0</span>, sum);
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8014">
                      <p data-nodeid="8015">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8766"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8770"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8774"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8016">
                      <strong data-nodeid="8781">复杂度分析</strong
                      >：首先遍历每个结点，复杂度肯定是
                      O(N)。但是最大的复杂度在于复制有效路径。假设有一棵满二叉树，最下面一层结点都符合要求。那么一共需要复制
                      N/2 次。而每次需要复制路径深度为 log(N)。因此，复杂度为
                      N/2 * log(N)，即 NlgN。
                    </p>
                    <p data-nodeid="8017">
                      【<strong data-nodeid="8795">小结</strong
                      >】本质上，这道题的考点就是：<strong data-nodeid="8796"
                        >回溯</strong
                      >，只不过借用了二叉树这个皮。反过来，在<strong
                        data-nodeid="8797"
                        >二叉树上进行回溯的代码模板，你也需要熟练掌握</strong
                      >。
                    </p>
                    <p data-nodeid="8018">
                      如果我们把题目中“路径之和等于
                      target”这个条件去掉，那么题目就变成了需要输出二叉树到叶子结点的所有路径。想必这道题目你也能够解决了吧？
                    </p>
                    <p data-nodeid="8019">
                      到这里，我们又可以进一步丰富了前面总结出的关于“二叉树的前序遍历”的思维导图了，如下图所示：
                    </p>
                    <p data-nodeid="8020">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtRmAU_NjAAEAKqKMPsY246.png"
                        alt="Drawing 7.png"
                        data-nodeid="8802"
                      />
                    </p>
                    <p data-nodeid="8021">
                      在这里，我们收获了：二叉树上的<strong data-nodeid="8808"
                        >回溯模板</strong
                      >。
                    </p>
                    <p data-nodeid="8022">
                      前序遍历的变种还有很多，结合不同的考点，还会有新的题型出现，但是只要我们能分析出题目的考点，有效地掌握一些代码模板进行相互组合，一定能克服这些新鲜的题目。
                    </p>
                    <h3 data-nodeid="8023">中序遍历</h3>
                    <p data-nodeid="8024">
                      接下来我们看一下中序遍历。中序遍历的顺序：
                    </p>
                    <ol data-nodeid="8025">
                      <li data-nodeid="8026">
                        <p data-nodeid="8027">左子树</p>
                      </li>
                      <li data-nodeid="8028">
                        <p data-nodeid="8029">根结点</p>
                      </li>
                      <li data-nodeid="8030">
                        <p data-nodeid="8031">右子树</p>
                      </li>
                    </ol>
                    <p data-nodeid="8032">
                      这里不再按照课本上一步一步演示的方式，同样可以采用一种概括处理的思路，如下所示：
                    </p>
                    <p data-nodeid="8033">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtSuAPkajAAkCntnG56c613.gif"
                        alt="4.gif"
                        data-nodeid="8818"
                      />
                    </p>
                    <ul data-nodeid="8034">
                      <li data-nodeid="8035">
                        <p data-nodeid="8036">
                          Step 1.
                          左子树作为一个整体放到左边；然后把根结点放到中间；最后把右子树作为一个整体放右边。
                        </p>
                      </li>
                      <li data-nodeid="8037">
                        <p data-nodeid="8038">Step 2. 接着再把左子树展开。</p>
                      </li>
                      <li data-nodeid="8039">
                        <p data-nodeid="8040">
                          Step 3.
                          最后再把右子树展开，此时我们就得到了最终中序遍历的结果。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8041">
                      经过上述过程的拆解和分析，有助于帮助你理解中序遍历。但是仍然要注意输出结点的顺序，结点真正输出顺序如下图所示：
                    </p>
                    <p data-nodeid="8042">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/21/3A/CioPOWBUI-qAV1MZAACWlNh4bls274.png"
                        alt="2021319-12844.png"
                        data-nodeid="8825"
                      />
                    </p>
                    <h4 data-nodeid="8043">递归中序遍历</h4>
                    <p data-nodeid="8044">
                      基于以上思路，我们可以写出递归的中序遍历的代码（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; ans)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 先遍历左子树</span>
</div></li><li><div class="code-word">        preOrder(root.left, ans);
</div></li><li><div class="code-word">        <span class="hljs-comment">// 然后遍历中间的根结点</span>
</div></li><li><div class="code-word">        ans.add(root.val);
</div></li><li><div class="code-word">        <span class="hljs-comment">// 最后遍历右子树</span>
</div></li><li><div class="code-word">        preOrder(root.right, ans);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8046">
                      <p data-nodeid="8047">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8831"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8835"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8839"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8048">
                      <strong data-nodeid="8844">复杂度分析</strong
                      >：时间复杂度为
                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)
                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。
                    </p>
                    <h4 data-nodeid="8049">使用栈完成中序遍历</h4>
                    <p data-nodeid="8050">
                      接下来，我们看一下如何将递归的中序代码，改成<strong
                        data-nodeid="8851"
                        >非递归的中序代码</strong
                      >（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>{
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">        <span class="hljs-comment">// 注意这里的判断条件，需要root或stack非空</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !s.empty()) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 往左边走，连续入栈，直到不能再走为止</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.push(root);
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = root.left;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
</div></li><li><div class="code-word">            <span class="hljs-comment">// 到达了最左边，把结点弹出来，进行遍历</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = s.peek();
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.pop();
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans.add(root.val);
</div></li><li><div class="code-word">            <span class="hljs-comment">// 转向右子树</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = root.right;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 返回遍历的结果</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8052">
                      <p data-nodeid="8053">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8855"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8859"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8863"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8054">
                      <strong data-nodeid="8868">复杂度分析</strong
                      >：时间复杂度为
                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)
                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。
                    </p>
                    <p data-nodeid="8055">
                      <strong data-nodeid="8873">备注</strong
                      >：虽然面试的时候极难考到
                      Morris，但如果你想多掌握一种解题方法，可以尝试用 Morris
                      遍历，其优点是只需要使用 O(1)
                      的空间复杂度。这里我先给出完整实现代码，如有你有疑问可以写在留言区，我们一起讨论。
                    </p>
                    <blockquote data-nodeid="8056">
                      <p data-nodeid="8057">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8877"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8881"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8885"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h4 data-nodeid="8058">例 3：验证二叉搜索树</h4>
                    <p data-nodeid="8059">
                      【<strong data-nodeid="8892">题目</strong>】（与例 1
                      一样）给定一棵二叉树，要求验证是不是一棵二叉搜索树。
                    </p>
                    <p data-nodeid="8060">
                      【<strong data-nodeid="8906">分析</strong>】根据<strong
                        data-nodeid="8907"
                        >二叉搜索树</strong
                      >的特性，可以知道。<strong data-nodeid="8908"
                        >中序遍历一定有序</strong
                      >。因此，可以利用这个特性进行验证。如果从这个角度来切入，那么题目的考点就可以总结如下：
                    </p>
                    <p data-nodeid="8061">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtUiAJEr9AAC21ET_Iqs675.png"
                        alt="Drawing 10.png"
                        data-nodeid="8911"
                      />
                    </p>
                    <p data-nodeid="8062">
                      接下来我们就尝试用中序遍历解决这道题目，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">boolean</span> ans = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    Long preValue = Long.MIN_VALUE;
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (!ans) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">            midOrder(root.left);
</div></li><li><div class="code-word">            <span class="hljs-comment">// 只需要在中序遍历的时候，</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 与前面的值进行一下比较就可以了。</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (preValue &gt;= root.val) {
</div></li><li><div class="code-word">                ans = <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">                <span class="hljs-keyword">return</span>;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            <span class="hljs-comment">// 比较完成之后，更新一下前面结点的值</span>
</div></li><li><div class="code-word">            preValue = Long.valueOf(root.val);
</div></li><li><div class="code-word">            midOrder(root.right);
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>{
</div></li><li><div class="code-word">        ans = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 注意，为了防止root.val取到最小值INT_MIN</span>
</div></li><li><div class="code-word">        <span class="hljs-comment">// 这里需要初始化为64位的最小值。</span>
</div></li><li><div class="code-word">        preValue = Long.MIN_VALUE;
</div></li><li><div class="code-word">        midOrder(root);
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8064">
                      <p data-nodeid="8065">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8916"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8920"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8924"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8066">
                      <strong data-nodeid="8929">复杂度分析</strong>：时间复杂度
                      O(N)，每个结点只遍历一次，并且每个结点访问只需要 O(1)
                      时间复杂度。空间复杂度为 O(H)，其中 H 为树的高度。
                    </p>
                    <p data-nodeid="8067">
                      【<strong data-nodeid="8935">小结</strong
                      >】平时练习的时候，你不妨将同类型的二叉树题目串起来进行比较，也许会发现题目真正的考点。比如将“二叉树的中序遍历”与“验证二叉搜索树”这两类题目放在一起思考，就会发现，考点是将中序遍历访问结点时候的处理做了一点小小的变化。
                    </p>
                    <p data-nodeid="8068">
                      另外，在处理二叉搜索树的时候，还需要利用有序性。中序遍历二叉搜索树的时候，可以把它<strong
                        data-nodeid="8940"
                        >看成一个有序的数组，在此基础上展开思路。</strong
                      >
                    </p>
                    <p data-nodeid="8069">
                      <strong data-nodeid="8945">练习题 3</strong
                      >：找出二叉搜索树里面出现次数最多的数。
                    </p>
                    <blockquote data-nodeid="8070">
                      <p data-nodeid="8071">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8949"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8953"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="8957"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8072">
                      我们还可以做进一步思考。经典的中序遍历只访问了一个结点，<strong
                        data-nodeid="8967"
                        >关心一个结点的性质</strong
                      >。而“验证二叉搜索树”需要访问两个结点，用<strong
                        data-nodeid="8968"
                        >两个结点的信息</strong
                      >做决策。
                    </p>
                    <p data-nodeid="8073">
                      因此，从“需要用的<strong data-nodeid="8974"
                        >结点个数</strong
                      >”角度出发，也可以衍生出一些题目。这里给你留两道练习题，帮助你巩固前面所讲的知识，希望你可以在课下完成它。
                    </p>
                    <p data-nodeid="8074">
                      <strong data-nodeid="8979">练习题 4</strong
                      >：找出二叉搜索树任意两结点之间绝对值的最小值
                    </p>
                    <blockquote data-nodeid="8075">
                      <p data-nodeid="8076">
                        代码：<a
                          href="http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.java"
                          data-nodeid="8983"
                          >Java</a
                        >/<a
                          href="http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.cpp"
                          data-nodeid="8987"
                          >C++</a
                        >/<a
                          href="http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.py"
                          data-nodeid="8991"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8077">
                      <strong data-nodeid="8996">练习题 5</strong
                      >：一棵二叉搜索树的两个结点被交换了，恢复这棵二叉搜索树
                    </p>
                    <blockquote data-nodeid="8078">
                      <p data-nodeid="8079">
                        解法 1（递归）：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java"
                          data-nodeid="9000"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.cpp"
                          data-nodeid="9004"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.py"
                          data-nodeid="9008"
                          >Python</a
                        ><br />
                        解法 2（栈）：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.java"
                          data-nodeid="9013"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.cpp"
                          data-nodeid="9017"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.py"
                          data-nodeid="9021"
                          >Python</a
                        ><br />
                        解法 3（Morris）：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.java"
                          data-nodeid="9026"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.cpp"
                          data-nodeid="9030"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.py"
                          data-nodeid="9034"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8080">
                      至此，我们已经挖掘了中序遍历可能的考点，如下图所示：<br />
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtVWASUJoAAD2XJCLLgQ425.png"
                        alt="Drawing 11.png"
                        data-nodeid="9039"
                      />
                    </p>
                    <p data-nodeid="8081">
                      讲完二叉搜索树（BST），我们再来看看“如何删除二叉搜索树的结点”，这也是面试中很重要的一个考点。
                    </p>
                    <h4 data-nodeid="8082">例 4：删除二叉搜索树的结点</h4>
                    <p data-nodeid="8083">
                      【<strong data-nodeid="9047">题目</strong
                      >】删除二叉搜索树的指定结点。返回删除之后的根结点。接口如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function">TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> value)</span></span>;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8085">
                      【<strong data-nodeid="9057">分析</strong
                      >】这是一道来自<strong data-nodeid="9058">微软</strong
                      >的面试题。它的难点在于需要考虑各种情况。因此，针对这道题的题目特点，我们把重点放在分析各种
                      Case。
                    </p>
                    <p data-nodeid="8086">
                      Case 1：空树。如果树是空树，那么只需要返回 null 即可。
                    </p>
                    <p data-nodeid="8087">
                      Case 2：如果 value
                      比根结点小，那么去左子树里面删除相应结点，执行：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">if</span> (value &lt; root.val) {
</div></li><li><div class="code-word">    root.left = deleteNode(root.left, value);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8089">
                      这里只有一行核心代码，但却<strong data-nodeid="9066"
                        >非常有意思</strong
                      >。因为这行代码统一处理了以下几种情况。
                    </p>
                    <p data-nodeid="8090">
                      a）当结点 1 删除之后，左子树为空，需要设置 root.left =
                      null。如下图所示：
                    </p>
                    <p data-nodeid="8091">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtWWAIxSJAABkVgPnF_o374.png"
                        alt="Drawing 12.png"
                        data-nodeid="9070"
                      />
                    </p>
                    <p data-nodeid="8092">
                      b）当结点 1 删除之后，左子树的根结点为 2，需要设置
                      root.left 指向结点 2。如下图所示：
                    </p>
                    <p data-nodeid="8093">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtW2AARGtAAB29vC847A588.png"
                        alt="Drawing 13.png"
                        data-nodeid="9074"
                      />
                    </p>
                    <p data-nodeid="8094">
                      c）当结点 1 删除之后，左子树根结点变成 2，需要设置
                      root.left 指向结点 2。如下图所示：
                    </p>
                    <p data-nodeid="8095">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtXaALQrkAAB3-_72MrY558.png"
                        alt="Drawing 14.png"
                        data-nodeid="9078"
                      />
                    </p>
                    <p data-nodeid="8096">因此，删除结点时，需要：</p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">root.left = deleteNode(root.left, value);
</div></li><li><div class="code-word">或
</div></li><li><div class="code-word">root.right = deleteNode(root.right, value);
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8098">
                      虽然看起来
                      b）没有重新赋值的必要，但是利用这一句话，却把a）、b）、c）三情况都统一起来了。我们再思考时，就不需要考虑更多的情况了。
                    </p>
                    <p data-nodeid="8099">
                      Case 3：如果 value 比根结点大，那么需要执行：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">if</span> (value &gt; root.val) {
</div></li><li><div class="code-word">    root.right = deleteNode(root.right, value);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="8101">
                      Case 4：如果 value
                      与根结点的值相等，那么需要再分四种情况考虑。
                    </p>
                    <p data-nodeid="8102">a）此时只有一个结点。比如：</p>
                    <p data-nodeid="8103">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtYOAaCxfAABz2q7dEO8442.png"
                        alt="Drawing 15.png"
                        data-nodeid="9086"
                      />
                    </p>
                    <p data-nodeid="8104">在删除 1 之后，都需要返回 null。</p>
                    <p data-nodeid="8105">
                      b）如果被删除的结点有左子树。那么需要从<strong
                        data-nodeid="9101"
                        >左子树中找到最大值</strong
                      >，然后与当前结点进行值<strong data-nodeid="9102"
                        >交换</strong
                      >。最后<strong data-nodeid="9103"
                        >再在左子树中删除 value</strong
                      >。步骤如下：
                    </p>
                    <p data-nodeid="8106">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtZiAEkBKAAanEhq-SYE408.gif"
                        alt="5.gif"
                        data-nodeid="9106"
                      />
                    </p>
                    <p data-nodeid="8107">
                      Step 1. 找到要删除的结点
                      1，发现它还有左子树。并不能直接删除。
                    </p>
                    <p data-nodeid="8108">
                      Step 2. 找到左子树里面的最大值 -1。
                    </p>
                    <p data-nodeid="8109">
                      Step 3. 将值 -1 与 1 的值进行交换。注意：我们只是交换
                      node.val，而不是交换 node。
                    </p>
                    <p data-nodeid="8110">
                      Step 4. 交换之后，接着在左子树中删除结点 1。
                    </p>
                    <p data-nodeid="8111">
                      Step 5. 最终得到的仍然是一棵二叉搜索树。
                    </p>
                    <p data-nodeid="8112">
                      c）如果要删除的结点只有右子树。那么需要从<strong
                        data-nodeid="9125"
                        >右子树中找到最小值</strong
                      >，然后与当前结点进行值<strong data-nodeid="9126"
                        >交换</strong
                      >。然后<strong data-nodeid="9127"
                        >再在右子树中删除 value</strong
                      >。步骤如下：
                    </p>
                    <p data-nodeid="8113">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtbCAEv1OAAXuSoTT_wY014.gif"
                        alt="6.gif"
                        data-nodeid="9130"
                      />
                    </p>
                    <p data-nodeid="8114">
                      Step 1. 找到要删除的结点 1，发现它还有右子树。
                    </p>
                    <p data-nodeid="8115">Step 2. 在右子树中找到最小的值 2。</p>
                    <p data-nodeid="8116">
                      Step 3. 交换值。注意：是交换值，不是结点交换。
                    </p>
                    <p data-nodeid="8117">Step 4. 继续在右子树中删除结点 1。</p>
                    <p data-nodeid="8118">
                      Step 5. 最终我们得到一棵删除结点 1 之后的二叉搜索树。
                    </p>
                    <p data-nodeid="8119">
                      d）被删除的结点既有左子树，也有右子树。这时，假设它只有左子树，或者假设它只有右子树，这两种假设你可以任选一个进行删除即可。
                    </p>
                    <p data-nodeid="8120">
                      不过这里我要给你留道<strong data-nodeid="9142"
                        >思考题</strong
                      >：如果我们想要删除结点之后，想让二叉搜索树尽量保持平衡，有什么办法呢？提示：可以增加一些结点信息。
                    </p>
                    <p data-nodeid="8121">
                      【<strong data-nodeid="9152">代码</strong
                      >】至此，我们把<strong data-nodeid="9153"
                        >删除二叉搜索树的结点</strong
                      >涉及的所有情况都分析清楚了，接下来就可以直接写代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapValue</span><span class="hljs-params">(TreeNode a, TreeNode b)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> t = a.val;
</div></li><li><div class="code-word">        a.val = b.val;
</div></li><li><div class="code-word">        b.val = t;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// case 1</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// case 2</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (key &lt; root.val) {
</div></li><li><div class="code-word">            root.left = deleteNode(root.left, key);
</div></li><li><div class="code-word">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.val) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// case 3</span>
</div></li><li><div class="code-word">            root.right = deleteNode(root.right, key);
</div></li><li><div class="code-word">        } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">            <span class="hljs-comment">// case 4. case4又分为4种小情况，最后一种可以被合并掉。</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 所以这里只处理了三种。</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 当前树只有一个结点，那么直接返回null</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 当前结点还有左子树</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 那么需要从左子树中找个较大的值。</span>
</div></li><li><div class="code-word">                TreeNode large = root.left;
</div></li><li><div class="code-word">                <span class="hljs-keyword">while</span> (large.right != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">                    large = large.right;
</div></li><li><div class="code-word">                }
</div></li><li><div class="code-word">                <span class="hljs-comment">// 交换再删除</span>
</div></li><li><div class="code-word">                swapValue(root, large);
</div></li><li><div class="code-word">                root.left = deleteNode(root.left, key);
</div></li><li><div class="code-word">            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 当前结点还有右子树</span>
</div></li><li><div class="code-word">                TreeNode small = root.right;
</div></li><li><div class="code-word">                <span class="hljs-comment">// 那么需要从右子树中找个较小的值</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">while</span> (small.left != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">                    small = small.left;
</div></li><li><div class="code-word">                }
</div></li><li><div class="code-word">                <span class="hljs-comment">// 交换再删除</span>
</div></li><li><div class="code-word">                swapValue(root, small);
</div></li><li><div class="code-word">                root.right = deleteNode(root.right, key);
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> root;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8123">
                      <p data-nodeid="8124">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9157"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9161"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9165"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8125">
                      <strong data-nodeid="9170">复杂度分析</strong
                      >：如果是一棵平衡的二叉搜索树，那么时间复杂度为
                      O(lgn)，否则时间复杂度为 O(N)。
                    </p>
                    <p data-nodeid="8126">
                      【<strong data-nodeid="9184">小结</strong
                      >】我们对“二叉搜索树的删除结点”的考点做一下小结。一方面是利用<strong
                        data-nodeid="9185"
                        >有序性</strong
                      >，另一方面就是<strong data-nodeid="9186"
                        >考察应聘者的分析能力</strong
                      >。因此，这道题的重点是清晰分析出其中涉及的四种情况。面试的时候，面试官会要求你：
                    </p>
                    <ul data-nodeid="8127">
                      <li data-nodeid="8128">
                        <p data-nodeid="8129">能清晰地讲出每种情况的处理办法</p>
                      </li>
                      <li data-nodeid="8130">
                        <p data-nodeid="8131">能清晰简洁地实现代码</p>
                      </li>
                    </ul>
                    <p data-nodeid="8132">
                      既然我们已经学习了二叉搜索树删除结点操作，那么另外两种操作想必你可以拿来练练手了。
                    </p>
                    <p data-nodeid="8133">
                      <strong data-nodeid="9194">练习题 6</strong>:
                      二叉搜索树插入一个新结点
                    </p>
                    <blockquote data-nodeid="8134">
                      <p data-nodeid="8135">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9198"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jcpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9202"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9206"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8136">
                      <strong data-nodeid="9211">练习题 7</strong
                      >：二叉搜索树查找结点
                    </p>
                    <blockquote data-nodeid="8137">
                      <p data-nodeid="8138">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9215"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9219"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9223"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8139">
                      此时我们就可以将<strong data-nodeid="9241"
                        >二叉搜索树的中序遍历</strong
                      >、<strong data-nodeid="9242">查找</strong>、<strong
                        data-nodeid="9243"
                        >插入</strong
                      >，<strong data-nodeid="9244">以及删除</strong
                      >加入我们的知识树里面了，如下图所示：
                    </p>
                    <p data-nodeid="8140">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtcGAHdsVAAD8g3mqZEQ373.png"
                        alt="Drawing 18.png"
                        data-nodeid="9247"
                      />
                    </p>
                    <h3 data-nodeid="8141">后序遍历</h3>
                    <p data-nodeid="8142">
                      接下来我们看一下后序遍历。后序遍历的顺序：
                    </p>
                    <ol data-nodeid="8143">
                      <li data-nodeid="8144">
                        <p data-nodeid="8145">左子树</p>
                      </li>
                      <li data-nodeid="8146">
                        <p data-nodeid="8147">右子树</p>
                      </li>
                      <li data-nodeid="8148">
                        <p data-nodeid="8149">根结点</p>
                      </li>
                    </ol>
                    <p data-nodeid="8150">
                      这里我们同样采用一种**概括处理的思路，**不再按照课本上一步一步演示的方式。下图是我们处理的步骤：
                    </p>
                    <p data-nodeid="8151">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtc6AUcUpAAoB4AbuqCg073.gif"
                        alt="7.gif"
                        data-nodeid="9262"
                      />
                    </p>
                    <ul data-nodeid="8152">
                      <li data-nodeid="8153">
                        <p data-nodeid="8154">
                          Step 1.
                          左子树作为一个整体放到左边，右子树作为一个整体放右边。
                        </p>
                      </li>
                      <li data-nodeid="8155">
                        <p data-nodeid="8156">Step 2. 再把左子树展开。</p>
                      </li>
                      <li data-nodeid="8157">
                        <p data-nodeid="8158">Step 3. 接着把右子树展开。</p>
                      </li>
                      <li data-nodeid="8159">
                        <p data-nodeid="8160">Step 4. 最后放上根结点。</p>
                      </li>
                    </ul>
                    <p data-nodeid="8161">
                      这样有助于帮助你理解后序遍历。但是仍然要<strong
                        data-nodeid="9272"
                        >注意输出结点的顺序</strong
                      >。结点真正输出顺序如下图所示（红色表示顺序）：
                    </p>
                    <p data-nodeid="8162">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtdmAVCQTAACWpvqFKDQ011.png"
                        alt="Drawing 20.png"
                        data-nodeid="9275"
                      />
                    </p>
                    <h4 data-nodeid="8163">递归后序遍历</h4>
                    <p data-nodeid="8164">
                      基于以上思路，我们可以写出递归的后序遍历代码（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; ans)</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 先遍历左子树</span>
</div></li><li><div class="code-word">    postOrder(root.left, ans);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 最后遍历右子树</span>
</div></li><li><div class="code-word">    postOrder(root.right, ans);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 然后遍历中间的根结点</span>
</div></li><li><div class="code-word">    ans.add(root.val);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8166">
                      <p data-nodeid="8167">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9281"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9285"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9289"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8168">
                      <strong data-nodeid="9294">复杂度分析</strong
                      >：时间复杂度为
                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)
                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。
                    </p>
                    <h4 data-nodeid="8169">使用栈完成后序遍历</h4>
                    <p data-nodeid="8170">
                      接下来，我们看一下如何将递归的后序代码，改成<strong
                        data-nodeid="9301"
                        >非递归的后序代码</strong
                      >（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode t)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// 存放遍历的结果</span>
</div></li><li><div class="code-word">        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
</div></li><li><div class="code-word">        <span class="hljs-comment">// pre表示遍历时前面一个已经遍历过的结点</span>
</div></li><li><div class="code-word">        TreeNode pre = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">        Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果栈中还有元素，或者当前结点t非空</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">while</span> (!s.isEmpty() || t != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 顺着左子树走，并且将所有的元素压入栈中</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">                s.push(t);
</div></li><li><div class="code-word">                t = t.left;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            <span class="hljs-comment">// 当没有任何元素可以压栈的时候</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 拿栈顶元素，注意这里并不将栈顶元素弹出</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 因为在迭代时，根结点需要遍历两次，这里需要判断一下</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 右子树是否遍历完毕</span>
</div></li><li><div class="code-word">            t = s.peek();
</div></li><li><div class="code-word">            <span class="hljs-comment">// 如果要遍历当前结点，需要确保右子树已经遍历完毕</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 1. 如果当前结点右子树为空，那么右子树没有遍历的必要</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 需要将当前结点放到ans中</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 2. 当t.right == pre时，说明右子树已经被打印过了</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 那么此时需要将当前结点放到ans中</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (t.right == <span class="hljs-keyword">null</span> || t.right == pre) {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 右子树已经遍历完毕，放到ans中。</span>
</div></li><li><div class="code-word">                ans.add(t.val);
</div></li><li><div class="code-word">                <span class="hljs-comment">// 弹栈</span>
</div></li><li><div class="code-word">                s.pop();
</div></li><li><div class="code-word">                <span class="hljs-comment">// 因为已经遍历了当前结点，所以需要更新pre结点</span>
</div></li><li><div class="code-word">                pre = t;
</div></li><li><div class="code-word">                <span class="hljs-comment">// 已经打印完毕。需要设置为空，否则下一轮循环</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 还会遍历t的左子树。</span>
</div></li><li><div class="code-word">                t = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">            } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 第一次走到t结点，不能放到ans中，因为t的右子树还没有遍历。</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 需要将t结点的右子树遍历</span>
</div></li><li><div class="code-word">                t = t.right;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>

                    <blockquote data-nodeid="8172">
                      <p data-nodeid="8173">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9305"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9309"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9313"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8174">
                      <strong data-nodeid="9318">复杂度分析</strong>：时间复杂度
                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)
                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。
                    </p>
                    <p data-nodeid="8175">
                      迭代写法的<strong data-nodeid="9324">考点</strong
                      >：判断当前结点是不是应该放到 ans 中。
                      这里我们用了两个条件进行判断：
                    </p>
                    <ul data-nodeid="8176">
                      <li data-nodeid="8177">
                        <p data-nodeid="8178">是否有右子树</p>
                      </li>
                      <li data-nodeid="8179">
                        <p data-nodeid="8180">
                          pre 指针是不是指向当前结点的右子树
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8181">
                      <strong data-nodeid="9331">备注</strong
                      >：虽然面试的时候极难考到
                      Morris，但如果你有时间我还是建议你看看 Morris
                      后序遍历，其优点是只需要使用 O(1) 的空间复杂度。
                    </p>
                    <blockquote data-nodeid="8182">
                      <p data-nodeid="8183">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9335"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9339"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9343"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8184">
                      相比前序遍历、中序遍历，后序遍历出题形式变化更多样。接下来我们看一下如何用后序遍历处理例
                      1。
                    </p>
                    <h4 data-nodeid="8185">例 5：验证二叉搜索树</h4>
                    <p data-nodeid="8186">
                      【<strong data-nodeid="9351">题目</strong>】（与例
                      1一样）给定一棵二叉树，要求验证是不是一棵二叉搜索树。
                    </p>
                    <p data-nodeid="8187">
                      【<strong data-nodeid="9357">分析</strong
                      >】这里要利用后序遍历来求解这道题目。回到二叉搜索树的定义：左子树所有值都比根结点小，右子树所有值都比根结点大。
                    </p>
                    <p data-nodeid="8188">
                      如果我们能够拿到左右子树的信息，根结点就可以利用这些信息判断是否满足二叉搜索树的要求。
                    </p>
                    <p data-nodeid="8189">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRte6AGgSSAANZYCc0W0I359.png"
                        alt="Drawing 21.png"
                        data-nodeid="9361"
                      />
                    </p>
                    <p data-nodeid="8190">
                      如上图所示：如果满足 lmax &lt; x 并且 x &lt;
                      rmin，那么可以认为这棵树是二叉搜索树。注意，<strong
                        data-nodeid="9371"
                        >我们是先拿到了左子树与右子树的信息，然后再利用这个信息做出判断</strong
                      >。这样的操作符合后序遍历的要求。
                    </p>
                    <p data-nodeid="8191">
                      【<strong data-nodeid="9377">画图</strong
                      >】这里我们拿一棵二叉搜索树来画图演示步骤，动图如下：
                    </p>
                    <p data-nodeid="8192">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/21/38/CioPOWBUIwGAAv3NAAp9VZSO5a4731.gif"
                        alt="12.gif"
                        data-nodeid="9380"
                      />
                    </p>
                    <p data-nodeid="8193">
                      Step 1.
                      想要判断根结点是否大于左子树，小于右子树。但是此时还没有拿到左右子树的信息，于是分别去拿左子树/右子树的信息。
                    </p>
                    <p data-nodeid="8194">
                      Step 2. 观察左子树.可以发现 1 &lt; 2， 并且 2 &lt;
                      3，左子树是一棵二叉搜索树，此外我们还得到了左子树的范围
                      [1, 3]。
                    </p>
                    <p data-nodeid="8195">
                      Step 3. 然后再看右子树，可以发现 5 &lt; 6 并且 6 &lt;
                      7，右子树是一棵二叉搜索树，此外我们还得到了右子树的范围
                      [5, 7]。
                    </p>
                    <p data-nodeid="8196">
                      Step 4.
                      分别得到左右子树的信息之后，我们将这个信息替换掉原来的子树，然后再比较
                      lmax = 3 &lt; 4 并且 4 &lt; rmin =
                      5，因此这棵树是一棵有效的二叉搜索树。
                    </p>
                    <p data-nodeid="8197">
                      【<strong data-nodeid="9410">技巧</strong
                      >】在利用后序遍历处理这道题目的时候，还需要考虑空结点带来的麻烦，如下图所示：
                    </p>
                    <p data-nodeid="8198">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtgKAIBrtAABQgHb3MVg861.png"
                        alt="Drawing 23.png"
                        data-nodeid="9413"
                      />
                    </p>
                    <p data-nodeid="8199">
                      我们在处理结点 4 的时候，右子树的范围比较容易确定 [5,
                      5]。但是左子树是一棵空树，返回什么范围给结点 4
                      合适呢？有什么办法可以比较好地避免用 if/else
                      去判断空结点呢？
                    </p>
                    <p data-nodeid="8200">
                      这里给你介绍一个<strong data-nodeid="9436"
                        >技巧：用 [Long.MAX_VALUE,
                        Long.MIN_VALUE]表示一个空区间</strong
                      >，也就是<strong data-nodeid="9437"
                        >下界是一个最大的数，上界是一个最小的数</strong
                      >。
                    </p>
                    <p data-nodeid="8201">
                      下面我们利用动图演示一下为什么在这种情况下可以工作（画图时分别用
                      -inf 取代最小值，用inf 取代最大值）：
                    </p>
                    <p data-nodeid="8202">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtheAAqTpAAqrC7nn9cs642.gif"
                        alt="9.gif"
                        data-nodeid="9441"
                      />
                    </p>
                    <p data-nodeid="8203">
                      Step 1.
                      根据后序遍历的要求，首先应该去查看左子树和右子树的信息。
                    </p>
                    <p data-nodeid="8204">
                      Step 2. 左子树是一棵空树，那么得到的区间就是
                      <strong data-nodeid="9450">[inf, -inf]</strong
                      >。注意这里表示空区间的方式。
                    </p>
                    <p data-nodeid="8205">
                      Step 3. 右子树只有一个结点 5，其左右子树也是空树，因此结点
                      5 的左右区间分别为 [inf, -inf] 和 [inf, -inf]。<strong
                        data-nodeid="9468"
                        >接下来进行比较，lmax = -inf &lt; 5 并且 5 &lt; rmin =
                        inf</strong
                      >。
                    </p>
                    <p data-nodeid="8206">
                      Step 4.
                      然后我们需要总结右子树的区间范围。这个区间就可以这样取了：[<strong
                        data-nodeid="9484"
                        >min(lmin=inf, 5)</strong
                      >,<strong data-nodeid="9485">max(5, rmax=-inf)</strong
                      >]，也就是 [5, 5]。
                    </p>
                    <p data-nodeid="8207">
                      Step 5.
                      接下来利用左子树的信息和右子树的信息，首先判断范围，lmax =
                      -inf &lt; 4并且4 &lt; rmin = 5，再得到整棵树的范围[<strong
                        data-nodeid="9505"
                        >min(lmin=inf, 4)</strong
                      >,<strong data-nodeid="9506">max(5, rmax=5)</strong
                      >]，也就是 [4, 5]。
                    </p>
                    <p data-nodeid="8208">
                      【<strong data-nodeid="9512">代码</strong
                      >】到这里，我们已经可以开始写一下代码了（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-comment">// 用来存放一棵树里面数值的区间</span>
</div></li><li><div class="code-word">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Range</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">public</span> Long min = Long.MAX_VALUE;
</div></li><li><div class="code-word">    <span class="hljs-keyword">public</span> Long max = Long.MIN_VALUE;
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Range</span><span class="hljs-params">()</span> </span>{}
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Range</span><span class="hljs-params">(Long l, Long r)</span> </span>{
</div></li><li><div class="code-word">      min = l;
</div></li><li><div class="code-word">      max = r;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ans = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> Range emptyRange = <span class="hljs-keyword">new</span> Range();
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> Range <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果是空树，或者已经判断不是一棵二叉搜索树了</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 那么就不需要再继续遍历了。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !ans) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> emptyRange;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    Range l = postOrder(root.left);
</div></li><li><div class="code-word">    Range r = postOrder(root.right);
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (!(l.max &lt; root.val &amp;&amp; root.val &lt; r.min)) {
</div></li><li><div class="code-word">      ans = <span class="hljs-keyword">false</span>;
</div></li><li><div class="code-word">      <span class="hljs-comment">// 当不符合的时候，返回任意区间都是可以的</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> emptyRange;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 需要取左子树最小值与当前结点的最小值。</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 需要取右子树最大值与当前结点的最大值</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Range(Math.min(l.min, root.val),
</div></li><li><div class="code-word">                    Math.max(r.max, root.val));
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>{
</div></li><li><div class="code-word">    ans = <span class="hljs-keyword">true</span>;
</div></li><li><div class="code-word">    postOrder(root);
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8210">
                      <p data-nodeid="8211">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9516"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9520"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9524"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8212">
                      <strong data-nodeid="9529">复杂度分析</strong
                      >：时间复杂度为 O(n)，空间复杂度为 O(H)，其中 H
                      表示树的高度。
                    </p>
                    <p data-nodeid="8213">
                      【<strong data-nodeid="9535">小结</strong
                      >】写完代码之后，我们来看一下这道题的考点：
                    </p>
                    <ul data-nodeid="8214">
                      <li data-nodeid="8215">
                        <p data-nodeid="8216">拿到子树的区间</p>
                      </li>
                      <li data-nodeid="8217">
                        <p data-nodeid="8218">
                          利用子树的区间，整合出整棵树的区间
                        </p>
                      </li>
                      <li data-nodeid="8219">
                        <p data-nodeid="8220">如何处理空结点</p>
                      </li>
                    </ul>
                    <p data-nodeid="8221">
                      我们可以把这些知识点浓缩一下，方便我们以后复习，如下图所示：
                    </p>
                    <p data-nodeid="8222">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtiyAGHC7AACr9Dp8WWE577.png"
                        alt="Drawing 25.png"
                        data-nodeid="9542"
                      />
                    </p>
                    <p data-nodeid="8223">
                      如果我们再深入思考一下，就会发现，后序遍历的时候有个<strong
                        data-nodeid="9556"
                        >特点</strong
                      >：<strong data-nodeid="9557">想要验证</strong
                      >一棵树是否是二叉搜索树，后序遍历的<strong
                        data-nodeid="9558"
                        >返回值</strong
                      >却是整棵树的信息。
                    </p>
                    <p data-nodeid="8224">这里画图来表示一下：</p>
                    <p data-nodeid="8225">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtjaACs7TAABq6h1DLRQ985.png"
                        alt="Drawing 26.png"
                        data-nodeid="9562"
                      />
                    </p>
                    <p data-nodeid="8226">
                      有点“<strong data-nodeid="9568">项庄舞剑，意在沛公</strong
                      >”的味道。那么我们再对后序遍历做一个小结，如下图所示：
                    </p>
                    <p data-nodeid="8227">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtj6AF94_AAC54hdOUJs668.png"
                        alt="Drawing 27.png"
                        data-nodeid="9571"
                      />
                    </p>
                    <p data-nodeid="8228">
                      完成总结后，我们再通过一道题目，加深对这个考点的理解。
                    </p>
                    <h4 data-nodeid="8229">例 6：最低公共祖先</h4>
                    <p data-nodeid="8230">
                      【<strong data-nodeid="9583">题目</strong
                      >】给定一棵二叉树，和两个在树上的结点，返回这两个结点的最低公共祖先。比如
                      [5,3] 两个结点的最低公共祖先是结点 6。
                    </p>
                    <p data-nodeid="8231">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtkaAE0QsAADAh6zPbnk294.png"
                        alt="Drawing 28.png"
                        data-nodeid="9586"
                      />
                    </p>
                    <p data-nodeid="8232">
                      【<strong data-nodeid="9600">分析</strong
                      >】这是一道来自<strong data-nodeid="9601">微软</strong
                      >的面试题。在面试时，注意面试官要求的是两个结点的<strong
                        data-nodeid="9602"
                        >最低</strong
                      >公共祖先。
                    </p>
                    <p data-nodeid="8233">
                      一个结点 x 如果是 p，q 的最低公共祖先，那么以结点 x
                      为根的树，必然包含了 p，q 这<strong data-nodeid="9608"
                        >2</strong
                      >个结点。并且只可能下面 2 种 Case。
                    </p>
                    <p data-nodeid="8234">
                      <strong data-nodeid="9613">Case 1</strong>：两个结点 p，q
                      分别在 x 的左边和右边。此时左子树会找到 1
                      个结点，右子树会找到 1 个结点。如下图所示：
                    </p>
                    <p data-nodeid="8235">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtlCAbdR9AARsIH_iZJY236.png"
                        alt="Drawing 29.png"
                        data-nodeid="9616"
                      />
                    </p>
                    <p data-nodeid="8236">
                      Case 2：根结点为 q，另外一个结点 p
                      在子树里，反之亦然。如下图所示：
                    </p>
                    <p data-nodeid="8237">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtlmAcMP0AAJsaaiXrk4163.png"
                        alt="Drawing 30.png"
                        data-nodeid="9620"
                      />
                    </p>
                    <p data-nodeid="8238">
                      这里你可能会想，如果<strong data-nodeid="9626"
                        >左子树</strong
                      >找到 2 个结点怎么办？比如下图展示的情况：
                    </p>
                    <p data-nodeid="8239">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/44/Cgp9HWBRtmKADj4gAAKGC_G6FjM242.png"
                        alt="Drawing 31.png"
                        data-nodeid="9629"
                      />
                    </p>
                    <p data-nodeid="8240">
                      绿色结点发现左子树计数有两个结点，那么绿色结点肯定不是最低公共祖先，最低公共祖先应该是左子树，比如红色结点。说明在处理左子树时，已经找到了最低公共祖先。这种情况不需要做什么处理。
                    </p>
                    <p data-nodeid="8241">
                      我们再提取一下分析思路里的<strong data-nodeid="9636"
                        >关键信息</strong
                      >。
                    </p>
                    <ul data-nodeid="8242">
                      <li data-nodeid="8243">
                        <p data-nodeid="8244">
                          最终想要的结论（<strong data-nodeid="9642"
                            >沛公</strong
                          >）：找到二叉树里面的最低公共祖先。
                        </p>
                      </li>
                      <li data-nodeid="8245">
                        <p data-nodeid="8246">
                          函数的返回值（<strong data-nodeid="9652">项庄</strong
                          >）：在当前子树中，<strong data-nodeid="9653"
                            >统计</strong
                          >结点为 p，q 的个数。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8247">
                      此时，我们已经有了“<strong data-nodeid="9659"
                        >沛公，项庄</strong
                      >”，就可以展开“鸿门宴”了。
                    </p>
                    <p data-nodeid="8248">
                      【<strong data-nodeid="9665">画图</strong
                      >】接下来通过一个实例先在一棵树上进行模拟，动图演示如下：
                    </p>
                    <p data-nodeid="8249">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtm-AabKNAAto4bxyLyY509.gif"
                        alt="10.gif"
                        data-nodeid="9668"
                      />
                    </p>
                    <p data-nodeid="8250">
                      Step 1. 给定一棵二叉树，需要找到结点 5, 3
                      的最低公共祖先。<strong data-nodeid="9674"
                        >后序遍历时，从最下层的结点开始逐层往上归纳信息</strong
                      >。
                    </p>
                    <p data-nodeid="8251">
                      Step 2. 最下层的结点为 3，统计数目为 1。
                    </p>
                    <p data-nodeid="8252">
                      Step 3. 接着处理倒数第二层，统计出当前子树里面结点为 [5,
                      3] 的个数。
                    </p>
                    <p data-nodeid="8253">
                      Step 4. 处理倒数第 3 层，分别统计出结点 7, 9 里面结点为
                      [5, 3] 的个数，[7, 9] 得到的统计值都为 1。
                    </p>
                    <p data-nodeid="8254">
                      Step 5. 处理结点 6，此时左结点统计值为 1，右子树统计值为
                      1，那么最低公共祖先为结点 6。
                    </p>
                    <p data-nodeid="8255" class="">
                      Step 6. 处理结点 11，此时统计值为
                      2，但是由于右子树统计值已经是 2 了，那么结点 11
                      不是最低公共祖先。
                    </p>
                    <p data-nodeid="8256">
                      【<strong data-nodeid="9697">代码</strong
                      >】至此，我们已经定义好了函数的返回值，也知道了利用子树的统计值处理前面提到的两种
                      Case，进而得到真正的答案。代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">private</span> TreeNode ans = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 查看子结点的梳计个数</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> lcnt = postOrder(root.left, p, q);
</div></li><li><div class="code-word">    <span class="hljs-keyword">int</span> rcnt = postOrder(root.right, p, q);
</div></li><li><div class="code-word">    <span class="hljs-comment">// 利用子结点返回的信息来进行处理</span>
</div></li><li><div class="code-word">    <span class="hljs-comment">// 如果左边有一个，右边有一个，那么当前root就是最低公共祖先</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (lcnt == <span class="hljs-number">1</span> &amp;&amp; rcnt == <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      ans = root;
</div></li><li><div class="code-word">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcnt == <span class="hljs-number">1</span> || rcnt == <span class="hljs-number">1</span>) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 如果左边找到一个，或者右边找到一个</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 并且我等于其中某一个结点p|q</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 那么当前root就是最低公共祖先</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (root == p || root == q) {
</div></li><li><div class="code-word">        ans = root;
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 返回值为以root为根的子树, 统计里面的p,q结点的个数。</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> lcnt + rcnt + ((root == p || root == q) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root,
</span></span></div></li><li><div class="code-word">                              TreeNode p, TreeNode q) {
</div></li><li><div class="code-word">    ans = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">    postOrder(root, p, q);
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="8258">
                      <p data-nodeid="8259">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9701"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9705"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9709"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8260">
                      <strong data-nodeid="9714">复杂度分析</strong
                      >：时间复杂度为 O(N)，空间复杂度为 O(H)，H 为树的高度。
                    </p>
                    <p data-nodeid="8261">
                      【<strong data-nodeid="9720">小结</strong
                      >】就这道题来说，考点为：
                    </p>
                    <ul data-nodeid="8262">
                      <li data-nodeid="8263">
                        <p data-nodeid="8264">
                          定义函数的返回值为统计结点 p，q 的个数;
                        </p>
                      </li>
                      <li data-nodeid="8265">
                        <p data-nodeid="8266">
                          利用子树返回的结点个数，得到想要的最低公共祖先。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="8267">
                      如果仔细思考一下，这道题还可以用前序遍历的方法来解决。你能思考一下吗？
                    </p>
                    <blockquote data-nodeid="8268">
                      <p data-nodeid="8269">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9727"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9731"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9735"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8270">
                      <strong data-nodeid="9740">思考题</strong
                      >：我们再把这道题从广度和深度上进行展开：
                    </p>
                    <p data-nodeid="8271">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtoqAPZ6tAADozszBVY4858.png"
                        alt="Drawing 33.png"
                        data-nodeid="9743"
                      />
                    </p>
                    <p data-nodeid="8272">
                      虽然我们只介绍了两个结点的后序遍历解法，但你也可以开阔思路来试一下多叉树的题目。
                    </p>
                    <p data-nodeid="8273">
                      我们再归纳一下<strong data-nodeid="9754"
                        >后序遍历的思路</strong
                      >，可以<strong data-nodeid="9755"
                        >总结为 8 个字“项庄舞剑，意在沛公”</strong
                      >，如下图所示：
                    </p>
                    <p data-nodeid="8274">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtpGAUxzZAADV23ElNds459.png"
                        alt="Drawing 34.png"
                        data-nodeid="9758"
                      />
                    </p>
                    <ul data-nodeid="8275">
                      <li data-nodeid="8276">
                        <p data-nodeid="8277">
                          子树的信息：即如何定义函数的返回值。可以巧妙记为“项庄是谁？”。
                        </p>
                      </li>
                      <li data-nodeid="8278">
                        <p data-nodeid="8279">
                          信息的处理：如何利用子树返回的信息，得到我们最终想要的结论，可以巧妙地记为“如何得到沛公？”。
                        </p>
                      </li>
                    </ul>
                    <h3 data-nodeid="8280">总结与延伸</h3>
                    <p data-nodeid="8281">
                      经过前面几讲的学习，我们马上就要和二叉树说再见了，回到知识层面，我再把本讲重点介绍，且需要你掌握的内容总结在一张思维导图中，如下图所示：
                    </p>
                    <p data-nodeid="8282">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtp2ACQ-ZAAKKPaNyzjs632.png"
                        alt="Drawing 35.png"
                        data-nodeid="9765"
                      />
                    </p>
                    <p data-nodeid="8283">
                      除去知识的扩展，你还要学会浓缩和简化，抓住三种遍历的核心。我同样为你总结了一张思维导图：
                    </p>
                    <p data-nodeid="8284">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtqWAL6DXAADFeBomwio444.png"
                        alt="Drawing 36.png"
                        data-nodeid="9769"
                      />
                    </p>
                    <p data-nodeid="8285">
                      除去介绍知识本身，这里我重点介绍了“我是如何通过三种遍历搞定所有的二叉树的题目”。由于篇幅的限制，关于“树”的介绍就要到这里。今天所讲的内容只是一引子，期待你还能发现更多树的特点和巧妙用法。欢迎在评论区和我交流，期待看到大家的奇思妙想。
                    </p>
                    <h3 data-nodeid="8286">思考题</h3>
                    <p data-nodeid="8287">
                      我再给你留一道<strong data-nodeid="9777">思考题</strong
                      >：给定一个二叉树的前序遍历和中序遍历，请构建出这棵二叉树。
                    </p>
                    <p data-nodeid="8288">
                      输入：pre = [2,1,3], mid = [1, 2, 3]
                    </p>
                    <p data-nodeid="8289">
                      输出：返回二叉树根结点 [2]，左子结点为 1，右子结点为3.
                    </p>
                    <blockquote data-nodeid="8290">
                      <p data-nodeid="8291">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9794"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9798"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8"
                          data-nodeid="9802"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="8292" class="">
                      你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。下一讲将介绍
                      0<strong data-nodeid="9810"
                        >7 |
                        并查集，如何利用两行代码完成并查集的解题技巧</strong
                      >？让我们一起前进。
                    </p>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >数据结构与算法面试宝典</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <!---->
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **健
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        1
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      非递归不是有更简洁的实现吗？
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    真哒？把代码写在留言区。悄悄告诉我。（写专栏有时候，代码主要是为了让大家更加容易懂）
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **方
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        1
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      Mirror算法https://zhuanlan.zhihu.com/p/101321696
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *旭
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        1
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      例 2 是回溯吗？我怎么觉得是深度优先搜索？
                      回溯不是撤销这一步往回走吗？搞不明白，请老师指点一下，谢谢
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    回溯本质上就是DFS。如果还不理解，欢迎你继续提问～
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **5700
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      先序遍历解决从上到下走向的问题，中序遍历解决从左到右走向的问题，后序遍历解决从下到上走向的问题
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *超
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      删除节点，平衡二叉树的复杂度是O(logN)，但用这种方法删除后，就不再平衡了。
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        刘
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div
                      data-v-4bc80e00=""
                      class="message-list-content ellipsis"
                    >
                      // 栈前序遍历public ListInteger preorderTraversal(TreeNode
                      root) { ListInteger result = new ArrayList();
                      StackTreeNode stack = new Stack(); stack.push(root); while
                      (!stack.isEmpty()) { TreeNode node = stack.pop();
                      result.add(node.val); if (node.right != null) {
                      stack.push(node.right); } if (node.left != null) {
                      stack.push(node.left); } } return result;}
                    </div>
                    <div data-v-4bc80e00="" class="message-list-expand">
                      全部
                    </div>
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *军
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div
                      data-v-4bc80e00=""
                      class="message-list-content ellipsis"
                    >
                      python版本的前序遍历好像有问题，只遍历了左节点，右节点没有https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8
                    </div>
                    <div data-v-4bc80e00="" class="message-list-expand">
                      全部
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    这个完全没问题。通过测试平台测试的。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **正
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      这章是学起来最费劲的 因为我总想去透彻理解递归
                      但是总会被绕进去。。老师有什么好的方法吗
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    不要递归！你只需要学会文章一开始说的，笼统和概括的思路就可以了。想象成你有一个非常可靠的小弟！递归的事，你总是交给你的这个靠谱的小弟去做。（作为一个将来可以当经理的你，也需要放心地把事情交给别人嘛！）
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **健
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      老师，你好，例二目标和的所有路径中，//
                      函数结束的时候弹栈，也要把结点从路径最后扔掉!这里不需要将sum
                      -=root.val；么？
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    首先，从正确性上来说，执行sum -=
                    root.val。没有什么问题。这里之所以没有这写。是因为。1.
                    sum是一个传值的参数。2.执行了sum -=
                    root.val。后面也没有用到sum了，没必要这么操作。一定要注意传值！传值！传值。最近linux
                    kernel里面就有一段这样的代码。void free_mem(void *mem) {
                    free(mem);}
                    有人提了PR，要求free(mem)之后，应该将mem置空。将代码，改成这样。
                    void free_mem(void *mem) { free(mem); mem = NULL; }
                    这实际上，也是没有理解到函数参数传值的内涵。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **亚
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      验证相同的树，有用到影子吗😂
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    当给定两棵树A,
                    B的时候，你想象成你有第三棵树，树上的结点存放着true/false。你现在要遍历第三棵树。然后树中的结点里面的true/false是动态生成的（由相应位置的A,B结点决定）。然后，你遇到false就不再继续遍历第三棵树了。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **6011
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      看了一周，终于快看完了，不得不说学了好多👍
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >编辑回复：</span
                    >
                    给你点赞哦！！
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **发
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      前序遍历有n的复杂度，你这个貌似n的2
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    妥妥的O(N)。妥妥的～妥妥滴~
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **用户9364
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      应该是ArrayList在Kotlin中有的TypeAlias的方法😅😅
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **用户9364
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      目标和的所有路径最后一行代码是不是应该是path.removeAt(path.size-1)
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    没有找到removeAt方法啊:https://docs.oracle.com/javase/8/docs/api/java/util/List.html
                  </div>
                  <!---->
                  <!---->
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 685,
      courseCId: "",
      courseName: "数据结构与算法面试宝典",
      teachers: [
        {
          id: 630,
          teacherName: "德鲁伊",
          position: "前微软资深软件工程师",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span class="ql-author-13568064 ql-font-microsoftyahei" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto; background-color: rgb(255, 255, 255);">9&nbsp;年技术研发经验，主导过&nbsp;40PB&nbsp;级别的分布式存储系统架构设计与实现。带领团队实现核心模块，如用户态文件系统、存储引擎、分布式&nbsp;KV&nbsp;缓存。负责部门技术面试，有丰富的技术面试经验。此外，曾</span><span class="ql-font-microsoftyahei ql-author-13568064" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto;">作为复旦大学特聘讲师，面向研究生学院开展 IT 类课程，拥有多年授课经验。擅长架构设计、机器学习、云计算、大数据等领域。</span></span></p>',
        },
      ],
      totalCourseTime: 23,
      totalDuration: 340,
      sales: 18623,
      price: "98",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
      sellGoodsId: 748,
      sellGoodsPriceId: 73322,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。",
      seoKeywords:
        "数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季",
      seoTitle: "数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育",
      shareTitle: "这15种题型，算法面试肯定会问！",
      shareDescription: "300+高频真题详解，一题多解攻克算法面试",
      brief: "300+大厂高频真题，一题多解攻克算法面试",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png",
      courseType: 1,
      previewFirstField: "共23讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 638,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 638,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "83ec46930d5245bcae30be7a5f7786a2"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
</body>
