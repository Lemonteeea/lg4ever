<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">数据结构与算法面试宝典 - 拉勾教育</h1>

  <meta
    content="数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季"
    name="keywords"
  />

  <meta
    content="数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。"
    name="description"
  />

  <title>数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  数据结构与算法面试宝典
                </div>
                <div data-v-5f686215="" class="name">
                  德鲁伊
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  前微软资深软件工程师
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 |&nbsp;告别盲目刷题，击破算法面试
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 759px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：数据结构之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 栈：从简单栈到单调栈，解决经典栈问题
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 队列：FIFO 队列与单调队列的深挖与扩展
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 优先级队列：堆与优先级队列，筛选最优元素
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 |
                          链表：如何利用“假头、新链表、双指针”解决链表题？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 树：如何深度运用树的遍历？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 并查集：如何利用两行代码写并查集？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          加餐与答疑 | 第一期 ：一问一答
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：算法之一解多题篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08&nbsp;|
                          排序：如何利用合并与快排的小技巧，解决算法难题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09&nbsp;| 二分搜索：为什么说有序皆可用二分？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10&nbsp;|
                          双指针：如何掌握最长、定长、最短区间问题的解题决窍？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12&nbsp;|
                          回溯：我把回溯总结成一个公式，回溯题一出就用它
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | DP：我是怎么治好“DP&nbsp;头痛症”的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：一题多解篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19&nbsp;|
                          最小体力消耗路径：如何突破经典题型，掌握解题模板？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20&nbsp;| 5
                          种解法，如何利用常量空间求解最长有效括号长度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21&nbsp;| 安排会议室：如何利用多种方法安排会议室？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：代码模板篇
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 |&nbsp;数据结构模板：如何让解题变成搭积木？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    彩蛋
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 |&nbsp;算法的精进之路
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 146px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  03 | 优先级队列：堆与优先级队列，筛选最优元素
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/03/08
                  <span data-v-1605a430="" class="auth">德鲁伊</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/35:06"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="2106"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/35:06</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">91.6M</div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/35:06
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="339093" class="">
                      在电影院，相信你也看到有人持有 VIP
                      卡，可以直接越过队列进场去看电影。对于这种情况，我们的程序也可以用<strong
                        data-nodeid="339103"
                        >优先级队列</strong
                      >（<strong data-nodeid="339104">Priority Queue</strong
                      >）来模拟这个场景。
                    </p>

                    <p data-nodeid="349606" class="te-preview-highlight">
                      通常而言，<strong data-nodeid="349620"
                        >优先级队列都是基于堆</strong
                      >（<strong data-nodeid="349621">Heap</strong>）<strong
                        data-nodeid="349622"
                        >这种数据结构来实现的</strong
                      >。因此，我们在正式开始学习优先级队列之前，还需要深入浅出地介绍一下堆及其相关的四种操作。
                    </p>

                    <p data-nodeid="326938">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB95iADDnqAACK2SKwkGM125.png"
                        alt="Drawing 0.png"
                        data-nodeid="327259"
                      />
                    </p>
                    <h3 data-nodeid="326939">堆</h3>
                    <p data-nodeid="326940">
                      FIFO 队列能够解决广度遍历、分层遍历类似的题目，FIFO
                      队列在遍历的时候，有一个有趣的特点：<strong
                        data-nodeid="327266"
                        >每一层结点的先后顺序，遍历时就确定下来了</strong
                      >。
                    </p>
                    <p data-nodeid="326941">
                      如果把这种先后顺序当成优先级，那么这些结点之间的优先级就由遍历时的顺序决定。但是有时候我们遇到的问题，结点之间需要按照<strong
                        data-nodeid="327280"
                        >大小进行排序之后</strong
                      >，<strong data-nodeid="327281">再决定优先级</strong
                      >。在这种情况下，FIFO
                      队列不再适用，就需要用一种新的数据结构——<strong
                        data-nodeid="327282"
                        >优先级队列</strong
                      >。
                    </p>
                    <p data-nodeid="326942">
                      <strong data-nodeid="327287"
                        >优先级队列底层依赖的数据结构一般是堆，而堆是面试中经常遇到的考点之一</strong
                      >。因此，在这里我会先介绍堆的实现与要点，再介绍优先级队列的特点以及具体如何运用。
                    </p>
                    <h4 data-nodeid="326943">堆的分类：大堆与小堆</h4>
                    <p data-nodeid="326944">
                      通常堆的结构都是表现为一棵树，如果<strong
                        data-nodeid="327298"
                        >根比左右子结点都大</strong
                      >，那么称为<strong data-nodeid="327299">大堆</strong
                      >。如下图所示：
                    </p>
                    <p data-nodeid="326945">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB96aAYBPuAADIgr8zVTQ525.png"
                        alt="Drawing 1.png"
                        data-nodeid="327302"
                      />
                    </p>
                    <p data-nodeid="326946">
                      如果<strong data-nodeid="327314"
                        >根比左右子结点都要小</strong
                      >，那么称为**小堆，**如下图所示：
                    </p>
                    <p data-nodeid="326947">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB966AG3lGAADMrGaqmms247.png"
                        alt="Drawing 2.png"
                        data-nodeid="327317"
                      />
                    </p>
                    <p data-nodeid="326948">
                      通过堆的定义，可以发现<strong data-nodeid="327323"
                        >堆的特点：大堆的根是最大值，小堆的根是最小值</strong
                      >。
                    </p>
                    <p data-nodeid="326949">
                      更有趣的是，每次有元素 push 或者 pop
                      的时候，调整堆的时间复杂度为
                      O(lgn)，速度也非常快。因此，<strong data-nodeid="327329"
                        >堆经常被用于优先级队列</strong
                      >。接下来，我将以大堆为例，详细介绍堆的表示方式、添加元素、移除元素。
                    </p>
                    <p data-nodeid="326950">
                      <em data-nodeid="327333"
                        >注：后面的堆操作都是基于大堆。</em
                      >
                    </p>
                    <h4 data-nodeid="326951">堆的表示</h4>
                    <p data-nodeid="326952">
                      大部分时候都是<strong data-nodeid="327340"
                        >使用数组</strong
                      >表示一个堆，而不是使用二叉树。这是因为:
                    </p>
                    <ul data-nodeid="326953">
                      <li data-nodeid="326954">
                        <p data-nodeid="326955">
                          数组的内存具有连续性，访问速度更快；
                        </p>
                      </li>
                      <li data-nodeid="326956">
                        <p data-nodeid="326957">
                          堆结构是一棵<strong data-nodeid="327347"
                            >完全二叉树</strong
                          >。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="326958">如下图所示，堆的规律有如下几点：</p>
                    <ul data-nodeid="326959">
                      <li data-nodeid="326960">
                        <p data-nodeid="326961">i 结点的父结点 par = (i-1)/2</p>
                      </li>
                      <li data-nodeid="326962">
                        <p data-nodeid="326963">i 结点的左子结点 2 * i + 1</p>
                      </li>
                      <li data-nodeid="326964">
                        <p data-nodeid="326965">i 结点的右子结点 2 * i + 2</p>
                      </li>
                    </ul>
                    <p data-nodeid="326966">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB97mANuA0AAEuXuRD7OM444.png"
                        alt="Drawing 3.png"
                        data-nodeid="327358"
                      />
                    </p>
                    <p data-nodeid="326967">
                      <em data-nodeid="327362"
                        >注意：这里的下标是从 0 开始的。</em
                      >
                    </p>
                    <p data-nodeid="326968">
                      接下来，我们将通过具体的题目将堆的操作代码<strong
                        data-nodeid="327368"
                        >模板化</strong
                      >。
                    </p>
                    <h4 data-nodeid="326969">堆的操作</h4>
                    <p data-nodeid="326970">
                      堆的操作实际上只有两种：<strong data-nodeid="327375"
                        >下沉和上浮</strong
                      >，如下图所示：
                    </p>
                    <p data-nodeid="326971">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB98KAGCi1AACNPdvPhX0284.png"
                        alt="Drawing 4.png"
                        data-nodeid="327378"
                      />
                    </p>
                    <p data-nodeid="326972">
                      通过下沉和上浮，又可以分别得到 pop 和 push
                      操作，接下来我们一起讨论这四种操作的特点。
                    </p>
                    <p data-nodeid="326973">
                      假设我们已经申请了数组 a[] 和元素 n
                      表示当前堆中元素的个数，代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 表示堆的数组空间, 100作示例大小</span>
</div></li><li><div class="code-word"><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">// 堆中元素个数</span>
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="326975">
                      <em data-nodeid="327387"
                        >注：这个数组的大小仅作为示例讲解，你可以根据实际情况调整，我们的重点是把算法讲清楚。</em
                      >
                    </p>
                    <p data-nodeid="326976">
                      <strong data-nodeid="327393">1. 下沉</strong>
                    </p>
                    <p data-nodeid="326977">
                      引起下沉操作的原因：假设 a[i] 比它的子结点要小，那么除
                      a[i]
                      以外，其他子树都满足堆的性质。这个时候，就可以通过下沉操作，帮助
                      a[i] 找到正确的位置。
                    </p>
                    <p data-nodeid="326978">
                      <em data-nodeid="327410">注意，上述操作的是大堆。</em>
                    </p>
                    <p data-nodeid="326979">
                      为了方便你理解，我制作了下沉过程的动图演示，如下图所示：
                    </p>
                    <p data-nodeid="326980">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB99OAQTpJAAGapaZWoyM328.gif"
                        alt="1.gif"
                        data-nodeid="327414"
                      />
                    </p>
                    <blockquote data-nodeid="326981">
                      <p data-nodeid="326982">
                        Step 1. 结点 3 需要下沉。<br />
                        Step 2. 将要下沉的值存入变量 t 中，腾出空位。<br />
                        Step 3. 在子结点 8 和 9 中选中较大的结点 9。<br />
                        Step 4. 9 比 3 大，9 需要上移，腾出空位。<br />
                        Step 5. 上移之后，再查看子结点 4 与 7，选中较大结点
                        7。<br />
                        Step 6. 由于 7 比 3 大，7 需要上移，腾出空位。<br />
                        Step 7. 将 3 填入最终空出来的空位中。
                      </p>
                    </blockquote>
                    <p data-nodeid="326983">
                      首先，写下沉代码时，需要记住一个<strong
                        data-nodeid="327437"
                        >贪心原则</strong
                      >：如果子结点大，那么子结点就要上移。实际上，如果我们将移动路径<strong
                        data-nodeid="327438"
                        >一维化</strong
                      >，那么这段下沉代码就会变成如下图所示的样子：
                    </p>
                    <p data-nodeid="326984">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB996AJuAmAACoyw2YoTY998.gif"
                        alt="2.gif"
                        data-nodeid="327441"
                      />
                    </p>
                    <blockquote data-nodeid="326985">
                      <p data-nodeid="326986">
                        Step 1. 最大堆，结点 3 需要下沉。<br />
                        Step 2. 用临时变量 t 保存值 3。<br />
                        Step 3.子结点 9 比 t = 3 大，向前移动。<br />
                        Step 4.接着子结点 7 比 t = 3 大，向前移动。<br />
                        Step 5.最终给 3 找取最终的位置。
                      </p>
                    </blockquote>
                    <p data-nodeid="326987">
                      可以发现，下沉与经典的<strong data-nodeid="327456"
                        >插入排序（递减）非常相似</strong
                      >。只有一点略有不同：插入排序是一维的，只与后继的元素进行比较，而下沉是二维的，需要在两个后继元素中找到最大值与插入值进行比较。
                    </p>
                    <p data-nodeid="326988">
                      根据这个原则，可以写出<strong data-nodeid="327462"
                        >下沉</strong
                      >的代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">int</span> t = a[i];
</div></li><li><div class="code-word">&nbsp; <span class="hljs-comment">// 找到i结点的左子结点</span>
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">while</span> ((j = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) &lt; n) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 比插入排序多出来的一步：需要在两个后继中找个最大的出来</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// j &lt; n - 1判断是否有右子结点</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 如果有，并且右子结点更大，那么</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// j指向右子结点</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; a[j] &lt; a[j + <span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; j++;
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 如果子结点比t大</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 那么t的位置还需要往后排</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">if</span> (a[j] &gt; t) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; a[i] = a[j];
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; i = j;
</div></li><li><div class="code-word">&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 找到了t的位置</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 此时t是大于所有的子结点的</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; }
</div></li><li><div class="code-word">&nbsp; <span class="hljs-comment">// 将t放在找到的位置那里</span>
</div></li><li><div class="code-word">&nbsp; a[i] = t;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="326990">
                      <strong data-nodeid="327467">复杂度分析</strong
                      >：由于堆是一个完全二叉树，所以在下沉的时候，下沉路径就是树的高度。如果堆中有
                      N 个元素的话，所以时间复杂度为 O(lgN)。
                    </p>
                    <p data-nodeid="326991">
                      <strong data-nodeid="327473">2. 上浮</strong>
                    </p>
                    <p data-nodeid="326992">
                      上浮操作的条件：假设 a[i] 比它的父结点要大，并且除 a[i]
                      以外，其他子树都满足大堆的性质。
                    </p>
                    <p data-nodeid="326993">
                      <em data-nodeid="327486">注意，上述操作的是大堆。</em>
                    </p>
                    <p data-nodeid="326994">
                      为了方便你理解，我同样制作了上浮过程的动图演示，如下图所示：
                    </p>
                    <p data-nodeid="326995">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB9-6AO_sXAAF4Rim8-h4328.gif"
                        alt="3.gif"
                        data-nodeid="327490"
                      />
                    </p>
                    <blockquote data-nodeid="326996">
                      <p data-nodeid="326997">
                        Step 1.结点 10 太大，需要上浮。<br />
                        Step 2.将要上浮的 10 放到临时变量 t 中，腾出空位。<br />
                        Step 3.找到空位的父结点 8。<br />
                        Step 4.由于 8 比 t = 10 小，所以 8 往下移，腾出空位。<br />
                        Step 5.选中空位的父结点 9。<br />
                        Step 6.由于 9 仍然比 10 小，腾出空位。<br />
                        Step 7.再也不能找到父结点了，将 10 放到空位中。
                      </p>
                    </blockquote>
                    <p data-nodeid="326998">
                      同样，在<strong data-nodeid="327521">上浮</strong
                      >的时候，可以发现<strong data-nodeid="327522"
                        >一个原则</strong
                      >：如果父结点比“我”<strong data-nodeid="327523">小</strong
                      >，那么父结点就需要下移。我们将移动路径<strong
                        data-nodeid="327524"
                        >一维化</strong
                      >，这段插入代码就会变成如下图所示的样子：
                    </p>
                    <p data-nodeid="326999">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB9_yAMrYIAACvs1tCxn0334.gif"
                        alt="4.gif"
                        data-nodeid="327527"
                      />
                    </p>
                    <blockquote data-nodeid="327000">
                      <p data-nodeid="327001">
                        Step 1.最大堆，结点 10 需要上浮。<br />
                        Step 2.将需要上浮的 10 放到临时变量 t 中，腾出空位。<br />
                        Step 3.8 比 t 小，移动 8，腾出空位。<br />
                        Step 4.9 比 t 小，移动 9，腾出空位。<br />
                        Step 5.不能再移动了，将 t 放到空位中。
                      </p>
                    </blockquote>
                    <p data-nodeid="327002">
                      可以发现，上浮与经典的<strong data-nodeid="327546"
                        >插入排序（递减的）非常相似</strong
                      >。到这里，结点 a[i] 上浮的代码也比较容易搞定了。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// 上浮</span>
</div></li><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">int</span> t = a[i];
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">int</span> par = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; <span class="hljs-comment">// 如果还存在父结点</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 由于我们的下标是从0开始</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 0结点没有父结点</span>
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">    par = (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 如果父结点比t值小</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">if</span> (a[par] &lt; t) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 那么向下移动父结点的值。</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; a[i] = a[par];
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; i = par;
</div></li><li><div class="code-word">&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; }
</div></li><li><div class="code-word">&nbsp; a[i] = t;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="327004">
                      <strong data-nodeid="327551">复杂度分析</strong
                      >：由于堆是一个完全二叉树，所以在上浮的时候，上浮路径就是树的高度。如果堆中有
                      N 个元素的话，所以时间复杂度为 O(lgN)。
                    </p>
                    <p data-nodeid="327005">
                      <strong data-nodeid="327558">3. push 操作</strong
                      >需要两步来完成：
                    </p>
                    <p data-nodeid="327006">
                      （1）往堆的尾巴 a[n] 上添加新来的元素
                    </p>
                    <p data-nodeid="327007">
                      （2）新来元素 a[n] 进行<strong data-nodeid="327573"
                        >上浮</strong
                      >的操作
                    </p>
                    <p data-nodeid="327008">
                      至此，我们可以写出代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{
</div></li><li><div class="code-word">&nbsp; <span class="hljs-comment">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span>
</div></li><li><div class="code-word">&nbsp; a[n++] = v;
</div></li><li><div class="code-word">&nbsp; swim(n - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="327010">
                      <strong data-nodeid="327579">复杂度分析</strong
                      >：主要是上浮操作，所以时间复杂度为 O(lgN)。
                    </p>
                    <p data-nodeid="327011">
                      <strong data-nodeid="327586">4. pop 操作</strong>需要以下
                      3 步：
                    </p>
                    <p data-nodeid="327012">（1）取出 a[0] 的值作为返回值</p>
                    <p data-nodeid="327013">（2）然后将 a[n-1] 存放至 a[0]</p>
                    <p data-nodeid="327014">
                      （3）将 a[0] 进行<strong data-nodeid="327609">下沉</strong
                      >操作
                    </p>
                    <p data-nodeid="327015">
                      有了 sink()
                      函数，操作还是比较简单的，我们可以直接写出代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">int</span> ret = a[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">&nbsp; a[<span class="hljs-number">0</span>] = a[--n];
</div></li><li><div class="code-word">&nbsp; sink(<span class="hljs-number">0</span>);
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">return</span> ret;
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="327017">
                      <strong data-nodeid="327615">复杂度分析</strong
                      >：主要是下沉操作，所以时间复杂度为 O(lgN)。
                    </p>
                    <p data-nodeid="327018">
                      堆的操作都梳理完成之后，这里我们给出完整的代码。虽然是一块比较基础的代码，但是我曾经在<strong
                        data-nodeid="327621"
                        >商汤</strong
                      >的面试中就遇到过这么“裸”的面试题：“实现堆的 push 和
                      pop”。
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">    <span class="hljs-comment">// 下沉</span>
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> t = a[i];
</div></li><li><div class="code-word">        <span class="hljs-comment">// 找到i结点的左子结点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">while</span> ((j = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) &lt; n) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// j &lt; n - 1判断是否有右子结点</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 如果有，并且右子结点更大，那么</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// j指向右子结点</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; a[j] &lt; a[j + <span class="hljs-number">1</span>]) {
</div></li><li><div class="code-word">                j++;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            <span class="hljs-comment">// 如果子结点比t大</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 那么t的位置还需要往后排</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (a[j] &gt; t) {
</div></li><li><div class="code-word">                a[i] = a[j];
</div></li><li><div class="code-word">                i = j;
</div></li><li><div class="code-word">            } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 找到了t的位置</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 此时t是大于所有的子结点的</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">break</span>;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 将t放在找到的位置那里</span>
</div></li><li><div class="code-word">        a[i] = t;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 上浮</span>
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> t = a[i];
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> par = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-comment">// 如果还存在父结点</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (par = (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) != i) {
</div></li><li><div class="code-word">            <span class="hljs-comment">// 如果父结点比t值小</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (a[par] &lt; t) {
</div></li><li><div class="code-word">                a[i] = a[par];
</div></li><li><div class="code-word">                i = par;
</div></li><li><div class="code-word">            } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">                <span class="hljs-keyword">break</span>;
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        a[i] = t;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span>
</div></li><li><div class="code-word">        a[n++] = v;
</div></li><li><div class="code-word">        swim(n - <span class="hljs-number">1</span>);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> ret = a[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">        a[<span class="hljs-number">0</span>] = a[--n];
</div></li><li><div class="code-word">        sink(<span class="hljs-number">0</span>);
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> ret;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> n;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="327020">
                      讲完了堆的四种操作，我们再来看一下如何把知识运用到题目求解和实际工作中。
                    </p>
                    <h4 data-nodeid="327021">例 1：最小的 k 个数</h4>
                    <p data-nodeid="327022">
                      【<strong data-nodeid="327632">题目</strong>】给定一个数组
                      a[]，返回这个数组中最小的 k 个数。
                    </p>
                    <p data-nodeid="327023">输入：A = [3,2,1], k = 2</p>
                    <p data-nodeid="327024">输出：[2, 1]</p>
                    <p data-nodeid="327025">
                      【<strong data-nodeid="327651">分析</strong
                      >】这是一道来自<strong data-nodeid="327652">阿里</strong
                      >的题目。首先来看，如果是先排序，然后再返回前面的 k
                      个数。这样操作的复杂度是
                      O(nlgn)，但面试官可能想要得到复杂度更低的一些算法。
                    </p>
                    <p data-nodeid="327026">
                      现在问题的特点是，只需要 k
                      个最小的数就可以了。假设我们已经拿到了前面 [0 ~ i]
                      个数中最小的 k 个数。那么当第 a[i+1]
                      进来的时候，应该怎么办呢？
                    </p>
                    <p data-nodeid="327027">
                      接下来我们按照“<a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690"
                        data-nodeid="327667"
                        >第 01</a
                      ><a
                        href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690"
                        data-nodeid="327670"
                        >讲</a
                      >”介绍的“<strong data-nodeid="327676">四步分析法”</strong>
                      寻找解题突破口。
                    </p>
                    <p data-nodeid="327028">
                      <strong data-nodeid="327682">1. 模拟</strong>
                    </p>
                    <p data-nodeid="327029">可以采用“挤出去的办法”：</p>
                    <ul data-nodeid="327030">
                      <li data-nodeid="327031">
                        <p data-nodeid="327032">
                          先把 a[i+1] 加入集合中，此时集合中已经有 k+1 个数了；
                        </p>
                      </li>
                      <li data-nodeid="327033">
                        <p data-nodeid="327034">
                          再把集合 k+1 个数中的<strong data-nodeid="327694"
                            >最大的数</strong
                          >扔出去。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="327035">
                      此时，存留下来的 k 个数，就是 [0 ~ i + 1] 里面最小的 k
                      个数了，具体演示如下图所示：
                    </p>
                    <p data-nodeid="327036">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB-CCAHNSQAAiT0tDfClw811.gif"
                        alt="5.gif"
                        data-nodeid="327704"
                      />
                    </p>
                    <blockquote data-nodeid="327037">
                      <p data-nodeid="327038">
                        Step 1.当 i 指向 8 时，如果我们已经得到了最小的 k = 2
                        个数的集合。<br />
                        Step 2.i+1 指向 1 时，需要把 1 加到最小集合中。<br />
                        Step 3.扔掉最大的元素 3，得到 [0~i+1] 范围里面的最小的 k
                        个数。
                      </p>
                    </blockquote>
                    <p data-nodeid="327039">
                      <strong data-nodeid="327721">2. 规律</strong>
                    </p>
                    <p data-nodeid="327040">由上述分析可以找出以下两个规律：</p>
                    <p data-nodeid="327041">
                      （1）我们要的是一个集合，这个集合并<strong
                        data-nodeid="327728"
                        >不需要有序</strong
                      >，但需要支持 push 功能；
                    </p>
                    <p data-nodeid="327042">
                      （2）pop 的时候，总是把<strong data-nodeid="327734"
                        >最大的元素</strong
                      >扔出去。
                    </p>
                    <p data-nodeid="327043">
                      <strong data-nodeid="327740">3. 匹配</strong>
                    </p>
                    <p data-nodeid="327044">
                      基于我们发现的两个规律，可以得出，这个时候应该使用<strong
                        data-nodeid="327746"
                        >大堆</strong
                      >。因为堆满足：
                    </p>
                    <p data-nodeid="327045">
                      （1）内部并不是有序的，支持 push 功能；
                    </p>
                    <p data-nodeid="327046">
                      （2）pop 时，扔掉<strong data-nodeid="327753"
                        >堆里最大元素</strong
                      >就可以了。
                    </p>
                    <p data-nodeid="327047">
                      <strong data-nodeid="327759">4. 边界</strong>
                    </p>
                    <p data-nodeid="327048">
                      数据结构选定后，在面试时，你还需要思考一下问题的边界。给定数组和
                      k 的情况，应该有以下 7 种：
                    </p>
                    <p data-nodeid="327049">（1）数组为 null</p>
                    <p data-nodeid="327050">（2）数组中元素个数小于 k</p>
                    <p data-nodeid="327051">（3）数组中元素个数等于 k</p>
                    <p data-nodeid="327052">（4）数组中元素个数大于 k</p>
                    <p data-nodeid="327053">（5）k &lt; 0</p>
                    <p data-nodeid="327054">（6）k == 0</p>
                    <p data-nodeid="327055">（7）k &gt; 0</p>
                    <p data-nodeid="327056">
                      【<strong data-nodeid="327775">画图</strong
                      >】分析到这里。我们可以利用大堆完成一次模拟了，动图演示如下：
                    </p>
                    <p data-nodeid="327057">
                      输入：[9, 3, 2, 8, 1, 7, 5, 6, 4], k = 4
                    </p>
                    <p data-nodeid="327058">输出：[1,2,3,4]</p>
                    <p data-nodeid="327059">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB-DmADf7pACpCmKnHs-c177.gif"
                        alt="6.gif"
                        data-nodeid="327787"
                      />
                    </p>
                    <blockquote data-nodeid="327060">
                      <p data-nodeid="327061">
                        Step 1.push(9)。<br />
                        Step 2.push(3)。<br />
                        Step 3.push(2)。<br />
                        Step 4.push(8)。<br />
                        Step 5.push(1)，堆中元素个数 &gt; k，需要执行 pop。<br />
                        Step 6.pop() 结束。<br />
                        Step 7.push(7)，堆中元素个数 &gt; k，需要执行 pop。<br />
                        Step 8.pop 操作结束。<br />
                        Step 9.push(5)，堆中元素个数 &gt; k，需要执行 pop。<br />
                        Step 10.pop 操作结束。<br />
                        Step 11.push(6)，堆中元素个数 &gt; k，需要执行 pop。<br />
                        Step 12.pop 结束。<br />
                        Step 13.push(4)，堆中元素个数 &gt; k，需要执行 pop。<br />
                        Step 14.pop 结束，最终得到最小的 k 个数 [1, 2, 3, 4]。
                      </p>
                    </blockquote>
                    <p data-nodeid="327062">
                      【<strong data-nodeid="327824">代码</strong
                      >】接下来，就可以开始写代码了，也是时候亮出你真正的实力了。代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; <span class="hljs-comment">// .. 这里省略了堆的四种操作的代码: 参考前面的实现</span>
</div></li><li><div class="code-word">&nbsp; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 返回堆中元素的个数</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">return</span> n;
</div></li><li><div class="code-word">&nbsp; }
</div></li><li><div class="code-word">&nbsp; <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) {
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span> || arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 初始化堆, 注意大小要为k + 1</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];
</div></li><li><div class="code-word">&nbsp; &nbsp; n = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : arr) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 首先将元素压入堆中</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果堆中已经有k个元素</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 此时压入，会有k+1个元素，</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 所以初始化时，申请数组大小需要为k+1</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; push(x);
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果堆中元素多于k个，那么扔掉最大的元素</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (size() &gt; k) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; pop();
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 返回最小的k个数</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">while</span> (size() &gt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; ans[i++] = pop();
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">return</span> ans;
</div></li><li><div class="code-word">&nbsp; }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="327064">
                      <p data-nodeid="327065">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.java"
                          data-nodeid="327828"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.cpp"
                          data-nodeid="327832"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.py"
                          data-nodeid="327836"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327066">
                      <strong data-nodeid="327841">复杂度分析</strong
                      >：时间复杂度，每个元素都需要入堆，而堆 push
                      的时间复杂度为 O(lgk)。因为我们控制了堆的大小为
                      k，所以总的时间复杂度为 O(Nlgk)。因为我们使用了 k
                      个元素的堆，所以空间复杂度为 O(k)。
                    </p>
                    <p data-nodeid="327067">
                      【<strong data-nodeid="327847">小结</strong
                      >】在这个并不算难的题目里，我们为了深入讲解优先级队列的原理，采用了一种“最费劲”的方式（自己写堆）来操作。
                    </p>
                    <p data-nodeid="327068">
                      但实际上，<strong data-nodeid="327861"
                        >大部分语言都内置了堆的实现</strong
                      >（<strong data-nodeid="327862">优先级队列</strong
                      >）。<strong data-nodeid="327863"
                        >当你面试的时候，如果面试官没有明确提出要求你自己写堆，赶紧麻溜地用内置的优先级队列啊</strong
                      >！
                    </p>
                    <p data-nodeid="327069">
                      接下来，我们一起看看如何用语言内置的优先级队列来解决这个问题。代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public</span>&nbsp;<span class="hljs-keyword">int</span>[]&nbsp;getLeastNumbers(<span class="hljs-keyword">int</span>[]&nbsp;arr,&nbsp;<span class="hljs-keyword">int</span>&nbsp;k)&nbsp;{
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(k&nbsp;&lt;=&nbsp;<span class="hljs-number">0</span>&nbsp;||&nbsp;arr&nbsp;==&nbsp;<span class="hljs-keyword">null</span>&nbsp;||&nbsp;arr.length&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;{
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="code-word">        <span class="hljs-comment">// 注意大堆的声明</span>
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;Integer&gt;&nbsp;Q&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;PriorityQueue&lt;&gt;((v1,&nbsp;v2)&nbsp;-&gt;&nbsp;v2&nbsp;-&nbsp;v1);
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">int</span>&nbsp;x:&nbsp;arr)&nbsp;{
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.offer(x);
</div></li><li><div class="code-word">            <span class="hljs-comment">// 保持堆中元素小于等于k个</span>
</div></li><li><div class="code-word">            <span class="hljs-comment">// 保证一直拿到的是k个最小的数</span>
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(Q.size()&nbsp;&gt;&nbsp;k)&nbsp;{
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.poll();
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="code-word">        <span class="hljs-comment">// 生成返回结果</span>
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">int</span>[]&nbsp;ans&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-keyword">int</span>[k];
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">int</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">int</span>&nbsp;x:&nbsp;Q)&nbsp;{
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[i++]&nbsp;=&nbsp;x;
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;ans;
</div></li><li><div class="code-word">&nbsp;&nbsp;&nbsp;&nbsp;}
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="327071">
                      <p data-nodeid="327072">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.java"
                          data-nodeid="327868"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp"
                          data-nodeid="327872"
                          >C++</a
                        >/<a
                          href="https://github.com/JiYou/LaGouAlgo/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.py"
                          data-nodeid="327876"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327073">
                      <strong data-nodeid="327881">复杂度分析：</strong>
                      首先堆的大小为 k，那么每次 push/pop 的复杂度都是
                      O(lgk)。一共有 n 个元素，所以复杂度为 O(nlgk)。
                    </p>
                    <p data-nodeid="327074">
                      此外，这道题还有不使用优先级队列，直接可以达到 O(N)
                      复杂度的算法，你可以尝试思考一下。
                    </p>
                    <blockquote data-nodeid="327075">
                      <p data-nodeid="327076">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.java"
                          data-nodeid="327886"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.cpp"
                          data-nodeid="327890"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.py"
                          data-nodeid="327894"
                          >Python</a
                        ><br />
                        注：<strong data-nodeid="327901"
                          >如果看不懂也没有关系，我们在“第 08
                          讲”介绍快排时还会进一步讲解</strong
                        >。
                      </p>
                    </blockquote>
                    <p data-nodeid="327077">
                      关于解决这类题目的思路、重点以及分析方法，建议你先尝试自己梳理总结一下，再来看我给出的思维导图：
                    </p>
                    <p data-nodeid="327078">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-FeAA31IAADlOdvhaHc020.png"
                        alt="Drawing 11.png"
                        data-nodeid="327905"
                      />
                    </p>
                    <p data-nodeid="327079">
                      例 1
                      是一道非常经典的题目，如果你掌握了这道题的解题思想，可以举一反三解决更多的题目。这里我给出一些堆的练习题。
                    </p>
                    <p data-nodeid="327080">
                      <strong data-nodeid="327911">练习题 1</strong
                      >：给定一个数组，求这个数组的前 k
                      个高频元素。如果有两个数出现次数一样，那么优先取较小的那个数。
                    </p>
                    <p data-nodeid="327081">
                      输入：A = [1,2,1,1,3,3,2,3] k = 2
                    </p>
                    <p data-nodeid="327082">输出：[1, 3]</p>
                    <p data-nodeid="327083">
                      <strong data-nodeid="327935">解释</strong
                      >：每个数字的出现频率从高到低排序&lt;1, 3次&gt;,
                      &lt;3,3次&gt; &lt;2, 2次&gt;，取前 2 个高频数字。所以是
                      [1, 3]。
                    </p>
                    <blockquote data-nodeid="327084">
                      <p data-nodeid="327085">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.java"
                          data-nodeid="327939"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.cpp"
                          data-nodeid="327943"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.py"
                          data-nodeid="327947"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327086">
                      <strong data-nodeid="327952">练习题 2</strong
                      >：在练习题1的基础上，给定的是一个单词数组，求这个数组前 k
                      个高频单词。如果有两个单词出现频率是一样的。那么输出字典序较小的那个单词。
                    </p>
                    <p data-nodeid="327087">
                      输入：A = ["AA", "BB", "AA", "BB", "CCC", "CCC", "CCC",
                      "AA"] k = 2
                    </p>
                    <p data-nodeid="327088">输出：["AA", "CCC"]</p>
                    <p data-nodeid="327089">
                      <strong data-nodeid="328011">解释</strong>：出现次数最多的
                      2 个单词就是["AA", "CCC"]
                    </p>
                    <blockquote data-nodeid="327090">
                      <p data-nodeid="327091">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.java"
                          data-nodeid="328015"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.cpp"
                          data-nodeid="328019"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.py"
                          data-nodeid="328023"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327092">
                      <strong data-nodeid="328031">练习题 3</strong
                      >：给定一个点集数组 A[]，求离原点最近的 k 个点。
                    </p>
                    <p data-nodeid="327093">
                      输入：A = [[0,1], [1,0], [100,1], [1,100]], k = 2
                    </p>
                    <p data-nodeid="327094">输出：[[0,1], [1,0]]</p>
                    <p data-nodeid="327095">
                      <strong data-nodeid="328074">解释</strong
                      >：离原点最近的两个点就是 [[0,1], [1,0]]
                    </p>
                    <blockquote data-nodeid="327096">
                      <p data-nodeid="327097">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.java"
                          data-nodeid="328078"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.cpp"
                          data-nodeid="328082"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.py"
                          data-nodeid="328086"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327098">
                      <strong data-nodeid="328091">练习题 4</strong>：将 k
                      个有序的链表，合并成一个有序的链表。
                    </p>
                    <blockquote data-nodeid="327099">
                      <p data-nodeid="327100">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.java"
                          data-nodeid="328095"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp"
                          data-nodeid="328099"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.py"
                          data-nodeid="328103"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327101">
                      <strong data-nodeid="328108">练习题 5</strong
                      >：给定两个有序数组，两个数组中各找一个数，凑成一对，找出相加之和最小的
                      k 对。
                    </p>
                    <p data-nodeid="327102">
                      输入：A = [1, 1, 2], B = [1, 2, 3], k = 2
                    </p>
                    <p data-nodeid="327103">输出：B = [[1, 1], [1, 1]]]</p>
                    <p data-nodeid="327104">
                      <strong data-nodeid="328137">解释</strong>：A,B
                      数组中各取一个1出来凑成一对，其和 [1+1=2, 1+1=2]是最小的 2
                      对。
                    </p>
                    <blockquote data-nodeid="327105">
                      <p data-nodeid="327106">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.java"
                          data-nodeid="328141"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.cpp"
                          data-nodeid="328145"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.py"
                          data-nodeid="328149"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h3 data-nodeid="327107">优先级队列</h3>
                    <p data-nodeid="327108">
                      前面提到，优先级队列主要基于堆来实现，因此，堆具备的特性优先级队列也同样具备。比如：
                    </p>
                    <ul data-nodeid="327109">
                      <li data-nodeid="327110">
                        <p data-nodeid="327111">
                          可以 O(lgn) 的复杂度往优先级队列中<strong
                            data-nodeid="328156"
                            >添加元素；</strong
                          >
                        </p>
                      </li>
                      <li data-nodeid="327112">
                        <p data-nodeid="327113">
                          可以 O(lgn) 的复杂度从优先级队列<strong
                            data-nodeid="328162"
                            >弹出最大/最小元素</strong
                          >。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="327114">
                      经过简化，我们可以得到优先级队列的特性，如下图所示：
                    </p>
                    <p data-nodeid="327115">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-GWAals1AACz-cwh5A0701.png"
                        alt="Drawing 12.png"
                        data-nodeid="328166"
                      />
                    </p>
                    <p data-nodeid="327116">
                      不过，如果只是知道这两个特性，你还不能从容地应对面试。接下来，我们一起看一下优先级队列的深度运用。
                    </p>
                    <h4 data-nodeid="327117">例 2：跳跃游戏</h4>
                    <p data-nodeid="327118">
                      【<strong data-nodeid="328178">题目</strong
                      >】假设你正在玩跳跃游戏，从<strong data-nodeid="328179"
                        >低处往高处跳</strong
                      >的时候，可以有两种方法。
                    </p>
                    <p data-nodeid="327119">
                      方法一：塞砖块，但是你拥有砖块数是有限制的。为了简单起见，高度差就是你需要砖块数。
                    </p>
                    <p data-nodeid="327120">
                      方法二：用梯子，梯子可以无视高度差（你可以认为再高也能爬上去），但是梯子的个数是有限的(一个只能用一次)。
                    </p>
                    <p data-nodeid="327121">
                      其他无论是<strong data-nodeid="328191">平着跳</strong
                      >，还是<strong data-nodeid="328192">从高处往低处跳</strong
                      >，不需要借助什么就可以完成（在这道题中我们默认无论从多高跳下来，也摔不死）。
                    </p>
                    <p data-nodeid="327122">
                      给你一个数组，用来表示不同的高度。假设你总是站在 index = 0
                      的高度开始。那么请问，你最远能跳到哪里?
                    </p>
                    <p data-nodeid="327123">
                      输入：[3, 1, 6, 20, 10, 20], bricks = 5, landers = 1
                    </p>
                    <p data-nodeid="327124">输出：4</p>
                    <p data-nodeid="327125">
                      <strong data-nodeid="328203">解释：</strong>
                    </p>
                    <ul data-nodeid="327126">
                      <li data-nodeid="327127">
                        <p data-nodeid="327128">
                          Step 1. 从 3 跳到 1
                          时，因为是从高往低处跳，直接跳就可以了
                        </p>
                      </li>
                      <li data-nodeid="327129">
                        <p data-nodeid="327130">
                          Step 2. 从 1 到 6 时，用掉 5 个砖块
                        </p>
                      </li>
                      <li data-nodeid="327131">
                        <p data-nodeid="327132">
                          Step 3. 从 6 到 20 时，用掉梯子
                        </p>
                      </li>
                      <li data-nodeid="327133">
                        <p data-nodeid="327134">
                          Step 4. 从 20 到 10 可以直接跳
                        </p>
                      </li>
                      <li data-nodeid="327135">
                        <p data-nodeid="327136">
                          Step 5.到 10 这里就停住了，没有东西可以帮助你跳到 20
                          了，所以只能跳到下标 index = 4 这里。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="327137">
                      【<strong data-nodeid="328226">分析</strong
                      >】这是一道来自<strong data-nodeid="328227">拼多多</strong
                      >的面试题。首先我们想一想<strong data-nodeid="328228"
                        >在什么情况下使用梯子</strong
                      >？因为梯子最好用，可以无视高度直接使用。但是这里有一个限制条件，只能在<strong
                        data-nodeid="328229"
                        >大高度差</strong
                      >的时候使用梯子。如果是在小高度差的时候使用，那么最终就走不远，比如对于上面给定的例子：
                    </p>
                    <ul data-nodeid="327138">
                      <li data-nodeid="327139">
                        <p data-nodeid="327140">
                          Step 1. 从 3 跳到 1 时，直接跳就可以了；
                        </p>
                      </li>
                      <li data-nodeid="327141">
                        <p data-nodeid="327142">
                          Step 2. 从 1 到 6 时，用掉梯子；
                        </p>
                      </li>
                      <li data-nodeid="327143">
                        <p data-nodeid="327144">
                          Step 3. 从 6 到 20 时，手里的 5
                          个砖头就不够用了！所以最远只能到下标 index = 2。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="327145">
                      因此，我们选择使用<strong data-nodeid="328238"
                        >梯子的时候，一定要使用得当</strong
                      >！那么应该如何判断在什么情况下使用梯子呢？
                    </p>
                    <p data-nodeid="327146">
                      下面可以尝试换种思路，从低往高跳跃的时候，本来是要使用砖块的。但是可以想象成我随身带着一个本子，在上面<strong
                        data-nodeid="328244"
                        >记录落差(落差定义为：低往高处跳时的高度差)</strong
                      >。比如从高度 1 跳到高度 6，就在小本子上写
                      5。而高处往低处跳的时候，不需要记录，因为这不是落差（题目说了高往低处跳可以直接跳，没有必要记录）。
                    </p>
                    <p data-nodeid="327147">
                      在跳跃的时候，一定要保证小本子上的<strong
                        data-nodeid="328250"
                        >落差之和要小于等于砖块数目</strong
                      >。可是当落差大于砖块之和时怎么办呢？
                    </p>
                    <p data-nodeid="327148">
                      别忘了，我们还有梯子呢。梯子可是万能的（可以把梯子想象成一次性橡皮擦
                      ）！如果还有梯子，我们只需要从小本子上挑出最大的落差，用“一次性<strong
                        data-nodeid="328256"
                        >橡皮擦</strong
                      >”将它从小本上擦掉即可。
                    </p>
                    <p data-nodeid="327149">
                      <strong data-nodeid="328262">1. 模拟</strong>
                    </p>
                    <p data-nodeid="327150">
                      有了思路之后，我们来执行一次模拟。具体演示如下图所示：
                    </p>
                    <p data-nodeid="327151">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-IeAcgVAABQeZUJ0g7s661.gif"
                        alt="7.gif"
                        data-nodeid="328266"
                      />
                    </p>
                    <blockquote data-nodeid="327152">
                      <p data-nodeid="327153">
                        Step 1. 首先从高度 3 出发，此时小本子为空 {}。<br />
                        Step 2. 从高度 3 跳到高度
                        1（高往低跳，无压力），此时小本子仍然为空 {}。<br />
                        Step 3. 从 1 跳到高度 6，小本子记录落差 {5} &lt;= 砖头数
                        5。<br />
                        Step 4. 从 6 跳到 20, 小本子记录{5, 14}，总和 &gt;
                        砖头数 5。<br />
                        Step 5.需要从小本子{5, 14}中选出最大数
                        14，然后梯子替换掉。<br />
                        Step 6. 从 20 跳到 10，高到低跳。<br />
                        Step 7. 要从 10 跳到 20，需要把落差 10 记录到本子上 {5,
                        10} 。<br />
                        Step 8. 小本子 {5, 10} 总和 = 15，大于砖头数
                        5，又没有梯子可以用了。因此只能停在 4 这个位置。
                      </p>
                    </blockquote>
                    <p data-nodeid="327154">
                      <strong data-nodeid="328290">2. 规律</strong
                      >：在这里，我们发现小本子有两个有趣的地方：
                    </p>
                    <p data-nodeid="327155">（1）需要在小本子上记录落差；</p>
                    <p data-nodeid="327156">
                      （2）需要用梯子来替换最大的落差。
                    </p>
                    <p data-nodeid="327157">
                      在我们学过的数据结构里面，满足这个 push/pop
                      特点的，应该就是<strong data-nodeid="328298"
                        >优先级队列</strong
                      >啦。
                    </p>
                    <p data-nodeid="327158">
                      <strong data-nodeid="328305">3. 边界</strong
                      >：注意考虑给定数组为空的情况。
                    </p>
                    <p data-nodeid="327159">
                      【<strong data-nodeid="328311">代码</strong
                      >】到这里，可以开始写出代码了。具体代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> bricks, <span class="hljs-keyword">int</span> ladders)</span> </span>{
</div></li><li><div class="code-word">        <span class="hljs-comment">// 注意处理非法输入</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights.length == <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-comment">// 记录落并的小本子: 最大堆</span>
</div></li><li><div class="code-word">        Queue&lt;Integer&gt; Q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> qSum = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> lastPos = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">        <span class="hljs-keyword">int</span> preHeight = heights[<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.length; i++) {
</div></li><li><div class="code-word">            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> curHeight = heights[i];
</div></li><li><div class="code-word">            <span class="hljs-comment">// 如果是从高处往低处跳</span>
</div></li><li><div class="code-word">            <span class="hljs-keyword">if</span> (preHeight &gt;= curHeight) {
</div></li><li><div class="code-word">                lastPos = i;
</div></li><li><div class="code-word">            } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">                <span class="hljs-comment">// 如果是低处往高处跳</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> delta = curHeight - preHeight;
</div></li><li><div class="code-word">                <span class="hljs-comment">// 拿到高度的落差</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 写到小本子上</span>
</div></li><li><div class="code-word">                Q.offer(delta);
</div></li><li><div class="code-word">                qSum += delta;
</div></li><li><div class="code-word">                <span class="hljs-comment">// 如果小本子上的总和比砖块多了</span>
</div></li><li><div class="code-word">                <span class="hljs-comment">// 并且还有梯子</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">while</span> (qSum &gt; bricks &amp;&amp; ladders &gt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">                    <span class="hljs-comment">// 需要用梯子把最大的落差给抵消掉</span>
</div></li><li><div class="code-word">                    qSum -= Q.peek();
</div></li><li><div class="code-word">                    Q.poll();
</div></li><li><div class="code-word">                    ladders--;
</div></li><li><div class="code-word">                }
</div></li><li><div class="code-word">                <span class="hljs-comment">// 看看经过一番处理之后，还能不能跳到i这个位置</span>
</div></li><li><div class="code-word">                <span class="hljs-keyword">if</span> (qSum &lt;= bricks) {
</div></li><li><div class="code-word">                    lastPos = i;
</div></li><li><div class="code-word">                } <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">                    <span class="hljs-comment">// 如果经过一番处理之后，还是不能跳</span>
</div></li><li><div class="code-word">                    <span class="hljs-comment">// 看来不能跳到i了</span>
</div></li><li><div class="code-word">                    <span class="hljs-comment">// 跳出循环!</span>
</div></li><li><div class="code-word">                    <span class="hljs-keyword">break</span>;
</div></li><li><div class="code-word">                }
</div></li><li><div class="code-word">            }
</div></li><li><div class="code-word">            <span class="hljs-comment">// 更新位置的高度</span>
</div></li><li><div class="code-word">            preHeight = curHeight;
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">return</span> lastPos;
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="327161">
                      <p data-nodeid="327162">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.java"
                          data-nodeid="328315"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.cpp"
                          data-nodeid="328319"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.py"
                          data-nodeid="328323"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327163">
                      <strong data-nodeid="328328">复杂度分析</strong
                      >：在跳跃的过程中，最差的情况下，我们需要把所有的高度差记录下来。在这种情况下，每个高度差都需要执行
                      push 操作。那么时间复杂度为 O(NlgN)，空间复杂度为O(N)。
                    </p>
                    <p data-nodeid="327164">
                      【<strong data-nodeid="328334">小结</strong
                      >】首先我们仔细总结一下这道题目的特点：
                    </p>
                    <ul data-nodeid="327165">
                      <li data-nodeid="327166">
                        <p data-nodeid="327167">
                          需要将<strong data-nodeid="328340"
                            >消耗的过程，转换为存储的过程</strong
                          >（记录在小本子上），对应堆的 push；
                        </p>
                      </li>
                      <li data-nodeid="327168">
                        <p data-nodeid="327169">
                          需要优先消除一些元素，对应堆的 pop。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="327170">
                      与例 1 关于堆的题目相比，例 2
                      的求解过程不再那么直白，需要我们深入挖掘题目的特点，才能找到正确的解答方法——使用push
                      和 pop。
                    </p>
                    <p data-nodeid="327171">
                      此外，我们还能挖出一些不同的东西来——关于堆中元素需要弹出时的处理方式。在
                      Top K 问题里，当堆中元素个数超出 k 个时，就要执行 pop
                      操作。而这道题，将弹出元素的条件变成了堆中的总和不能超出砖块的数目。
                    </p>
                    <p data-nodeid="327172">
                      <strong data-nodeid="328360">练习题 6</strong
                      >：一只蚂蚁在树下吃果子，第 i 天会掉 落A[i]
                      个果子，这些果子会在接下来的 B[i] 天（即第 i+B[i]
                      天）立马坏掉不能吃。给定 A，B
                      两个数组，蚂蚁一天只能吃一个果子。吃不完了它可以存放起来。请问最多蚂蚁可以吃多少个果子。
                    </p>
                    <p data-nodeid="327173">输入：A = [3, 1], B = [3, 1]</p>
                    <p data-nodeid="327174">输出：3</p>
                    <p data-nodeid="327175">
                      <strong data-nodeid="328374">解释</strong>：我们假设下标从
                      1 开始：
                    </p>
                    <p data-nodeid="327176">第 1 天你吃 1 个第 1 天的果子</p>
                    <p data-nodeid="327177">
                      第 2 天吃 1 个第 1 天的果子，同时把第 2 天的果子存起来。
                    </p>
                    <p data-nodeid="327178">
                      第 3 天吃 1 个第 1 天的果子，第 2 天的果子只能放 1 天，第
                      2 天的果子第 3 天坏了。
                    </p>
                    <p data-nodeid="327179">第 4 天没有果子吃了。</p>
                    <blockquote data-nodeid="327180">
                      <p data-nodeid="327181">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.java"
                          data-nodeid="328382"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.cpp"
                          data-nodeid="328386"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.py"
                          data-nodeid="328390"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327182">
                      你可以自己尝试总结一下解决这类题目的思路和重点，然后再来参考我给出的思维导图：
                    </p>
                    <p data-nodeid="327183">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-LyAd-I8AACuBAvv24c185.png"
                        alt="Drawing 14.png"
                        data-nodeid="328394"
                      />
                    </p>
                    <h4 data-nodeid="327184">例 3：汽车加油次数</h4>
                    <p data-nodeid="327185">
                      【<strong data-nodeid="328417">题目</strong>】一辆汽车携带
                      startFuel 升汽油从位置 0 出发前往位置
                      target，按顺序有一系列加油站 stations。第 i 个加油站位于
                      stations[i][0]，可以加 stations[i][1]
                      升油（一个加油站只能加一次）。如果想要到达
                      target，输出最少加油次数。如果不能到达 target，那么返回
                      -1。
                    </p>
                    <p data-nodeid="327186">
                      <strong data-nodeid="328422">两个条件</strong>：
                    </p>
                    <ol data-nodeid="327187">
                      <li data-nodeid="327188">
                        <p data-nodeid="327189">假设汽车油箱总是很大；</p>
                      </li>
                      <li data-nodeid="327190">
                        <p data-nodeid="327191">
                          假设行走一单位距离，消耗一升汽油。
                        </p>
                      </li>
                    </ol>
                    <p data-nodeid="327192">
                      <strong data-nodeid="328429">示例</strong>：
                    </p>
                    <p data-nodeid="327193">
                      输入：target = 100, startFuel = 10, stations = [[10, 60],
                      [20, 30], [30, 30], [60, 40]]
                    </p>
                    <p data-nodeid="327194">输出：2</p>
                    <p data-nodeid="327195">
                      【<strong data-nodeid="328454">分析</strong>】首先带着 10
                      升汽油，可以顺利开到 pos = 10 的加油站，加上 60
                      升汽油。然后直接开车到 pos = 60 的加油站，加上 40
                      升汽油就可以顺利到达 target = 100 处。所以最少需要加 2
                      次油。
                    </p>
                    <p data-nodeid="327196">
                      在<strong data-nodeid="328466">微软和头条</strong
                      >都有同学遇到过这道题目。仔细读题之后，可以发现，需要加油的情况只有一种：汽<strong
                        data-nodeid="328467"
                        >车当前位置 + 车里剩余汽油 &lt;
                        要到达的下一个目标地点</strong
                      >。这里的下一个目标地点，有可能是
                      target，也有可能是加油站。
                    </p>
                    <p data-nodeid="327197">
                      那么问题是，当我们发现汽油不够的时候，应该如何加油呢？题目最终目的是产生尽量少的加油次数，所以每次加油加得越多越好！这就找到了一个解题方向：应该<strong
                        data-nodeid="328473"
                        >挑油量最大的加油站</strong
                      >进行加油。
                    </p>
                    <p data-nodeid="327198">
                      假设有一个巨大无比的副油箱，每次经过加油站的时候，都可以把加油站里面的油放到副油箱里面<strong
                        data-nodeid="328479"
                        >存起来</strong
                      >。缺油的时候，就从副油箱里把最大量的汽油加到车里（这里才算加一次油）。
                    </p>
                    <p data-nodeid="327199">
                      <strong data-nodeid="328485">1. 模拟</strong>
                    </p>
                    <p data-nodeid="327200">
                      接下来我们就利用这个副油箱进行一下模拟，具体演示如下图所示（注意：副油箱里面的汽油不能算在已经加到车的汽油里，你可以认为它还放在后面座位上呢）：
                    </p>
                    <p data-nodeid="327201">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-NWATbp5ABcZWJEFfns318.gif"
                        alt="8.gif"
                        data-nodeid="328489"
                      />
                    </p>
                    <blockquote data-nodeid="327202">
                      <p data-nodeid="327203">
                        Step 1. 从 0 位置出发，下一站位于 pos =
                        10，当前汽油可以达到。<br />
                        Step 2. 开到了pos = 10，将 60
                        升汽油放到副油箱，此时余下汽油量为 0。<br />
                        Step 3. 汽油里面的汽油不足开到 pos = 20
                        加油站，从副油箱中取出最多汽油 60 加上。<strong
                          data-nodeid="328509"
                          >第 1 次</strong
                        >加油之后，余下油量变成 60。<br />
                        Step 4. 开到 pos = 20 处，余下汽油 50, 并且将加油站的 30
                        升汽油放到副油箱。<br />
                        Step 5. 开到 pos = 30 处，余下 40 升汽油，并且将加油站的
                        30 升汽油放到副油箱。<br />
                        Step 6. 开到加油站 60 处，余下 10 升汽油，并且将加油站的
                        40 升汽油放到副油箱。<br />
                        Step 7. 发现无法开到位置 100 处，那么将最多的汽油 40
                        升加到汽车里，此时余下汽油 50。<br />
                        最后，成功开到了终点。
                      </p>
                    </blockquote>
                    <p data-nodeid="327204">
                      <strong data-nodeid="328515">2. 规律</strong>
                    </p>
                    <p data-nodeid="327205">
                      通过观察副油箱的操作，我们发现它的行为具有两个特点：
                    </p>
                    <p data-nodeid="327206">
                      （1）每次经过加油站会把汽油<strong data-nodeid="328522"
                        >加到</strong
                      >副油箱
                    </p>
                    <p data-nodeid="327207">
                      （2）缺油的时候，总是把<strong data-nodeid="328528"
                        >最大升</strong
                      >的汽油拿出来加上
                    </p>
                    <p data-nodeid="327208">
                      这两个行为让我们联想到本讲学过的 push/pop 操作。并且每次
                      pop
                      的时候，都要弹出最大的元素，这又让我们想起了今天学过的堆（不过这里不再写堆的四种操作了），就用优先级队列吧。因为总是<strong
                        data-nodeid="328534"
                        >最大升的汽油优先</strong
                      >。
                    </p>
                    <p data-nodeid="327209">
                      <strong data-nodeid="328540">3. 边界</strong>
                    </p>
                    <p data-nodeid="327210">
                      在正式写代码前，你还是要考虑到以下 3 种情况：
                    </p>
                    <p data-nodeid="327211">（1）加油站的位置都小于 target</p>
                    <p data-nodeid="327212">（2）某些加油站的位置等于 target</p>
                    <p data-nodeid="327213">（3）有些加油站的位置大于 target</p>
                    <p data-nodeid="327214">
                      在处理的时候，<strong data-nodeid="328550"
                        >可以将 target
                        也当成一个站。只不过这个站，并不提供汽油</strong
                      >。这样处理起来更容易一些。
                    </p>
                    <p data-nodeid="327215">
                      【<strong data-nodeid="328556">代码</strong
                      >】通过了前面的分析，此时我们应该撸起袖子开始写代码了，代码如下（解析在注释里）：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
</div></li><li><div class="code-word">&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minRefuelStops</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> startFuel, <span class="hljs-keyword">int</span>[][] stations)</span> </span>{
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = stations.length;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 当前汽车的状态{位置, 还余下多少汽油}</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">int</span> curPos = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">int</span> fuelLeft = startFuel;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 副油箱</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; Queue&lt;Integer&gt; Q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 从副油箱里面往汽车加油的次数</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">int</span> addFuelTimes = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">while</span> (curPos + fuelLeft &lt; target) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 默认期望的下一站，站点设置为target</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 此时能加的汽油为0</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> pos = target;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> fuel = <span class="hljs-number">0</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果有位于target之前的站点, 那么更新</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 加油站的位置，以及能加到副油箱的油量</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (i &lt; N &amp;&amp; stations[i][<span class="hljs-number">0</span>] &lt;= target) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; pos = stations[i][<span class="hljs-number">0</span>];
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; fuel = stations[i][<span class="hljs-number">1</span>];
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果当前汽车的状态，不能到达期望的下一站</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (curPos + fuelLeft &lt; pos) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 拿出副油箱啊</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 惨了，副油箱没有油了，</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (Q.isEmpty()) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 从副油箱里面拿出最大的汽油加上去</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> curMaxFuel = Q.peek();
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; Q.poll();
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; fuelLeft += curMaxFuel;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 加油次数++</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; addFuelTimes++;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 好了，现在可以到达期望的下一站了</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 不过需要把消耗的汽油扣掉</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fuelCost = pos - curPos;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 更新当前汽车的状态</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; fuelLeft -= fuelCost;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; curPos = pos;
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 这个汽油站里面的汽油加到副油箱</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (fuel &gt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; Q.offer(fuel);
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 这个站就过去了</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; i++;
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-comment">// 能到达target吗？如果能，返回加油次数，不能返回-1</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; <span class="hljs-keyword">return</span> curPos + fuelLeft &gt;= target ? addFuelTimes : -<span class="hljs-number">1</span>;
</div></li><li><div class="code-word">&nbsp; }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <blockquote data-nodeid="327217">
                      <p data-nodeid="327218">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.java"
                          data-nodeid="328560"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.cpp"
                          data-nodeid="328564"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.py"
                          data-nodeid="328568"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327219">
                      <strong data-nodeid="328573">复杂度分析</strong
                      >：最差情况下，需要把所有的油都收集起来，此时所有的油都需要有
                      push 操作，所以时间复杂度为O(NlgN)，而空间复杂度为O(N)。
                    </p>
                    <p data-nodeid="327220">
                      【<strong data-nodeid="328583">小结</strong
                      >】首先，当你发现这道题属于“<strong data-nodeid="328584"
                        >消耗物品</strong
                      >”类题目，并且优先消耗较大的油箱时，脑海中应该联想前面我们讲过的关于堆的总结：
                    </p>
                    <ul data-nodeid="327221">
                      <li data-nodeid="327222">
                        <p data-nodeid="327223">
                          将消耗的过程转换为存储的过程，对应堆的 push 操作；
                        </p>
                      </li>
                      <li data-nodeid="327224">
                        <p data-nodeid="327225">
                          将优先选择大油桶的过程看成堆的 pop 操作。
                        </p>
                      </li>
                    </ul>
                    <p data-nodeid="327226">
                      经过一番分析，我们挖出了这道题背后的考点，以及优先级队列可能存在变化地方：
                    </p>
                    <ul data-nodeid="327227">
                      <li data-nodeid="327228">
                        <p data-nodeid="327229">什么时候执行 push 操作？</p>
                      </li>
                      <li data-nodeid="327230">
                        <p data-nodeid="327231">什么时候执行 pop 操作？</p>
                      </li>
                    </ul>
                    <p data-nodeid="327232">
                      <strong data-nodeid="328600">练习题 7</strong
                      >：在一个网络中有 N 台计算机，编号从
                      1~N，现在给定一些<strong data-nodeid="328601">有向</strong
                      >边，表示计算机之间网络传输使用的时间（ms），请问，从节点编号为k的计算机发出一个信号，需要多久才能让所有的计算机接收到信号。如果不能让所有人接收到信号，请输出
                      -1。
                    </p>
                    <p data-nodeid="327233">
                      输入：N = 2, times = [1, 2, 100], k = 1
                    </p>
                    <p data-nodeid="327234">输出：100</p>
                    <p data-nodeid="327235">
                      <strong data-nodeid="328612">解释</strong>：只有两个计算机
                      1，和计算机 2。从计算机 1 发送信息到计算机 2 需要
                      100ms。所以输出 100。
                    </p>
                    <blockquote data-nodeid="327236">
                      <p data-nodeid="327237">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java"
                          data-nodeid="328616"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp"
                          data-nodeid="328620"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py"
                          data-nodeid="328624"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <h3 data-nodeid="327238">总结与延伸</h3>
                    <p data-nodeid="327239">
                      至此，我们已经学习了堆的特性与实现。在了解了 push/pop
                      元素的复杂度为 logn
                      后，我们还需要知道考点可能出现在以下两个地方：
                    </p>
                    <ol data-nodeid="327240">
                      <li data-nodeid="327241">
                        <p data-nodeid="327242">什么时候 push 元素</p>
                      </li>
                      <li data-nodeid="327243">
                        <p data-nodeid="327244">什么时候 pop 元素</p>
                      </li>
                    </ol>
                    <p data-nodeid="327245">
                      这里我做了一个简单的归纳，并且列举了例题中的条件，你能在实战中补充一些其他有趣的条件吗？
                    </p>
                    <p data-nodeid="327246">
                      <img
                        src="https://s0.lgstatic.com/i/image6/M00/13/4A/Cgp9HWBB-QCAcvk-AADd5wNIZG0008.png"
                        alt="Drawing 16.png"
                        data-nodeid="328632"
                      />
                    </p>
                    <p data-nodeid="327247">
                      优先级队列非常有趣，也非常有用，在后面的<strong
                        data-nodeid="328638"
                        >广度优先搜索中，还会重拾这个知识，</strong
                      >
                      帮助你解决更多的疑难问题。
                    </p>
                    <h3 data-nodeid="327248">思考题</h3>
                    <p data-nodeid="327249">
                      最后我再给你留一道<strong data-nodeid="328645"
                        >思考题</strong
                      >：
                    </p>
                    <p data-nodeid="327250">
                      来自
                      <strong data-nodeid="328651">Google</strong>
                      的面试题。一个机器每隔一秒钟就会输出一个整数，请你写一个查询接口，输出所有已经得到的整数的中位数。中位数就是排序之后位于中间的数。如果数目为偶数，则是中间两个数的平均值。
                    </p>
                    <blockquote data-nodeid="327251">
                      <p data-nodeid="327252">
                        代码：<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.java"
                          data-nodeid="328655"
                          >Java</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp"
                          data-nodeid="328659"
                          >C++</a
                        >/<a
                          href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.py"
                          data-nodeid="328663"
                          >Python</a
                        >
                      </p>
                    </blockquote>
                    <p data-nodeid="327253">
                      你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。后会有期，优先级队列！
                    </p>
                    <p data-nodeid="327254" class="">
                      下一讲将介绍 04 |
                      链表：如何利用“假头，新链表，双指针”解决链表题？（上）记得按时来探险。
                    </p>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >数据结构与算法面试宝典</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <!---->
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *中
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        7
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      有一说一，感觉好难
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **成
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      >
                        3
                      </div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      写的很好理解，就是这一期的动态图实在太快了
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >编辑回复：</span
                    >
                    您建议我们收到了，后面的内容已会降低动图速度哈
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **奇
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      练习题 6：一只蚂蚁在树下吃果子，第 i 天会掉 落A[i]
                      个果子，这些果子会在接下来的 B[i] 天（即第 i+B[i]
                      天）立马坏掉不能吃。给定 A，B
                      两个数组，蚂蚁一天只能吃一个果子。吃不完了它可以存放起来。请问最多蚂蚁可以吃多少个果子。如何证明解法得到的就是最大值呢？？
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **5700
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      感觉梯子的例子使用的数字不太好，让人误以为有砖头时优先使用砖头就好了，如果使用3，11，2,5,7,9
                      八个砖块，一个梯子这种例子在砖块不够时消除前面最大的需要8个砖块，这样是不是更好😁
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    赞！这个例子不错!
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **成
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      很实用，需要多想，多打
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **用户7186
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      梯子例题替换最大需要砖块数这里 ，while (qSum ，while循环
                      可以换成 if 判断嘛？感觉这里每次都只会执行一次呀。
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    可以。用while更保险，习惯了。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **林
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      这节课有点意思。
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **军
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      给定一个数组，求这个数组的前 k
                      个高频元素。如果有两个数出现次数一样，那么优先取较小的那个数.
                      这道题对应的代码只有“给定一个数组，求这个数组的前 k
                      个高频元素”逻辑,
                      没有“如果有两个数出现次数一样，那么优先取较小的那个数”这个的逻辑呢?
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    leetcode原题中是有一个约束的：
                    题目数据保证答案唯一，换句话说，数组中前 k
                    个高频元素的集合是唯一的。
                    不过你提的这个点很有意思。在面试的时候，如果面试官没有主动说出这个约束，那么需要向面试官问清楚，如果出现这种情况怎么办？
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **正
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      老师 你好，练习题 4：将 k
                      个有序的链表，合并成一个有序的链表。
                      你的github的答案里面的 y.val 怎么理解比较好
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    我看了一下代码。我觉得你说的应该是c++的代码，如果我说错了，更正一下。c++
                    priority_queue的，在自定义排序的时候。 会利用x-&gt;val
                    与y-&gt;val进行比较。当写成x-&gt;val &gt;
                    y-&gt;val的时候，会优先将y元素出队。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *海
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      例题2有些疑问点：1. while (qSum 0)
                      {}这个条件判断，如果前面的都是低阶的楼梯，但是叠加起来比bricks大，那么其实此时的台阶还不是最大的却用了梯子；2.
                      这里是不是少了个用bricks抵消delta的代码if (qSum = bricks)
                      {}
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    1. while qSum &gt;
                    bricks这个循环是说，当走到这里的时候，发现不能往前走了。因为砖头不够用了。于是用梯子去填最大的那个落差。注意，梯子填的是以前的某个位置出现的最大的落差，而不是当前。
                    2. 不要设置qSum ==
                    bricks。梯子是万能的，我们在能用砖头的时候，要尽量用砖头
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **福
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      练习一应该改为这样才合理吧。实际测试用例[1,1,1, 2,2, 3,3]
                      - [1,2]而用github代码是 [1,3]auto cmp = ["&gt;const
                      pair"&gt;int,int"&gt;,const pair"&gt;int,int B) {
                      if(A.second != B.second) { return B.second "&gt;second; }
                      return A.first "&gt;first;};
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    leetcode原题中是有一个约束的：
                    题目数据保证答案唯一，换句话说，数组中前 k
                    个高频元素的集合是唯一的。
                    不过你提的这个点很有意思。在面试的时候，如果面试官没有主动说出这个约束，那么需要向面试官问清楚，如果出现这种情况怎么办？
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        pmk
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      老师您好，关于汽车加油次数的题，你的解法我看好像并不是按最少加油次数来算的？如果要解原题应该怎么做？
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    while (true) {printf("解法是原题，100%包过");}
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        pmk
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      老师您好，下层操作里面a[n-1] 存放至
                      a[0]是什么意思？不应该直接对a[0]直接下沉吗
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    注意pop操作的顺序： pop 操作需要以下 3 步： （1）取出 a[0]
                    的值作为返回值 （2）然后将 a[n-1] 存放至 a[0] （3）将 a[0]
                    进行下沉操作
                    如果是一个最大堆，那么原来的A[0](晁盖)就是堆中的最大元素，但是此时，最大元素是要被pop出去的(晁盖跪了)。pop出去之后，谁来当老大就是一个问题了。那么操作的时候呢，就是先把A[n-1]扔上来当老大(对的，就是卢俊义要上来当老大，此时已经在A[0]的位置上了)。A[0](卢俊义)一看，唉哟，下面的人个个都是李逵(人才），这个老大不好当。于是往下怂～
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **方
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      算法学习---技术宅男 “加油站”
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **0747
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      我能想到的方法1 维护一个大顶堆，一个小顶堆。2 树状数组。
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    赞，思路正确。我给出的答案就是方法1
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        *飞
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      练习题7为什么要用堆而不用队列呢，用堆似乎只是保证了计算延迟的时候，计算机编号从小到大
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    练习题7，我重新看了，应该是使用”最小时延“结点优先出队，所以这里应该是命名用优先队列。并且在顺序的比较时，应该按照时延出队。不是按照编号来出队。
                    ”按照编号来出队“当然也不会有什么大问题，只是没有达到最优的效果。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **辉
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      下沉实例代码中的n是什么？好像没有定义直接用了
                    </div>
                    <!---->
                  </div>
                  <div data-v-4bc80e00="" class="message-list-replay">
                    <div data-v-4bc80e00="" class="borleft"></div>
                    <span data-v-4bc80e00="" class="message-list-replay-name"
                      >讲师回复：</span
                    >
                    n在前文中定了。 " 假设我们已经申请了数组 a[] 和元素 n
                    表示当前堆中元素的个数，代码如下： int[] a = new int[100];
                    // 表示堆的数组空间, 100作示例大小 int n = 0; //
                    堆中元素个数 " 另外，后面也给出了堆的完整的代码。
                  </div>
                  <!---->
                  <!---->
                </div>
                <div data-v-4bc80e00="" class="message-list">
                  <div data-v-4bc80e00="" class="message-list-title">
                    <div data-v-4bc80e00="" class="message-list-title-left">
                      <!---->
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-left-name"
                      >
                        **亚
                      </div>
                    </div>
                    <div data-v-4bc80e00="" class="message-list-title-right">
                      <!---->
                      <img
                        data-v-4bc80e00=""
                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4BAMAAABaqCYtAAAAKlBMVEVHcExnZ2dzc3NmZmZqampmZmZmZmZnZ2dnZ2dnZ2dmZmZoaGhmZmZmZmZl+8SAAAAADXRSTlMA/AbsFtilbj5YwSqJPyESoQAAAZxJREFUOMt1lTtLA1EQha8xRhPTBEmhuKCCoNgoIlYLMcRKBG0sxIUgCDaBSDohEO0FEbQyIBZaBazERvAPWCwxPnP+i3tnrlGTmVPswn73NXNm7hrzq9m9kZ2ckTUUABifkOEBrK7liR7BMRFOA/uFc+BUgnV8mFisEW5IsIFi9FzBuwR91KJnAm8S9EIbxSBeBRZHk86MrBQJWjymJUC3nlugSyk+SQyhANfxos+s4krfM0DZvmbw2cuSCHNGi3PAfUygXYiU79ryyw1ibf0xZ9intBsz6SBadx24iiZXz8kPxCiTtYdLPzKTVFkkLQAZO/VikwYW/x/wHohcT/MiPQE8W9frxJrlbpiw4xvA0vbNmWyhj2Nrhmy+B7nEyTsN0rIaJAc0SDWqwX7rhAYfMa/Dui0bDZbwZAwUGNjWUWActnUUyN2hwDTaOkxRaSiwj6pRhjHKgTazSkWlwBK1jgIpBwrkHCgwyZ0oQ86BAjkHCjziG0KE8YBvCA/5KacOm6sgrHFAotouT6J23bkkLbsNDjM9yt7yP+IbQYga5De+eBMAAAAASUVORK5CYII="
                        alt="right-icon"
                        class="message-list-title-right-icon"
                      />
                      <div
                        data-v-4bc80e00=""
                        class="message-list-title-right-praise"
                      ></div>
                    </div>
                  </div>
                  <div data-v-4bc80e00="" class="message-list-container">
                    <div data-v-4bc80e00="" class="message-list-content">
                      德哥，可以把对应的题号给写上吗
                    </div>
                    <!---->
                  </div>
                  <!---->
                  <!---->
                  <!---->
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 685,
      courseCId: "",
      courseName: "数据结构与算法面试宝典",
      teachers: [
        {
          id: 630,
          teacherName: "德鲁伊",
          position: "前微软资深软件工程师",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><span class="ql-author-13568064 ql-font-microsoftyahei" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto; background-color: rgb(255, 255, 255);">9&nbsp;年技术研发经验，主导过&nbsp;40PB&nbsp;级别的分布式存储系统架构设计与实现。带领团队实现核心模块，如用户态文件系统、存储引擎、分布式&nbsp;KV&nbsp;缓存。负责部门技术面试，有丰富的技术面试经验。此外，曾</span><span class="ql-font-microsoftyahei ql-author-13568064" style="margin: 0px; padding: 0px; outline: none; box-sizing: border-box; caret-color: rgb(73, 73, 73); color: rgb(73, 73, 73); font-size: 14.6667px; text-size-adjust: auto;">作为复旦大学特聘讲师，面向研究生学院开展 IT 类课程，拥有多年授课经验。擅长架构设计、机器学习、云计算、大数据等领域。</span></span></p>',
        },
      ],
      totalCourseTime: 23,
      totalDuration: 340,
      sales: 18623,
      price: "98",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/0E/B5/CioPOWA8uS6AMKX5AAAUwKendGs238.png",
      sellGoodsId: 748,
      sellGoodsPriceId: 73322,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "数据结构与算法是程序员面试的必考要点，为了攻克算法面试拿下心仪 offer，很多程序员面试前都会在 LeetCode 上刷题备战面试。然而面对海量题目，你很难在短时间内刷完并熟练掌握。那我们该如何高效准备，快速应对即将到来的算法面试？专栏以解题为核心， 300+ 道大厂高频面试题为切入点，引出很多你在面试中常踩的坑和卡壳的知识点，给你一套通用的解题方法论。",
      seoKeywords:
        "数据结构,算法,面试,互联网大厂,微软,C++,Java,Python,阿里,腾讯,头条,百度, Google,Facebook,Apple,一解多题,一题多解,面试实战,栈,队列,优先级队列,链表,树,并查集,排序,二分搜索,双指针,贪心,回溯,搜索,DP,金三银四,招聘季",
      seoTitle: "数据结构与算法面试宝典- 前微软资深软件工程师 - 拉勾教育",
      shareTitle: "这15种题型，算法面试肯定会问！",
      shareDescription: "300+高频真题详解，一题多解攻克算法面试",
      brief: "300+大厂高频真题，一题多解攻克算法面试",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M01/0E/27/CioPOWA8SL-Aflz3AAFSxYqXH4o426.png",
      courseType: 1,
      previewFirstField: "共23讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 638,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 638,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "83ec46930d5245bcae30be7a5f7786a2"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
</body>
