<body
  style="
    font-size: 15px;
    height: 100%;
    width: 100%;
    background-color: rgb(237, 237, 237);
  "
>
  <h1 style="display: none">Vue.js 3.0 核心源码内参 - 拉勾教育</h1>

  <meta
    content="关键词：前端开发,Vue,源码分析,架构师,JavaScript,Composition API,Java, Vue.js,React , MVVM 框架,JavaScript, cube-ui 开发,uni-app,Mpx,chameleon,WePY,组件渲染,DOM diff, 组件渲染,vnode ,侦听器,共享数据,AST,Props,Virtual DOM,Snabbdon,patch,Diff 算法,Dep,底层原理,VueapI,Vue-cli,原生内置功能,Tree-shaking,代码逻辑,模板无关性,"
    name="keywords"
  />

  <meta
    content="Vue.js 作为前端最火的三大主流框架之一，越来越多的公司将其作为项目开发的技术栈，抑或将原有项目迁移过来。对于从业者和求职者来说，学会阅读Vue.sj 源码有助于从底层逻辑学习框架原理，这很大程度上帮助前端开发者提高工作效率。"
    name="description"
  />

  <title>Vue.js 3.0 核心源码解析 - 前百度、滴滴资深技术专家 - 拉勾教育</title>
  <meta
    name="apple-mobile-web-app-title"
    content="Vue.js 3.0 核心源码解析 - 前百度、滴滴资深技术专家 - 拉勾教育"
  />

  <script>
    // 全局token变量，防CSRF，防重复提交
    window.X_Anti_Forge_Code = ""
    window.X_Anti_Forge_Token = ""
    var mds = {
      userInfo: {
        shortName: "",
      },
    }
    window.mds = mds
  </script>
  <script
    type="text/javascript"
    src="//g.alicdn.com/AWSC/AWSC/awsc.js"
  ></script>
  <script src="//s20.lgstatic.com/components/edu-fe/edu-pay-component/1.0.12/main.js"></script>
  <script>
    window.userInfo = {
      userId: "20015885",
    }
    //风控系统
    ;(function () {
      console.log(window)
      window._smReadyFuncs = []
      window.SMSdk = {
        ready: function (fn) {
          fn && _smReadyFuncs.push(fn)
        },
      }
      // 1. 通用配置项
      window._smConf = {
        organization: "uTuOLHj2zLGJgglbtLOC", //必填，组织标识，邮件中organization项
        staticHost: "static.fengkongcloud.com", //必填, 设置JS-SDK文件域名

        //2.连接海外机房特殊配置项，仅供设备数据上报海外机房客户使用
        //
        // 2.1 业务机房在国内
        //     1) 用户分布：国内（默认设置）
        // apiHost:'fp-it.fengkongcloud.com'
        //      2) 用户分布：全球
        //  apiHost:'fp-it-acc.fengkongcloud.com'
        //
        // 2.2 业务机房在欧美
        //    1) 用户分布：欧美
        // apiHost: 'fp-na-it.fengkongcloud.com'
        //    2) 用户分布：全球
        // apiHost: 'fp-na-it-acc.fengkongcloud.com'
        //
        //2.3 业务机房在东南亚
        //   1) 用户分布：东南亚
        // apiHost:'fp-sa-it.fengkongcloud.com'
        //   2) 用户分布：全球
        // apiHost:'fp-sa-it-acc.fengkongcloud.com'

        // 2.4 私有化特殊配置
        // staticHost: 'xxxxxx';  // 私有化部署的JS-SDK文件域名
        // apiHost: 'xxxxxx';  // 私有化部署的服务域名
      }

      var url = (function () {
        var originHost = "static2.fengkongcloud.com"
        var isHttps = document.location.protocol === "https:"
        var protocol = isHttps ? "https://" : "http://"
        var fpJsPath = "/fpv2.js"
        var url = protocol + _smConf.staticHost + fpJsPath
        var ua = navigator.userAgent.toLowerCase()
        var isWinXP = /windows\s(?:nt\s5.1)|(?:xp)/.test(ua)
        var isLowIE = /msie\s[678]\.0/.test(ua)

        if (isHttps && isWinXP && isLowIE) {
          url = protocol + originHost + fpJsPath
        }

        return url
      })()
      var sm = document.createElement("script")
      var s = document.getElementsByTagName("script")[0]
      sm.src = url
      s.parentNode.insertBefore(sm, s)
    })()
    //阿里云风控系统
    var uabModule
    var webUmidToken
    //人机识别模块，只需初始化一次
    AWSC.use("uab", function (state, uab) {
      if (state === "loaded") {
        uabModule = uab
      }
    })
    //设备指纹模块，得到设备token，只需初始化一次
    AWSC.use("um", function (state, um) {
      if (state === "loaded") {
        um.init(
          {
            //appName请直接使用'saf-aliyun-com'
            appName: "saf-aliyun-com",
          },
          function (initState, result) {
            if (initState === "success") {
              webUmidToken = result.tn
            }
          }
        )
      }
    })
    /////
    function dealSmDeviceId(cb) {
      var smTimeoutTime = 200
      var smDeviceId = ""
      var smDeviceIdReady = false
      var smTimer = setTimeout(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      }, smTimeoutTime)

      SMSdk.ready(function () {
        smDeviceId = SMSdk.getDeviceId ? SMSdk.getDeviceId() : smDeviceId
        clearTimeout(smTimer)

        if (!smDeviceIdReady && smDeviceId) {
          smDeviceIdReady = true
          //执行业务逻辑
          cb && cb(smDeviceId)
        }
      })
    }
    function getCookie(name) {
      var arr,
        reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)")
      if ((arr = document.cookie.match(reg))) {
        return unescape(arr[2])
      } else {
        return null
      }
    }
    function getHost() {
      let host = window.location.host.split(".")
      if (host[1] && host[1] == "lagou") {
        return true
      }
      return false
    }
    const getdeviceld = function (deviceId) {
      if (deviceId) {
        let data = []
        data.push({ channel: 1, thirdDeviceId: deviceId })
        data.push({
          channel: 2,
          thirdDeviceId: uabModule && uabModule.getUA() + "," + webUmidToken,
        })
        var expats = new Date()
        expats.setTime(expats.getTime() + 7 * 24 * 60 * 60 * 1000)
        if (getHost()) {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;domain=.lagou.com;"
        } else {
          document.cookie =
            "thirdDeviceIdInfo=" +
            escape(JSON.stringify(data)) +
            ";expires=" +
            expats.toGMTString() +
            ";path=/;"
        }
      } else {
        dealSmDeviceId(getdeviceld)
      }
    }
    if (!getCookie("thirdDeviceIdInfo")) {
      dealSmDeviceId(getdeviceld)
    }
    // Note: onepass h5无感本机认证
    // https://docs.geetest.com/onelogin/deploy/h5
    ;(function () {
      const isPc = !/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(
        window.navigator.userAgent
      )
      if (isPc) return
      // 网络判断方法
      function getNetworkType() {
        var common_cell = ["cellular", "2g", "3g", "4g", "5g", "3G/2G"]
        var user_agent = navigator.userAgent.toLowerCase()
        var connection = navigator.connection ||
          navigator.mozConnection ||
          navigator.webkitConnection || { type: "unknown" }
        var type
        // 判断是否是微信内置浏览器
        var isWeixin = /micromessenger/.test(user_agent)
        if (isWeixin) {
          if (user_agent.indexOf("nettype") !== -1) {
            type = user_agent.match(/nettype\/\w+/)
              ? user_agent.match(/nettype\/\w+/)[0]
              : "nettype/unknow"
            type = type.replace("nettype/", "")
          } else {
            var weixinType = {
              "network_type:wifi": "wifi",
              "network_type:edge": "3G/2G",
              "network_type:fail": "fail",
              "network_type:wwan": "3G/2G",
            }
            document.addEventListener(
              "WeixinJSBridgeReady",
              function onBridgeReady() {
                WeixinJSBridge.invoke("getNetworkType", {}, function (e) {
                  type = weixinType[e.err_msg]
                })
              }
            )
          }
        } else {
          type = (connection && connection.type) || "unknown"
        }
        // 对type 做统一处理
        if (type && common_cell.indexOf(type) !== -1) {
          return "cellular"
        } else if (type === "wifi") {
          return "wifi"
        }
        return "unknown"
      }
      var metaEle = document.createElement("meta")
      metaEle.content = "always"
      metaEle.name = "referrer"
      document.head.appendChild(metaEle)
      var scriptEle = document.createElement("script")
      scriptEle.src =
        "https://s21.lgstatic.com/components/onepassh5/2.3.0/onepassh5.min.js"
      document.head.appendChild(scriptEle)
      scriptEle.onload = function () {
        console.log(GOP, "GOP 加载成功")
        if (typeof GOP !== "function") return
        var nettype = getNetworkType()
        // Note: onepass api h5场景只支持数据网络的场景
        var ispre = nettype === "wifi" ? false : true
        window.OP_INSTANCE = new GOP({
          app_id: "000760cd4c8bb48a3860e5070ded2717", // 在极验后台获取，生成app_id后等待极验审核成功后生效
          timeout: 30000, // 超时时长，默认30000
          pre_init: ispre, // 是否初始化时获取运营商参数，默认为true。 建议开启避免影响认证的响应时间
        })
      }
    })()
  </script>
  <link
    href="https://s0.lgstatic.com/kw-web-fed/common.9f883843.css"
    rel="stylesheet"
  /><link
    href="https://s0.lgstatic.com/kw-web-fed/course/main.793fddbd.css"
    rel="stylesheet"
  />

  <div id="app" class="">
    <div data-v-daa3f53a="" data-v-6cc00bca="" class="pc-detail-wrap">
      <div data-v-5d185b94="" data-v-daa3f53a="" class="wrap pc-header">
        <div data-v-5d185b94="" class="wrap-content">
          <div data-v-5d185b94="" class="wrap-left">
            <a data-v-5d185b94="" href="https://edu.lagou.com"
              ><img
                data-v-5d185b94=""
                src="https://s21.lgstatic.com/growth/activity/20210729/1627528017710.png?x-oss-process=style/80"
                alt=""
                class="logo"
            /></a>
            <h1 data-v-5d185b94="" class="title">拉勾教育</h1>
            <h1 data-v-5d185b94="" class="desc">互联网职业教育平台</h1>
          </div>
          <div data-v-5d185b94="" class="wrap-right">
            <div data-v-5d185b94="" class="tab-list">
              <h2 data-v-5d185b94="" class="tab-item">选课</h2>
              <h2 data-v-5d185b94="" class="tab-item">学习</h2>
              <h2 data-v-5d185b94="" class="tab-item">企业培训</h2>
            </div>
            <div data-v-5d185b94="" class="login-wrap">
              <div data-v-5d185b94="" class="wrap-login">
                <span data-v-5d185b94="" class="username triangle">
                  张熙远
                  <div data-v-5d185b94="" class="tool-tip tool-tip-user">
                    <a
                      data-v-5d185b94=""
                      href="https://tb.53kf.com/code/client/90d3e270b5d355aa44bafe74fd7fe8a11/3"
                      target="_blank"
                      class="tool-tip-item"
                    >
                      帮助与反馈 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/certificate/index"
                      target="_certificate"
                      class="tool-tip-item"
                    >
                      学业证书 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/setting"
                      target="_self"
                      class="tool-tip-item"
                    >
                      账号设置 </a
                    ><a
                      data-v-5d185b94=""
                      href="https://kaiwu.lagou.com/frontLogout.do"
                      target="_self"
                      class="tool-tip-item"
                    >
                      退出登录
                    </a>
                  </div></span
                >
                <img
                  data-v-5d185b94=""
                  src="https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png"
                  alt=""
                  class="avatar"
                />
              </div>
            </div>
          </div>
        </div>
        <!---->
      </div>
      <div data-v-daa3f53a="" class="container">
        <div data-v-130a0286="" data-v-daa3f53a="" class="pub-header">
          <div data-v-130a0286="" class="pub-header-container-wrap">
            <div data-v-130a0286="" class="item-wrap inline-block catalog">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                收起目录
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block pre">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                上一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block next">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                下一讲
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block detail">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                课程详情
              </div>
            </div>
            <div data-v-130a0286="" class="splice-line inline-block"></div>
            <div data-v-130a0286="" class="item-wrap inline-block all">
              <div data-v-130a0286="" class="img-wrap inline-block"></div>
              <div data-v-130a0286="" class="text-wrap inline-block">
                全部课程
              </div>
            </div>
          </div>
        </div>
        <div data-v-daa3f53a="" class="content-wrap">
          <div data-v-daa3f53a="" class="left-content-wrap">
            <div
              data-v-5f686215=""
              data-v-daa3f53a=""
              class="menu-top-tips inline-block"
            >
              <img
                data-v-5f686215=""
                src="https://s0.lgstatic.com/i/image6/M00/41/5A/Cgp9HWCrqJeAfHpMAAEhcFmUStA456.png"
                class="image-wrap"
              />
              <div data-v-5f686215="" class="menu-top-tips-wrap inline-block">
                <div data-v-5f686215="" class="title">
                  Vue.js 3.0 核心源码内参
                </div>
                <div data-v-5f686215="" class="name">
                  HuangYi
                  <div data-v-5f686215="" class="incise inline-block"></div>
                  Zoom 前端架构师，前百度、滴滴资深技术专家
                </div>
                <!---->
                <div data-v-5f686215="" class="button btn btn-pc-css">
                  专属班主任
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="menu-content calc">
              <div
                data-v-68b0779c=""
                data-v-daa3f53a=""
                class="class-menu-contaniner more-sections more-sections-detail"
              >
                <!---->
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 267px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    开篇词
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          开篇词 | 解析 Vue.js 源码，提升编码能力
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          导读 | 一文看懂 Vue.js 3.0 的优化
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 431px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块一：直击 Vue.js 核心组件的实现
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          模块一导读 | 组件的实现：直击 Vue 核心的实现
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          01 | 组件渲染：vnode 到真实 DOM 是如何转变的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          02 | 组件更新：完整的 DOM diff 流程是怎样的？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        isclick
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          03 | 组件更新：完整的 DOM diff 流程是怎样的？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 841px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块二：学会新设计 Composition API
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          模块二导读 | 逻辑复用最佳实践：Composition API
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          04 | Setup：组件渲染前的初始化过程是怎样的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          05 | 响应式：响应式内部的实现原理是怎样的？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          07 | 计算属性：计算属性比普通函数好在哪里？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          08 | 侦听器：侦听器的实现原理和使用场景是什么？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          06 | 响应式：响应式内部的实现原理是怎样的？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          09 | 侦听器：侦听器的实现原理和使用场景是什么？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          10 |
                          生命周期：各个生命周期的执行时机和应用场景是怎样的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          11 | 依赖注入：子孙组件如何共享数据？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 677px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块三：编译过程和背后的优化思想
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          12 | 模板解析：构造 AST 的完整流程是怎样的？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          模块三导读 | 编译和优化：了解编译过程和背后的优化思想
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          13 | 模板解析：构造 AST 的完整流程是怎样的？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          14 | AST 转换：AST 节点内部做了哪些转换？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          15 | AST 转换：AST 节点内部做了哪些转换？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          16 | 生成代码：AST 如何生成可运行的代码？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          17 | 生成代码：AST 如何生成可运行的代码？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 513px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块四：探索更多实用特性背后的实现原理
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          模块四导读 | 实用特性：探索更多实用特性背后的原理
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          18 | Props：Props 的初始化和更新流程是怎样的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          19 | 插槽：如何实现内容分发？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          20 | 指令：指令完整的生命周期是怎样的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          21 | v-model：双向绑定到底是怎么实现的？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 513px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    模块五：学习 Vue 内置组件的实现原理
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          模块五导读 | 内置组件：学习 Vue 内置组件的实现原理
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          22 | Teleport 组件：如何脱离当前组件渲染子组件？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          23 | KeepAlive 组件：如何让组件在内存中缓存和调度？
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          24 | Transition
                          组件：过渡动画的实现原理是怎样的？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          25 | Transition
                          组件：过渡动画的实现原理是怎样的？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 349px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    特别放送：研究 Vue 官方生态的实现原理
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          特别放送导读 | 研究 Vue 官方生态的实现原理
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          26 | Vue Router：如何实现一个前端路由？（上）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          27 | Vue Router：如何实现一个前端路由？（下）
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div
                  data-v-68b0779c=""
                  class="class-menu-box"
                  style="max-height: 185px"
                >
                  <div
                    data-v-68b0779c=""
                    class="kw-icon-arrow show show-detail show-active"
                  ></div>
                  <div
                    data-v-68b0779c=""
                    class="section-name single-line section-name-detail"
                  >
                    结束语
                  </div>
                  <div data-v-68b0779c="" class="class-menu-block">
                    <div
                      data-v-68b0779c=""
                      class="
                        class-level-one
                        over-ellipsis
                        class-level-one-detail
                      "
                    >
                      <div data-v-68b0779c="" class="text-wrap">
                        <div data-v-68b0779c="" class="content">
                          结束语 | 终点也是起点
                        </div>
                        <div data-v-68b0779c="" class="item-status-wrap">
                          <!---->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            data-v-daa3f53a=""
            class="right-content-wrap"
            style="height: 100px"
          >
            <div data-v-1605a430="" data-v-daa3f53a="" class="main-wrap">
              <div data-v-1605a430="">
                <h1 data-v-1605a430="" class="main-title">
                  03 | 组件更新：完整的 DOM diff 流程是怎样的？（下）
                </h1>
                <div data-v-1605a430="" class="main-tips">
                  2021/05/24
                  <span data-v-1605a430="" class="auth">HuangYi</span>
                </div>
                <div data-v-1605a430="" class="media-player-wrap">
                  <div data-v-6ecd2302="" data-v-1605a430="">
                    <div data-v-6ecd2302="" class="media-container">
                      <div data-v-6ecd2302="" class="button-wrap inline-block">
                        <div
                          data-v-6ecd2302=""
                          class="button-icon inline-block"
                        ></div>
                      </div>
                      <div data-v-6ecd2302="" class="data-wrap inline-block">
                        <div data-v-6ecd2302="" class="progress-bar">
                          <div
                            class="vue-slider vue-slider-ltr"
                            style="padding: 7px 0px; width: auto; height: 4px"
                          >
                            <div
                              class="vue-slider-rail"
                              style="
                                height: 2px;
                                background: rgb(213, 218, 223);
                                border-radius: 1.5px;
                              "
                            >
                              <div
                                class="vue-slider-process"
                                style="
                                  height: 100%;
                                  top: 0px;
                                  left: 0%;
                                  width: 0%;
                                  transition-property: width, left;
                                  transition-duration: 0.5s;
                                  background: rgb(252, 215, 102);
                                "
                              ></div>
                              <div
                                aria-valuetext="00:00/16:09"
                                class="vue-slider-dot vue-slider-dot-hover"
                                role="slider"
                                aria-valuenow="0"
                                aria-valuemin="0"
                                aria-valuemax="969"
                                aria-orientation="horizontal"
                                tabindex="0"
                                style="
                                  width: 14px;
                                  height: 14px;
                                  transform: translate(-50%, -50%);
                                  top: 50%;
                                  left: 0%;
                                  transition: left 0.5s ease 0s;
                                "
                              >
                                <div
                                  class="vue-slider-dot-handle"
                                  style="
                                    width: 16px;
                                    height: 16px;
                                    background: rgb(252, 215, 102);
                                    box-shadow: none;
                                    margin-top: -1px;
                                    z-index: 1;
                                  "
                                ></div>
                                <div
                                  class="
                                    vue-slider-dot-tooltip
                                    vue-slider-dot-tooltip-top
                                  "
                                >
                                  <div
                                    class="
                                      vue-slider-dot-tooltip-inner
                                      vue-slider-dot-tooltip-inner-top
                                    "
                                    style="
                                      padding: 2px 12px;
                                      border-radius: 14px;
                                      font-size: 14px;
                                      color: rgb(0, 0, 0);
                                      background: rgb(252, 215, 102);
                                      min-width: 20px;
                                      border-color: rgb(252, 215, 102);
                                    "
                                  >
                                    <span class="vue-slider-dot-tooltip-text"
                                      >00:00/16:09</span
                                    >
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div data-v-6ecd2302="" class="detail-wrap">
                          <div data-v-6ecd2302="" class="detail-one">9.3M</div>
                          <div data-v-6ecd2302="" class="detail-two">
                            00:00/16:09
                          </div>
                        </div>
                      </div>
                      <div
                        data-v-6ecd2302=""
                        class="division-line inline-block"
                      ></div>
                      <div data-v-6ecd2302="" class="viedo-wrap inline-block">
                        <div data-v-6ecd2302="" class="viedo-icon"></div>
                        <div data-v-6ecd2302="" class="text">看视频</div>
                      </div>
                    </div>
                    <!---->
                  </div>
                </div>
                <div data-v-1605a430="" class="main-container">
                  <div data-v-1605a430="" class="rich-text-wrap">
                    <p data-nodeid="1252" class="">
                      下面我们来继续讲解上节课提到的<strong data-nodeid="1405"
                        >核心 diff 算法</strong
                      >。
                    </p>
                    <p data-nodeid="1253">
                      新子节点数组相对于旧子节点数组的变化，无非是通过更新、删除、添加和移动节点来完成，而核心
                      diff 算法，就是在已知旧子节点的 DOM 结构、vnode
                      和新子节点的 vnode
                      情况下，以较低的成本完成子节点的更新为目的，求解生成新子节点
                      DOM 的系列操作。
                    </p>
                    <p data-nodeid="1254">
                      为了方便你理解，我先举个例子，假设有这样一个列表：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word">&lt;ul&gt;
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"a"</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"b"</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"c"</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"d"</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1256">
                      然后我们在中间插入一行，得到一个新列表：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word">&lt;ul&gt;
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"a"</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"b"</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"e"</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"c"</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"d"</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1258">
                      在插入操作的前后，它们对应渲染生成的 vnode
                      可以用一张图表示：
                    </p>
                    <p data-nodeid="1259">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/33/86/CgqCHl8QHwmAHuQrAAB7807ZTzY864.png"
                        alt="111.png"
                        data-nodeid="1412"
                      />
                    </p>
                    <p data-nodeid="1260">
                      从图中我们可以直观地感受到，差异主要在新子节点中的 b
                      节点后面多了一个 e 节点。
                    </p>
                    <p data-nodeid="1261">
                      我们再把这个例子稍微修改一下，多添加一个 e 节点：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word">&lt;ul&gt;
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"a"</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"b"</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"c"</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"d"</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"e"</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1263">
                      然后我们删除中间一项，得到一个新列表：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word">&lt;ul&gt;
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"a"</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"b"</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"d"</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"e"</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1265">
                      在删除操作的前后，它们对应渲染生成的 vnode
                      可以用一张图表示：
                    </p>
                    <p data-nodeid="1266">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C3/Ciqc1F8OxNCAbTueAABtqP8l5JI050.png"
                        alt="图片2.png"
                        data-nodeid="1419"
                      />
                    </p>
                    <p data-nodeid="1267">
                      我们可以看到，这时差异主要在新子节点中的 b
                      节点后面少了一个 c 节点。
                    </p>
                    <p data-nodeid="1268">
                      综合这两个例子，我们很容易发现新旧 children
                      拥有相同的头尾节点。对于相同的节点，我们只需要做对比更新即可，所以
                      diff 算法的第一步<strong data-nodeid="1426"
                        >从头部开始同步</strong
                      >。
                    </p>
                    <h3 data-nodeid="1269">同步头部节点</h3>
                    <p data-nodeid="1270">
                      我们先来看一下头部节点同步的实现代码：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function">(<span class="hljs-params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> {
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> l2 = c2.length
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 1. 从头部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 0, e1 = 3, e2 = 4</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> n1 = c1[i]
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> n2 = c2[i]
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (isSameVNodeType(n1, n2)) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 相同的节点，递归执行 patch 更新节点</span>
</div></li><li><div class="code-word">      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      <span class="hljs-keyword">break</span>
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    i++
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1272">
                      在整个 diff 的过程，我们需要维护几个变量：头部的索引
                      i、旧子节点的尾部索引 e1和新子节点的尾部索引 e2。
                    </p>
                    <p data-nodeid="1273">
                      同步头部节点就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行
                      patch 更新节点；如果不同或者索引 i 大于索引 e1 或者
                      e2，则同步过程结束。
                    </p>
                    <p data-nodeid="1274">
                      我们拿第一个例子来说，通过下图看一下同步头部节点后的结果：
                    </p>
                    <p data-nodeid="1275">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C3/Ciqc1F8OxN6AMzbfAACPna55Fmk255.png"
                        alt="图片3.png"
                        data-nodeid="1434"
                      />
                    </p>
                    <p data-nodeid="1276">
                      可以看到，完成头部节点同步后：i 是 2，e1 是 3，e2 是 4。
                    </p>
                    <h3 data-nodeid="1277">同步尾部节点</h3>
                    <p data-nodeid="1278">
                      接着从尾部开始<strong data-nodeid="1442"
                        >同步尾部节点</strong
                      >，实现代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function">(<span class="hljs-params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> {
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> l2 = c2.length
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 1. 从头部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 0, e1 = 3, e2 = 4</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 2. 从尾部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 3, e2 = 4</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) (c d)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e (c d)</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> n1 = c1[e1]
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> n2 = c2[e2]
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (isSameVNodeType(n1, n2)) {
</div></li><li><div class="code-word">      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      <span class="hljs-keyword">break</span>
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    e1--
</div></li><li><div class="code-word">    e2--
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1280">
                      同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行
                      patch 更新节点；如果不同或者索引 i 大于索引 e1 或者
                      e2，则同步过程结束。
                    </p>
                    <p data-nodeid="1281">
                      我们来通过下图看一下同步尾部节点后的结果：
                    </p>
                    <p data-nodeid="1282">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C3/Ciqc1F8OxO2AffFhAACJ52ATnwQ480.png"
                        alt="图片4.png"
                        data-nodeid="1447"
                      />
                    </p>
                    <p data-nodeid="1283">
                      可以看到，完成尾部节点同步后：i 是 2，e1 是 1，e2 是 2。
                    </p>
                    <p data-nodeid="1284">接下来只有 3 种情况要处理：</p>
                    <ul data-nodeid="1285">
                      <li data-nodeid="1286">
                        <p data-nodeid="1287">新子节点有剩余要添加的新节点；</p>
                      </li>
                      <li data-nodeid="1288">
                        <p data-nodeid="1289">
                          旧子节点有剩余要删除的多余节点；
                        </p>
                      </li>
                      <li data-nodeid="1290">
                        <p data-nodeid="1291">未知子序列。</p>
                      </li>
                    </ul>
                    <p data-nodeid="1292">我们继续看一下具体是怎样操作的。</p>
                    <h3 data-nodeid="1293">添加新的节点</h3>
                    <p data-nodeid="1294">
                      首先要判断新子节点是否有剩余的情况，如果满足则添加新子节点，实现代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function">(<span class="hljs-params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> {
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> l2 = c2.length
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 1. 从头部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 0, e1 = 3, e2 = 4</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// ...</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 2. 从尾部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 3, e2 = 4</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) (c d)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e (c d)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 3. 挂载剩余的新节点</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 1, e2 = 2</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (i &gt; e1) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (i &lt;= e2) {
</div></li><li><div class="code-word">      <span class="hljs-keyword">const</span> nextPos = e2 + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor
</div></li><li><div class="code-word">      <span class="hljs-keyword">while</span> (i &lt;= e2) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 挂载新节点</span>
</div></li><li><div class="code-word">        patch(<span class="hljs-literal">null</span>, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)
</div></li><li><div class="code-word">        i++
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1296">
                      如果索引 i 大于尾部索引 e1 且 i 小于 e2，那么从索引 i
                      开始到索引 e2 之间，我们直接挂载新子树这部分的节点。
                    </p>
                    <p data-nodeid="1297">
                      对我们的例子而言，同步完尾部节点后 i 是 2，e1 是 1，e2 是
                      2，此时满足条件需要添加新的节点，我们来通过下图看一下添加后的结果：
                    </p>
                    <p data-nodeid="1298">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/CF/CgqCHl8OxQKAd7fjAACNTHXEkuQ335.png"
                        alt="图片5.png"
                        data-nodeid="1460"
                      />
                    </p>
                    <p data-nodeid="1299">
                      添加完 e 节点后，旧子节点的 DOM 和新子节点对应的 vnode
                      映射一致，也就完成了更新。
                    </p>
                    <h3 data-nodeid="1300">删除多余节点</h3>
                    <p data-nodeid="1301">
                      如果不满足添加新节点的情况，我就要接着判断旧子节点是否有剩余，如果满足则删除旧子节点，实现代码如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function">(<span class="hljs-params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> {
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> l2 = c2.length
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 1. 从头部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 0, e1 = 4, e2 = 3</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d e</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) d e</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// ...</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 2. 从尾部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 4, e2 = 3</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c (d e)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) (d e)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 3. 普通序列挂载剩余的新节点</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 2, e2 = 1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 不满足</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">if</span> (i &gt; e1) {
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-comment">// 4. 普通序列删除多余的旧节点</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 2, e2 = 1</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; e2) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">while</span> (i &lt;= e1) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 删除节点</span>
</div></li><li><div class="code-word">      unmount(c1[i], parentComponent, parentSuspense, <span class="hljs-literal">true</span>)
</div></li><li><div class="code-word">      i++
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1303">
                      如果索引 i 大于尾部索引 e2，那么从索引 i 开始到索引 e1
                      之间，我们直接删除旧子树这部分的节点。
                    </p>
                    <p data-nodeid="1304">
                      第二个例子是就删除节点的情况，我们从同步头部节点开始，用图的方式演示这一过程。
                    </p>
                    <p data-nodeid="1305">首先从头部同步节点：</p>
                    <p data-nodeid="1306">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C4/Ciqc1F8OxQ-ADmRcAACCSIpni8Y429.png"
                        alt="图片6.png"
                        data-nodeid="1469"
                      />
                    </p>
                    <p data-nodeid="1307">
                      此时的结果：i 是 2，e1 是 4，e2 是 3。
                    </p>
                    <p data-nodeid="1308">接着从尾部同步节点：</p>
                    <p data-nodeid="1309">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C4/Ciqc1F8OxRqANXzyAACGFb9dacI061.png"
                        alt="图片7.png"
                        data-nodeid="1474"
                      />
                    </p>
                    <p data-nodeid="1310">
                      此时的结果：i 是 2，e1 是 2，e2 是
                      1，满足删除条件，因此删除子节点中的多余节点：
                    </p>
                    <p data-nodeid="1311">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/CF/CgqCHl8OxSeAMW8gAACCvYcKESo055.png"
                        alt="图片8.png"
                        data-nodeid="1478"
                      />
                    </p>
                    <p data-nodeid="1312">
                      删除完 c 节点后，旧子节点的 DOM 和新子节点对应的 vnode
                      映射一致，也就完成了更新。
                    </p>
                    <h3 data-nodeid="1313">处理未知子序列</h3>
                    <p data-nodeid="1314">
                      单纯的添加和删除节点都是比较理想的情况，操作起来也很容易，但是有些时候并非这么幸运，我们会遇到比较复杂的未知子序列，这时候
                      diff 算法会怎么做呢？
                    </p>
                    <p data-nodeid="1315">
                      我们再通过例子来演示存在未知子序列的情况，假设一个按照字母表排列的列表：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word">&lt;ul&gt;
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"a"</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"b"</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"c"</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"d"</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"e"</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"f"</span>&gt;</span>f<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"g"</span>&gt;</span>g<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"h"</span>&gt;</span>h<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1317">
                      然后我们打乱之前的顺序得到一个新列表：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word">&lt;ul&gt;
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"a"</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"b"</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"e"</span>&gt;</span>e<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"d"</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"c"</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"i"</span>&gt;</span>i<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"g"</span>&gt;</span>g<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"h"</span>&gt;</span>h<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1319">
                      在操作前，它们对应渲染生成的 vnode 可以用一张图表示：
                    </p>
                    <p data-nodeid="1320">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C4/Ciqc1F8OxT6AVycJAAClkNghf-k681.png"
                        alt="图片9.png"
                        data-nodeid="1487"
                      />
                    </p>
                    <p data-nodeid="1321">
                      我们还是从同步头部节点开始，用图的方式演示这一过程。
                    </p>
                    <p data-nodeid="1322">首先从头部同步节点：</p>
                    <p data-nodeid="1323">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/CF/CgqCHl8OxUyAaCXvAAC6Lv79hSs090.png"
                        alt="图片10.png"
                        data-nodeid="1492"
                      />
                    </p>
                    <p data-nodeid="1324">
                      同步头部节点后的结果：i 是 2，e1 是 7，e2 是 7。
                    </p>
                    <p data-nodeid="1325">接着从尾部同步节点：</p>
                    <p data-nodeid="1326">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C4/Ciqc1F8OxVeAYV_ZAADCIt6XIHI609.png"
                        alt="图片11.png"
                        data-nodeid="1497"
                      />
                    </p>
                    <p data-nodeid="1327">
                      同步尾部节点后的结果：i 是 2，e1 是 5，e2 是
                      5。可以看到它既不满足添加新节点的条件，也不满足删除旧节点的条件。那么对于这种情况，我们应该怎么处理呢？
                    </p>
                    <p data-nodeid="1328">
                      结合上图可以知道，要把旧子节点的 c、d、e、f
                      转变成新子节点的 e、c、d、i。从直观上看，我们把 e
                      节点移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加
                      i 节点即可。
                    </p>
                    <p data-nodeid="1329">
                      其实无论多复杂的情况，最终无非都是通过更新、删除、添加、移动这些动作来操作节点，而我们要做的就是找到相对优的解。
                    </p>
                    <p data-nodeid="1330">
                      当两个节点类型相同时，我们执行更新操作；当新子节点中没有旧子节点中的某些节点时，我们执行删除操作；当新子节点中多了旧子节点中没有的节点时，我们执行添加操作，这些操作我们在前面已经阐述清楚了。相对来说这些操作中最麻烦的就是移动，我们既要判断哪些节点需要移动也要清楚如何移动。
                    </p>
                    <h4 data-nodeid="1331">移动子节点</h4>
                    <p data-nodeid="1332">
                      那么什么时候需要移动呢，就是当子节点排列顺序发生变化的时候，举个简单的例子具体看一下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">var</span> prev = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code-word"><span class="hljs-keyword">var</span> next = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1334">
                      可以看到，从 prev 变成
                      next，数组里的一些元素的顺序发生了变化，我们可以把子节点类比为元素，现在问题就简化为我们如何用最少的移动使元素顺序从
                      prev 变化为 next 。
                    </p>
                    <p data-nodeid="1335">
                      一种思路是在 next 中找到一个递增子序列，比如 [1, 3, 6]
                      、[1, 2, 4, 5]。之后对 next
                      数组进行倒序遍历，移动所有不在递增序列中的元素即可。
                    </p>
                    <p data-nodeid="1336">
                      如果选择了 [1, 3, 6]
                      作为递增子序列，那么在倒序遍历的过程中，遇到 6、3、1
                      不动，遇到 5、4、2 移动即可，如下图所示：
                    </p>
                    <p data-nodeid="1337">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/CF/CgqCHl8OxWOAKRnGAAAzjDtkQJI201.png"
                        alt="图片12.png"
                        data-nodeid="1521"
                      />
                    </p>
                    <p data-nodeid="1338">
                      如果选择了 [1, 2, 4, 5]
                      作为递增子序列，那么在倒序遍历的过程中，遇到 5、4、2、1
                      不动，遇到 6、3 移动即可，如下图所示：
                    </p>
                    <p data-nodeid="1339">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/CF/CgqCHl8OxW6APB5gAAAshOjdgMY518.png"
                        alt="图片13.png"
                        data-nodeid="1529"
                      />
                    </p>
                    <p data-nodeid="1340">
                      可以看到第一种移动了三次，而第二种只移动了两次，递增子序列越长，所需要移动元素的次数越少，所以如何移动的问题就回到了求解最长递增子序列的问题。我们稍后会详细讲求解最长递增子序列的算法，所以先回到我们这里的问题，对未知子序列的处理。
                    </p>
                    <p data-nodeid="1341">
                      我们现在要做的是在新旧子节点序列中找出相同节点并更新，找出多余的节点删除，找出新的节点添加，找出是否有需要移动的节点，如果有该如何移动。
                    </p>
                    <p data-nodeid="1342">
                      在查找过程中需要对比新旧子序列，那么我们就要遍历某个序列，如果在遍历旧子序列的过程中需要判断某个节点是否在新子序列中存在，这就需要双重循环，而双重循环的复杂度是
                      O(n<sup>2</sup>)
                      ，为了优化这个复杂度，我们可以用一种空间换时间的思路，建立索引图，把时间复杂度降低到
                      O(n)。
                    </p>
                    <h4 data-nodeid="1343">建立索引图</h4>
                    <p data-nodeid="1344">
                      所以处理未知子序列的第一步，就是建立索引图。
                    </p>
                    <p data-nodeid="1345">
                      通常我们在开发过程中， 会给 v-for
                      生成的列表中的每一项分配唯一 key 作为项的唯一 ID，这个 key
                      在 diff
                      过程中起到很关键的作用。对于新旧子序列中的节点，我们认为
                      key 相同的就是同一个节点，直接执行 patch 更新即可。
                    </p>
                    <p data-nodeid="1346">
                      我们根据 key 建立新子序列的索引图，实现如下：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function">(<span class="hljs-params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> {
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> l2 = c2.length
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 1. 从头部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 0, e1 = 7, e2 = 7</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d e f g h</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d i g h</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 2. 从尾部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 7, e2 = 7</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d e f (g h)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d i (g h)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 3. 普通序列挂载剩余的新节点， 不满足</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 4. 普通序列删除多余的旧节点，不满足</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 4, e2 = 5</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子序列开始索引，从 i 开始记录</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> s1 = i
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子序列开始索引，从 i 开始记录</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> s2 = i <span class="hljs-comment">//</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 5.1 根据 key 建立新子序列的索引图</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> keyToNewIndexMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (i = s2; i &lt;= e2; i++) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> nextChild = c2[i]
</div></li><li><div class="code-word">    keyToNewIndexMap.set(nextChild.key, i)
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1348">
                      新旧子序列是从 i 开始的，所以我们先用 s1、s2
                      分别作为新旧子序列的开始索引，接着建立一个
                      keyToNewIndexMap 的 Map&lt;key, index&gt;
                      结构，遍历新子序列，把节点的 key 和 index 添加到这个 Map
                      中，注意我们这里假设所有节点都是有 key 标识的。
                    </p>
                    <p data-nodeid="1349">
                      keyToNewIndexMap
                      存储的就是新子序列中每个节点在新子序列中的索引，我们来看一下示例处理后的结果，如下图所示：
                    </p>
                    <p data-nodeid="1350">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/D0/CgqCHl8OxciAQJ6GAADhf7zD47s944.png"
                        alt="图片14.png"
                        data-nodeid="1547"
                      />
                    </p>
                    <p data-nodeid="1351">
                      我们得到了一个值为 {e:2,c:3,d:4,i:5} 的新子序列索引图。
                    </p>
                    <h4 data-nodeid="1352">更新和移除旧节点</h4>
                    <p data-nodeid="1353">
                      接下来，我们就需要遍历旧子序列，有相同的节点就通过 patch
                      更新，并且移除那些不在新子序列中的节点，同时找出是否有需要移动的节点，我们来看一下这部分逻辑的实现：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function">(<span class="hljs-params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> {
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> l2 = c2.length
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 1. 从头部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 0, e1 = 7, e2 = 7</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d e f g h</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d i g h</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 2. 从尾部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 7, e2 = 7</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d e f (g h)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d i (g h)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 3. 普通序列挂载剩余的新节点，不满足</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 4. 普通序列删除多余的旧节点，不满足</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 4, e2 = 5</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子序列开始索引，从 i 开始记录</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> s1 = i
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子序列开始索引，从 i 开始记录</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> s2 = i
</div></li><li><div class="code-word">  <span class="hljs-comment">// 5.1 根据 key 建立新子序列的索引图</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子序列已更新节点的数量</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> patched = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子序列待更新节点的数量，等于新子序列的长度</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> toBePatched = e2 - s2 + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 是否存在要移动的节点</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> moved = <span class="hljs-literal">false</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 用于跟踪判断是否有节点移动</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> maxNewIndexSoFar = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 这个数组存储新子序列中的元素在旧子序列节点的索引，用于确定最长递增子序列</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> newIndexToOldIndexMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(toBePatched)
</div></li><li><div class="code-word">  <span class="hljs-comment">// 初始化数组，每个元素的值都是 0</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 0 是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明这个新节点没有对应的旧节点</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; toBePatched; i++)
</div></li><li><div class="code-word">    newIndexToOldIndexMap[i] = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 正序遍历旧子序列</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (i = s1; i &lt;= e1; i++) {
</div></li><li><div class="code-word">    <span class="hljs-comment">// 拿到每一个旧子序列节点</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> prevChild = c1[i]
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (patched &gt;= toBePatched) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 所有新的子序列节点都已经更新，剩余的节点删除</span>
</div></li><li><div class="code-word">      unmount(prevChild, parentComponent, parentSuspense, <span class="hljs-literal">true</span>)
</div></li><li><div class="code-word">      <span class="hljs-keyword">continue</span>
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-comment">// 查找旧子序列中的节点在新子序列中的索引</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">let</span> newIndex = keyToNewIndexMap.get(prevChild.key)
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (newIndex === <span class="hljs-literal">undefined</span>) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 找不到说明旧子序列已经不存在于新子序列中，则删除该节点</span>
</div></li><li><div class="code-word">      unmount(prevChild, parentComponent, parentSuspense, <span class="hljs-literal">true</span>)
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 更新新子序列中的元素在旧子序列中的索引，这里加 1 偏移，是为了避免 i 为 0 的特殊情况，影响对后续最长递增子序列的求解</span>
</div></li><li><div class="code-word">      newIndexToOldIndexMap[newIndex - s2] = i + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// maxNewIndexSoFar 始终存储的是上次求值的 newIndex，如果不是一直递增，则说明有移动</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) {
</div></li><li><div class="code-word">        maxNewIndexSoFar = newIndex
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        moved = <span class="hljs-literal">true</span>
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      <span class="hljs-comment">// 更新新旧子序列中匹配的节点</span>
</div></li><li><div class="code-word">      patch(prevChild, c2[newIndex], container, <span class="hljs-literal">null</span>, parentComponent, parentSuspense, isSVG, optimized)
</div></li><li><div class="code-word">      patched++
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1355">
                      我们建立了一个 newIndexToOldIndexMap
                      的数组，来存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，用于确定最长递增子序列，这个数组的长度为新子序列的长度，每个元素的初始值设为
                      0， 它是一个特殊的值，如果遍历完了仍有元素的值为
                      0，则说明遍历旧子序列的过程中没有处理过这个节点，这个节点是新添加的。
                    </p>
                    <p data-nodeid="1356">
                      下面我们说说具体的操作过程：正序遍历旧子序列，根据前面建立的
                      keyToNewIndexMap
                      查找旧子序列中的节点在新子序列中的索引，如果找不到就说明新子序列中没有该节点，就删除它；如果找得到则将它在旧子序列中的索引更新到
                      newIndexToOldIndexMap 中。
                    </p>
                    <p data-nodeid="1357">
                      注意这里索引加了长度为 1 的偏移，是为了应对 i 为 0
                      的特殊情况，如果不这样处理就会影响后续求解最长递增子序列。
                    </p>
                    <p data-nodeid="2505" class="">
                      遍历过程中，我们用变量 maxNewIndexSoFar
                      跟踪判断节点是否移动，maxNewIndexSoFar
                      始终存储的是上次求值的 newIndex，一旦本次求值的 newIndex
                      小于
                      maxNewIndexSoFar，这说明顺序遍历旧子序列的节点在新子序列中的索引并不是一直递增的，也就说明存在移动的情况。
                    </p>

                    <p data-nodeid="1359">
                      除此之外，这个过程中我们也会更新新旧子序列中匹配的节点，另外如果所有新的子序列节点都已经更新，而对旧子序列遍历还未结束，说明剩余的节点就是多余的，删除即可。
                    </p>
                    <p data-nodeid="1360">
                      至此，我们完成了新旧子序列节点的更新、多余旧节点的删除，并且建立了一个
                      newIndexToOldIndexMap
                      存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，并确定是否有移动。
                    </p>
                    <p data-nodeid="1361">
                      我们来看一下示例处理后的结果，如下图所示：
                    </p>
                    <p data-nodeid="1362">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/D0/CgqCHl8OxdeAVdPEAAEh9JAOZ_E654.png"
                        alt="图片15.png"
                        data-nodeid="1560"
                      />
                    </p>
                    <p data-nodeid="1363">
                      可以看到， c、d、e 节点被更新，f
                      节点被删除，newIndexToOldIndexMap 的值为 [5, 3, 4
                      ,0]，此时 moved 也为 true，也就是存在节点移动的情况。
                    </p>
                    <h4 data-nodeid="1364">移动和挂载新节点</h4>
                    <p data-nodeid="1365">
                      接下来，就到了处理未知子序列的最后一个流程，移动和挂载新节点，我们来看一下这部分逻辑的实现：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-keyword">const</span> patchKeyedChildren = <span class="hljs-function">(<span class="hljs-params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt;</span> {
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> l2 = c2.length
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e1 = c1.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点的尾部索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> e2 = l2 - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 1. 从头部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 0, e1 = 6, e2 = 7</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c d e f g</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) e c d h f g</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 2. 从尾部开始同步</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 6, e2 = 7</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) c (d e)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// (a b) (d e)</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 3. 普通序列挂载剩余的新节点， 不满足</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 4. 普通序列删除多余的节点，不满足</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// i = 2, e1 = 4, e2 = 5</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 旧子节点开始索引，从 i 开始记录</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> s1 = i
</div></li><li><div class="code-word">  <span class="hljs-comment">// 新子节点开始索引，从 i 开始记录</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> s2 = i <span class="hljs-comment">//</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 5.1 根据 key 建立新子序列的索引图</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 5.3 移动和挂载新节点</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 仅当节点移动时生成最长递增子序列</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> increasingNewIndexSequence = moved
</div></li><li><div class="code-word">    ? getSequence(newIndexToOldIndexMap)
</div></li><li><div class="code-word">    : EMPTY_ARR
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> j = increasingNewIndexSequence.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">  <span class="hljs-comment">// 倒序遍历以便我们可以使用最后更新的节点作为锚点</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (i = toBePatched - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> nextIndex = s2 + i
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> nextChild = c2[nextIndex]
</div></li><li><div class="code-word">    <span class="hljs-comment">// 锚点指向上一个更新的节点，如果 nextIndex 超过新子节点的长度，则指向 parentAnchor</span>
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> anchor = nextIndex + <span class="hljs-number">1</span> &lt; l2 ? c2[nextIndex + <span class="hljs-number">1</span>].el : parentAnchor
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (newIndexToOldIndexMap[i] === <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 挂载新的子节点</span>
</div></li><li><div class="code-word">      patch(<span class="hljs-literal">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (moved) {
</div></li><li><div class="code-word">      <span class="hljs-comment">// 没有最长递增子序列（reverse 的场景）或者当前的节点索引不在最长递增子序列中，需要移动</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span> || i !== increasingNewIndexSequence[j]) {
</div></li><li><div class="code-word">        move(nextChild, container, anchor, <span class="hljs-number">2</span>)
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 倒序递增子序列</span>
</div></li><li><div class="code-word">        j--
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1367">
                      我们前面已经判断了是否移动，如果 moved 为 true 就通过
                      getSequence(newIndexToOldIndexMap)
                      计算最长递增子序列，这部分算法我会放在后文详细介绍。
                    </p>
                    <p data-nodeid="1368">
                      接着我们采用倒序的方式遍历新子序列，因为倒序遍历可以方便我们使用最后更新的节点作为锚点。在倒序的过程中，锚点指向上一个更新的节点，然后判断
                      newIndexToOldIndexMap[i] 是否为
                      0，如果是则表示这是新节点，就需要挂载它；接着判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果在则倒序最长递增子序列，否则把它移动到锚点的前面。
                    </p>
                    <p data-nodeid="1369">
                      为了便于你更直观地理解，我们用前面的例子展示一下这个过程，此时
                      toBePatched 的值为 4，j 的值为 1，最长递增子序列
                      increasingNewIndexSequence 的值是 [1,
                      2]。在倒序新子序列的过程中，首先遇到节点 i，发现它在
                      newIndexToOldIndexMap 中的值是
                      0，则说明它是新节点，我们需要挂载它；然后继续遍历遇到节点
                      d，因为 moved 为 true，且 d
                      的索引存在于最长递增子序列中，则执行 j--
                      倒序最长递增子序列，j 此时为 0；接着继续遍历遇到节点
                      c，它和 d 一样，索引也存在于最长递增子序列中，则执行
                      j--，j 此时为 -1；接着继续遍历遇到节点 e，此时 j 是 -1
                      并且 e
                      的索引也不在最长递增子序列中，所以做一次移动操作，把 e
                      节点移到上一个更新的节点，也就是 c 节点的前面。
                    </p>
                    <p data-nodeid="1370">
                      新子序列倒序完成，即完成了新节点的插入和旧节点的移动操作，也就完成了整个核心
                      diff 算法对节点的更新。
                    </p>
                    <p data-nodeid="1371">
                      我们来看一下示例处理后的结果，如下图所示：
                    </p>
                    <p data-nodeid="1372">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C5/Ciqc1F8OxeiAIp0WAAFBcsdATCI981.png"
                        alt="图片16.png"
                        data-nodeid="1583"
                      />
                    </p>
                    <p data-nodeid="1373">
                      可以看到新子序列中的新节点 i 被挂载，旧子序列中的节点 e
                      移动到了 c 节点前面，至此，我们就在已知旧子节点 DOM 结构和
                      vnode、新子节点 vnode 的情况下，求解出生成新子节点的 DOM
                      的更新、移动、删除、新增等系列操作，并且以一种较小成本的方式完成
                      DOM 更新。
                    </p>
                    <p data-nodeid="1374">
                      我们知道了子节点更新调用的是 patch 方法， Vue.js
                      正是通过这种递归的方式完成了整个组件树的更新。
                    </p>
                    <p data-nodeid="1375">
                      核心 diff
                      算法中最复杂就是求解最长递增子序列，下面我们再来详细学习一下这个算法。
                    </p>
                    <h4 data-nodeid="1376">最长递增子序列</h4>
                    <p data-nodeid="1377">
                      求解最长递增子序列是一道经典的算法题，多数解法是使用动态规划的思想，算法的时间复杂度是
                      O(n<sup>2</sup>)，而 Vue.js
                      内部使用的是维基百科提供的一套“贪心 +
                      二分查找”的算法，贪心算法的时间复杂度是
                      O(n)，二分查找的时间复杂度是
                      O(logn)，所以它的总时间复杂度是 O(nlogn)。
                    </p>
                    <p data-nodeid="1378">
                      单纯地看代码并不好理解，我们用示例来看一下这个子序列的求解过程。
                    </p>
                    <p data-nodeid="1379">
                      假设我们有这个样一个数组 arr：[2, 1, 5, 3, 6, 4, 8, 9,
                      7]，求解它最长递增子序列的步骤如下：
                    </p>
                    <p data-nodeid="1380">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/DC/Ciqc1F8O342ATpU7AMfwii64x74028.gif"
                        alt="序列_05.gif"
                        data-nodeid="1603"
                      />
                    </p>
                    <p data-nodeid="1381">
                      最终求得最长递增子序列的值就是 [1, 3, 4, 8, 9]。
                    </p>
                    <p data-nodeid="1382">
                      通过演示我们可以得到这个算法的主要思路：对数组遍历，依次求解长度为
                      i 时的最长递增子序列，当 i 元素大于 i - 1 的元素时，添加 i
                      元素并更新最长子序列；否则往前查找直到找到一个比 i
                      小的元素，然后插在该元素后面并更新对应的最长递增子序列。
                    </p>
                    <p data-nodeid="1383">
                      这种做法的主要目的是让递增序列的差尽可能的小，从而可以获得更长的递增子序列，这便是一种贪心算法的思想。
                    </p>
                    <p data-nodeid="1384">
                      了解了算法的大致思想后，接下来我们看一下源码实现：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="js"><ol><li><div class="code-word"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSequence</span> (<span class="hljs-params">arr</span>) </span>{
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> p = arr.slice()
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> result = [<span class="hljs-number">0</span>]
</div></li><li><div class="code-word">  <span class="hljs-keyword">let</span> i, j, u, v, c
</div></li><li><div class="code-word">  <span class="hljs-keyword">const</span> len = arr.length
</div></li><li><div class="code-word">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
</div></li><li><div class="code-word">    <span class="hljs-keyword">const</span> arrI = arr[i]
</div></li><li><div class="code-word">    <span class="hljs-keyword">if</span> (arrI !== <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">      j = result[result.length - <span class="hljs-number">1</span>]
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (arr[j] &lt; arrI) {
</div></li><li><div class="code-word">        <span class="hljs-comment">// 存储在 result 更新前的最后一个索引的值</span>
</div></li><li><div class="code-word">        p[i] = j
</div></li><li><div class="code-word">        result.push(i)
</div></li><li><div class="code-word">        <span class="hljs-keyword">continue</span>
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      u = <span class="hljs-number">0</span>
</div></li><li><div class="code-word">      v = result.length - <span class="hljs-number">1</span>
</div></li><li><div class="code-word">      <span class="hljs-comment">// 二分搜索，查找比 arrI 小的节点，更新 result 的值</span>
</div></li><li><div class="code-word">      <span class="hljs-keyword">while</span> (u &lt; v) {
</div></li><li><div class="code-word">        c = ((u + v) / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (arr[result[c]] &lt; arrI) {
</div></li><li><div class="code-word">          u = c + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        <span class="hljs-keyword">else</span> {
</div></li><li><div class="code-word">          v = c
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">      <span class="hljs-keyword">if</span> (arrI &lt; arr[result[u]]) {
</div></li><li><div class="code-word">        <span class="hljs-keyword">if</span> (u &gt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">          p[i] = result[u - <span class="hljs-number">1</span>]
</div></li><li><div class="code-word">        }
</div></li><li><div class="code-word">        result[u] = i
</div></li><li><div class="code-word">      }
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  u = result.length
</div></li><li><div class="code-word">  v = result[u - <span class="hljs-number">1</span>]
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">  <span class="hljs-comment">// 回溯数组 p，找到最终的索引</span>
</div></li><li><div class="code-word">  <span class="hljs-keyword">while</span> (u-- &gt; <span class="hljs-number">0</span>) {
</div></li><li><div class="code-word">    result[u] = v
</div></li><li><div class="code-word">    v = p[v]
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  <span class="hljs-keyword">return</span> result
</div></li><li><div class="code-word">}
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1386">
                      其中 result 存储的是长度为 i
                      的递增子序列最小末尾值的索引。比如我们上述例子的第九步，在对数组
                      p 回溯之前， result 值就是 [1, 3, 4, 7, 9]
                      ，这不是最长递增子序列，它只是存储的对应长度递增子序列的最小末尾。因此在整个遍历过程中会额外用一个数组
                      p，来存储在每次更新 result 前最后一个索引的值，并且它的
                      key 是这次要更新的 result 值：
                    </p>
                    <div class="course-code-area">
                      <div class="copy-btn">
                        <div class="copy-icon"></div>
                        复制代码
                      </div>
                      <pre><code data-language="java"><ol><li><div class="code-word">j = result[result.length - <span class="hljs-number">1</span>]
</div></li><li><div class="code-word">p[i] = j
</div></li><li><div class="code-word">result.push(i)
</div></li></ol></code></pre>
                    </div>
                    <p data-nodeid="1388">
                      可以看到，result 添加的新值 i 是作为 p 存储 result
                      最后一个值 j 的 key。上述例子遍历后 p 的结果如图所示：
                    </p>
                    <p data-nodeid="1389">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/C5/Ciqc1F8OxgOALDcQAABERFRRNqo370.png"
                        alt="图片17.png"
                        data-nodeid="1620"
                      />
                    </p>
                    <p data-nodeid="1390">
                      从 result 最后一个元素 9 对应的索引 7 开始回溯，可以看到
                      p[7] = 6，p[6] = 5，p[5] = 3，p[3] = 1，所以通过对 p
                      的回溯，得到最终的 result 值是 [1, 3 ,5 ,6
                      ,7]，也就找到最长递增子序列的最终索引了。这里要注意，我们求解的是最长子序列索引值，它的每个元素其实对应的是数组的下标。对于我们的例子而言，[2,
                      1, 5, 3, 6, 4, 8, 9, 7] 的最长子序列是 [1, 3, 4, 8,
                      9]，而我们求解的 [1, 3 ,5 ,6 ,7]
                      就是最长子序列中元素在原数组中的下标所构成的新数组。
                    </p>
                    <h2 data-nodeid="1391">总结</h2>
                    <p data-nodeid="1392">
                      这两节课我们主要分析了组件的更新流程，知道了 Vue.js
                      的更新粒度是组件级别的，并且 Vue.js 在 patch
                      某个组件的时候，如果遇到组件这类抽象节点，在某些条件下也会触发子组件的更新。
                    </p>
                    <p data-nodeid="1393">
                      对于普通元素节点的更新，主要是更新一些属性，以及它的子节点。子节点的更新又分为多种情况，其中最复杂的情况为数组到数组的更新，内部又根据不同情况分成几个流程去
                      diff，遇到需要移动的情况还要去求解子节点的最长递增子序列。
                    </p>
                    <p data-nodeid="1394">
                      整个更新过程还是利用了树的深度遍历，递归执行 patch
                      方法，最终完成了整个组件树的更新。
                    </p>
                    <p data-nodeid="1395">
                      下面，我们通过一张图来更加直观感受组件的更新流程：
                    </p>
                    <p data-nodeid="1396">
                      <img
                        src="https://s0.lgstatic.com/i/image/M00/32/CB/Ciqc1F8OyzuASuJ7AAHSjr5SVlc999.png"
                        alt="1.png"
                        data-nodeid="1661"
                      />
                    </p>
                    <p data-nodeid="1397">
                      最后，给你留一道思考题目，我们使用 v-for 编写列表的时候
                      key 能用遍历索引 index
                      表示吗，为什么？欢迎你在留言区与我分享。
                    </p>
                    <blockquote data-nodeid="1398">
                      <p data-nodeid="1399" class="">
                        <strong data-nodeid="1668"
                          >本节课的相关代码在源代码中的位置如下：</strong
                        ><br />
                        packages/runtime-core/src/renderer.ts
                      </p>
                    </blockquote>
                  </div>
                </div>
              </div>
              <div
                data-v-1605a430=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center show-img-wrap"
                  style="margin-top: 15vh; width: 60%"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
            <div data-v-daa3f53a="" class="fix-box-wrap">
              <div data-v-daa3f53a="" class="mini-player-wrap">
                <div
                  data-v-2ee8fa4a=""
                  data-v-daa3f53a=""
                  class="player-container-wrap"
                >
                  <div data-v-2ee8fa4a="" class="player">
                    <div data-v-2ee8fa4a="" class="close-btn"></div>
                    <div data-v-2ee8fa4a="" class="content">
                      <div
                        data-v-2ee8fa4a=""
                        class="theme single-line narrow-theme"
                      ></div>
                      <div data-v-2ee8fa4a="" class="time-course">
                        <div data-v-2ee8fa4a="" class="time">
                          00:00<span data-v-2ee8fa4a="" class="line"></span>
                        </div>
                        <span data-v-2ee8fa4a="" class="course-name single-line"
                          >Vue.js 3.0 核心源码内参</span
                        >
                      </div>
                    </div>
                    <div data-v-2ee8fa4a="" class="player-container">
                      <div data-v-2ee8fa4a="" class="play-btn">
                        <div
                          data-v-2ee8fa4a=""
                          class="play-status playing"
                        ></div>
                      </div>
                      <div
                        data-v-2ee8fa4a=""
                        class="play-next next-unable"
                      ></div>
                    </div>
                  </div>
                </div>
              </div>
              <!---->
            </div>
            <div data-v-daa3f53a="" class="right-content-space"></div>
            <div data-v-daa3f53a="" class="right-content-message">
              <div
                data-v-4bc80e00=""
                data-v-daa3f53a=""
                class="message pc-message"
              >
                <div data-v-4bc80e00="" class="message-topic">
                  <div data-v-4bc80e00="" class="message-topic-title">
                    精选留言
                  </div>
                  <div
                    data-v-4bc80e00=""
                    class="message-topic-write pointer btn-pc-css"
                  >
                    <img
                      data-v-4bc80e00=""
                      src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAMAAABF0y+mAAABDlBMVEUAAAAAAAArKyscHBwrKyswMDAtLS0xMTEuLi4rKyszMzMzMzMyMjIvLy8zMzMxMTEvLy8tLS0zMzMyMjIxMTEwMDAyMjIwMDAzMzMxMTEwMDAxMTEyMjIzMzMyMjIzMzMxMTEyMjIyMjIyMjIyMjIyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIzMzMyMjIyMjIzMzMyMjIyMjIzMzMyMjIyMjIyMjIzMzMyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIzMzMzMzMyMjIzMzMzMzMzMzMzMzMyMjIzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMzMzMyMjIzMzMzMzMyMjIzMzMMFbxYAAAAWXRSTlMAAwYJDBARFRYYHiMkJigqKy0tMzk7PUBBQ0VJTFBSVVlbXGFla3B0dXh/hYeKjY+QkZSVlpiao6ausbK3u73DxcfIys3O0NPY3N3g4uXm6Ovu8fX3+Pr7/Z2GrlIAAAEvSURBVCjPdZJrT8JAEEVvC4ggqAiKiq0vlLa8tIoWBQFBRK0yIrTM//8jfighLWzPh8nNnsnMZrPAAlkxe+Q41DMVGUGiOrHbbzYazb7LpEf9TiVuKzEvx5Q2k7pUUo0HOX9vbsA1aZFNvl9ZI9+x6SWdq1ijyjoApGcWBFizNIAWxUUyTi0gwyUIKXEGZTchlgm3jG4HAAq2XQhWoNMF1QHAZraDFagTHCNMGg4mlbCxlT+MLIRgjWB9hTjp28IZ74vlIV8gQk9i2fqNABqfiJzKVwDk4Xhr3e3QmwQAKfrcXnUp+yfppSzRadCdT2hv2TfkS5/Kv3Av6fsWjgHk1d3NZFa9HfFYk/xzpkb0gT3mr9eR4JLp88f85qCoacXj2NrNp2wfhb0x3h83BKf/ogM3zcQrR7gAAAAASUVORK5CYII="
                      class="message-topic-write-icon"
                    />
                    写留言
                  </div>
                </div>
                <!---->
                <div data-v-4bc80e00="" class="message-edit-empty">
                  学习知识要善于思考，思考，再思考。—爱因斯坦
                </div>
                <!---->
              </div>
              <div
                data-v-7580e7ec=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 25vh; width: 400px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><button
                      type="button"
                      aria-label="Close"
                      class="el-dialog__headerbtn"
                    >
                      <i class="el-dialog__close el-icon el-icon-close"></i>
                    </button>
                  </div>
                  <!----><!---->
                </div>
              </div>
              <div
                data-v-e31d0af2=""
                data-v-daa3f53a=""
                class="el-dialog__wrapper"
                style="display: none"
              >
                <div
                  role="dialog"
                  aria-modal="true"
                  aria-label="dialog"
                  class="el-dialog el-dialog--center"
                  style="margin-top: 10vh; width: 500px"
                >
                  <div class="el-dialog__header">
                    <span class="el-dialog__title"></span
                    ><!---->
                  </div>
                  <!----><!---->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <video
      data-v-537ed502=""
      id="video"
      controls="controls"
      x-webkit-airplay="true"
      x5-video-player-fullscreen="true"
      preload="auto"
      playsinline="true"
      webkit-playsinline=""
      x5-video-player-type="h5"
      class="video vjs-default-skin"
    >
      <source data-v-537ed502="" type="application/x-mpegURL" src="" />
    </video>
    <!---->
    <div>
      <!---->
      <!---->
      <!---->
      <div
        data-v-51f7ab0d=""
        class="vux-alert purchase-alert-container"
        current-environment="PC"
      >
        <div class="vux-x-dialog">
          <div class="weui-mask" style="display: none"></div>
          <div class="weui-dialog" style="display: none">
            <div class="weui-dialog__hd">
              <strong class="weui-dialog__title">购买成功</strong>
            </div>
            <div class="weui-dialog__bd">
              <div data-v-51f7ab0d="" class="purchase-alert-content">
                <img
                  data-v-51f7ab0d=""
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAYAAAA5gg06AAAAAXNSR0IArs4c6QAADpNJREFUeAHtXQmQFNUZ/nt2F1h2OeQSBEG5VhBUFJVTAySiskBIggseGDUVKzGmirCIoIWJsYDIEqosSMWkClIrgXAUBHdRCLB4cEjkMKAIiBSi3LfLLsfuTuf/Xm/v9Ox2z/T09DWz81dNdU+/N+/97//mf/2/9/73fokShTYtbERlZ7uSJOeQHMhRrtSR2W8iPrKcrdxLjYnkcr4vJUm6LK7ino6SLB0gKXhAXLNaHaIhz1zldN+T5FsON81tTuWVD1KQhpLEH1nuybwGbOQ3yCDuI5lKuNQSapz+IQ2ZeNHG8m0ryl8gFc/tTFLlUwxILgvvbptBiSY0Bo12MXDFJKe/Q7kTD0f7gVvp3oMEjSmreoyBeYq7qUFuNTx6PdJmBuwdykpb5rWGeQcStIYqX2ZhTWCAGkYXmkc5JOka11xIlD7LK+1yH6TiuT0YnGncnY1nzUnzSPQWqpWquDtcQgFpJj2av89CAZZ/4h5I6+bcTBXBAuZ0LGuOe/VaFo3BDyVJ5pTllBHIp+GTvjXIZetj54W14+0MOnFpIvfv0xmcLFu597IwSSrj9rxO7ZrNpb7PVzjJirMgFc3+AXcR87kxMJ+TkxQz/gUaOfkDpxroDEjQnpOXZvJ7Z5JTjPuuXInmUNtmU53QKvtBWlPQiTVnKX/u950gnWZIkrZzt55HI/K/sbMqO0fwRGtmjyY5uLteAgRU8MdE+yEHG8k+kNbMnszd2yr+3GAjf4lXFNoPOUAeNlH83R3M6eICNq3l39nEUxIVI/2ZcvPzuQuE2W6Z4gNJGAjfL2A1f9IyB8n+Q0laRG2bPhuPQWEdJGX8s5JlnJvscrahfcU8nvqJVaCsvZPQxZ1kDUoBZBa/XCEvizMt1ubO+mbP4XfQ82Y5TOUTEriDDm5rQkvW/ydWecSuSUVvvpQyEmIVs5qfjSshP/W7uWts7yTY/0H53+aKTuXSlQAsPYnG0IjJq3XTdR6aB0nMJGCgWs/HQTpCjPmRRBdICvQxOzNhrruDJSemelIAxQyI3g/EgJenziBXE2QOJDFZWg/n4kwI0HIWTCFBriYoeneH5QaSN5koK5XFkgSkIdGWOSJrEtQR60Epck4CkG+Ubi8ySFhRTeYFO+dEb75kyBdyjkDG3Z3ik/Alg5Q8S94RBOFpEpbiMwI9jHwmjDUJTiMpgNzBDnJWnHR069PXpPcKevKg9XMGST9dt6jUw7gkgEFuQOql5y6mr0lBeWoKoLhEHvuPoRCQuw7VBQmepcJxUSd36lGYBPLa5dDqvmMoQ6orxrCMZr9A7sKzN/wHOqXD9TeRPEvDG+TGt5ysG6ikXx79655RNKptV3qlWz+bqoXchet1WHnh7xzhPF95krs6//pmh7Hv7pc0HjTmd7mXft99IDVKS6+pvCJYRfdtXkSffX+65pnlG/ieZ6W31W4SCNWEUpXdDSmAdCTcpXFzKrzrURrQon2d1OsM0o0Nee+aHQQFAQ5Ef1OLq9XdyRPUhNQ1JIEn2vegzx54WhegY1dKafDWJbTuzJHQD+K9E9uAQoWEujthMFR8HUpK3WUG0mlerx/Ssx176wpj58WTNOrTlXT8WpluelwPpYwu6labkCZhh12KaiRwS2ZT2jLwcUOA1p4+TA+wBjkCELjQ4BECSaaRNRzW85thLTvSzsETqE+zG3UlUXTqEI3+dBWVByt10215qMFD6e5g1V2uOMeFh0CzpabEK+RXne6it24fRukBfVGsPHGQxu0qogo56HTjgpSd0RJWnsIJdnnXc4AgiLduH0p/6f0jQ4CWHt9PebvedQMg/AECYvd9DTDYhl+PqVEgjVbcM5pevPUeQym8d+owPbm7mCrluDyGDcvXTajGRRkniXMSdLMl/cMWGY3o3XvH0MAWHQzb+smF4zR252p3AQI3wEVccNLI5TOwIZWuD0/rCbVrmEXr+z1GtzdpZdjiL0vP0aCti+l8hSeHp/B7qXVWujgKph4CBBN7AwPUhefhjAgD1eHbl3sFENgKAJ/06jN6jPhMyueYIN3AE6QdMpsYtu9KVQX9eMcq+vZqqWEeVxL4LKV0cZgSH+BTX6g7A7Sp/zhq1yg7YpOf+99a2nHpVMQ8riTyYVcBoUmu1OZ9Jd2ympsCaOZXn9ASNrd9QaxJAV7g6+gLZhxmoivPYm/qN45uiqJBa059Ta8e+NhhbmIonvGBRWfcMcdQlp+zdmBgNvbPo/YR3kHg//jVy/Tzz973W+ffJOlBapWRKczsjmzNRaIgD1IxWD1bcSVSNi/SkhukJmkZ9P79P6PbsltGFe6sQ9tp0zlXjgqKykutDAySnJzdXQN2Dll9L29Tbd62VpvrfsWMwmsHN9dN8MMTxgfdXabbvNzEI30MJp2kBXc+QkNaRbeJLlVco/E8q+3qnFxsDc9kkMShsrH9LI7cbRmgEh6nYL3mkda3xlGS8U//mDOInuhg7syp5/esoyNXvjcuzPMUuZzHSeLEX1dYubFBYx6n5FFOdgtq0SCT1tz3U/a8GWDrpOFzN/emV7v1N9WeBUf30tITB0zl9TBTKbo7V+Y92jBAJQyQ9iUuSRK9xu5RAKslz0bHS0N5RfWvvR8yVczBy+fpt19sNJXX00ysRK6A1Jq1ZiNPZvY0mG1+uE1n0f31NViuNiOkzo2b0TJ2VjRaUdWWIbO5/Ys9a9lzytGzBLVVxnPvvCZhnLKRJzN7NW0dkdFOLOTNAx6nX3a8I2I+vcRsNrXh7tuS/wxm6O9H99DH54+ZyeqHPAySxCfPO0TowrAc0DsKQGr1Ddkr9O07htM/2DKDO5UZgpMGnBaj/QnUsk7yrMKULz9Uv/r/yvjwOIlDAzhAWPEEQHc2axNz6U/f3Iu2DXyC4DUajaZ3G0Bj2nWPlq0m/UV+D12svFbz3fc3jA9rEsducIDQBWXyxyoB3B2Dn6KRbboYFvFQq1toOluHZgmuWCvY2yehiPFxTJOO8mLZwC3/pO08mrdKzVkbV7P/wYycwQRneS2150nTRX1G8L6r8OfaPNr70srr9Ou967WPEuNeaBKin5AzE7/n2C9g6LalBE8bqwQzfSpvLVnXbyzBSgSl87Nld4+i1jE4yb+y/2P6jt9HCUZBYnwCIjwNjk12iODlOXrHSlr47d64ahjWqhPtGvw09Wvejmbd9qCu87xRBdDm+Ud2GSX79zlw4fBBigmF8DREvZziFvNiz/Jy9ImrZTQtjg1X8En4aMB43qjNe61MEpYgXvh8gzNdhUkeLGdTcKmekUH8IBfoFV7xfBECY8FZpVgAQh3Q4J1+8FWw0uBqXDDjQCLAk0Pvpdq8zTuyW7jqXqty0Nm9ulLMcE/jd1GCUrAal2pNQgQuSdrtVmNgBj/83xUEITpJrx/cSqevlztZhXNlI+BWdWQ0RZNQlURFztVYt+QPeBVU7O9xyOL6uuwCzUtEY0EVFSKiVVMIJIRIc5n2lJ6hATyWOsAz0nbTy/s/ouvOb0+xm+1QeRo8QiCJGHYcIs1l+oYX3DDoxRK2XbSVJ08TbmYhrPGMgyamYAgkZEIMOw8Ig95hPOiFz5sd9FIiTaDqNbgWDuEgIcigEsNO76eOPsOgF77X8Q56MT+35ULCLEPUlak4x4Fx0FA4SIo1UahJd/VWHfTOYDdfK4TxF6Z/EpwKVatObUc4SOIpR4EkDjLoIWHQ+5u9sQ96Fx/bR3tLz3rIebxVQ+6QfzjVBQkvLESB9JjmfxPboLeKLbk/8LgooQly1xgMalvqgoQUhOmMM5yMWkE8V1ho2MRlZtBb+N0XdKjcl1GxzYlAOe9O93RjfZCUOKrLzZXubK4Pz38XddBbGQzSG19tc5YR50tfrncgIarVBwkpiKOKs0F9QOqgd/9lHDVRlxYd+4IOl1+qm5AoT5QzWPON2DUGCYFuEUfVJ4RB76Ati+sMemHRzThkzRr0SdPYiZjlHCGwsDFIaAEC3Tq4IBirkNRBb7Fm0LucPVC/Kkvod9E+IecIwogMEiIR85qZH4wItQ0Y9I7hQS9chEF/4i0rCUswFiDfKBGfzXlxFL/Jx0/7L7DvY3wG6jL/+3Ib/4cQQDj3JcN3kfrDyJqk5kIkYiLfdfwJDRDkqchVlbLh1RxIUMdAYBwPci8YlpRKMC8ByBHyjNLNqQWaAwm5ESpakp7x0/tJbURCXfEeghxjCL1tHiQBFIc4k2hKQgnFb8xCfjGEigP75gyH2g0tmj2HjftUhObacon6nSM4j5w8KWq2WhmsgYQj+9cUFPIg7Mla5aW+GkkAkZtH5E+w8rqIrbtTGUC/ilDRRDXOEmpS6qorgWIhL8jNAlkDCRXBMkGoaPxDUmQsAcgnjpDaKNhad6dlCV1fcUFB6h2lFYp6z++g3HxMVFvSILUU65qklgAGlJfhlHiZUYtM+KsCyhQhlzgBgizi1yStRBHRWZYX8hSS8XGM2vzJeC8C/WIcZD4iczQx2AsSahORnTnQLeKo1jeSpO3cm+TFMlA1IyL7QUKtCMkpAgj7b1LWjFAs5cFkKebiTE71xFKHMyCpHCCQMOKoJnMYVKy3Yblh5OQP1GbbfXUWJHALrUIcVUmazmAlTzhULHljRRULow5ojxZo50FSa1Pi1rKpTmO5ce7Vq9Zv11Wx1pYLH5AIS952VYdy3BdW8dweHLduGncR43lslWZnY5wtix0X4RcHdzfFm8rZ6jSluw+SWrmIAimCDE5gzfJviDrFN75QeJbqOC6qzXHy6h1IaqtEsEfEsONQdbI8UH3s+VWStnBHU0jYxFC9484rnrwHSdtyaBcicCHAkyz34aT4Z0S05Ue+D7Jxs5u7tCLCBi6PtEaPRX+BpOUQGoa4TghPI6LSyDgK0k7QAArM5xIutURsIvZYY7TN1977FyQtl7hHdBoOrqHE1gjkVMfYwCGrONdc+SiH/uLYlCsMbClfQx+cRobDrnCWEq44CYYPsuA8vqf/AzeOq1TDOdDkAAAAAElFTkSuQmCC"
                  alt="购买成功"
                  class="purchase-success-img"
                />
              </div>
            </div>
            <div class="weui-dialog__ft">
              <a
                href="javascript:;"
                class="weui-dialog__btn weui-dialog__btn_primary"
                >我知道了</a
              >
            </div>
          </div>
        </div>
      </div>
      <!---->
      <!---->
      <!---->
      <!---->
      <div data-v-0b91fc6d="" class="pc-all-dirlog-wrap">
        <div
          data-v-467635e0=""
          data-v-0b91fc6d=""
          class="el-dialog__wrapper sale-pc-all-dirlog"
          style="display: none"
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-label="dialog"
            class="el-dialog el-dialog--center"
            style="margin-top: 25vh; width: 500px"
          >
            <div class="el-dialog__header">
              <span class="el-dialog__title"></span
              ><button
                type="button"
                aria-label="Close"
                class="el-dialog__headerbtn"
              >
                <i class="el-dialog__close el-icon el-icon-close"></i>
              </button>
            </div>
            <!----><!---->
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- 如需在IE8、9浏览器中初始化播放器，浏览器需支持Flash并在页面中引入 -->
  <!--[if lt IE 9]>
    <script src="//imgcache.qq.com/open/qcloud/video/tcplayer/ie8/videojs-ie8.js"></script>
  <![endif]-->

  <script
    id="_lgpassport_"
    data-css-site="0"
    data-css-popup="0"
    type="text/javascript"
    src="https://passport.lagou.com/static/js/passport.js"
  ></script>

  <script type="text/javascript">
    //后端变量赋值
    window.courseInfo = {
      id: 946,
      courseCId: "",
      courseName: "Vue.js 3.0 核心源码内参",
      teachers: [
        {
          id: 696,
          teacherName: "HuangYi",
          position: "Zoom 前端架构师，前百度、滴滴资深技术专家",
          teacherHeadPicUrl:
            "https://s0.lgstatic.com/i/image6/M00/41/62/CioPOWCrp-6Aapx_AAArHqFn_nM169.png",
          description:
            '<p><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 14px;">现任 Zoom 前端架构师，主要负责推进前后端分离架构方案和 Zoom 自研组件库，不仅将Vue.js 带入 Zoom，而且通过魔改 Vue.js 源码开发了 Vue.js 2.x 的 CSP 兼容版本，并稳定服务于几十个用 Vue.js 做增强开发的页面。之前，他先后在百度和滴滴担任前端资深技术专家，并曾使用 Vue.js 重构了滴滴出行WebApp，主导开发 Vue.js 开源组件库 cube-ui。</span></p><p><span style="color: rgb(43, 47, 54); font-family: LarkEmojiFont, LarkChineseQuote, -apple-system, system-ui, &quot;Helvetica Neue&quot;, Tahoma, &quot;PingFang SC&quot;, &quot;Microsoft Yahei&quot;, Arial, &quot;Hiragino Sans GB&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-size: 14px; font-variant-ligatures: none; white-space: pre-wrap; background-color: rgb(255, 255, 255);"><br/></span></p>',
        },
      ],
      totalCourseTime: 28,
      totalDuration: 440,
      sales: 768,
      price: "0",
      priceTag: "立即购买",
      discounts: "98",
      discountsTag: "立即购买",
      courseImgUrl:
        "https://s0.lgstatic.com/i/image6/M00/41/62/CioPOWCrp-6Aapx_AAArHqFn_nM169.png",
      sellGoodsId: 1004,
      sellGoodsPriceId: 40841,
      lgCoinPrice: 98,
      isBuy: false,
      isFavorite: false,
      isNewDes: "",
      seoDescription:
        "Vue.js 作为前端最火的三大主流框架之一，越来越多的公司将其作为项目开发的技术栈，抑或将原有项目迁移过来。对于从业者和求职者来说，学会阅读Vue.sj 源码有助于从底层逻辑学习框架原理，这很大程度上帮助前端开发者提高工作效率。",
      seoKeywords:
        "关键词：前端开发,Vue,源码分析,架构师,JavaScript,Composition API,Java, Vue.js,React , MVVM 框架,JavaScript, cube-ui 开发,uni-app,Mpx,chameleon,WePY,组件渲染,DOM diff, 组件渲染,vnode ,侦听器,共享数据,AST,Props,Virtual DOM,Snabbdon,patch,Diff 算法,Dep,底层原理,VueapI,Vue-cli,原生内置功能,Tree-shaking,代码逻辑,模板无关性,",
      seoTitle: "Vue.js 3.0 核心源码解析 - 前百度、滴滴资深技术专家 - 拉勾教育",
      shareTitle: "Vue.js 3.0 核心源码解析，新鲜出炉！",
      shareDescription: "前百度、滴滴资深技术专家带你成为高阶前端！",
      brief: "深入分析核心源码，透彻理解 Vue.js 3.0 实现原理",
      courseListImg:
        "https://s0.lgstatic.com/i/image6/M00/41/5A/Cgp9HWCrqJeAfHpMAAEhcFmUStA456.png",
      courseType: 1,
      previewFirstField: "共28讲",
      previewSecondField: "已全部更新",
      joinMember: false,
      freeForVip: true,
      decorateId: 942,
      successShowType: "COURSE_COMMUNITY",
      appDecorateId: 0,
      recruitAppDecorateId: 0,
      joinSeckill: false,
      seckillRemainSeconds: "0",
      hasActivityTask: false,
      enterpriseDecorateId: 942,
      hasCoupon: false,
      hasActivityGroup: false,
      synEnterprise: true,
      classCourseType: 0,
    }
    window.isLogin = true
    window.sellGoodsPriceId = -1
    window.orderToken = "b6ab25786e164c088d2551b21ab5d605"
    window.userInfo = {
      id: 20015885,
      nickName: "张熙远",
      isActive: 0,
      portrait:
        "https://s0.lgstatic.com/common/image/pc/default_boy_headpic1.png",
    }
    window.enterNewPage = false
    window.activityButtonInfo = null
  </script>
  <script
    type="text/javascript"
    src="https://s21.lgstatic.com/growth/activity/20201206/1607238135888.js"
    crossorigin=""
  ></script>

  <!-- <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> -->

  <!---->
  <!---->

  <script
    type="text/javascript"
    src="https://s1.lgstatic.com/kw-web-fed/js/dll/vendor.424fdf064e46228ef60d.dll.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/runtime~course/main.807e6d9.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/common.29b3b88.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/vendors~404/main~500/main~activity-collage/main~activity/main~activity818/main~algorithm-shock/main~~4141e3fd.69f9030.js"
    crossorigin="anonymous"
  ></script>
  <script
    src="https://s0.lgstatic.com/kw-web-fed/js/lazy-load/course/main.9a9f2f8.js"
    crossorigin="anonymous"
  ></script>
  <div class="lg-pay lg-recharge-pay-container">
    <div class="lg-pay-container recharge-pay-container">
      <div class="lg-pay-close"></div>
      <div class="modal-payment-title">
        <i class="icon-hd"></i>
        <span class="title-text">已开启安全支付</span>
      </div>
      <div class="amount-coupon"></div>
      <div class="recharge-pay-title">请选择支付方式</div>
      <div class="pay-methods">
        <div class="pay-method-list">
          <div
            class="
              lg-pay-select lg-pay-select-ali
              pay-method-item pay-ali
              active
            "
          >
            <i class="pay-icon-ali"></i>
            <span class="pay-method-name">支付宝支付</span>
          </div>
          <div class="lg-pay-select lg-pay-select-wx pay-method-item pay-wx">
            <i class="pay-icon-wx"></i>
            <span class="pay-method-name">微信支付</span>
          </div>
        </div>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-wx">
        <canvas id="wxQrcode"></canvas>
      </div>
      <div class="lg-pay-qrcode lg-pay-qrcode-ali" style="display: block">
        <canvas id="aliQrcode"></canvas>
      </div>

      <div class="pay-qrcode-status">
        <span>
          <span class="left-text">未支付成功，请重新扫码支付</span>
          <div class="pay-tips">
            <span>使用支付宝扫码支付</span>
            <a class="link"> 我已支付 </a>
          </div>
        </span>
      </div>
      <div class="pay-notes">
        <span
          >付费即表示同意<a
            href="https://activity.lagou.com/app/business/service-agreement.html"
            }=""
            target="_blank"
            >《拉勾网在线增值服务协议》</a
          ></span
        >
      </div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <div class="lg-pay-recharge" style="display: none">
    <div class="lg-pay-container lg-pay-recharge-confirm">
      <div class="lg-pay-close"></div>
      <div class="recharge-title">勾豆充值</div>
      <div>
        <div class="recharge-label">填写充值勾豆数量</div>
        <div class="recharge-amount">
          <input
            type="text"
            class="amount input"
            min="0"
            max="9999"
            value="100"
          />
        </div>
      </div>
      <div class="recharge-tips">
        需支付：<span class="count-show">100元</span
        ><span class="recharge-description">（1元=1勾豆）</span>
      </div>
      <div class="recharge-btn">立即充值</div>
    </div>
  </div>
  <script
    type="text/javascript"
    crossorigin="anonymous"
    src="https://kaiwu.lagou.com/upload/oss.js?v=1010"
  ></script>

  <div
    class="xl-chrome-ext-bar"
    id="xl_chrome_ext_{4DB361DE-01F7-4376-B494-639E489D19ED}"
    style="display: none"
  >
    <div class="xl-chrome-ext-bar__logo"></div>

    <a
      id="xl_chrome_ext_download"
      href="javascript:;"
      class="xl-chrome-ext-bar__option"
      >下载视频</a
    >
    <a
      id="xl_chrome_ext_close"
      href="javascript:;"
      class="xl-chrome-ext-bar__close"
    ></a>
  </div>
  <script></script>
  <div id="cboxOverlay" style="display: none"></div>
  <div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none">
    <div id="cboxWrapper">
      <div>
        <div id="cboxTopLeft" style="float: left"></div>
        <div id="cboxTopCenter" style="float: left"></div>
        <div id="cboxTopRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxMiddleLeft" style="float: left"></div>
        <div id="cboxContent" style="float: left">
          <div id="cboxTitle" style="float: left"></div>
          <div id="cboxCurrent" style="float: left"></div>
          <button type="button" id="cboxPrevious"></button
          ><button type="button" id="cboxNext"></button
          ><button id="cboxSlideshow"></button>
          <div id="cboxLoadingOverlay" style="float: left"></div>
          <div id="cboxLoadingGraphic" style="float: left"></div>
        </div>
        <div id="cboxMiddleRight" style="float: left"></div>
      </div>
      <div style="clear: left">
        <div id="cboxBottomLeft" style="float: left"></div>
        <div id="cboxBottomCenter" style="float: left"></div>
        <div id="cboxBottomRight" style="float: left"></div>
      </div>
    </div>
    <div
      style="
        position: absolute;
        width: 9999px;
        visibility: hidden;
        display: none;
      "
    ></div>
  </div>
</body>
