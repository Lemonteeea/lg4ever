{"title":"33 | 如何追踪分布式系统调用链路的问题？","context":"\n                    <p data-nodeid=\"139375\" class=\"\">\n                      微服务极大地改变了软件的开发和交付模式，单体应用被拆分为多个微服务，单个服务的复杂度大幅降低，库之间的依赖也转变为服务之间的依赖。由此带来的问题是部署的粒度变得越来越细，众多的微服务给运维带来巨大压力，即使有了\n                      Docker 容器和服务编排组件\n                      Kubernetes，这依然是个严肃的问题。\n                    </p>\n\n                    <h3 data-nodeid=\"138732\">\n                      常见的追踪分布式系统调用链路的方式\n                    </h3>\n                    <p data-nodeid=\"138733\">\n                      在分布式系统场景中，一个请求可能需要经历多个业务单元的处理才能完成响应，如果出现了错误或异常，是很难定位的。因此，利用分析性能问题的工具以及理解系统的行为就变得很重要了。\n                    </p>\n                    <p data-nodeid=\"138734\">\n                      对于早期系统或者服务来说，开发人员一般<strong\n                        data-nodeid=\"138810\"\n                        >通过打日志的方式来进行埋点</strong\n                      >（常用的数据采集方式），然后再根据日志系统和性能监控定位及分析问题。采用日志打点的方式，虽然可以排查大部分的问题，但是侵入性非常大，且对于出现的紧急问题，往往并不能快速进行响应处理。对于排查性能问题，涉及更改的工作量更大，具体到调用的每个服务和服务里面的方法，得到的结果往往也是事倍功半。\n                    </p>\n                    <p data-nodeid=\"138735\">\n                      除了日志打点的方式，有时甚至会出现开发人员<strong\n                        data-nodeid=\"138816\"\n                        >直接连接服务器进行代码调试</strong\n                      >的情况，这种方式的优点是能够针对请求涉及的某个服务进行排查，或许也能快速解决，但其弊端是显而易见的，线上生产环境很多时候并不具备直接Debug\n                      调试的条件，这种调试也是严重影响了线上服务的正常运行。特别是随着业务变得越来越复杂，现代互联网服务通常会使用复杂的、大规模的分布式系统来实现。\n                    </p>\n                    <p data-nodeid=\"138736\">\n                      虽说传统的日志监控和服务器调试的方式也可以解决业务异常问题，但是很显然，这两种方式已经无法满足跟踪调用、排查问题等一系列需求了。\n                    </p>\n                    <h3 data-nodeid=\"138737\">为什么需要分布式链路追踪</h3>\n                    <p data-nodeid=\"138738\">\n                      如上所述，随着服务数量的增多和内部调用链的复杂化，开发者仅凭借日志和性能监控，难以做到全局的监控，在进行问题排查或者性能分析时，无异于“盲人摸象”。\n                    </p>\n                    <p data-nodeid=\"138739\">\n                      为了解决这个问题，业界推出了<strong data-nodeid=\"138825\"\n                        >分布式链路追踪组件</strong\n                      >。Google 内部开发了\n                      Dapper，用于收集更多的复杂分布式系统的行为信息；Twitter\n                      开源了分布式链路追踪组件\n                      Zipkin；同时，也有很多其他公司开发了自己的链路追踪组件。\n                    </p>\n                    <p data-nodeid=\"138740\">\n                      <strong data-nodeid=\"138829\"\n                        >分布式链路追踪不仅能够帮助开发者直观分析请求链路，快速定位性能瓶颈，逐渐优化服务间的依赖，而且还有助于开发者从宏观角度更好地理解整个分布式系统。</strong\n                      >\n                    </p>\n                    <h3 data-nodeid=\"138741\">什么是分布式链路追踪</h3>\n                    <p data-nodeid=\"138742\">\n                      在微服务架构下，原单体服务被拆分为多个微服务独立部署，客户端的请求涉及多个微服务，从而无法知晓服务的具体位置。系统由大量服务组成，这些服务可能由不同的团队开发，可能使用不同的编程语言来实现，多实例部署，这些实例横跨多个不同的数据中心。在这种环境中，当出现错误异常或性能瓶颈时，<strong\n                        data-nodeid=\"138840\"\n                        >获取请求的依赖拓扑</strong\n                      >和<strong data-nodeid=\"138841\">调用详情</strong\n                      >对于解决问题是非常有效的。\n                    </p>\n                    <p data-nodeid=\"138743\">\n                      <strong data-nodeid=\"138853\"\n                        >所谓分布式链路追踪，就是记录一次分布式请求的调用链路，并将分布式请求的调用情况集中展示</strong\n                      >。其中，<strong data-nodeid=\"138854\">调用详情</strong\n                      >包括各个请求的服务实例信息、服务节点的耗时、每个服务节点的请求状态等；分布式链路追踪还可以分析出<strong\n                        data-nodeid=\"138855\"\n                        >请求的依赖拓扑，即这次请求涉及哪些服务、这些服务上下游的关系等，这对于排查性能瓶颈非常有帮助。</strong\n                      >\n                    </p>\n                    <h3 data-nodeid=\"138744\">链路追踪与日志、Metrics 的关系</h3>\n                    <p data-nodeid=\"138745\">\n                      在上文我们提到早期通常是使用日志和监控的方式来排查系统问题的，但在工作中我发现一些开发者对链路追踪和日志、Metrics\n                      三者之间的关系并不是很清楚，经常会混淆，因此这里我们就简要介绍下这三者。\n                    </p>\n                    <p data-nodeid=\"140533\">\n                      Tracing 表示链路追踪，Logging 和 Metrics\n                      是与之相近的两个概念。这三者的关系如下图所示：\n                    </p>\n                    <p data-nodeid=\"140534\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/73/Ciqc1F-GvOSAV_BRAAEKN28KEAQ070.png\"\n                        alt=\"image (4).png\"\n                        data-nodeid=\"140543\"\n                      />\n                    </p>\n                    <div data-nodeid=\"140535\">\n                      <p style=\"text-align: center\">\n                        Tracing &amp; Logging &amp; Metrics三者的关系\n                      </p>\n                    </div>\n\n                    <ul data-nodeid=\"138749\">\n                      <li data-nodeid=\"138750\">\n                        <p data-nodeid=\"138751\">\n                          Tracing：记录单个请求的处理流程，其中包括服务调用和处理时长等信息。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138752\">\n                        <p data-nodeid=\"138753\">\n                          Logging：用于记录离散的日志事件，包含程序执行到某一点或某一阶段的详细信息。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138754\">\n                        <p data-nodeid=\"138755\">\n                          Metrics：可聚合的数据，通常是固定类型的时序数据，包括\n                          Counter、Gauge、Histogram 等。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"138756\">\n                      同时，这三者相交的情况（或者说混合出现）也比较常见。\n                    </p>\n                    <ul data-nodeid=\"138757\">\n                      <li data-nodeid=\"138758\">\n                        <p data-nodeid=\"138759\">\n                          Logging &amp;\n                          Metrics：可聚合的事件。例如，分析某对象存储的 Nginx\n                          日志，统计某段时间内 GET、PUT、DELETE、OPTIONS\n                          操作的总数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138760\">\n                        <p data-nodeid=\"138761\">\n                          Metrics &amp;\n                          Tracing：单个请求中的可计量数据。例如，SQL\n                          执行总时长、gRPC 调用总次数等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138762\">\n                        <p data-nodeid=\"138763\">\n                          Tracing &amp; Logging：请求阶段的标签数据。例如，在\n                          Tracing 的信息中标记详细的错误原因。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"138764\">\n                      针对这每种分析需求，我们都有非常强大的集中式分析工具。\n                    </p>\n                    <ul data-nodeid=\"138765\">\n                      <li data-nodeid=\"138766\">\n                        <p data-nodeid=\"138767\">\n                          Logging：ELK（Elasticsearch、Logstash和Kibana），Elastic\n                          公司提供的一套完整的日志收集以及展示的解决方案。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138768\">\n                        <p data-nodeid=\"138769\">\n                          Metrics：Prometheus，专业的Metric\n                          统计系统，存储的是时序数据，即按相同时序（相同名称和标签），以时间维度存储连续数据的集合。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138770\">\n                        <p data-nodeid=\"138771\">\n                          Tracing：Jaeger，是 Uber 开源的一个兼容 OpenTracing\n                          标准的分布式追踪服务。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"138772\">\n                      通过以上讲解，你现在应该知道，<strong data-nodeid=\"138889\"\n                        >Tracing、Logging 和 Metrics\n                        这三者之间有一定的关系，既可以单独使用，也可以组合使用</strong\n                      >。每一个组件都有其侧重点，Tracing\n                      用于追踪具体的请求，绘制调用的拓扑；Logging\n                      则是主动记录的日志事件；Metrics\n                      记录了请求相关的时序数据，通常用于性能统计。在分布式系统中，这三者通常是组合在一起使用。\n                    </p>\n                    <h3 data-nodeid=\"138773\">分布式链路追踪的基础概念</h3>\n                    <p data-nodeid=\"138774\">\n                      分布式链路追踪组件涉及 Span、Trace、Annotation\n                      等基本概念，这些概念还是比较重要的，所以下面我们就具体介绍下这些概念。\n                    </p>\n                    <ul data-nodeid=\"138775\">\n                      <li data-nodeid=\"138776\">\n                        <p data-nodeid=\"138777\">\n                          <strong data-nodeid=\"138896\"\n                            >Span，分布式链路追踪组件的基本工作单元</strong\n                          >。一次请求，即发起的一次链路调用（可以是 RPC、DB\n                          调用等）会创建一个\n                          Span。通过一个64位ID标识Span，通常使用 UUID，Span\n                          中还有其他的数据，例如描述信息、时间戳、parentID\n                          等，其中 parentID 用来表示 Span 调用链路的层级关系。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138778\">\n                        <p data-nodeid=\"138779\">\n                          <strong data-nodeid=\"138901\"\n                            >Trace，Span 集合，类似树结构</strong\n                          >。表示一条完整的调用链路，存在唯一标识。Trace\n                          代表了一个事务或者流程在系统中的执行过程，由多个 Span\n                          组成的一个有向无环图，每一个 Span 代表 Trace\n                          中被命名并计时的连续性的执行片段。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"138780\">\n                        <p data-nodeid=\"138781\">\n                          <strong data-nodeid=\"138906\">Annotation，注解</strong\n                          >。用来记录请求特定事件相关信息（例如时间），通常包含\n                          4 种注解信息，分别包括：①CS（Client\n                          Sent），表示客户端发起请求；②SR（Server\n                          Received），表示服务端收到请求；③SS（ServerSent），表示服务端完成处理，并将结果发送给了客户端；④CR（Client\n                          Received），表示客户端获取到服务端返回信息。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"138782\">\n                      链路信息的还原依赖于两种数据：一种是各个节点产生的事件，如\n                      CS、SS，称为<strong data-nodeid=\"138916\">带外数据</strong\n                      >，这些数据可以由节点独立生成，并且需要集中上报到存储端；另一种数据是TraceID、SpanID、ParentID，用来标识\n                      Trace、Span 以及 Span 在一个Trace中的位置，称为<strong\n                        data-nodeid=\"138917\"\n                        >带内数据</strong\n                      >，这些数据需要从链路的起点一直传递到终点。\n                    </p>\n                    <p data-nodeid=\"138783\">\n                      <strong data-nodeid=\"138921\"\n                        >通过带内数据的传递，可以将一个链路的所有过程串起来；通过带外数据，可以在存储端分析更多链路的细节。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"141710\">\n                      下图展示了 Trace 树的运行机制，通过 Trace\n                      树我们可以了解一次请求过程中链路追踪的基本运行原理。\n                    </p>\n                    <p data-nodeid=\"141711\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/7F/CgqCHl-GvPCASsTBAACuOCx60p8798.png\"\n                        alt=\"image (5).png\"\n                        data-nodeid=\"141720\"\n                      />\n                    </p>\n                    <div data-nodeid=\"141712\">\n                      <p style=\"text-align: center\">Trace 树</p>\n                    </div>\n\n                    <p data-nodeid=\"138787\">\n                      对于每个 Trace 树，Trace 都要定义一个全局唯一的\n                      TraceID，在这个跟踪中的所有 Span\n                      都将获取到这个TraceID。每个 Span 都有一个 ParentID\n                      和它自己的 SpanID。上面图中 Frontend Request 调用的\n                      ParentID 为空，SpanID 为 1；然后 Backend Call 的 ParentID\n                      为 1，SpanID 为 2；Backend DoSomething 调用的 ParentID\n                      也为 1，SpanID 为 3，其内部还有两个调用，Helper Call 的\n                      ParentID 为 3，SpanID 为 4，以此类推。\n                    </p>\n                    <p data-nodeid=\"138788\">\n                      <strong data-nodeid=\"138932\"\n                        >Span\n                        表示一个服务调用的开始和结束时间，即执行的时间段</strong\n                      >。分布式链路追踪组件记录了 Span 的名称以及每个 SpanID 的\n                      ParentID，如果一个 Span 没有 ParentID 则被称为 Root\n                      Span，当前节点的 ParentID 即为调用链路上游的\n                      SpanID，所有的 Span 都属于一个特定的 Trace，共用一个\n                      TraceID。\n                    </p>\n                    <h3 data-nodeid=\"138789\">小结</h3>\n                    <p data-nodeid=\"138790\">\n                      分布式链路追踪组件主要用来追踪分布式系统调用链路的问题。\n                    </p>\n                    <p data-nodeid=\"138791\">\n                      本课时我们主要介绍了分布式链路追踪组件产生的背景，以及分布式链路追踪的相关概念。分布式链路追踪组件对于快速解决线上问题、发现性能瓶颈并优化分布式系统的性能、合理部署服务器资源具有重要的作用。在接下来的课时中，我们将具体介绍几种业界流行的分布式链路追踪组件，并选择其中的一款进行实践。\n                    </p>\n                    <p data-nodeid=\"138792\">\n                      关于分布式链路追踪，你有什么经验和踩坑的经历呢？欢迎你在留言区和我分享。\n                    </p>\n            "}