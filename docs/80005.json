{"title":"02 | 组件更新：完整的 DOM diff 流程是怎样的？（上）","context":"\n                    <p data-nodeid=\"547\" class=\"\">\n                      上一节课我们梳理了组件渲染的过程，本质上就是把各种类型的\n                      vnode 渲染成真实\n                      DOM。我们也知道了组件是由模板、组件描述对象和数据构成的，数据的变化会影响组件的变化。组件的渲染过程中创建了一个带副作用的渲染函数，当数据变化的时候就会执行这个渲染函数来触发组件的更新。那么接下来，我们就具体分析一下组件的更新过程。\n                    </p>\n                    <h3 data-nodeid=\"548\">副作用渲染函数更新组件的过程</h3>\n                    <p data-nodeid=\"549\">\n                      我们先来回顾一下带副作用渲染函数 setupRenderEffect\n                      的实现，但是这次我们要重点关注更新组件部分的逻辑：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建响应式的副作用渲染函数</span>\n</div></li><li><div class=\"code-word\">  instance.update = effect(<span class=\"hljs-function\">function <span class=\"hljs-title\">componentEffect</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!instance.isMounted) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 渲染组件</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 更新组件</span>\n</div></li><li><div class=\"code-word\">      let { next, vnode } = instance\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// next 表示新的组件 vnode</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (next) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 更新组件 vnode 节点信息</span>\n</div></li><li><div class=\"code-word\">        updateComponentPreRender(instance, next, optimized)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        next = vnode\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 渲染新的子树 vnode</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> nextTree = renderComponentRoot(instance)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 缓存旧的子树 vnode</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> prevTree = instance.subTree\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 更新子树 vnode</span>\n</div></li><li><div class=\"code-word\">      instance.subTree = nextTree\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 组件更新核心逻辑，根据新旧子树 vnode 做 patch</span>\n</div></li><li><div class=\"code-word\">      patch(prevTree, nextTree,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点</span>\n</div></li><li><div class=\"code-word\">        hostParentNode(prevTree.el),\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 参考节点在 fragment 的情况可能改变，所以直接找旧树 DOM 元素的下一个节点</span>\n</div></li><li><div class=\"code-word\">        getNextHostNode(prevTree),\n</div></li><li><div class=\"code-word\">        instance,\n</div></li><li><div class=\"code-word\">        parentSuspense,\n</div></li><li><div class=\"code-word\">        isSVG)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 缓存更新后的 DOM 节点</span>\n</div></li><li><div class=\"code-word\">      next.el = nextTree.el\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }, prodEffectOptions)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"551\">\n                      可以看到，更新组件主要做三件事情：<strong\n                        data-nodeid=\"629\"\n                        >更新组件 vnode 节点、渲染新的子树 vnode、根据新旧子树\n                        vnode 执行 patch 逻辑</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"552\">\n                      首先是更新组件 vnode\n                      节点，这里会有一个条件判断，判断组件实例中是否有新的组件\n                      vnode（用 next 表示），有则更新组件 vnode，没有 next\n                      指向之前的组件\n                      vnode。为什么需要判断，这其实涉及一个组件更新策略的逻辑，我们稍后会讲。\n                    </p>\n                    <p data-nodeid=\"553\">\n                      接着是渲染新的子树\n                      vnode，因为数据发生了变化，模板又和数据相关，所以渲染生成的子树\n                      vnode 也会发生相应的变化。\n                    </p>\n                    <p data-nodeid=\"554\">\n                      最后就是<strong data-nodeid=\"637\"\n                        >核心的 patch 逻辑</strong\n                      >，用来找出新旧子树 vnode 的不同，并找到一种合适的方式更新\n                      DOM，接下来我们就来分析这个过程。\n                    </p>\n                    <h4 data-nodeid=\"555\">核心逻辑：patch 流程</h4>\n                    <p data-nodeid=\"556\">我们先来看 patch 流程的实现代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> patch = (n1, n2, container, anchor = <span class=\"hljs-keyword\">null</span>, parentComponent = <span class=\"hljs-keyword\">null</span>, parentSuspense = <span class=\"hljs-keyword\">null</span>, isSVG = <span class=\"hljs-keyword\">false</span>, optimized = <span class=\"hljs-keyword\">false</span>) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) {\n</div></li><li><div class=\"code-word\">    anchor = getNextHostNode(n1)\n</div></li><li><div class=\"code-word\">    unmount(n1, parentComponent, parentSuspense, <span class=\"hljs-keyword\">true</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// n1 设置为 null 保证后续都走 mount 逻辑</span>\n</div></li><li><div class=\"code-word\">    n1 = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> { type, shapeFlag } = <span class=\"hljs-function\">n2\n</span></div></li><li><div class=\"code-word\">  <span class=\"hljs-title\">switch</span> <span class=\"hljs-params\">(type)</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> Text:\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 处理文本节点</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">break</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> Comment:\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 处理注释节点</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">break</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> Static:\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 处理静态节点</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">break</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> Fragment:\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 处理 Fragment 元素</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">break</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">default</span>:\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">/* ELEMENT */</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 处理普通 DOM 元素</span>\n</div></li><li><div class=\"code-word\">        processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">6</span> <span class=\"hljs-comment\">/* COMPONENT */</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 处理组件</span>\n</div></li><li><div class=\"code-word\">        processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">64</span> <span class=\"hljs-comment\">/* TELEPORT */</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 处理 TELEPORT</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">128</span> <span class=\"hljs-comment\">/* SUSPENSE */</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 处理 SUSPENSE</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">isSameVNodeType</span> <span class=\"hljs-params\">(n1, n2)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// n1 和 n2 节点的 type 和 key 都相同，才是相同节点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> n1.type === n2.type &amp;&amp; n1.key === n2.key\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"558\">\n                      在这个过程中，首先判断新旧节点是否是相同的 vnode\n                      类型，如果不同，比如一个 div 更新成一个\n                      ul，那么最简单的操作就是删除旧的 div 节点，再去挂载新的 ul\n                      节点。\n                    </p>\n                    <p data-nodeid=\"559\">\n                      如果是相同的 vnode 类型，就需要走 diff\n                      更新流程了，接着会根据不同的 vnode\n                      类型执行不同的处理逻辑，这里我们仍然只分析普通元素类型和组件类型的处理过程。\n                    </p>\n                    <h5 data-nodeid=\"560\">1. 处理组件</h5>\n                    <p data-nodeid=\"561\">\n                      如何<strong data-nodeid=\"650\">处理组件</strong\n                      >的呢？举个例子，我们在父组件 App 中里引入了 Hello 组件：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>This is an app.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">hello</span> <span class=\"hljs-attr\">:msg</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">hello</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"toggle\"</span>&gt;</span>Toggle msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    data() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'Vue'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">methods</span>: {\n</div></li><li><div class=\"code-word\">      toggle() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-built_in\">this</span>.msg ==== <span class=\"hljs-string\">'Vue'</span>? <span class=\"hljs-string\">'World'</span>: <span class=\"hljs-string\">'Vue'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"563\">\n                      Hello 组件中是\n                      <code data-backticks=\"1\" data-nodeid=\"652\"\n                        >&lt;div&gt;</code\n                      >\n                      包裹着一个\n                      <code data-backticks=\"1\" data-nodeid=\"654\"\n                        >&lt;p&gt;</code\n                      >\n                      标签， 如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"hello\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello, {{msg}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">props</span>: {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-built_in\">String</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"565\">\n                      点击 App 组件中的按钮执行 toggle 函数，就会修改 data 中的\n                      msg，并且会触发App 组件的重新渲染。\n                    </p>\n                    <p data-nodeid=\"566\">\n                      结合前面对渲染函数的流程分析，这里 App 组件的根节点是 div\n                      标签，重新渲染的子树 vnode 节点是一个普通元素的\n                      vnode，应该先走 processElement\n                      逻辑。组件的更新最终还是要转换成内部真实 DOM\n                      的更新，而实际上普通元素的处理流程才是真正做 DOM\n                      的更新，由于稍后我们会详细分析普通元素的处理流程，所以我们先跳过这里，继续往下看。\n                    </p>\n                    <p data-nodeid=\"567\">\n                      和渲染过程类似，更新过程也是一个树的深度优先遍历过程，更新完当前节点后，就会遍历更新它的子节点，因此在遍历的过程中会遇到\n                      hello 这个组件 vnode 节点，就会执行到 processComponent\n                      处理逻辑中，我们再来看一下它的实现，我们重点关注一下组件更新的相关逻辑：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (n1 == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 挂载组件</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 更新子组件</span>\n</div></li><li><div class=\"code-word\">    updateComponent(n1, n2, parentComponent, optimized)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> updateComponent = (n1, n2, parentComponent, optimized) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> instance = (n2.component = n1.component)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 根据新旧子组件 vnode 判断是否需要更新子组件</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (shouldUpdateComponent(n1, n2, parentComponent, optimized)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 新的子组件 vnode 赋值给 instance.next</span>\n</div></li><li><div class=\"code-word\">    instance.next = n2\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span>\n</div></li><li><div class=\"code-word\">    invalidateJob(instance.update)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 执行子组件的副作用渲染函数</span>\n</div></li><li><div class=\"code-word\">    instance.update()\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 不需要更新，只复制属性</span>\n</div></li><li><div class=\"code-word\">    n2.component = n1.component\n</div></li><li><div class=\"code-word\">    n2.el = n1.el\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"569\">\n                      可以看到，processComponent 主要通过执行 updateComponent\n                      函数来更新子组件，updateComponent\n                      函数在更新子组件的时候，会先执行 shouldUpdateComponent\n                      函数，根据新旧子组件 vnode\n                      来判断是否需要更新子组件。这里你只需要知道，在\n                      shouldUpdateComponent 函数的内部，主要是通过检测和对比组件\n                      vnode 中的 props、chidren、dirs、transiton\n                      等属性，来决定子组件是否需要更新。\n                    </p>\n                    <p data-nodeid=\"570\">\n                      这是很好理解的，因为在一个组件的子组件是否需要更新，我们主要依据子组件\n                      vnode\n                      是否存在一些会影响组件更新的属性变化进行判断，如果存在就会更新子组件。\n                    </p>\n                    <p data-nodeid=\"571\">\n                      虽然 Vue.js\n                      的更新粒度是组件级别的，组件的数据变化只会影响当前组件的更新，但是在组件更新的过程中，也会对子组件做一定的检查，判断子组件是否也要更新，并通过某种机制避免子组件重复更新。\n                    </p>\n                    <p data-nodeid=\"572\">\n                      我们接着看 updateComponent 函数，如果\n                      shouldUpdateComponent 返回 true ，那么在它的最后，先执行\n                      invalidateJob（instance.update）避免子组件由于自身数据变化导致的重复更新，然后又执行了子组件的副作用渲染函数\n                      instance.update 来主动触发子组件的更新。\n                    </p>\n                    <p data-nodeid=\"573\">\n                      再回到副作用渲染函数中，有了前面的讲解，我们再看组件更新的这部分代码，就能很好地理解它的逻辑了：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 更新组件</span>\n</div></li><li><div class=\"code-word\">let { next, vnode } = instance\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// next 表示新的组件 vnode</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (next) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 更新组件 vnode 节点信息</span>\n</div></li><li><div class=\"code-word\">  updateComponentPreRender(instance, next, optimized)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">  next = vnode\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> updateComponentPreRender = (instance, nextVNode, optimized) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 新组件 vnode 的 component 属性指向组件实例</span>\n</div></li><li><div class=\"code-word\">  nextVNode.component = instance\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 旧组件 vnode 的 props 属性</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> prevProps = instance.vnode.props\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 组件实例的 vnode 属性指向新的组件 vnode</span>\n</div></li><li><div class=\"code-word\">  instance.vnode = nextVNode\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 清空 next 属性，为了下一次重新渲染准备</span>\n</div></li><li><div class=\"code-word\">  instance.next = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 更新 props</span>\n</div></li><li><div class=\"code-word\">  updateProps(instance, nextVNode.props, prevProps, optimized)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 更新 插槽</span>\n</div></li><li><div class=\"code-word\">  updateSlots(instance, nextVNode.children)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"575\">\n                      结合上面的代码，我们在更新组件的 DOM 前，需要先更新组件\n                      vnode 节点信息，包括更改组件实例的 vnode 指针、更新 props\n                      和更新插槽等一系列操作，因为组件在稍后执行\n                      renderComponentRoot 时会重新渲染新的子树 vnode\n                      ，它依赖了更新后的组件 vnode 中的 props 和 slots 等数据。\n                    </p>\n                    <p data-nodeid=\"576\">\n                      所以我们现在知道了一个组件重新渲染可能会有两种场景，一种是组件本身的数据变化，这种情况下\n                      next 是\n                      null；另一种是父组件在更新的过程中，遇到子组件节点，先判断子组件是否需要更新，如果需要则主动执行子组件的重新渲染方法，这种情况下\n                      next 就是新的子组件 vnode。\n                    </p>\n                    <p data-nodeid=\"577\">\n                      你可能还会有疑问，这个子组件对应的新的组件 vnode\n                      是什么时候创建的呢？答案很简单，它是在父组件重新渲染的过程中，通过\n                      renderComponentRoot 渲染子树 vnode 的时候生成，因为子树\n                      vnode\n                      是个树形结构，通过遍历它的子节点就可以访问到其对应的组件\n                      vnode。再拿我们前面举的例子说，当 App\n                      组件重新渲染的时候，在执行 renderComponentRoot 生成子树\n                      vnode 的过程中，也生成了 hello 组件对应的新的组件 vnode。\n                    </p>\n                    <p data-nodeid=\"578\">\n                      所以 processComponent 处理组件\n                      vnode，本质上就是去判断子组件是否需要更新，如果需要则递归执行子组件的副作用渲染函数来更新，否则仅仅更新一些\n                      vnode 的属性，并让子组件实例保留对组件 vnode\n                      的引用，用于子组件自身数据变化引起组件重新渲染的时候，在渲染函数内部可以拿到新的组件\n                      vnode。\n                    </p>\n                    <p data-nodeid=\"579\">\n                      前面也说过，组件是抽象的，组件的更新最终还是会落到对普通\n                      DOM\n                      元素的更新。所以接下来我们详细分析一下组件更新中<strong\n                        data-nodeid=\"673\"\n                        >对普通元素</strong\n                      >的处理流程。\n                    </p>\n                    <h5 data-nodeid=\"580\">2. 处理普通元素</h5>\n                    <p data-nodeid=\"581\">\n                      我们再来看如何处理普通元素，我把之前的示例稍加修改，将其中的\n                      Hello 组件删掉，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>This is {{msg}}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"toggle\"</span>&gt;</span>Toggle msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    data() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'Vue'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">methods</span>: {\n</div></li><li><div class=\"code-word\">      toggle() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-string\">'Vue'</span>? <span class=\"hljs-string\">'World'</span>: <span class=\"hljs-string\">'Vue'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"583\">\n                      当我们点击 App 组件中的按钮会执行 toggle 函数，然后修改\n                      data 中的 msg，这就触发了 App 组件的重新渲染。\n                    </p>\n                    <p data-nodeid=\"584\">\n                      App 组件的根节点是 div 标签，重新渲染的子树 vnode\n                      节点是一个普通元素的 vnode，所以应该先走 processElement\n                      逻辑，我们来看这个函数的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {\n</div></li><li><div class=\"code-word\">  isSVG = isSVG || n2.type === <span class=\"hljs-string\">'svg'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (n1 == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 挂载元素</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 更新元素</span>\n</div></li><li><div class=\"code-word\">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> el = (n2.el = n1.el)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> newProps = n2.props || EMPTY_OBJ\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 更新 props</span>\n</div></li><li><div class=\"code-word\">  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> areChildrenSVG = isSVG &amp;&amp; n2.type !== <span class=\"hljs-string\">'foreignObject'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 更新子节点</span>\n</div></li><li><div class=\"code-word\">  patchChildren(n1, n2, el, <span class=\"hljs-keyword\">null</span>, parentComponent, parentSuspense, areChildrenSVG)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"586\">\n                      可以看到，更新元素的过程主要做两件事情：更新 props\n                      和更新子节点。其实这是很好理解的，因为一个 DOM\n                      节点元素就是由它自身的一些属性和子节点构成的。\n                    </p>\n                    <p data-nodeid=\"587\">\n                      首先是更新 props，这里的 patchProps 函数就是在更新 DOM\n                      节点的 class、style、event 以及其它的一些 DOM\n                      属性，这个过程我不再深入分析了，感兴趣的同学可以自己看这部分代码。\n                    </p>\n                    <p data-nodeid=\"588\">\n                      其次是更新子节点，我们来看一下这里的 patchChildren\n                      函数的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = <span class=\"hljs-keyword\">false</span>) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> c1 = n1 &amp;&amp; n1.children\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> prevShapeFlag = n1 ? n1.shapeFlag : <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> c2 = n2.children\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> { shapeFlag } = n2\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 子节点有 3 种可能情况：文本、数组、空</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* TEXT_CHILDREN */</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (prevShapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 数组 -&gt; 文本，则删除之前的子节点</span>\n</div></li><li><div class=\"code-word\">      unmountChildren(c1, parentComponent, parentSuspense)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (c2 !== c1) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 文本对比不同，则替换为新文本</span>\n</div></li><li><div class=\"code-word\">      hostSetElementText(container, c2)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (prevShapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 之前的子节点是数组</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 新的子节点仍然是数组，则做完整地 diff</span>\n</div></li><li><div class=\"code-word\">        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 数组 -&gt; 空，则仅仅删除之前的子节点</span>\n</div></li><li><div class=\"code-word\">        unmountChildren(c1, parentComponent, parentSuspense, <span class=\"hljs-keyword\">true</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 之前的子节点是文本节点或者为空</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 新的子节点是数组或者为空</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (prevShapeFlag &amp; <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* TEXT_CHILDREN */</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果之前子节点是文本，则把它清空</span>\n</div></li><li><div class=\"code-word\">        hostSetElementText(container, <span class=\"hljs-string\">''</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果新的子节点是数组，则挂载新子节点</span>\n</div></li><li><div class=\"code-word\">        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"590\">\n                      对于一个元素的子节点 vnode 可能会有三种情况：纯文本、vnode\n                      数组和空。那么根据排列组合对于新旧子节点来说就有九种情况，我们可以通过三张图来表示。\n                    </p>\n                    <p data-nodeid=\"591\">\n                      首先来看一下<strong data-nodeid=\"689\"\n                        >旧子节点是纯文本</strong\n                      >的情况：\n                    </p>\n                    <ul data-nodeid=\"592\">\n                      <li data-nodeid=\"593\">\n                        <p data-nodeid=\"594\">\n                          如果新子节点也是纯文本，那么做简单地文本替换即可；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"595\">\n                        <p data-nodeid=\"596\">\n                          如果新子节点是空，那么删除旧子节点即可；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"597\">\n                        <p data-nodeid=\"598\">\n                          如果新子节点是 vnode\n                          数组，那么先把旧子节点的文本清空，再去旧子节点的父容器下添加多个新子节点。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"599\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/31/18/Ciqc1F8MBDWAfUAXAADe59XvjHY701.png\"\n                        alt=\"2.png\"\n                        data-nodeid=\"695\"\n                      />\n                    </p>\n                    <p data-nodeid=\"600\">\n                      接下来看一下<strong data-nodeid=\"701\">旧子节点是空</strong\n                      >的情况：\n                    </p>\n                    <ul data-nodeid=\"601\">\n                      <li data-nodeid=\"602\">\n                        <p data-nodeid=\"603\">\n                          如果新子节点是纯文本，那么在旧子节点的父容器下添加新文本节点即可；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"604\">\n                        <p data-nodeid=\"605\">\n                          如果新子节点也是空，那么什么都不需要做；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"606\">\n                        <p data-nodeid=\"607\">\n                          如果新子节点是 vnode\n                          数组，那么直接去旧子节点的父容器下添加多个新子节点即可。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"608\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/31/23/CgqCHl8MBEOANnFmAADYr-_R5mM894.png\"\n                        alt=\"3.png\"\n                        data-nodeid=\"707\"\n                      />\n                    </p>\n                    <p data-nodeid=\"609\">\n                      最后来看一下<strong data-nodeid=\"713\"\n                        >旧子节点是 vnode 数组</strong\n                      >的情况：\n                    </p>\n                    <ul data-nodeid=\"610\">\n                      <li data-nodeid=\"611\">\n                        <p data-nodeid=\"612\">\n                          如果新子节点是纯文本，那么先删除旧子节点，再去旧子节点的父容器下添加新文本节点；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"613\">\n                        <p data-nodeid=\"614\">\n                          如果新子节点是空，那么删除旧子节点即可；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"615\">\n                        <p data-nodeid=\"616\">\n                          如果新子节点也是 vnode 数组，那么就需要做完整的 diff\n                          新旧子节点了，这是最复杂的情况，内部运用了核心 diff\n                          算法。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"617\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/31/23/CgqCHl8MBCuAUZksAADplAU2718113.png\"\n                        alt=\"1.png\"\n                        data-nodeid=\"719\"\n                      />\n                    </p>\n                    <p data-nodeid=\"618\">\n                      下节课我们就来深入探究一下这个复杂的 diff 算法。\n                    </p>\n                    <blockquote data-nodeid=\"619\">\n                      <p data-nodeid=\"620\" class=\"\">\n                        <strong data-nodeid=\"728\"\n                          >本节课的相关代码在源代码中的位置如下：</strong\n                        ><br />\n                        packages/runtime-core/src/renderer.ts<br />\n                        packages/runtime-core/src/componentRenderUtils.ts\n                      </p>\n                    </blockquote>\n            "}