{"title":"14 | 解析 Webpack 源码，实现自己的构建工具","context":"\n                    <p data-nodeid=\"3596\">\n                      前端工程化和基础建设这个话题，自然少不了分析构建工具。作为前端工程中最常见、最经典的构建工具，Webpack\n                      必须要有一个独立小节进行精讲。可是，关于 Webpack\n                      什么样的内容才更有意义呢？当前社区，Webpack\n                      插件编写、loader 编写相关内容已经非常多了，甚至 Tapable\n                      机制也已经有了涉猎。\n                    </p>\n                    <p data-nodeid=\"3597\">\n                      这一讲，我们独辟蹊径，从 Webpack\n                      的实现入手，帮助你构建一个自己的工程化工具。\n                    </p>\n                    <h3 data-nodeid=\"3598\">Webpack 的初心和揭秘</h3>\n                    <p data-nodeid=\"3599\">\n                      我不建议对着 Webpack 源码讲解，因为 Webpack\n                      是一个庞大的体系，其源码逐行讲解太过枯燥，真正能转化在技术积累上的内容较少。今天，我们先抽丝剥茧，从\n                      Webpack 的使命谈起，相信你会有一个更加清晰的认知。\n                    </p>\n                    <p data-nodeid=\"3600\">Webpack 的介绍只有简单一句：</p>\n                    <blockquote data-nodeid=\"3601\">\n                      <p data-nodeid=\"3602\">\n                        Webpack is a static module bundler for modern JavaScript\n                        applications.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3603\">\n                      虽然 Webpack 看上去无所不能，但从其本质上来说，Webpack\n                      实质就是一个“前端模块打包器”。前端模块打包器做的事情很简单：它帮助开发者将\n                      JavaScript 模块（各种类型的模块化规范）打包为一个或多个\n                      JavaScript 脚本文件。\n                    </p>\n                    <p data-nodeid=\"3604\">\n                      我们回到最初起源，前端为什么需要一个模块打包器呢？其实理由很简单：\n                    </p>\n                    <ul data-nodeid=\"3605\">\n                      <li data-nodeid=\"3606\">\n                        <p data-nodeid=\"3607\">\n                          不是所有浏览器都直接支持 JavaScript 规范；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3608\">\n                        <p data-nodeid=\"3609\">\n                          前端需要管理依赖脚本，把控不同脚本加载的顺序；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3610\">\n                        <p data-nodeid=\"3611\">\n                          前端需要按顺序加载不同类型的静态资源。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3612\">\n                      想象一下，我们的 Web 应用有这样一段内容：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;html&gt;\n</div></li><li><div class=\"code-word\">  &lt;script src=\"/src/1.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">  &lt;script src=\"/src/2.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">  &lt;script src=\"/src/3.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">  &lt;script src=\"/src/4.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">  &lt;script src=\"/src/5.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">  &lt;script src=\"/src/6.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">&lt;/html&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3614\">\n                      每个 JavaScript 文件都需要额外的 HTTP\n                      请求获取，并且因为依赖关系，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3778\"\n                        >1.js</code\n                      >到<code data-backticks=\"1\" data-nodeid=\"3780\">6.js</code\n                      >需要按顺序加载。因此，打包需求应运而生：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;html&gt;\n</div></li><li><div class=\"code-word\">  &lt;script src=\"/dist/bundle.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">&lt;/html&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3616\">这里需要注意几点：</p>\n                    <ul data-nodeid=\"5616\">\n                      <li data-nodeid=\"5617\">\n                        <p data-nodeid=\"5618\" class=\"\">\n                          随着 HTTP/2\n                          技术的推广，未来长远上看，浏览器像上述代码一样发送多个请求不再是性能瓶颈，但目前来看还过于乐观（更多内容参见\n                          <a\n                            href=\"https://developers.google.com/web/fundamentals/performance/http2/\"\n                            data-nodeid=\"5624\"\n                            >HTTP/2 简介</a\n                          >）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"5619\">\n                        <p data-nodeid=\"5620\">\n                          <strong data-nodeid=\"5636\"\n                            >并不是将所有脚本都打包在一起就是性能最优</strong\n                          >，<code data-backticks=\"1\" data-nodeid=\"5630\"\n                            >/dist/bundle.js</code\n                          >的 size\n                          一般较大，但这属于另外“性能优化”话题了，相关内容，我们在<a\n                            href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=584#/detail/pc?id=5915\"\n                            data-nodeid=\"5634\"\n                            >10 讲“代码拆分和按需加载：缩减 bundle\n                            size，把性能做到极致”</a\n                          >中已有涉及。\n                        </p>\n                      </li>\n                    </ul>\n\n                    <p data-nodeid=\"3622\">\n                      总之，打包器的需求就是前端“刚需”，实现上述打包需要也并不简单，需要考虑：\n                    </p>\n                    <ul data-nodeid=\"3623\">\n                      <li data-nodeid=\"3624\">\n                        <p data-nodeid=\"3625\">\n                          如何维护不同脚本的打包顺序，保证<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3801\"\n                            >bundle.js</code\n                          >的可用性；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3626\">\n                        <p data-nodeid=\"3627\">\n                          如何避免不同脚本、不同模块的命名冲突；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3628\">\n                        <p data-nodeid=\"3629\">\n                          在打包过程中，如何确定真正需要的脚本，而不将没有用到的脚本排除在<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3805\"\n                            >bundle.js</code\n                          >之外？\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3630\">\n                      事实上，虽然当前 Webpack 依靠 loader\n                      机制实现了对于不同类型资源的解析和打包，依靠插件机制实现了第三方介入编译构建的过程，但究其本质，Webpack\n                      只是一个“无所不能”的打包器，实现了：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">a.js + b.js + c.js. =&gt; bundle.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3632\">的能力。</p>\n                    <p data-nodeid=\"3633\">\n                      下面我们继续揭秘 Webpack 在打包过程中的奥秘。\n                    </p>\n                    <p data-nodeid=\"3634\">\n                      为了简化，我们以 ESM 模块化规范举例。假设我们有：\n                    </p>\n                    <ul data-nodeid=\"3635\">\n                      <li data-nodeid=\"3636\">\n                        <p data-nodeid=\"3637\">\n                          <code data-backticks=\"1\" data-nodeid=\"3811\"\n                            >circle.js</code\n                          >模块求圆形面积；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3638\">\n                        <p data-nodeid=\"3639\">\n                          <code data-backticks=\"1\" data-nodeid=\"3813\"\n                            >square.js</code\n                          >模块求正方形面积；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3640\">\n                        <p data-nodeid=\"3641\">\n                          <code data-backticks=\"1\" data-nodeid=\"3815\"\n                            >app.js</code\n                          >模块作为主模块。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3642\">对应内容分别如下代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// filename: circle.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PI = <span class=\"hljs-number\">3.141</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export <span class=\"hljs-keyword\">default</span> function <span class=\"hljs-title\">area</span><span class=\"hljs-params\">(radius)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> PI * radius * radius;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// filename: square.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export <span class=\"hljs-keyword\">default</span> function <span class=\"hljs-title\">area</span><span class=\"hljs-params\">(side)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> side * side;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// filename: app.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> squareArea from <span class=\"hljs-string\">'./square'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> circleArea from <span class=\"hljs-string\">'./circle'</span>;\n</div></li><li><div class=\"code-word\">console.log(<span class=\"hljs-string\">'Area of square: '</span>, squareArea(<span class=\"hljs-number\">5</span>));\n</div></li><li><div class=\"code-word\">console.log(<span class=\"hljs-string\">'Area of circle'</span>, circleArea(<span class=\"hljs-number\">5</span>));\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3644\">\n                      经过 Webpack 打包之后，我们用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3819\"\n                        >bundle.js</code\n                      >来表示 Webpack 处理结果（精简并可读化处理后）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// filename: bundle.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> modules = {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'circle.js'</span>: function(<span class=\"hljs-keyword\">exports</span>, require) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> PI = <span class=\"hljs-number\">3.141</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">exports</span>.<span class=\"hljs-keyword\">default</span> = <span class=\"hljs-function\">function <span class=\"hljs-title\">area</span><span class=\"hljs-params\">(radius)</span> </span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> PI * radius * radius;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'square.js'</span>: function(<span class=\"hljs-keyword\">exports</span>, require) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">exports</span>.<span class=\"hljs-keyword\">default</span> = <span class=\"hljs-function\">function <span class=\"hljs-title\">area</span><span class=\"hljs-params\">(side)</span> </span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> side * side;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'app.js'</span>: function(<span class=\"hljs-keyword\">exports</span>, require) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> squareArea = require(<span class=\"hljs-string\">'square.js'</span>).<span class=\"hljs-keyword\">default</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> circleArea = require(<span class=\"hljs-string\">'circle.js'</span>).<span class=\"hljs-keyword\">default</span>;\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'Area of square: '</span>, squareArea(<span class=\"hljs-number\">5</span>))\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'Area of circle'</span>, circleArea(<span class=\"hljs-number\">5</span>))\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">webpackBundle({\n</div></li><li><div class=\"code-word\">  modules,\n</div></li><li><div class=\"code-word\">  entry: <span class=\"hljs-string\">'app.js'</span>\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3646\">\n                      如上代码，我们维护了<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3822\"\n                        >modules</code\n                      >变量，存储了不同模块信息，这个 map 中，key\n                      为模块路径名，value 为一个被 wrapped\n                      过的模块函数，我们先称之为<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3824\"\n                        >module factory function</code\n                      >，该函数形如：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">function(<span class=\"hljs-keyword\">exports</span>, require) {\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 模块内容</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3648\">\n                      这样做是为每个模块提供<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3827\"\n                        >exports</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"3829\"\n                        >require</code\n                      >能力，同时<strong data-nodeid=\"3835\"\n                        >保证了每个模块都处于一个隔离的函数作用域范围</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"3649\">\n                      有了<code data-backticks=\"1\" data-nodeid=\"3837\"\n                        >modules</code\n                      >变量还不够，我们依赖<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3839\"\n                        >webpackBundle</code\n                      >方法，将所有内容整合在一起。<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3841\"\n                        >webpackBundle</code\n                      >方法接收<code data-backticks=\"1\" data-nodeid=\"3843\"\n                        >modules</code\n                      >模块信息以及一个入口脚本。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">webpackBundle</span><span class=\"hljs-params\">({ modules, entry })</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> moduleCache = {};\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> require = moduleName =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果已经解析并缓存过，直接返回缓存内容</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (moduleCache[moduleName]) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> moduleCache[moduleName];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">exports</span> = {};\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里是为了防止循环引用</span>\n</div></li><li><div class=\"code-word\">    moduleCache[moduleName] = <span class=\"hljs-keyword\">exports</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 执行模块内容，如果遇见了 require 方法，则继续递归执行 require 方法 </span>\n</div></li><li><div class=\"code-word\">    modules[moduleName](<span class=\"hljs-keyword\">exports</span>, require);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> moduleCache[moduleName];\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  require(entry);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3651\">\n                      上述代码中需要注意：<strong data-nodeid=\"3853\"\n                        >webpackBundle 方法中声明的</strong\n                      ><code data-backticks=\"1\" data-nodeid=\"3849\">require</code\n                      >方法和 CommonJS 规范中的 require 是两回事，该<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3851\"\n                        >require</code\n                      >方法是 Webpack 自己实现的模块化解决方案。\n                    </p>\n                    <p data-nodeid=\"3652\">\n                      我们通过下图来总结一下 Webpack 风格的打包器原理和流程：\n                    </p>\n                    <p data-nodeid=\"7255\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/91/75/Ciqc1GAOlIOAYZLfAAFmQUf14uQ501.png\"\n                        alt=\"Lark20210125-174549.png\"\n                        data-nodeid=\"7259\"\n                      />\n                    </p>\n                    <div data-nodeid=\"7256\" class=\"\">\n                      <p style=\"text-align: center\">\n                        Webpack 打包器原理和流程图\n                      </p>\n                    </div>\n\n                    <p data-nodeid=\"3655\">\n                      讲到这里，我们再扩充一下另一个打包器——Rollup\n                      的打包原理，针对上述代码，Rollup 打包过后的产出为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PI = <span class=\"hljs-number\">3.141</span>;\n</div></li><li><div class=\"code-word\">function circle$area(radius) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> PI * radius * radius;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">function square$area(side) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> side * side;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">console.log(<span class=\"hljs-string\">'Area of square: '</span>, square$area(<span class=\"hljs-number\">5</span>));\n</div></li><li><div class=\"code-word\">console.log(<span class=\"hljs-string\">'Area of circle'</span>, circle$area(<span class=\"hljs-number\">5</span>));\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3657\">\n                      如上代码，我们看到，Rollup 的原理思想与 Webpack\n                      不同：<strong data-nodeid=\"3865\"\n                        >Rollup 不会维护一个 module\n                        map，而是将所有模块拍平（flatten）放到 bundle 中</strong\n                      >，也就不存在包裹函数（module factory function）。\n                    </p>\n                    <p data-nodeid=\"3658\">\n                      为了保证命名冲突不出现，Rollup\n                      将函数和变量名进行了改写，在模块脚本<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3867\"\n                        >circle.js</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"3869\"\n                        >square.js</code\n                      >中，都命名了一个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3871\"\n                        >area</code\n                      >方法。经过 Rollup 打包后，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3873\"\n                        >area</code\n                      >方法根据模块主体，进行了重命名。\n                    </p>\n                    <p data-nodeid=\"3659\">\n                      我们将 Webpack 和 Rollup 的打包方式进行对比总结。\n                    </p>\n                    <ul data-nodeid=\"3660\">\n                      <li data-nodeid=\"3661\">\n                        <p data-nodeid=\"3662\">Webpack 理念：</p>\n                      </li>\n                    </ul>\n                    <ol data-nodeid=\"3663\">\n                      <li data-nodeid=\"3664\">\n                        <p data-nodeid=\"3665\">\n                          使用了 module map，维护项目中的依赖关系；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3666\">\n                        <p data-nodeid=\"3667\">\n                          使用了包裹函数，对每个模块进行包裹；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3668\">\n                        <p data-nodeid=\"3669\">\n                          使用了一个“runtime”方法（这里举例为<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3880\"\n                            >webpackBundle</code\n                          >），最终合成 bundle 内容。\n                        </p>\n                      </li>\n                    </ol>\n                    <ul data-nodeid=\"3670\">\n                      <li data-nodeid=\"3671\">\n                        <p data-nodeid=\"3672\">Rollup 理念：</p>\n                      </li>\n                    </ul>\n                    <ol data-nodeid=\"3673\">\n                      <li data-nodeid=\"3674\">\n                        <p data-nodeid=\"3675\">将每个模块拍平；</p>\n                      </li>\n                      <li data-nodeid=\"3676\">\n                        <p data-nodeid=\"3677\">\n                          不使用包裹函数，不需要对每个模块进行包裹。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"3678\">\n                      不同的理念也会造成不同的打包结果，这里我想给你留一个思考题：<strong\n                        data-nodeid=\"3890\"\n                        >在 Rollup\n                        处理理念下，如果模块出现了循环依赖，会发生什么现象呢</strong\n                      >？\n                    </p>\n                    <h3 data-nodeid=\"3679\">手动实现打包器</h3>\n                    <p data-nodeid=\"3680\">\n                      前面内容我们剖析了以 Webpak、Rollup\n                      为代表的打包器核心原理。下面内容，我们将手动实现一个自己的简易打包器，我们的目标将会向\n                      Webpack 打包设计对齐。核心思路如下：\n                    </p>\n                    <ol data-nodeid=\"3681\">\n                      <li data-nodeid=\"3682\">\n                        <p data-nodeid=\"3683\">\n                          读取入口文件（比如<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3894\"\n                            >entry.js</code\n                          >）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3684\">\n                        <p data-nodeid=\"3685\">\n                          基于 AST 分析入口文件，并产出依赖列表；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3686\">\n                        <p data-nodeid=\"3687\">\n                          使用 Babel 将相关模块编译到 ES5；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3688\">\n                        <p data-nodeid=\"3689\">\n                          对每个依赖模块产出一个唯一的\n                          ID，方便后续读取模块相关内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3690\">\n                        <p data-nodeid=\"3691\">\n                          将每个依赖以及经过 Babel\n                          编译过后的内容，存储在一个对象中进行维护；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3692\">\n                        <p data-nodeid=\"3693\">\n                          遍历上一步中的对象，构建出一个依赖图（Dependency\n                          Graph）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3694\">\n                        <p data-nodeid=\"3695\">将各模块内容 bundle 产出。</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"3696\">我们来一步一步实现。首先创建项目：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">mkdir bundler-playground &amp;&amp; cd $_\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3698\">并启动 npm：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">npm init -y\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3700\">安装以下依赖：</p>\n                    <ul data-nodeid=\"3701\">\n                      <li data-nodeid=\"3702\">\n                        <p data-nodeid=\"3703\">\n                          <code data-backticks=\"1\" data-nodeid=\"3905\"\n                            >@babel/parser</code\n                          >用于分析源代码，产出 AST；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3704\">\n                        <p data-nodeid=\"3705\">\n                          <code data-backticks=\"1\" data-nodeid=\"3907\"\n                            >@babel/traverse</code\n                          >用于遍历 AST，找到 import 声明；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3706\">\n                        <p data-nodeid=\"3707\">\n                          <code data-backticks=\"1\" data-nodeid=\"3909\"\n                            >@babel/core</code\n                          >用于编译，将源代码编译为 ES5；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3708\">\n                        <p data-nodeid=\"3709\">\n                          <code data-backticks=\"1\" data-nodeid=\"3911\"\n                            >@babel/preset-env</code\n                          >搭配<code data-backticks=\"1\" data-nodeid=\"3913\"\n                            >@babel/core</code\n                          >使用；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3710\">\n                        <p data-nodeid=\"3711\">\n                          <code data-backticks=\"1\" data-nodeid=\"3915\"\n                            >resolve</code\n                          >用于获取依赖的绝对路径。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3712\">相关命令：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">npm install --save <span class=\"hljs-meta\">@babel</span>/parser <span class=\"hljs-meta\">@babel</span>/traverse <span class=\"hljs-meta\">@babel</span>/core  <span class=\"hljs-meta\">@babel</span>/preset-env resolve\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3714\">\n                      做完了这些，我们开始核心逻辑的编写，创建<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3919\"\n                        >index.js</code\n                      >，并引入如下依赖代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"> <span class=\"hljs-keyword\">const</span> fs = require(<span class=\"hljs-string\">\"fs\"</span>);\n</div></li><li><div class=\"code-word\"> <span class=\"hljs-keyword\">const</span> path = require(<span class=\"hljs-string\">\"path\"</span>);\n</div></li><li><div class=\"code-word\"> <span class=\"hljs-keyword\">const</span> parser = require(<span class=\"hljs-string\">\"@babel/parser\"</span>);\n</div></li><li><div class=\"code-word\"> <span class=\"hljs-keyword\">const</span> traverse = require(<span class=\"hljs-string\">\"@babel/traverse\"</span>).<span class=\"hljs-keyword\">default</span>;\n</div></li><li><div class=\"code-word\"> <span class=\"hljs-keyword\">const</span> babel = require(<span class=\"hljs-string\">\"@babel/core\"</span>); \n</div></li><li><div class=\"code-word\"> <span class=\"hljs-keyword\">const</span> resolve = require(<span class=\"hljs-string\">\"resolve\"</span>).sync;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3716\">\n                      接着，我们维护一个全局 ID，并通过遍历 AST，访问<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3922\"\n                        >ImportDeclaration</code\n                      >节点，收集依赖到<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3924\"\n                        >deps</code\n                      >数组中，同时完成 Babel 降级编译：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">let ID = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">createModuleInfo</span><span class=\"hljs-params\">(filePath)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 读取模块源代码</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> content = fs.readFileSync(filePath, <span class=\"hljs-string\">\"utf-8\"</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 对源代码进行 AST 产出</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> ast = parser.parse(content, {\n</div></li><li><div class=\"code-word\">    sourceType: <span class=\"hljs-string\">\"module\"</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 相关模块依赖数组</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> deps = [];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 遍历模块 AST，将依赖推入 deps 数组中</span>\n</div></li><li><div class=\"code-word\">    traverse(ast, {\n</div></li><li><div class=\"code-word\">        ImportDeclaration: ({ node }) =&gt; {\n</div></li><li><div class=\"code-word\">          deps.push(node.source.value);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> id = ID++;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 编译为 ES5</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> { code } = babel.transformFromAstSync(ast, <span class=\"hljs-keyword\">null</span>, {\n</div></li><li><div class=\"code-word\">        presets: [<span class=\"hljs-string\">\"@babel/preset-env\"</span>]\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        id,\n</div></li><li><div class=\"code-word\">        filePath,\n</div></li><li><div class=\"code-word\">        deps,\n</div></li><li><div class=\"code-word\">        code\n</div></li><li><div class=\"code-word\">    };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3718\">\n                      上述代码中，相关注释已经比较明晰了。这里需要指出的是，我们采用了<strong\n                        data-nodeid=\"3935\"\n                        >自增 ID</strong\n                      >的方式，<strong data-nodeid=\"3936\"\n                        >如果采用随机的 GUID，会是更安全的做法</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"3719\">\n                      至此，我们实现了对一个模块的分析，并产出：\n                    </p>\n                    <ul data-nodeid=\"3720\">\n                      <li data-nodeid=\"3721\">\n                        <p data-nodeid=\"3722\">该模块对应 ID；</p>\n                      </li>\n                      <li data-nodeid=\"3723\">\n                        <p data-nodeid=\"3724\">该模块路径；</p>\n                      </li>\n                      <li data-nodeid=\"3725\">\n                        <p data-nodeid=\"3726\">该模块的依赖数组；</p>\n                      </li>\n                      <li data-nodeid=\"3727\">\n                        <p data-nodeid=\"3728\">\n                          该模块经过 Babel 编译后的代码。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3729\">\n                      接下来，我们生成整个项目的依赖树（Dependency\n                      Graph）。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">createDependencyGraph</span><span class=\"hljs-params\">(entry)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 获取模块信息</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> entryInfo = createModuleInfo(entry);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 项目依赖树</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> graphArr = [];\n</div></li><li><div class=\"code-word\">    graphArr.push(entryInfo);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 以入口模块为起点，遍历整个项目依赖的模块，并将每个模块信息维护到 graphArr 中</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">module</span> of graphArr) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">module</span>.map = {};\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">module</span>.deps.forEach(depPath =&gt; {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> baseDir = path.dirname(<span class=\"hljs-keyword\">module</span>.filePath);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> moduleDepPath = resolve(depPath, { baseDir });\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> moduleInfo = createModuleInfo(moduleDepPath);\n</div></li><li><div class=\"code-word\">            graphArr.push(moduleInfo);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">module</span>.map[depPath] = moduleInfo.id;\n</div></li><li><div class=\"code-word\">        });\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> graphArr;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3731\">\n                      上述代码中，我们使用一个数组类型的变量<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3944\"\n                        >graphArr</code\n                      >来描述整个项目的依赖树情况。最后，我们基于<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3946\"\n                        >graphArr</code\n                      >内容，将相关模块进行打包。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">pack</span><span class=\"hljs-params\">(graph)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> moduleArgArr = graph.map(<span class=\"hljs-keyword\">module</span> =&gt; {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> \\`${<span class=\"hljs-keyword\">module</span>.id}: {\n</div></li><li><div class=\"code-word\">            factory: (<span class=\"hljs-keyword\">exports</span>, require) =&gt; {\n</div></li><li><div class=\"code-word\">                ${<span class=\"hljs-keyword\">module</span>.code}\n</div></li><li><div class=\"code-word\">            },\n</div></li><li><div class=\"code-word\">            map: ${JSON.stringify(<span class=\"hljs-keyword\">module</span>.map)}\n</div></li><li><div class=\"code-word\">        }\\`;\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> iifeBundler = \\`(function(modules){\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> require = id =&gt; {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> {factory, map} = modules[id];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> localRequire = requireDeclarationName =&gt; require(map[requireDeclarationName]); \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">module</span> = {<span class=\"hljs-keyword\">exports</span>: {}};\n</div></li><li><div class=\"code-word\">            factory(<span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span>, localRequire); \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span>; \n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        require(<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        })({${moduleArgArr.join()}})\n</div></li><li><div class=\"code-word\">    \\`;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> iifeBundler;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3733\">\n                      如上代码，我们创建一个对应每个模块的模板对象：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> \\`${<span class=\"hljs-keyword\">module</span>.id}: {\n</div></li><li><div class=\"code-word\">  factory: (<span class=\"hljs-keyword\">exports</span>, require) =&gt; {\n</div></li><li><div class=\"code-word\">    ${<span class=\"hljs-keyword\">module</span>.code}\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  map: ${JSON.stringify(<span class=\"hljs-keyword\">module</span>.map)}\n</div></li><li><div class=\"code-word\">  }\\`;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3735\">\n                      在<code data-backticks=\"1\" data-nodeid=\"3950\"\n                        >factory</code\n                      >对应的内容中，我们包裹模块代码，并注入<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3952\"\n                        >exports</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"3954\"\n                        >require</code\n                      >两个参数。同时，我们构造了一个 IIFE\n                      风格的代码区块，用于将依赖树中的代码串联在一起。最难理解的部分在于：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> iifeBundler = \\`(function(modules){\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> require = id =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> {factory, map} = modules[id];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> localRequire = requireDeclarationName =&gt; require(map[requireDeclarationName]); \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">module</span> = {<span class=\"hljs-keyword\">exports</span>: {}};\n</div></li><li><div class=\"code-word\">      factory(<span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span>, localRequire); \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span>; \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    require(<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">  })({${moduleArgArr.join()}})\n</div></li><li><div class=\"code-word\">  \\`;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3737\">\n                      针对这段代码，我们进行更细致的分析。\n                    </p>\n                    <ul data-nodeid=\"3738\">\n                      <li data-nodeid=\"3739\">\n                        <p data-nodeid=\"3740\">\n                          使用 IIFE 的方式，来保证模块变量不会影响到全局作用域。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3741\">\n                        <p data-nodeid=\"3742\">\n                          构造好的项目依赖树（Dependency\n                          Graph）数组，将会作为名为<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3959\"\n                            >modules</code\n                          >的行参，传递给 IIFE。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3743\">\n                        <p data-nodeid=\"3744\">\n                          我们构造了<code data-backticks=\"1\" data-nodeid=\"3962\"\n                            >require(id)</code\n                          >方法，这个方法的意义在于：\n                        </p>\n                      </li>\n                    </ul>\n                    <ol data-nodeid=\"3745\">\n                      <li data-nodeid=\"3746\">\n                        <p data-nodeid=\"3747\">\n                          通过<code data-backticks=\"1\" data-nodeid=\"3965\"\n                            >require(map[requireDeclarationName])</code\n                          >方式，按顺序递归调用各个依赖模块；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3748\">\n                        <p data-nodeid=\"3749\">\n                          通过调用<code data-backticks=\"1\" data-nodeid=\"3968\"\n                            >factory(module.exports, localRequire)</code\n                          >执行模块相关代码；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3750\">\n                        <p data-nodeid=\"3751\">\n                          该方法最终返回<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3971\"\n                            >module.exports</code\n                          >对象，module.exports 最初值为空对象（<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3973\"\n                            >{exports: {}}</code\n                          >），但在一次次调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"3975\"\n                            >factory()</code\n                          >函数后，<code data-backticks=\"1\" data-nodeid=\"3977\"\n                            >module.exports</code\n                          >对象内容已经包含了模块对外暴露的内容了。\n                        </p>\n                      </li>\n                    </ol>\n                    <h3 data-nodeid=\"3752\">总结</h3>\n                    <p data-nodeid=\"3753\">\n                      这一讲虽然标题包含“解析 Webpack\n                      源码”，但我们并没有采用源码解读的方式展开，而是从打包器的设计原理入手，换一种角度进行\n                      Webpack 源码解读，并最终动手实现了一个自己的简易打包器。\n                    </p>\n                    <p data-nodeid=\"3754\">\n                      实际上，打包过程主要分为两步：<strong data-nodeid=\"3990\"\n                        >依赖解析</strong\n                      >（Dependency Resolution）和<strong data-nodeid=\"3991\"\n                        >代码打包</strong\n                      >（Bundling）：\n                    </p>\n                    <ul data-nodeid=\"3755\">\n                      <li data-nodeid=\"3756\">\n                        <p data-nodeid=\"3757\">\n                          在依赖解析过程中，我们通过 AST\n                          技术，找到每个模块的依赖模块，并组合为最终的项目依赖树。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3758\">\n                        <p data-nodeid=\"3759\">\n                          在代码打包过程中，我们使用 Babel\n                          对源代码进行编译，其中也包括了对 imports /\n                          exports（即对 ESM） 的编译。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3760\">\n                      整个过程稍微有些抽象，需要你用心体会。\n                    </p>\n                    <p data-nodeid=\"3761\">主要内容总结为下图：</p>\n                    <p data-nodeid=\"8064\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/09/65/Cip5yGAOlKiAA3uyAAG87LhMy8s651.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"8067\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"3763\">\n                      在实际生产环节，打包器当然功能更多，比如需要考虑：code\n                      spliting 甚至 watch mode 以及 reloading\n                      能力等。但是不管什么样的特性和能力，只要我们理清最初心，掌握最基本的思想，任何疑问都会迎刃而解。\n                    </p>\n            "}