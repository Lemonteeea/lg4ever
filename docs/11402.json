{"title":"01 | 栈：从简单栈到单调栈，解决经典栈问题","context":"\n                    <p data-nodeid=\"6685\" class=\"\">\n                      今天我们开始学习一个在工作，以及面试中经常被问到的一个数据结构——<strong\n                        data-nodeid=\"7015\"\n                        >栈</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6686\">\n                      栈这种数据结构，在计算机中有着广泛地运用，比如编程语言中函数的调用、操作系统中从用户态到内核态寄存器的保存、网络消息的处理等都会用到栈。\n                    </p>\n                    <p data-nodeid=\"6687\">\n                      今天我们主要介绍面试中经常考察的栈相关的高频题目，主要内容包含两方面：\n                    </p>\n                    <ul data-nodeid=\"6688\">\n                      <li data-nodeid=\"6689\">\n                        <p data-nodeid=\"6690\">栈的特性与使用</p>\n                      </li>\n                      <li data-nodeid=\"6691\">\n                        <p data-nodeid=\"6692\">单调栈的解题技巧</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6693\">\n                      针对一道题目，我会深度讲解一种解法，以及其变型，并且带你总结同类问题的解题技巧和规律，从而解决多种相似及变形题目。并且，我会给出\n                      Java/C++/Python\n                      三种代码示例，方便你学习。现在，开始我们的旅程与探险！\n                    </p>\n                    <h3 data-nodeid=\"6694\">栈的特性与使用</h3>\n                    <p data-nodeid=\"6695\">\n                      简单栈的特点可以用一句话来概括，<strong data-nodeid=\"7027\"\n                        >先进后出</strong\n                      >（LIFO）顺序。比如 Java 代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">Stack&lt;Character&gt; t = <span class=\"hljs-keyword\">new</span> Stack&lt;Character&gt;();\n</div></li><li><div class=\"code-word\">t.push(<span class=\"hljs-string\">'a'</span>);\n</div></li><li><div class=\"code-word\">t.push(<span class=\"hljs-string\">'b'</span>);\n</div></li><li><div class=\"code-word\">t.peek(); <span class=\"hljs-comment\">// 这里得到栈顶元素'b'</span>\n</div></li><li><div class=\"code-word\">t.pop();  <span class=\"hljs-comment\">// 这里将栈顶元素'b'弹出</span>\n</div></li><li><div class=\"code-word\">t.peek(); <span class=\"hljs-comment\">// 此时栈顶元素为'a'</span>\n</div></li><li><div class=\"code-word\">t.pop();  <span class=\"hljs-comment\">// 这里将栈顶元素'a'弹出</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6697\">这部分代码片段执行效果如下图所示：</p>\n                    <p data-nodeid=\"6698\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/63/Cgp9HWA4jJaAMKH7ADCb3Og8L1Q358.gif\"\n                        alt=\"1.gif\"\n                        data-nodeid=\"7031\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6699\">\n                      那么如何深度利用栈的“<strong data-nodeid=\"7037\"\n                        >先进后出</strong\n                      >”特点来解决实际工作和面试中的问题呢？是否可以总结出什么有用的知识技巧？现在你的大脑里可能已经有了一个栈的“萌芽”，如下图所示：\n                    </p>\n                    <p data-nodeid=\"6700\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/64/Cgp9HWA4jLCAYaYWAAAXKWOZhe8052.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"7040\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6701\">\n                      接下来我将通过大厂面试题，带你学习这块重点知识。经过不断地“浇灌”，栈这棵“萌芽”才能抽枝散叶，长得更加茁壮。\n                    </p>\n                    <h4 data-nodeid=\"6702\">例 1：判断字符串括号是否合法</h4>\n                    <p data-nodeid=\"6703\">\n                      【<strong data-nodeid=\"7056\">题目</strong\n                      >】字符串中只有字符'('和')'。合法字符串需要括号可以配对。比如：\n                    </p>\n                    <p data-nodeid=\"6704\">输入：\"()\"</p>\n                    <p data-nodeid=\"6705\">输出：true</p>\n                    <p data-nodeid=\"6706\">\n                      <strong data-nodeid=\"7066\">解释</strong\n                      >：()，()()，(())是合法的。)(，()(，(()是非法的。\n                    </p>\n                    <p data-nodeid=\"6707\">\n                      请你实现一个函数，来判断给定的字符串是否合法。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isValid</span><span class=\"hljs-params\">(String s)</span></span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6709\">\n                      【<strong data-nodeid=\"7085\">分析</strong\n                      >】虽然这是一道<strong data-nodeid=\"7086\">简单题</strong\n                      >，但是我们依然可以拿它来<strong data-nodeid=\"7087\"\n                        >训练深度思考的能力</strong\n                      >。如果你已经知道答案，或者说能够轻松地解决这道题，不妨再跟我一起看看<strong\n                        data-nodeid=\"7088\"\n                        >如何拆解这道题</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6710\">\n                      首先，分析题目的时候，要特别注意以下 4 点，归纳为“<strong\n                        data-nodeid=\"7094\"\n                        >四步分析法</strong\n                      >”。\n                    </p>\n                    <ol data-nodeid=\"6711\">\n                      <li data-nodeid=\"6712\">\n                        <p data-nodeid=\"6713\">\n                          <strong data-nodeid=\"7102\">模拟</strong>：<strong\n                            data-nodeid=\"7103\"\n                            >模拟题目的运行。</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6714\">\n                        <p data-nodeid=\"6715\">\n                          <strong data-nodeid=\"7111\">规律</strong>：<strong\n                            data-nodeid=\"7112\"\n                            >尝试总结出题目的一般规律和特点。</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6716\">\n                        <p data-nodeid=\"6717\">\n                          <strong data-nodeid=\"7120\">匹配</strong>：<strong\n                            data-nodeid=\"7121\"\n                            >找到符合这些特点的数据结构与算法。</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6718\">\n                        <p data-nodeid=\"6719\">\n                          <strong data-nodeid=\"7129\">边界</strong>：<strong\n                            data-nodeid=\"7130\"\n                            >考虑特殊情况。</strong\n                          >\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"6720\">\n                      接下来我们就按照上面的步骤来拆解题目。\n                    </p>\n                    <p data-nodeid=\"6721\">\n                      <strong data-nodeid=\"7137\">1. 模拟</strong>\n                    </p>\n                    <p data-nodeid=\"6722\">\n                      首先我们以字符串 s = \"()()(())\"，进行模拟，如下动图所示：\n                    </p>\n                    <p data-nodeid=\"6723\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/61/CioPOWA4jh2AHCJwACmFB7AcuZA768.gif\"\n                        alt=\"2.gif\"\n                        data-nodeid=\"7145\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6724\">\n                      <strong data-nodeid=\"7151\">2. 规律</strong>\n                    </p>\n                    <p data-nodeid=\"6725\">\n                      我们回顾一下模拟过程，可以总结出以下 3 个特点。\n                    </p>\n                    <p data-nodeid=\"6726\">\n                      （1）每个左括号'('或者右括号')'都完成<strong\n                        data-nodeid=\"7166\"\n                        >配对</strong\n                      >，才是合法的。\n                    </p>\n                    <p data-nodeid=\"6727\">\n                      （2）配对可以通过<strong data-nodeid=\"7172\">消除法</strong\n                      >来消掉合法的括号，如果最后没有任何字符了，那么就是合法字符串。\n                    </p>\n                    <p data-nodeid=\"6728\">（3）奇数长度的字符串总是非法的。</p>\n                    <p data-nodeid=\"6729\">\n                      <strong data-nodeid=\"7179\">3. 匹配</strong>\n                    </p>\n                    <p data-nodeid=\"6730\">\n                      到这里，我们已经弄清楚题目考核的重点，就是<strong\n                        data-nodeid=\"7193\"\n                        >消除法</strong\n                      >的模拟。如果仔细观察消除法的行为模式，你会发现，在消除的时候，上图中<strong\n                        data-nodeid=\"7194\"\n                        >红色</strong\n                      >的部分和<strong data-nodeid=\"7195\">栈的行为</strong\n                      >非常像。因此，可以用栈来进行消除法的模拟。\n                    </p>\n                    <p data-nodeid=\"6731\">\n                      <strong data-nodeid=\"7201\">4. 边界</strong>\n                    </p>\n                    <p data-nodeid=\"6732\">\n                      当我们找到问题匹配的算法或者数据结构之后，一定要记住，接下来一步并不是马上写代码，而是要考虑一些边界问题，也就是一些特殊情况：\n                    </p>\n                    <ul data-nodeid=\"6733\">\n                      <li data-nodeid=\"6734\">\n                        <p data-nodeid=\"6735\">字符串为空</p>\n                      </li>\n                      <li data-nodeid=\"6736\">\n                        <p data-nodeid=\"6737\">字符串只有 1 个或者奇数个</p>\n                      </li>\n                      <li data-nodeid=\"6738\">\n                        <p data-nodeid=\"6739\">\n                          字符串是\"(((())))\"嵌套很多层的是否可以处理\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6740\">\n                      【<strong data-nodeid=\"7215\">画图</strong\n                      >】可以采用画图的方法来判断自己是否已经了解题目，或者是否能灵活运用一个算法。在面试中经常需要在白板或者纸上画图，所以在学习算法时候建议你培养多画图的习惯。\n                    </p>\n                    <ul data-nodeid=\"6741\">\n                      <li data-nodeid=\"6742\">\n                        <p data-nodeid=\"6743\">\n                          当遇到左括号'('时，进行压栈操作\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6744\">\n                        <p data-nodeid=\"6745\">\n                          当遇到右括号')'时，进行弹栈操作\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6746\">\n                      为了帮助你更好地理解，我将求解过程制作成一张动图，如下所示，注意左边<strong\n                        data-nodeid=\"7231\"\n                        >栈的变化</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6747\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/68/Cgp9HWA4kDOANTojAGASkY8p8QQ593.gif\"\n                        alt=\"3.gif\"\n                        data-nodeid=\"7234\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6748\">\n                      【<strong data-nodeid=\"7240\">代码</strong\n                      >】到这里时，你可以写出以下核心代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isValid</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 当字符串本来就是空的时候，我们可以快速返回true</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-keyword\">null</span> || s.length() == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (s.length() % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 消除法的主要核心逻辑: </span>\n</div></li><li><div class=\"code-word\">  Stack&lt;Character&gt; t = <span class=\"hljs-keyword\">new</span> Stack&lt;Character&gt;();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; s.length(); i++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 取出字符</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">'('</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果是'('，那么压栈</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp;   t.push(c);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果是')'，那么就尝试弹栈</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (t.empty()) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果弹栈失败，那么返回false</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      t.pop();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> t.empty();\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6750\">\n                      <p data-nodeid=\"6751\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.Java\"\n                          data-nodeid=\"7244\"\n                          >Java</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.cpp\"\n                          data-nodeid=\"7248\"\n                          >C++</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.py\"\n                          data-nodeid=\"7252\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6752\">\n                      <strong data-nodeid=\"7257\">复杂度分析</strong\n                      >：每个字符只入栈一次，出栈一次，所以时间复杂度为\n                      O(N)，而空间复杂度为\n                      O(N)，因为最差情况下可能会把整个字符串都入栈。\n                    </p>\n                    <p data-nodeid=\"6753\">\n                      做完一道题后，我们还需要从两个角度进行深度思考：\n                    </p>\n                    <ul data-nodeid=\"6754\">\n                      <li data-nodeid=\"6755\">\n                        <p data-nodeid=\"6756\">\n                          深度，比如这种解法还可以怎么优化呢？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6757\">\n                        <p data-nodeid=\"6758\">\n                          广度，比如这种解法具有普适性吗？可以推广吗？\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6759\">\n                      <strong data-nodeid=\"7266\">1. 深度扩展</strong>\n                    </p>\n                    <p data-nodeid=\"6760\">\n                      如果仔细观察，你会发现，栈中存放的元素是一样的。全部都是左括号'('，除此之外，再也没有别的元素，优化方法如下。\n                    </p>\n                    <p data-nodeid=\"6761\">\n                      <strong data-nodeid=\"7276\"\n                        >栈中元素都相同时，实际上没有必要使用栈，只需要记录栈中元素个数。</strong\n                      >\n                      我们可以通过画图来解决这个问题，如下动图所示：\n                    </p>\n                    <p data-nodeid=\"6762\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/65/CioPOWA4kG2AWiD2AAJ2CaCcwJY807.gif\"\n                        alt=\"4.gif\"\n                        data-nodeid=\"7279\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6763\">\n                      实际上，就是把入栈与出栈变成了 leftBraceNumber\n                      的加减。代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isValid</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 当字符串本来就是空的时候，我们可以快速返回true</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-keyword\">null</span> || s.length() == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">if</span> (s.length() % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 消除法的主要核心逻辑:</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span> leftBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; s.length(); i++) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 取出字符</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">'('</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果是'('，那么压栈</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; leftBraceNumber++;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果是')'，那么就尝试弹栈</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (leftBraceNumber &lt;= <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果弹栈失败，那么返回false</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; --leftBraceNumber;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">return</span> leftBraceNumber == <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6765\">\n                      <p data-nodeid=\"6766\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.java\"\n                          data-nodeid=\"7284\"\n                          >Java</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.cpp\"\n                          data-nodeid=\"7288\"\n                          >C++</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.py\"\n                          data-nodeid=\"7292\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6767\">\n                      <strong data-nodeid=\"7297\">复杂度分析</strong\n                      >：每个字符只入栈一次，出栈一次，所以时间复杂度为\n                      O(N)，而空间复杂度为\n                      O(1)，因为我们已经只用一个变量来记录栈中的内容。\n                    </p>\n                    <p data-nodeid=\"6768\">\n                      【<strong data-nodeid=\"7303\">小结</strong\n                      >】经过前面的分析，现在我们可以将题目的特点做一下小结：\n                    </p>\n                    <p data-nodeid=\"6769\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/77/Cgp9HWA4ny2ASkpXAABGeRYQOyU298.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"7306\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6770\">\n                      <strong data-nodeid=\"7312\">2. 广度扩展</strong>\n                    </p>\n                    <p data-nodeid=\"6771\">\n                      接下来再来看看如何进行广度扩展。观察题目可以发现，栈中只存放了一个维度的信息：左括号'('和右括号')'。如果<strong\n                        data-nodeid=\"7326\"\n                        >栈中的内容变得更加丰富</strong\n                      >一点，就可以得到下面这道扩展题。\n                    </p>\n                    <p data-nodeid=\"6772\">\n                      【<strong data-nodeid=\"7356\">题目扩展</strong\n                      >】给定一个只包括 '('，')'，'{'，'}'，'['，']'\n                      的字符串，判断字符串是否有效。有效字符串需满足：\n                    </p>\n                    <ol data-nodeid=\"6773\">\n                      <li data-nodeid=\"6774\">\n                        <p data-nodeid=\"6775\">\n                          左括号必须用相同类型的右括号闭合\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6776\">\n                        <p data-nodeid=\"6777\">左括号必须以正确的顺序闭合</p>\n                      </li>\n                      <li data-nodeid=\"6778\">\n                        <p data-nodeid=\"6779\">\n                          注意空字符串可被认为是有效字符串\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"6780\">\n                      请实现接口：\n                      public&nbsp;boolean&nbsp;isValid(String&nbsp;s)\n                    </p>\n                    <p data-nodeid=\"6781\">\n                      对于这道题，我希望你能再走一下：<strong data-nodeid=\"7382\"\n                        >分析</strong\n                      >，<strong data-nodeid=\"7383\">画图</strong>，<strong\n                        data-nodeid=\"7384\"\n                        >代码</strong\n                      >，扩<strong data-nodeid=\"7385\">展</strong>，<strong\n                        data-nodeid=\"7386\"\n                        >小结</strong\n                      >的五步曲。\n                    </p>\n                    <blockquote data-nodeid=\"6782\">\n                      <p data-nodeid=\"6783\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.java\"\n                          data-nodeid=\"7390\"\n                          >Java</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.cpp\"\n                          data-nodeid=\"7394\"\n                          >C++</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.py\"\n                          data-nodeid=\"7398\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6784\">\n                      【<strong data-nodeid=\"7408\">小结</strong\n                      >】接下来，我们对拓展题目进行总结，希望你从中<strong\n                        data-nodeid=\"7409\"\n                        >提炼出经验</strong\n                      >，以后再遇到相似的题目能够轻松应对。\n                    </p>\n                    <p data-nodeid=\"6785\">\n                      对于栈的使用，除了知道“后进先出”这个规律，我们还可以帮它长出一些叶子来，如下图所示：\n                    </p>\n                    <p data-nodeid=\"6786\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/74/CioPOWA4nzyAJYfYAABDA_sAa3Q037.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"7413\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6787\">\n                      因此，以后你在看到题目中类似<strong data-nodeid=\"7427\"\n                        >配对</strong\n                      >、<strong data-nodeid=\"7428\">消除</strong\n                      >之类的动作时，可以采用<strong data-nodeid=\"7429\"\n                        >栈</strong\n                      >来操作。通过这两个方向上的整理和归纳，我们进一步探寻到了题目和解法之间的联系。让我们继续前进。\n                    </p>\n                    <h4 data-nodeid=\"6788\">例 2：大鱼吃小鱼</h4>\n                    <p data-nodeid=\"6789\">\n                      【<strong data-nodeid=\"7444\">题目</strong\n                      >】在水中有许多鱼，可以认为这些鱼停放在 x\n                      轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i\n                      条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1\n                      表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:\n                    </p>\n                    <ol data-nodeid=\"6790\">\n                      <li data-nodeid=\"6791\">\n                        <p data-nodeid=\"6792\">\n                          所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6793\">\n                        <p data-nodeid=\"6794\">当方向相对时，大鱼会吃掉小鱼；</p>\n                      </li>\n                      <li data-nodeid=\"6795\">\n                        <p data-nodeid=\"6796\">鱼的大小都不一样。</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"6797\">\n                      输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]\n                    </p>\n                    <p data-nodeid=\"6798\">输出：3</p>\n                    <p data-nodeid=\"6799\">请完成以下接口来计算还剩下几条鱼？</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] Size, <span class=\"hljs-keyword\">int</span>[] Dir)</span></span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6801\">题目的示意图如下所示：</p>\n                    <p data-nodeid=\"6802\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/74/CioPOWA4n3uAM9nhAACmI5boRa0503.gif\"\n                        alt=\"Stack01.大鱼吃小鱼.gif\"\n                        data-nodeid=\"7461\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6803\">\n                      【<strong data-nodeid=\"7471\">分析</strong\n                      >】对于这道题而言，大鱼吃掉小鱼的时候，可以认为是一种<strong\n                        data-nodeid=\"7472\"\n                        >消除</strong\n                      >行为。只不过与括号匹配时的行为不一样：\n                    </p>\n                    <ul data-nodeid=\"6804\">\n                      <li data-nodeid=\"6805\">\n                        <p data-nodeid=\"6806\">\n                          括号匹配是会<strong data-nodeid=\"7478\">同时</strong\n                          >把左括号与右括号消除掉；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6807\">\n                        <p data-nodeid=\"6808\">\n                          大鱼吃小鱼，<strong data-nodeid=\"7484\"\n                            >只会把小鱼</strong\n                          >消除掉。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6809\">\n                      <strong data-nodeid=\"7490\">1. 模拟</strong>\n                    </p>\n                    <p data-nodeid=\"6810\">首先我们以如下示例进行演示：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">Size = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">5</span>], Dir = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6812\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/74/CioPOWA4n5yAIhjtAAXAzjrqmCE807.gif\"\n                        alt=\"5.gif\"\n                        data-nodeid=\"7494\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6813\">\n                      <em data-nodeid=\"7498\"\n                        >注意：当鱼的游动方向相同，或者相反时，并不会相遇，此时大鱼不能吃掉小鱼。</em\n                      >\n                    </p>\n                    <p data-nodeid=\"6814\">\n                      <strong data-nodeid=\"7504\">2. 规律</strong>\n                    </p>\n                    <p data-nodeid=\"6815\">通过模拟，可以发现如下规律:</p>\n                    <ul data-nodeid=\"6816\">\n                      <li data-nodeid=\"6817\">\n                        <p data-nodeid=\"6818\">\n                          如果两条鱼<strong data-nodeid=\"7510\"\n                            >相对而游时，那么较小的鱼会被吃掉；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6819\">\n                        <p data-nodeid=\"6820\">\n                          <strong data-nodeid=\"7515\">其他情况</strong\n                          >没有鱼被吃掉。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6821\">\n                      <strong data-nodeid=\"7521\">3. 匹配</strong>\n                    </p>\n                    <p data-nodeid=\"6822\">\n                      我们发现，下面活下来的鱼的行为（上图红框部分）就是一个<strong\n                        data-nodeid=\"7527\"\n                        >栈</strong\n                      >。每当有新的鱼要进来的时候，就会与栈顶的鱼进行比较。那么我们匹配到的算法就是栈了。\n                    </p>\n                    <p data-nodeid=\"6823\">\n                      <strong data-nodeid=\"7533\">4. 边界</strong>\n                    </p>\n                    <p data-nodeid=\"6824\">\n                      在正式开始求解之前，我们还是想一想两种边界：\n                    </p>\n                    <ul data-nodeid=\"6825\">\n                      <li data-nodeid=\"6826\">\n                        <p data-nodeid=\"6827\">所有的鱼都朝着一个方向游；</p>\n                      </li>\n                      <li data-nodeid=\"6828\">\n                        <p data-nodeid=\"6829\">一条鱼吃掉了其他的所有鱼。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6830\">\n                      我们在后面设计算法的时候，这些情况都需要考虑到。\n                    </p>\n                    <p data-nodeid=\"6831\">\n                      【<strong data-nodeid=\"7547\">画图</strong>】<strong\n                        data-nodeid=\"7548\"\n                        >这道题的关键仍然是如何使用栈来模拟鱼的消除行为</strong\n                      >。接下来我们用栈画一下图，演示出我们的思路，动图如下：\n                    </p>\n                    <p data-nodeid=\"6832\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/74/CioPOWA4n7eAEu-UAAY8UjR-F74828.gif\"\n                        alt=\"7.gif\"\n                        data-nodeid=\"7551\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"6833\"></h3>\n                    <p data-nodeid=\"6834\">\n                      【<strong data-nodeid=\"7557\">代码</strong\n                      >】根据之前的思考，可以得到如下解法（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] fishSize, <span class=\"hljs-keyword\">int</span>[] fishDirection)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 首先拿到鱼的数量</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果鱼的数量小于等于1，那么直接返回鱼的数量</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> fishNumber = fishSize.length;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">if</span> (fishNumber &lt;= <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> fishNumber;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 0表示鱼向左游</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> left = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 1表示鱼向右游</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> right = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">&nbsp; Stack&lt;Integer&gt; t = <span class=\"hljs-keyword\">new</span> Stack();\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; fishNumber; i++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 当前鱼的情况：1，游动的方向；2，大小</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> curFishDirection = fishDirection[i];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> curFishSize = fishSize[i];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 当前的鱼是否被栈中的鱼吃掉了</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">boolean</span> hasEat = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果栈中还有鱼，并且栈中鱼向右，当前的鱼向左游，那么就会有相遇的可能性</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (!t.empty() &amp;&amp; fishDirection[t.peek()] == right &amp;&amp;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;curFishDirection == left) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果栈顶的鱼比较大，那么把新来的吃掉</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (fishSize[t.peek()] &gt; curFishSize) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; hasEat = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果栈中的鱼较小，那么会把栈中的鱼吃掉，栈中的鱼被消除，所以需要弹栈。</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; t.pop();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果新来的鱼，没有被吃掉，那么压入栈中。</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (!hasEat) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; t.push(i);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">return</span> t.size();\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6836\">\n                      <p data-nodeid=\"6837\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.java\"\n                          data-nodeid=\"7561\"\n                          >Java</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.cpp\"\n                          data-nodeid=\"7565\"\n                          >C++</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.py\"\n                          data-nodeid=\"7569\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6838\">\n                      <strong data-nodeid=\"7574\">复杂度分析</strong\n                      >：每只鱼只入栈一次，出栈一次，所以时间复杂度 为\n                      O(N)，而空间复杂度为\n                      O(N)，因为最差情况下可能把所有的鱼都入栈。\n                    </p>\n                    <p data-nodeid=\"6839\">\n                      【<strong data-nodeid=\"7580\">小结</strong\n                      >】接下来我们一起对这道题做一下归纳。可以发现，与例 1\n                      相比，它们的消除行为有所不同：\n                    </p>\n                    <ul data-nodeid=\"6840\">\n                      <li data-nodeid=\"6841\">\n                        <p data-nodeid=\"6842\">\n                          在例 1 中，消除行为表现为配对的<strong\n                            data-nodeid=\"7585\"\n                            >两者都会消除；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6843\">\n                        <p data-nodeid=\"6844\">\n                          在例 2 中，消除行为表现为配对的两者中<strong\n                            data-nodeid=\"7591\"\n                            >有一个会被消除</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6845\">\n                      此外，在与 例 1 的比较中，可以发现，栈中的内容也有所不同：\n                    </p>\n                    <ul data-nodeid=\"6846\">\n                      <li data-nodeid=\"6847\">\n                        <p data-nodeid=\"6848\">\n                          在例 1 中，栈中的<strong data-nodeid=\"7598\"\n                            >存放的就是内容本</strong\n                          >身；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6849\">\n                        <p data-nodeid=\"6850\">\n                          在例 2 中，栈中存<strong data-nodeid=\"7604\"\n                            >放的只是内容的索引</strong\n                          >，可以通过索引得到内容。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6851\">\n                      再者，我们也发现，在弹栈的时候，不再像以前那样，每次只弹一个元素，而是采用了\n                      while\n                      循环，要一直弹到满足某个条件为止。所以我们总结出，弹栈的时候有两种情况：\n                    </p>\n                    <ul data-nodeid=\"6852\">\n                      <li data-nodeid=\"6853\">\n                        <p data-nodeid=\"6854\">\n                          <strong data-nodeid=\"7610\">弹一个元素</strong>就可以；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6855\">\n                        <p data-nodeid=\"6856\">\n                          用 while 语句<strong data-nodeid=\"7616\"\n                            >一直弹，直到满足某个条件</strong\n                          >为止。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6857\">\n                      因此，这道题的考点我们也挖掘出来了：\n                    </p>\n                    <ul data-nodeid=\"6858\">\n                      <li data-nodeid=\"6859\">\n                        <p data-nodeid=\"6860\">\n                          是否会<strong data-nodeid=\"7623\"\n                            >用栈来存放索引</strong\n                          >？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6861\">\n                        <p data-nodeid=\"6862\">\n                          是否想到在弹栈的时候一定要<strong data-nodeid=\"7629\"\n                            >满足某个条件才停止弹栈</strong\n                          >？\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6863\">\n                      到这里栈的特点更丰富了，通过我们不断地浇灌也让栈这棵“萌芽”长出了更多的叶子，总结如下图所示：\n                    </p>\n                    <p data-nodeid=\"6864\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/77/Cgp9HWA4n9WAA59XAACgLfhWcGY098.png\"\n                        alt=\"Drawing 19.png\"\n                        data-nodeid=\"7633\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"6865\">单调栈的解题技巧</h3>\n                    <p data-nodeid=\"6866\">\n                      大部分数据结构书上都不太会讲单调栈的知识，但是在面试中却经常考察这一类题，这就非常考验你的知识储备了。\n                    </p>\n                    <p data-nodeid=\"6867\">\n                      首先我们看一下<strong data-nodeid=\"7653\"\n                        >单调栈的定义</strong\n                      >：单调栈就是指栈中的元素<strong data-nodeid=\"7654\"\n                        >必须</strong\n                      >是按照<strong data-nodeid=\"7655\">升序</strong\n                      >排列的栈，或者是<strong data-nodeid=\"7656\">降序</strong\n                      >排列的栈。对于这两种排序方式的栈，还给它们各自取了小名。\n                    </p>\n                    <p data-nodeid=\"6868\">\n                      升序排列的栈称为<strong data-nodeid=\"7662\">递增栈</strong\n                      >，如下图所示：\n                    </p>\n                    <p data-nodeid=\"6869\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/7B/CioPOWA4qWKAWwxXAAClLMMoPFk436.gif\"\n                        alt=\"8.gif\"\n                        data-nodeid=\"7665\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6870\">\n                      降序排列的栈称为<strong data-nodeid=\"7671\">递减栈</strong\n                      >，如下图所示：\n                    </p>\n                    <p data-nodeid=\"6871\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/7F/Cgp9HWA4qXCAM4-PAADnGTexjMk160.gif\"\n                        alt=\"9.gif\"\n                        data-nodeid=\"7674\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6872\">\n                      <em data-nodeid=\"7678\"\n                        >注意：示意图所展示的这两种栈是横向排列的。栈中元素的值，分别用不同高度的矩形来表示，值越大，矩形越高。</em\n                      >\n                    </p>\n                    <p data-nodeid=\"6873\">\n                      接下来我们介绍一下递增栈的有序性，一句话：“<strong\n                        data-nodeid=\"7684\"\n                        >任何时候都需要保证栈的有序性</strong\n                      >”。\n                    </p>\n                    <p data-nodeid=\"6874\">\n                      递增栈的特性可以演示如下（上方数组是要依次入栈的元素）：\n                    </p>\n                    <p data-nodeid=\"6875\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/7B/CioPOWA4qXmAUt2VAANQuRNAR14194.gif\"\n                        alt=\"13.gif\"\n                        data-nodeid=\"7688\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6876\">递减栈的特性可以演示如下：</p>\n                    <p data-nodeid=\"6877\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/7B/CioPOWA4qYCABi8aAAUfrNnOGUY452.gif\"\n                        alt=\"14.gif\"\n                        data-nodeid=\"7692\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6878\">\n                      通过这两个动图，我们可以总结出单调栈的特点，如下图所示：\n                    </p>\n                    <p data-nodeid=\"6879\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/7C/CioPOWA4qiiAEfpbAABn_-GStTI565.png\"\n                        alt=\"Drawing 29.png\"\n                        data-nodeid=\"7696\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6880\">\n                      接下来我们通过一些小题目来对单调栈进行“浇灌”，也让单调栈长出更多的“叶子”。\n                    </p>\n                    <h4 data-nodeid=\"6881\">例 3：找出数组中右边比我小的元素</h4>\n                    <p data-nodeid=\"6882\">\n                      【<strong data-nodeid=\"7704\">题目</strong>】一个整数数组\n                      A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1\n                      表示。\n                    </p>\n                    <p data-nodeid=\"6883\">输入：[5, 2]</p>\n                    <p data-nodeid=\"6884\">输出：[1, -1]</p>\n                    <p data-nodeid=\"6885\">\n                      <strong data-nodeid=\"7721\">解释</strong>：因为元素 5\n                      的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2\n                      右边没有比 2 小的元素，所以应该输出 -1。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">接口：<span class=\"hljs-keyword\">int</span>[] findRightSmall(<span class=\"hljs-keyword\">int</span>[] A);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6887\">\n                      【<strong data-nodeid=\"7731\">分析</strong\n                      >】每次开始分析题意时，记得要拿出我们的“<strong\n                        data-nodeid=\"7732\"\n                        >四步分析法”</strong\n                      >，通过一步步分析找到题目相应的解法。\n                    </p>\n                    <p data-nodeid=\"6888\">\n                      <strong data-nodeid=\"7738\">1. 模拟</strong>\n                    </p>\n                    <p data-nodeid=\"6889\">\n                      在正式开始上手之后，我们先拿两个例子演示一下，看看能不能发现题目中隐藏的一些有趣规律，动图如下所示：\n                    </p>\n                    <p data-nodeid=\"6890\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/7F/Cgp9HWA4qYqASCuDAArtP3-ZB0A448.gif\"\n                        alt=\"15.gif\"\n                        data-nodeid=\"7742\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6891\">\n                      <strong data-nodeid=\"7748\">2. 规律</strong>\n                    </p>\n                    <p data-nodeid=\"6892\">\n                      这里我们是照着题意去寻找一个右边比它小的数的下标。可以发现，A[4]\n                      = 4 及 A[5] = 0，这两个数字多次被用到。并且：\n                    </p>\n                    <ul data-nodeid=\"6893\">\n                      <li data-nodeid=\"6894\">\n                        <p data-nodeid=\"6895\">\n                          A[4] 发现有左边 A[3]，A[3] 就匹配成功；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6896\">\n                        <p data-nodeid=\"6897\">\n                          结合 A[5] = 0\n                          的例子，我们发现它会把比它大的数都进行<strong\n                            data-nodeid=\"7784\"\n                            >匹配成功</strong\n                          >，但是 A[3] 除外；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6898\">\n                        <p data-nodeid=\"6899\">\n                          A[3] 可以认为是匹配成功之后，被 A[4]<strong\n                            data-nodeid=\"7797\"\n                            >消除</strong\n                          >了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6900\">\n                      <strong data-nodeid=\"7802\"\n                        >这时可以总结出：一个数总是想与左边比它大的数进行匹配，匹配到了之后，小的数会消除掉大的数</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6901\">\n                      <strong data-nodeid=\"7808\">3. 匹配</strong>\n                    </p>\n                    <p data-nodeid=\"6902\">当你发现要解决的题目有两个特点：</p>\n                    <ul data-nodeid=\"6903\">\n                      <li data-nodeid=\"6904\">\n                        <p data-nodeid=\"6905\">\n                          小的数要与大的数<strong data-nodeid=\"7814\"\n                            >配对</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6906\">\n                        <p data-nodeid=\"6907\">\n                          小的数会<strong data-nodeid=\"7820\">消除</strong>大的数\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6908\">\n                      你的脑海里应该联想到关于<strong data-nodeid=\"7826\"\n                        >单调栈</strong\n                      >的特性。下面我们看看如何利用单调栈解决这道题目。\n                    </p>\n                    <p data-nodeid=\"6909\">\n                      【<strong data-nodeid=\"7836\">画图</strong\n                      >】在这里，依然需要画一个图来描述一下我们的思路及想法，如下图所示：（红色部分表示栈，我们只将<strong\n                        data-nodeid=\"7837\"\n                        >下标绿色值</strong\n                      >放到栈中，为了看图方便，把下标对应的值也标在了相应位置。）\n                    </p>\n                    <p data-nodeid=\"6910\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/7F/Cgp9HWA4qkaALlpRAHsvPijzTIg101.gif\"\n                        alt=\"16.gif\"\n                        data-nodeid=\"7840\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6911\">\n                      Step 1. 首先将 A[0] = 1 的下标\n                      <strong data-nodeid=\"7850\">0</strong> 入栈。\n                    </p>\n                    <p data-nodeid=\"6912\">\n                      Step 2. 将 A[1] = 2 的下标 1 入栈。满足单调栈。\n                    </p>\n                    <p data-nodeid=\"6913\">\n                      Step 3. 将 A[2] = 4 的下标 2 入栈。满足单调栈。\n                    </p>\n                    <p data-nodeid=\"6914\">\n                      Step 4. 将 A[3] = 9 的下标 3 入栈。满足单调栈。\n                    </p>\n                    <p data-nodeid=\"6915\">\n                      Step 5. 将 A[4] = 4 的下标 4 入栈时，不满足单调性，需要将\n                      A[3] = 9 从栈中弹出去。下标 4 将栈中下标 3 弹出栈，记录\n                      A[3] 右边更小的是 index = 4。\n                    </p>\n                    <p data-nodeid=\"6916\">\n                      Step 6. 将 A[5] = 0 的下标 5 入栈时，不满足单调性，需要将\n                      A[4] = 4 从栈中弹出去。下标 5 将下标 4 弹出栈，记录 A[4]\n                      右边更小的是 index = 5。A[5] = 0 会将栈中的下标 0, 1, 2\n                      都弹出栈，因此也需要记录相应下标右边比其小的下标为 5，再将\n                      A[5] = 0 的下标 5 放入栈中。\n                    </p>\n                    <p data-nodeid=\"6917\">\n                      Step 7. 将 A[6] = 5 的下标 6 放入栈中。满足单调性。\n                    </p>\n                    <p data-nodeid=\"6918\">\n                      Step 8.\n                      此时，再也没有元素要入栈了，那么栈中的元素右边没有比其更小的元素。因此设置为\n                      -1.\n                    </p>\n                    <p data-nodeid=\"6919\">\n                      【<strong data-nodeid=\"7911\">代码</strong\n                      >】到此为止，相信你已经可以根据思路写出代码了，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] findRightSmall(<span class=\"hljs-keyword\">int</span>[] A) {\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 结果数组</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[A.length];\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 注意，栈中的元素记录的是下标</span>\n</div></li><li><div class=\"code-word\">&nbsp; Stack&lt;Integer&gt; t = <span class=\"hljs-keyword\">new</span> Stack();\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.length; i++) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = A[i];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 每个元素都向左遍历栈中的元素完成消除动作</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 消除的时候，记录一下被谁消除了</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; ans[t.peek()] = i;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 消除时候，值更大的需要从栈中消失</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; t.pop();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 剩下的入栈</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; t.push(i);\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">while</span> (!t.empty()) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; ans[t.peek()] = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; t.pop();\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6921\">\n                      <p data-nodeid=\"6922\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.java\"\n                          data-nodeid=\"7915\"\n                          >Java</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.cpp\"\n                          data-nodeid=\"7919\"\n                          >C++</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.py\"\n                          data-nodeid=\"7923\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6923\">\n                      <strong data-nodeid=\"7928\">复杂度分析</strong\n                      >：每个元素只入栈一次，出栈一次，所以时间复杂度为\n                      O(N)，而空间复杂度为\n                      O(N)，因为最差情况可能会把所有的元素都入栈。\n                    </p>\n                    <p data-nodeid=\"6924\">\n                      【<strong data-nodeid=\"7942\">小结</strong\n                      >】到这里我们可以得到一个有趣且非常有用的结论：数组中右边<strong\n                        data-nodeid=\"7943\"\n                        >第一个比我小</strong\n                      >的元素的位置，求解用<strong data-nodeid=\"7944\"\n                        >递增栈</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6925\">\n                      这里给你留几道<strong data-nodeid=\"7950\">练习题</strong\n                      >，请你思考如何求解。\n                    </p>\n                    <ol data-nodeid=\"6926\">\n                      <li data-nodeid=\"6927\">\n                        <p data-nodeid=\"6928\">\n                          数组中右边第一个比我大的元素的位置\n                        </p>\n                      </li>\n                    </ol>\n                    <blockquote data-nodeid=\"98718\">\n                      <p data-nodeid=\"98719\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.java\"\n                          data-nodeid=\"98724\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.cpp\"\n                          data-nodeid=\"98728\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.py\"\n                          data-nodeid=\"98732\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <ol start=\"2\" data-nodeid=\"162421\">\n                      <li data-nodeid=\"162422\" class=\"\">\n                        <p data-nodeid=\"162423\">\n                          数组中元素左边离我最近且比我小的元素的位置\n                        </p>\n                      </li>\n                    </ol>\n\n                    <blockquote data-nodeid=\"6934\">\n                      <p data-nodeid=\"6935\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.java\"\n                          data-nodeid=\"7968\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.cpp\"\n                          data-nodeid=\"7972\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.py\"\n                          data-nodeid=\"7976\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <ol start=\"3\" data-nodeid=\"170788\">\n                      <li data-nodeid=\"170789\">\n                        <p data-nodeid=\"170790\" class=\"te-preview-highlight\">\n                          数组中元素左边离我最近且比我大的元素的位置\n                        </p>\n                      </li>\n                    </ol>\n\n                    <blockquote data-nodeid=\"6939\">\n                      <p data-nodeid=\"6940\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.java\"\n                          data-nodeid=\"7981\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.cpp\"\n                          data-nodeid=\"7985\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.py\"\n                          data-nodeid=\"7989\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6941\">\n                      如果我们进一步归纳，会发现消除的时候，这里仍然是消除一个元素，保留一个元素。弹栈的时候，仍然是一<strong\n                        data-nodeid=\"7995\"\n                        >直弹栈，直到满足某个条件为止</strong\n                      >。只是条件变成了直到元素大于栈顶元素。为了方便你理解，我把内容总结到了一张大图里：\n                    </p>\n                    <p data-nodeid=\"6942\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/7F/Cgp9HWA4qrWAR4cuAADTLTA3i8c099.png\"\n                        alt=\"Drawing 45.png\"\n                        data-nodeid=\"7998\"\n                      />\n                    </p>\n                    <h4 data-nodeid=\"6943\">\n                      例 4：字典序最小的 k 个数的子序列\n                    </h4>\n                    <p data-nodeid=\"6944\">\n                      【<strong data-nodeid=\"8013\">题目</strong\n                      >】给定一个正整数数组和 k，要求依次取出 k\n                      个数，输出其中数组的一个子序列，需要满足：1.\n                      <strong data-nodeid=\"8014\">长度为 k</strong>；2.<strong\n                        data-nodeid=\"8015\"\n                        >字典序最小</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6945\">\n                      输入：nums = [3,5,2,6], k = 2<br />\n                      输出：[2,6]\n                    </p>\n                    <p data-nodeid=\"6946\">\n                      <strong data-nodeid=\"8058\">解释</strong\n                      >：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6],\n                      [2,6]} 中，[2,6] 字典序最小。\n                    </p>\n                    <p data-nodeid=\"6947\">\n                      所谓字典序就是，给定两个数组：x =\n                      [x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,x<sub>4</sub>]，y\n                      =\n                      [y<sub>1</sub>,y<sub>2</sub>,y<sub>3</sub>,y<sub>4</sub>]，如果\n                      0 ≤ p &lt; i，x<sub>p</sub> == y<sub>p</sub> 且 x<sub\n                        >i</sub\n                      >\n                      &lt; y<sub>i</sub>，那么我们认为 x 的字典序小于 y。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">接口：<span class=\"hljs-keyword\">int</span>[] findSmallSeq(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> k);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6949\">\n                      【<strong data-nodeid=\"8123\">分析</strong\n                      >】根据“四步分析法”，我们一步一步拆解题目。\n                    </p>\n                    <p data-nodeid=\"6950\">\n                      <strong data-nodeid=\"8129\">1. 模拟</strong>\n                    </p>\n                    <p data-nodeid=\"6951\">\n                      首先应该拿例子来模拟一下题目所述的过程，动图如下所示：\n                    </p>\n                    <p data-nodeid=\"6952\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/80/Cgp9HWA4qsyASrO1AAMU43HNuI4415.gif\"\n                        alt=\"12.gif\"\n                        data-nodeid=\"8133\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6953\">\n                      <strong data-nodeid=\"8139\">2. 规律</strong>\n                    </p>\n                    <p data-nodeid=\"6954\">\n                      通过模拟，我们发现<strong data-nodeid=\"8145\"\n                        >一个特点：一旦发现更小的数时，就可以把前面已经放好的数扔掉，然后把这个最小的数放在最前面</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6955\">\n                      如果机智一点，就会发现这里与<strong data-nodeid=\"8159\"\n                        >例 2 的</strong\n                      >“<strong data-nodeid=\"8160\">大鱼吃小鱼</strong\n                      >”结果很像。区别在于消除的过程中，大鱼吃小鱼是大鱼留下来了，而这里较小的数和较大的数相遇时，是<strong\n                        data-nodeid=\"8161\"\n                        >较小的数</strong\n                      >留下来了。\n                    </p>\n                    <p data-nodeid=\"6956\">\n                      <strong data-nodeid=\"8167\">3. 匹配</strong>\n                    </p>\n                    <p data-nodeid=\"6957\">\n                      到这里，我们已经发现了题目的特点——<strong\n                        data-nodeid=\"8181\"\n                        >较小数消除掉较大数</strong\n                      >。根据<strong data-nodeid=\"8182\">例 3</strong>\n                      总结出来的规律，此时就可以用上单调栈。并且，由于是较小的数消除掉较大的数，所以应该使用<strong\n                        data-nodeid=\"8183\"\n                        >递增栈</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6958\">\n                      <strong data-nodeid=\"8189\">4. 边界</strong>\n                    </p>\n                    <p data-nodeid=\"6959\">不过我们还是需要小心题目的边界。</p>\n                    <p data-nodeid=\"6960\">\n                      <strong data-nodeid=\"8195\">Case 1</strong\n                      >：假设数组右边有一个最小的数，这个最小的数会把左边的数全部都消掉，然后递增栈里面就只剩下这\n                      1 个数了。这跟题意有点不符合，题意需要的是找到 k = 2\n                      个出来。\n                    </p>\n                    <p data-nodeid=\"6961\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/80/Cgp9HWA4quuAMBDzAALrKCGW33s184.gif\"\n                        alt=\"10.gif\"\n                        data-nodeid=\"8198\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6962\">\n                      <strong data-nodeid=\"8203\">解决办法</strong\n                      >：不过你可以想一想，是不是可以控制一下消去的数目。当剩下的数字个数与栈中的元素刚好能凑够\n                      k 个数时，就不能再消除了，代码如下 :\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">rightLeftNumber + stack.size() == k\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6964\">\n                      此时，如果还要进行消除，就不能凑够 k\n                      个数了。这样操作可以保证我们取的序列是最小的 k 个数。\n                    </p>\n                    <p data-nodeid=\"6965\">\n                      <strong data-nodeid=\"8209\">Case 2</strong\n                      >：如果数组是一个升序的数组，那么此时所有的元素都会被压栈。栈中的数目有可能远远超出\n                      k 个。\n                    </p>\n                    <p data-nodeid=\"6966\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/80/Cgp9HWA4qxqAFbVgAAH8B7oHgJo512.gif\"\n                        alt=\"11.gif\"\n                        data-nodeid=\"8212\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6967\">\n                      <strong data-nodeid=\"8217\">解决办法</strong\n                      >：只需要把栈中的多出来的数字弹出来即可。\n                    </p>\n                    <p data-nodeid=\"6968\">\n                      【<strong data-nodeid=\"8227\">画图</strong>】假定输入为[9,\n                      2, 4, 5, 1, 2, 3, 0], k = 3.输出能构成的最小的序列。\n                    </p>\n                    <p data-nodeid=\"6969\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/81/Cgp9HWA4qzaAHEjwAGccHgMTVOU699.gif\"\n                        alt=\"17.gif\"\n                        data-nodeid=\"8230\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6970\">Step 1. 首先将 9 加入栈中。</p>\n                    <p data-nodeid=\"6971\">\n                      Step 2. 当 2 要入栈时，不满足单调栈，需要将数字 9\n                      出栈。由于后面还有足够多的元素，可以把 9 弹栈，再将 2\n                      入栈。\n                    </p>\n                    <p data-nodeid=\"6972\">Step 3. 将 4 入栈，满足单调性。</p>\n                    <p data-nodeid=\"6973\">\n                      Step 4. 再将元素 5 入栈，满足单调性。\n                    </p>\n                    <p data-nodeid=\"6974\">\n                      Step 5. 将要入栈的元素 1，会弹出栈中所有元素。\n                    </p>\n                    <p data-nodeid=\"6975\">Step 6. 将元素 1 入栈。</p>\n                    <p data-nodeid=\"6976\">\n                      Step 7. 将元素 2 入栈，满足单调性。\n                    </p>\n                    <p data-nodeid=\"6977\">\n                      Step 8. 将元素 3 入栈，满足单调性。\n                    </p>\n                    <p data-nodeid=\"6978\">\n                      Step 9. 将 0 入栈时，需要将栈顶元素 3 弹出。\n                    </p>\n                    <p data-nodeid=\"6979\">\n                      Step 10. 将 0 入栈，不满足单调性。这是因为，如果 0\n                      将前面的元素再弹栈，余下的元素个数就小于 k = 3\n                      个了。所以不能再利用单调性来弹出栈中元素了。\n                    </p>\n                    <p data-nodeid=\"6980\">\n                      【<strong data-nodeid=\"8246\">代码</strong\n                      >】到这里，相信你已经可以根据思路写出代码了，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] findSmallSeq(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> k) {\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[k];\n</div></li><li><div class=\"code-word\">&nbsp; Stack&lt;Integer&gt; s = <span class=\"hljs-keyword\">new</span> Stack();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里生成单调栈</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.length; i++) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = nums[i];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> left = nums.length - i;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意我们想要提取出k个数，所以注意控制扔掉的数的个数</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (!s.empty() &amp;&amp; (s.size() + left &gt; k) &amp;&amp; s.peek() &gt; x) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; s.pop();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; s.push(x);\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果递增栈里面的数太多，那么我们只需要取出前k个就可以了。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 多余的栈中的元素需要扔掉。</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">while</span> (s.size() &gt; k) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; s.pop();\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 把k个元素取出来，注意这里取的顺序!</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = k - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; ans[i] = s.peek();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; s.pop();\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6982\">\n                      <p data-nodeid=\"6983\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.java\"\n                          data-nodeid=\"8250\"\n                          >Java</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.cpp\"\n                          data-nodeid=\"8254\"\n                          >C++</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.py\"\n                          data-nodeid=\"8258\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6984\">\n                      <strong data-nodeid=\"8263\">复杂度分析</strong\n                      >：每个元素只入栈一次，出栈一次，所以时间复杂度为\n                      O(N)，而空间复杂度为\n                      O(N)，因为最差情况可能会把所有元素都入栈。\n                    </p>\n                    <p data-nodeid=\"6985\">\n                      【<strong data-nodeid=\"8269\">小结</strong\n                      >】写完代码之后，我们需要对代码和题目做一个小结：\n                    </p>\n                    <ul data-nodeid=\"6986\">\n                      <li data-nodeid=\"6987\">\n                        <p data-nodeid=\"6988\">\n                          较小的数<strong data-nodeid=\"8278\">消除</strong\n                          >掉较大的数的时候，使用<strong data-nodeid=\"8279\"\n                            >递增栈；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6989\">\n                        <p data-nodeid=\"6990\">要注意控制剩下的元素的个数；</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6991\">\n                      如果更进一步推而广之，会发现<strong data-nodeid=\"8286\"\n                        >从简单栈到单调栈，层层推进的过程中，不停变化就是入栈与出栈的时机</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6992\">\n                      那么，到这里，这个题目的考点也就非常明了了：\n                    </p>\n                    <ul data-nodeid=\"6993\">\n                      <li data-nodeid=\"6994\">\n                        <p data-nodeid=\"6995\">递增栈</p>\n                      </li>\n                      <li data-nodeid=\"6996\">\n                        <p data-nodeid=\"6997\">\n                          个数控制，我们只需要取 k 个数出来。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"6998\">总结与延伸</h3>\n                    <p data-nodeid=\"6999\">\n                      在本讲我带你一起剖析了栈相关的知识和题目，经过我们不断地“浇灌”，栈这棵“萌芽”开始抽枝散叶，终于长成了一棵枝繁叶茂的“大树”。回到知识层面，我把本讲重点介绍、且需要你掌握的内容总结在一张思维导图中，如下图所示：\n                    </p>\n                    <p data-nodeid=\"7000\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0B/7F/CioPOWA4q6qASB-UAADhj7uzOwg933.png\"\n                        alt=\"Drawing 65.png\"\n                        data-nodeid=\"8294\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7001\">\n                      除了带你学习知识本身，我还介绍了题目的变形和演进，希望能够帮助你建立深度分析的能力。在学习算法与数据结构的过程中，作为“刷题过来人”，我非常建议你加强总结和归纳\n                      ，建立自己的<strong data-nodeid=\"8300\">学习方法论</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"7002\">\n                      虽然栈很有趣，不过我们的介绍就要到这里了，我对于栈的总结和归纳只是个开头，期待你还能发现更多栈的特点和巧妙用法，并且将它们总结下来。也欢迎在评论区和我交流，期待看到你的奇思妙想。\n                    </p>\n                    <h3 data-nodeid=\"7003\">思考题</h3>\n                    <p data-nodeid=\"7004\">\n                      我再给你留一道<strong data-nodeid=\"8312\">思考题</strong\n                      >：给定一个数组，数组中的元素代表木板的高度。请你求出<strong\n                        data-nodeid=\"8313\"\n                        >相邻木板</strong\n                      >能剪出的最大矩形面积。\n                    </p>\n                    <p data-nodeid=\"7005\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0B/83/Cgp9HWA4q--AZmcbAABdc5tNqDI318.png\"\n                        alt=\"尾图.png\"\n                        data-nodeid=\"8316\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7006\">\n                      这道题会涉及一个<strong data-nodeid=\"8326\"\n                        >非常重要且有用</strong\n                      >的单调栈的性质，<strong data-nodeid=\"8327\"\n                        >希望你能找到它</strong\n                      >。你可以把答案写在评论区，我们一起讨论。\n                    </p>\n                    <blockquote data-nodeid=\"7007\">\n                      <p data-nodeid=\"7008\">\n                        解法 1：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.java\"\n                          data-nodeid=\"8331\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.cpp\"\n                          data-nodeid=\"8335\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.py\"\n                          data-nodeid=\"8339\"\n                          >Python</a\n                        ><br />\n                        解法 2：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java\"\n                          data-nodeid=\"8344\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp\"\n                          data-nodeid=\"8348\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py\"\n                          data-nodeid=\"8352\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7009\" class=\"\">\n                      接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。下一讲将介绍\n                      02 | 队列：FIFO\n                      队列与单调队列的深挖与扩展，记得按时来探险。\n                    </p>\n            "}