{"title":"05 | 如何设计 React 组件？","context":"\n                    <p data-nodeid=\"34530\" class=\"\">\n                      在第 01\n                      讲中，我们知道了&nbsp;React&nbsp;通过组件化的方式，解决了工程实践中代码如何组织的问题，但它并没有指出组件之间应该按照什么样的方式去组合，本讲我们一起来探讨这个问题，即“如何设计\n                      React 组件”。\n                    </p>\n                    <h3 data-nodeid=\"34531\">破题</h3>\n                    <p data-nodeid=\"34532\">\n                      “如何设计 React 组件？”其实就是在考察你是否了解 React\n                      组件的设计模式。\n                    </p>\n                    <p data-nodeid=\"34533\">\n                      你有没有发现在实际的工程实践中，如果缺乏一个指导性的设计模式，而直接开发，代码往往会非常凌乱。常见的情况就是：\n                    </p>\n                    <ul data-nodeid=\"34534\">\n                      <li data-nodeid=\"34535\">\n                        <p data-nodeid=\"34536\">将一个页面写成一个组件；</p>\n                      </li>\n                      <li data-nodeid=\"34537\">\n                        <p data-nodeid=\"34538\">一个组件包含两三千行的代码。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"34539\">\n                      这些都没有明显的模块划分，缺乏组合的思想。所以如何将组件更好地组合，这是需要探讨的第一个问题。\n                    </p>\n                    <p data-nodeid=\"34540\">\n                      在明确了“如何组合”这一核心主题后，我们需要思考的是，如何将核心主题以更好的形式展示出来，因为平铺直叙地罗列知识，那内容是非常干瘪的。而基于不同的业务场景，组件的组合形式是不一样的，所以如果结合丰富场景来展示“如何组合”的方式，可以让表述变得有血有肉，也显得你经验十足。\n                    </p>\n                    <p data-nodeid=\"34541\">\n                      这里你就需要先搞清楚基于场景的设计分类了。\n                    </p>\n                    <h3 data-nodeid=\"34542\">承题</h3>\n                    <p data-nodeid=\"34543\">\n                      通过以上的分析，我们可以得出“如何设计 React\n                      组件？”这一题的答题套路是“一个主题，多个场景”，即围绕“如何组合”这一核心主题，通过列举场景的方式展现设计模式的分类及用途。\n                    </p>\n                    <p data-nodeid=\"34544\">\n                      我们先来了解下 React 的组件有哪些分类，这里可以直接采用\n                      React 社区中非常经典的分类模式：\n                    </p>\n                    <ul data-nodeid=\"34545\">\n                      <li data-nodeid=\"34546\">\n                        <p data-nodeid=\"34547\">\n                          把只作展示、独立运行、不额外增加功能的组件，称为<strong\n                            data-nodeid=\"34700\"\n                            >哑组件</strong\n                          >，或<strong data-nodeid=\"34701\">无状态组件</strong\n                          >，还有一种叫法是<strong data-nodeid=\"34702\"\n                            >展示组件</strong\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34548\">\n                        <p data-nodeid=\"34549\">\n                          把处理业务逻辑与数据状态的组件称为有<strong\n                            data-nodeid=\"34712\"\n                            >状态组件</strong\n                          >，或<strong data-nodeid=\"34713\">灵巧组件</strong\n                          >，灵巧组件一定包含至少一个灵巧组件或者展示组件。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"34550\">\n                      从分类中可以看出<strong data-nodeid=\"34719\"\n                        >展示组件的复用性更强，灵巧组件则更专注于业务本身</strong\n                      >。那么基于以上的思路，你可以整理出如下的知识导图：\n                    </p>\n                    <p data-nodeid=\"36697\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/84/27/CgqCHl_TIYmAVjAWAAUY2rGM2bc188.png\"\n                        alt=\"react面试05金句.png\"\n                        data-nodeid=\"36701\"\n                      />\n                    </p>\n                    <p data-nodeid=\"36698\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/84/1C/Ciqc1F_TIY-ANgywAAB0DSyjFv4894.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"36704\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"34552\">\n                      接下来我将结合各个场景来为你展开讲解这些组件。\n                    </p>\n                    <h3 data-nodeid=\"34553\">入题</h3>\n                    <p data-nodeid=\"34554\">\n                      无论是怎样的设计，始终是不能脱离工程实践进行探讨的。回到前端工程中来，如果使用\n                      create-react-app 初始化项目，通常会有类似这样的目录结构：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">.\n</div></li><li><div class=\"code-word\">├── README.md\n</div></li><li><div class=\"code-word\">├── <span class=\"hljs-keyword\">package</span>.json\n</div></li><li><div class=\"code-word\">├── <span class=\"hljs-keyword\">public</span>\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── favicon.ico\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── index.html\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── logo192.png\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── logo512.png\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── manifest.json\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;└── robots.txt\n</div></li><li><div class=\"code-word\">├── src\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── App.css\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── App.js\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── App.test.js\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── index.css\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── index.js\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── logo.svg\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── reportWebVitals.js\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;└── setupTests.js\n</div></li><li><div class=\"code-word\">└── yarn.lock\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34556\">\n                      在源码目录，也就是 src\n                      目录中，所有组件就像衣服散落在房间里一样堆在了一起，如果继续添置衣物，可以想象这个房间最后会变得有多乱。就像每件衣服总有它适用的场合，组件也有同样的分类。\n                    </p>\n                    <p data-nodeid=\"34557\">\n                      我先带你从功能最薄弱的展示组件开始梳理，其次是展示组件中装饰作用的小物件。\n                    </p>\n                    <h4 data-nodeid=\"34558\">展示组件</h4>\n                    <p data-nodeid=\"34559\">\n                      展示组件内部是没有状态管理的，正如其名，就像一个个“装饰物”一样，完全受制于外部的\n                      props 控制。展示组件具有极强的<strong data-nodeid=\"34738\"\n                        >通用性</strong\n                      >，<strong data-nodeid=\"34739\">复用率</strong\n                      >也很高，往往与当前的前端工程关系相对薄弱，甚至可以做到跨项目级的复用。\n                    </p>\n                    <p data-nodeid=\"34560\">\n                      我们先来看一下展示组件中最常用的代理组件。\n                    </p>\n                    <p data-nodeid=\"34561\">\n                      <strong data-nodeid=\"34744\">代理组件</strong>\n                    </p>\n                    <p data-nodeid=\"34562\">\n                      <strong data-nodeid=\"34753\"\n                        >代理组件常用于封装常用属性</strong\n                      >，<strong data-nodeid=\"34754\">减少重复代码</strong\n                      >。关于代理组件你应该不陌生，可能经常会写。\n                    </p>\n                    <p data-nodeid=\"34563\">\n                      举一个最常见的例子，当需要定义一个按钮的时候，需要在按钮上添加\n                      button 属性，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;button type=<span class=\"hljs-string\">\"button\"</span>&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34565\">\n                      当然在 React\n                      中使用的时候，不可能每次都写这样一段代码，非常麻烦。常见的做法是<strong\n                        data-nodeid=\"34761\"\n                        >封装</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Button = props =&gt;\n</div></li><li><div class=\"code-word\">&nbsp; &lt;button type=<span class=\"hljs-string\">\"button\"</span> {...props}&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34567\">\n                      在开发中使用 Button 组件替代原生的 button，可以确保 type\n                      保证一致。\n                    </p>\n                    <p data-nodeid=\"34568\">\n                      在使用 Antd\n                      开发时，你也会采用类似的设计模式，大致情况如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { Button as AntdButton } from from <span class=\"hljs-string\">'antd'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Button = props =&gt;\n</div></li><li><div class=\"code-word\">  &lt;AntdButton size=<span class=\"hljs-string\">\"small\"</span> type=<span class=\"hljs-string\">\"primary\"</span> {...props}&gt;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> Button\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34570\">\n                      虽然进行封装感觉是多此一举，但切断了外部组件库的<strong\n                        data-nodeid=\"34769\"\n                        >强依赖特性</strong\n                      >。在大厂中引入外部组件库需要考虑两点：\n                    </p>\n                    <ul data-nodeid=\"34571\">\n                      <li data-nodeid=\"34572\">\n                        <p data-nodeid=\"34573\">\n                          如果当前组件库不能使用了，是否能实现业务上的无痛切换；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34574\">\n                        <p data-nodeid=\"34575\">\n                          如果需要批量修改基础组件的字段，如何解决？\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"34576\">\n                      代理组件的设计模式很好地解决了上面两个问题。从业务上看，代理组件隔绝了\n                      Antd，仅仅是一个组件 Props API\n                      层的交互。这一层如若未来需要替换，是可以保证兼容、快速替换的，而不需要在原有的代码库中查找修改。其次，如果要修改基础组件的颜色、大小、间距，代理组件也可以相对优雅地解决，使得这些修改都内聚在当前的\n                      Button 组件中，而非散落在其他地方。\n                    </p>\n                    <p data-nodeid=\"34577\">\n                      基于展示组件的思想，可以封装类似的其他组件，比如样式组件。\n                    </p>\n                    <p data-nodeid=\"34578\">\n                      <strong data-nodeid=\"34777\">样式组件</strong>\n                    </p>\n                    <p data-nodeid=\"34579\">\n                      样式组件也是一种代理组件，只是又细分了处理样式领域，将当前的关注点分离到当前组件内。你是否还记得在第\n                      02\n                      讲中提到过“关注点分离”的概念，其中就说到“将代码分隔为不同部分，其中每一部分都会有自己的关注焦点”。\n                    </p>\n                    <p data-nodeid=\"34580\">\n                      但在工程实践中，我们并不会因为一个按钮需要协商 className\n                      而封装成一个组件，就像下面这样：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Button = props =&gt; (\n</div></li><li><div class=\"code-word\">  &lt;button type=<span class=\"hljs-string\">\"button\"</span> className=<span class=\"hljs-string\">\"btn btn-primary\"</span>&gt;\n</div></li><li><div class=\"code-word\">)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34582\">\n                      这并没有什么意义。真实工程项目的样式管理往往是复杂的，它更接近于下面这个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> classnames from <span class=\"hljs-string\">\"classnames\"</span>;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> StyleButton = ({ className, primary, isHighLighted,  ...props }) =&gt; (\n</div></li><li><div class=\"code-word\">&nbsp; &lt;Button\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; type=<span class=\"hljs-string\">\"button\"</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; className={classnames(<span class=\"hljs-string\">\"btn\"</span>, {\n</div></li><li><div class=\"code-word\">     btn-primary: primary,\n</div></li><li><div class=\"code-word\">     highLight: isHighLighted,\n</div></li><li><div class=\"code-word\">}, className)}\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; {...props}\n</div></li><li><div class=\"code-word\">&nbsp; /&gt;\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34584\">\n                      复杂的样式管理对于 Button 是没有意义的，如果直接使用\n                      Button，在属性上修改，对工程代码而言就是编写大量的面条代码。而\n                      StyleButton\n                      的思路是将样式判断逻辑分离到自身上，面向未来改动的时候会更为友好。\n                    </p>\n                    <p data-nodeid=\"34585\">\n                      接下来可以看下基于样式组件的优化设计。\n                    </p>\n                    <p data-nodeid=\"34586\">\n                      <strong data-nodeid=\"34786\">布局组件</strong>\n                    </p>\n                    <p data-nodeid=\"34587\">\n                      布局组件的基本设计与样式组件完全一样，但它基于自身特性做了一个小小的优化。\n                    </p>\n                    <p data-nodeid=\"34588\">\n                      首先来看下它的基础使用案例，主要用于安放其他组件，类似于这样的用法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;Layout\n</div></li><li><div class=\"code-word\">&nbsp; Top={&lt;NavigationBar /&gt;}\n</div></li><li><div class=\"code-word\">  Content={&lt;Article /&gt;}\n</div></li><li><div class=\"code-word\">&nbsp; Bottom={&lt;BottomBar /&gt;}\n</div></li><li><div class=\"code-word\">/&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34590\">\n                      布局本身是确定的，不需要根据外部状态的变化去修改内部组件。所以这也是一个可以减少渲染的优化点。（当然，这里的样式结构写得比较简单）\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">class Layout extends React.Component {\n</div></li><li><div class=\"code-word\">&nbsp; shouldComponentUpdate() {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; return false;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; render() {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &lt;div&gt;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &lt;div&gt;{this.props.NavigationBar}&lt;/div&gt;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &lt;div&gt;{this.props.Article}&lt;/div&gt;\n</div></li><li><div class=\"code-word\">      &lt;div&gt;{this.props.BottomBar}&lt;/div&gt;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &lt;/div&gt;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34592\">\n                      由于布局组件无需更新，所以对应到第 3\n                      讲中提到的生命周期，就可以通过写死<strong\n                        data-nodeid=\"34799\"\n                        >shouldComponentUpdate</strong\n                      >\n                      的返回值直接阻断渲染过程。对于大型前端工程，类似的小心思可以带来性能上的提升。当然，这也是基于代理组件<strong\n                        data-nodeid=\"34800\"\n                        >更易于维护</strong\n                      >而带来的好处。\n                    </p>\n                    <h4 data-nodeid=\"34593\">灵巧组件</h4>\n                    <p data-nodeid=\"34594\">\n                      由于灵巧组件面向业务，所以相对于展示组件来说，其功能更为丰富、复杂性更高，而复用度更低。<strong\n                        data-nodeid=\"34811\"\n                        >展示组件专注于组件本身特性</strong\n                      >，<strong data-nodeid=\"34812\"\n                        >灵巧组件更专注于组合组件</strong\n                      >。那么最常见的案例则是容器组件。\n                    </p>\n                    <p data-nodeid=\"34595\">\n                      <strong data-nodeid=\"34816\">容器组件</strong>\n                    </p>\n                    <p data-nodeid=\"34596\">\n                      容器组件几乎没有复用性，它主要用在两个方面：<strong\n                        data-nodeid=\"34822\"\n                        >拉取数据与组合组件</strong\n                      >。可以看这样一个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">const CardList = ({ cards }) =&gt; (\n</div></li><li><div class=\"code-word\">&nbsp; &lt;div&gt;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; {cards.map(card =&gt; (\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &lt;CardLayout\n</div></li><li><div class=\"code-word\">        header={&lt;Avatar url={card.avatarUrl} /&gt;}\n</div></li><li><div class=\"code-word\">        Content={&lt;Card {...card} /&gt;}\n</div></li><li><div class=\"code-word\">      /&gt;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; {comment.body}-{comment.author}\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; ))}\n</div></li><li><div class=\"code-word\">&nbsp; &lt;/div&gt;\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34598\">\n                      这是一个 CardList 组件，负责将 cards\n                      数据渲染出来，接下来将获取网络数据。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CardListContainer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; state = { cards: [] }\n</div></li><li><div class=\"code-word\">&nbsp;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-function\">async <span class=\"hljs-title\">componentDidMount</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-function\">await <span class=\"hljs-title\">fetch</span><span class=\"hljs-params\">(<span class=\"hljs-string\">'/api/cards'</span>)</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-title\">setState</span><span class=\"hljs-params\">({cards: response})</span>\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-title\">render</span><span class=\"hljs-params\">()</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> &lt;CardList cards={<span class=\"hljs-keyword\">this</span>.state.cards} /&gt;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34600\">\n                      像这样切分代码后，你会发现容器组件内非常干净，没有冗余的样式与逻辑处理。你有没有发现这也是采取了关注点分离的策略？其实这一策略还可以直接应用到你的工作中。因为互联网人的工作常常是多线并行，如果想把事做得更漂亮，可以尝试把它切分成多个片段，让自己的关注点在短时间内更为集中，从而做到高效快速地处理。\n                    </p>\n                    <p data-nodeid=\"34601\">\n                      回到组件的问题上来，那么对复用性更强的业务逻辑采用什么方式处理呢？\n                    </p>\n                    <p data-nodeid=\"34602\">\n                      <strong data-nodeid=\"34829\">高阶组件</strong>\n                    </p>\n                    <p data-nodeid=\"34603\">\n                      React 的官方文档将高阶组件称为 React 中<strong\n                        data-nodeid=\"34835\"\n                        >复用组件逻辑的高级技术</strong\n                      >。高阶组件本身并不是 React API 的一部分，它是一种基于\n                      React\n                      的组合特性而形成的设计模式。简而言之，高阶组件的参数是组件，返回值为新组件的函数。\n                    </p>\n                    <p data-nodeid=\"34604\">\n                      这样听起来有一些高阶函数的味儿了。那什么是<strong\n                        data-nodeid=\"34841\"\n                        >高阶函数</strong\n                      >呢？如果一个函数可以接收另一个函数作为参数，且在执行后返回一个函数，这种函数就称为高阶函数。在\n                      React 的社区生态中，有很多基于高阶函数设计的库，比如\n                      reselector 就是其中之一。\n                    </p>\n                    <p data-nodeid=\"34605\">\n                      思想一脉相承，React\n                      团队在组件方向也汲取了同样的设计模式。源自高阶函数的高阶组件，可以同样优雅地抽取公共逻辑。\n                    </p>\n                    <p data-nodeid=\"34606\">\n                      <strong data-nodeid=\"34846\">抽取公共逻辑</strong>\n                    </p>\n                    <p data-nodeid=\"34607\">\n                      用一个常见的例子来说，就是登录态的判断。假设当前项目有订单页面、用户信息页面及购物车首页，那么对于订单页面与用户信息页面都需要检查当前是否已登录，如果没有登录，则应该跳转登录页。\n                    </p>\n                    <p data-nodeid=\"34608\">一般的思路类似于：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> checkLogin = () =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> !!localStorage.getItem(<span class=\"hljs-string\">'token'</span>)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CartPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">   ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  componentDidMount() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span>(!checkLogin) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 重定向跳转登录页面</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  componentDidMount() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span>(!checkLogin) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 重定向跳转登录页面</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\"> }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34610\">\n                      虽然已经抽取了一个函数，但还是需要在对应的页面添加<strong\n                        data-nodeid=\"34854\"\n                        >登录态的判断逻辑</strong\n                      >。然而如果有高阶组件的话，情况会完全不同。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> checkLogin = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> !!localStorage.getItem(<span class=\"hljs-string\">'token'</span>)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> checkLogin = <span class=\"hljs-function\">(<span class=\"hljs-params\">WrappedComponent</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-keyword\">return</span> checkLogin() ? <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WrappedComponent</span> {<span class=\"hljs-attr\">...props</span>} /&gt;</span></span> : <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LoginPage</span> /&gt;</span></span>;\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 函数写法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RawUserPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> UserPage = checkLogin(RawUserPage)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 装饰器写法</span>\n</div></li><li><div class=\"code-word\">@checkLogin\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">@checkLogin\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; ...\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34612\">\n                      从上面的例子中可以看出无论<strong data-nodeid=\"34864\"\n                        >采用函数</strong\n                      >还是<strong data-nodeid=\"34865\">装饰器</strong\n                      >的写法，都使得重复代码量下降了一个维度。\n                    </p>\n                    <p data-nodeid=\"34613\">\n                      还有一个非常经典的场景就是<strong data-nodeid=\"34871\"\n                        >页面埋点统计</strong\n                      >。如果使用装饰器编写的话，大概是这样的：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> trackPageView = (pageName) = { \n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 发送埋点信息请求</span>\n</div></li><li><div class=\"code-word\">   ... \n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PV = <span class=\"hljs-function\">(<span class=\"hljs-params\">pageName</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">WrappedComponent</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Wrap</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">      componentDidMount() {\n</div></li><li><div class=\"code-word\">        trackPageView(pageName)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">      render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">          <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WrappedComponent</span> {<span class=\"hljs-attr\">...this.props</span>} /&gt;</span></span>\n</div></li><li><div class=\"code-word\">        );\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">@PV(<span class=\"hljs-string\">'用户页面'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">@PV(<span class=\"hljs-string\">'购物车页面'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CartPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">@PV(<span class=\"hljs-string\">'订单页面'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  ..\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34615\">\n                      就连埋点这样的烦琐操作都变得优雅了起来。那我想同时使用\n                      checkLogin 与 PV\n                      怎么办呢？这里涉及到了一个新的概念，就是链式调用。\n                    </p>\n                    <p data-nodeid=\"34616\">\n                      <strong data-nodeid=\"34876\">链式调用</strong>\n                    </p>\n                    <p data-nodeid=\"34617\">\n                      由于高阶组件返回的是一个新的组件，所以链式调用是默认支持的。基于\n                      checkLogin 与 PV 两个例子，链式使用是这样的：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 函数调用方式</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RawUserPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> UserPage = checkLogin(PV(<span class=\"hljs-string\">'用户页面'</span>)(RawUserPage))\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 装饰器调用方式</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-meta\">@checkLogin</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-meta\">@PV('用户页面')</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34619\">\n                      在链式调用后，装饰器会按照从外向内、从上往下的顺序进行执行。\n                    </p>\n                    <p data-nodeid=\"34620\">\n                      除了抽取公用逻辑以外，还有一种修改渲染结果的方式，被称为<strong\n                        data-nodeid=\"34883\"\n                        >渲染劫持。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"34621\">\n                      <strong data-nodeid=\"34887\">渲染劫持</strong>\n                    </p>\n                    <p data-nodeid=\"34622\">\n                      渲染劫持可以通过控制 render\n                      函数修改输出内容，常见的场景是显示加载元素，如下情况所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withLoading</span>(<span class=\"hljs-params\">WrappedComponent</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WrappedComponent</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; render() {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.props.isLoading) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Loading</span> /&gt;</span></span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.render();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34624\">\n                      通过高阶函数中继承原组件的方式，劫持修改 render\n                      函数，篡改返回修改，达到显示 Loading 的效果。\n                    </p>\n                    <p data-nodeid=\"34625\">\n                      但高阶组件并非万能，它同样也有缺陷。\n                    </p>\n                    <p data-nodeid=\"34626\">\n                      <strong data-nodeid=\"34894\">缺陷</strong>\n                    </p>\n                    <p data-nodeid=\"34627\">\n                      <strong data-nodeid=\"34898\">丢失静态函数</strong>\n                    </p>\n                    <p data-nodeid=\"34628\">\n                      由于被包裹了一层，所以静态函数在外层是无法获取的。如下面的案例中\n                      getUser 是无法被调用的。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// UserPage.jsx</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-meta\">@PV('用户页面')</span>\n</div></li><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserPage</span> <span class=\"hljs-keyword\">extends</span>  <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">      ...\n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// page.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> UserPage from <span class=\"hljs-string\">'./UserPage'</span>\n</div></li><li><div class=\"code-word\">UserPage.checkLogin() <span class=\"hljs-comment\">// 调用失败，并不存在。</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34630\">\n                      如果希望外界能够被调用，那么可以在 PV\n                      函数中将静态函数复制出来。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PV = <span class=\"hljs-function\">(<span class=\"hljs-params\">pageName</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">WrappedComponent</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Wrap</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">      componentDidMount() {\n</div></li><li><div class=\"code-word\">        trackPageView(pageName)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">      render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">          <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WrappedComponent</span> {<span class=\"hljs-attr\">...this.props</span>} /&gt;</span></span>\n</div></li><li><div class=\"code-word\">        );\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    &nbsp;Wrap.getUser = WrappedComponent.getUser;\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> Wrap;\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\"> }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34632\">\n                      这样做确实能解决静态函数在外部无法调用的问题，但一个类的静态函数可能会有很多，都需要一一手动复制么？其实也有更为简便的处理方案。社区中早就有了现成的工具，通过\n                      hoist-non-react-statics\n                      来处理，可以自动复制所有静态函数。如下代码所示。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> hoistNonReactStatics <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'hoist-non-react-statics'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PV = <span class=\"hljs-function\">(<span class=\"hljs-params\">pageName</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">WrappedComponent</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Wrap</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">      componentDidMount() {\n</div></li><li><div class=\"code-word\">        trackPageView(pageName)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">      render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">          <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WrappedComponent</span> {<span class=\"hljs-attr\">...this.props</span>} /&gt;</span></span>\n</div></li><li><div class=\"code-word\">        );\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">     hoistNonReactStatics(Wrap, WrappedComponent);\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> Wrap;\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\"> }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34634\">\n                      虽然缺少官方的解决方案，但社区方案弥补了不足。除了静态函数的问题以外，还有\n                      refs 属性不能透传的问题。\n                    </p>\n                    <p data-nodeid=\"34635\">\n                      <strong data-nodeid=\"34906\">refs 属性不能透传</strong>\n                    </p>\n                    <p data-nodeid=\"34636\">\n                      ref\n                      属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React\n                      为我们提供了一个名为 React.forwardRef 的 API\n                      来解决这一问题，以下是官方文档中的一个案例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withLog</span>(<span class=\"hljs-params\">Component</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LogProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">    componentDidUpdate(prevProps) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'old props:'</span>, prevProps);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'new props:'</span>, <span class=\"hljs-keyword\">this</span>.props);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> {forwardedRef, ...rest} = <span class=\"hljs-keyword\">this</span>.props;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{forwardedRef}</span> {<span class=\"hljs-attr\">...rest</span>} /&gt;</span></span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> React.forwardRef(<span class=\"hljs-function\">(<span class=\"hljs-params\">props, ref</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LogProps</span> {<span class=\"hljs-attr\">...props</span>} <span class=\"hljs-attr\">forwardedRef</span>=<span class=\"hljs-string\">{ref}</span> /&gt;</span></span>;\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34638\">\n                      这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的\n                      React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到\n                      LogProps 内部。\n                    </p>\n                    <h4 data-nodeid=\"34639\">工程实践</h4>\n                    <p data-nodeid=\"34640\">\n                      通过以上的梳理，接下来看一下如何在目录中给组件安排位置。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">src\n</div></li><li><div class=\"code-word\">├── components\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── basic\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;├── container\n</div></li><li><div class=\"code-word\">│&nbsp; &nbsp;└── hoc\n</div></li><li><div class=\"code-word\">└── pages\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"34642\">\n                      <li data-nodeid=\"34643\">\n                        <p data-nodeid=\"34644\">\n                          首先将最基本的展示组件放入 basic 目录中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34645\">\n                        <p data-nodeid=\"34646\">\n                          然后将容器组件放入 container；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34647\">\n                        <p data-nodeid=\"34648\">高阶组件放入 hoc 中；</p>\n                      </li>\n                      <li data-nodeid=\"34649\">\n                        <p data-nodeid=\"34650\">\n                          将页面外层组件放在页面目录中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34651\">\n                        <p data-nodeid=\"34652\">通过目录级别完成切分。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"34653\">\n                      在开发中，针对 basic 组件，建议使用类似 Storybook\n                      的工具进行组件管理。因为Storybook\n                      可以有组织地、高效地构建基础组件，有兴趣的话可以查阅下它的<a\n                        href=\"https://storybook.js.org\"\n                        data-nodeid=\"34919\"\n                        >官网</a\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"34654\">答题</h3>\n                    <p data-nodeid=\"34655\">\n                      通过以上的归类分析，关于 React\n                      组件设计，我们的脑海中就有比较清晰的认知了。\n                    </p>\n                    <blockquote data-nodeid=\"34656\">\n                      <p data-nodeid=\"34657\">\n                        React 组件应从设计与工程实践两个方向进行探讨。\n                      </p>\n                      <p data-nodeid=\"34658\">\n                        从设计上而言，社区主流分类的方案是展示组件与灵巧组件。\n                      </p>\n                      <p data-nodeid=\"34659\">\n                        展示组件内部没有状态管理，仅仅用于最简单的展示表达。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码。很经典的场景就是引入\n                        Antd 的 Button 时，你再自己封一层。如果未来需要替换掉\n                        Antd 或者需要在所有的 Button\n                        上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。\n                      </p>\n                      <p data-nodeid=\"34660\">\n                        灵巧组件由于面向业务，其功能更为丰富，复杂性更高，复用度低于展示组件。最经典的灵巧组件是容器组件。在开发中，我们经常会将网络请求与事件处理放在容器组件中进行。容器组件也为组合其他组件预留了一个恰当的空间。还有一类灵巧组件是高阶组件。高阶组件被\n                        React 官方称为 React\n                        中复用组件逻辑的高级技术，它常用于抽取公共业务逻辑或者提供某些公用能力。常用的场景包括检查登录态，或者为埋点提供封装，减少样板代码量。高阶组件可以组合完成链式调用，如果基于装饰器使用，就更为方便了。高阶组件中还有一个经典用法就是反向劫持，通过重写渲染函数的方式实现某些功能，比如场景的页面加载圈等。但高阶组件也有两个缺陷，第一个是静态方法不能被外部直接调用，需要通过向上层组件复制的方式调用，社区有提供解决方案，使用\n                        hoist-non-react-statics 可以解决；第二个是 refs\n                        不能透传，使用 React.forwardRef API 可以解决。\n                      </p>\n                      <p data-nodeid=\"34661\">\n                        从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的\n                        components 建立一个目录，在下面分别建立 basic、container\n                        和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在\n                        Page 中，而可以抽象复用的部分放入 components 中。其中\n                        basic\n                        文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用\n                        Storybook 进行组件的开发管理，提升项目的工程化管理能力。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"34662\">\n                      还可以通过以下知识导图来检验你的学习成果，看是否能将每部分补充完整。\n                    </p>\n                    <p data-nodeid=\"37575\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/84/27/CgqCHl_TIbaAEiBdAAEujtJGnY8994.png\"\n                        alt=\"图片2 (1).png\"\n                        data-nodeid=\"37582\"\n                      />\n                    </p>\n\n                    <h3 data-nodeid=\"34664\">进阶</h3>\n                    <p data-nodeid=\"34665\">\n                      <strong data-nodeid=\"34937\"\n                        >“如何在渲染劫持中为原本的渲染结果添加新的样式？”</strong\n                      >\n                      这个问题也经常被追问，其实并不难，但是有可能考察手写代码，所以这里我会做一些提示。\n                    </p>\n                    <p data-nodeid=\"34666\">\n                      首先回滚上面的案例，在调用 super.render\n                      的时候就可以拿到原本的渲染结果。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">withLoading</span><span class=\"hljs-params\">(WrappedComponent)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WrappedComponent</span> </span>{\n</div></li><li><div class=\"code-word\">        render() {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.props.isLoading) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> &lt;Loading /&gt;;\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.render();\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34668\">\n                      那 super.render() 返回的是什么呢？你可以结合 JSX\n                      一讲中的内容思考下。\n                    </p>\n                    <h3 data-nodeid=\"34669\">总结</h3>\n                    <p data-nodeid=\"34670\">\n                      在本讲中主要对 React\n                      组件的设计模式进行了梳理与回顾，并探讨了设计模式在工程实践中的作用。\n                    </p>\n                    <p data-nodeid=\"34671\">\n                      在面试中面试官不仅希望听到设计模式有哪些，社区的推荐方式有哪些，更希望听到<strong\n                        data-nodeid=\"34947\"\n                        >模式具体用在哪儿</strong\n                      >。如果你知道具体的场景，就会显得更有经验。设计模式并非有确定的标准答案，社区流行的分类方式也并非万能。如果你有自己的见解，在面试中与面试官进行探讨，也是非常值得鼓励的。\n                    </p>\n                    <p data-nodeid=\"34672\">\n                      下一讲我将会介绍 React 中的一个关于 setState\n                      的经典面试题：“setState 是同步更新还是异步更新”。\n                    </p>\n                    <p data-nodeid=\"34673\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"34953\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image/M00/73/68/Ciqc1F_F_CeAHYQKAASyC72ZqWw053.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"34952\" /></a\n                      ><br />\n                      《大前端高薪训练营》\n                    </p>\n                    <p data-nodeid=\"34674\" class=\"\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"34959\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}