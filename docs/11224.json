{"title":"22 | 剖析前端中的数据结构应用场景","context":"\n                    <p data-nodeid=\"4608\">\n                      上一讲我们使用 JavaScript\n                      实现了几种常见的数据结构。事实上，前端领域到处体现着数据结构的应用，尤其随着需求的复杂度上升，前端工程师越来越离不开数据结构。React、Vue\n                      这些设计精巧的框架，在线文档编辑系统、大型管理系统，甚至一个简单的检索需求，都离不开数据结构的支持。是否能够掌握这个难点内容，将是进阶的重要考量。\n                    </p>\n                    <p data-nodeid=\"4609\">\n                      这一讲，我们就来解析数据结构在前端中的应用场景，以此来帮助大家加深理解，做到灵活应用。\n                    </p>\n                    <h3 data-nodeid=\"5703\" class=\"\">堆栈和队列的应用</h3>\n\n                    <p data-nodeid=\"4611\">关于栈和队列的实际应用比比皆是：</p>\n                    <ul data-nodeid=\"4612\">\n                      <li data-nodeid=\"4613\">\n                        <p data-nodeid=\"4614\">\n                          浏览器的历史记录，因为回退总是回退“上一个”最近的页面，它需要遵循栈的原则；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4615\">\n                        <p data-nodeid=\"4616\">\n                          类似浏览器的历史记录，任何 Undo/Redo\n                          都是一个栈的实现；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4617\">\n                        <p data-nodeid=\"4618\">\n                          在代码中，广泛应用的递归产生的调用栈，同样也是栈思想的体现，想想我们常说的“栈溢出”就是这个道理；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4619\">\n                        <p data-nodeid=\"4620\">\n                          同上，浏览器在抛出异常时，常规都会抛出调用栈信息；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4621\">\n                        <p data-nodeid=\"4622\">\n                          在计算机科学领域应用广泛，如进制转换、括号匹配、栈混洗、表达式求值等；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4623\">\n                        <p data-nodeid=\"4624\">\n                          队列的应用更为直观，我们常说的宏任务/微任务都是队列，不管是什么类型的任务，都是先进先执行；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4625\">\n                        <p data-nodeid=\"4626\">\n                          后端也应用广泛，如消息队列、RabbitMQ、ActiveMQ\n                          等，能起到延迟缓冲的功效。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"4627\">\n                      另外，与性能话题相关，HTTP 1.1\n                      有一个队头阻塞的问题，而原因就在于队列这样的数据结构的特点。具体来说，在\n                      HTTP 1.1 中，每一个链接都默认是长链接，因此对于同一个 TCP\n                      链接，HTTP 1.1 规定：<strong data-nodeid=\"4709\"\n                        >服务端的响应返回顺序需要遵循其接收到相应的顺序</strong\n                      >。但这样存在一个问题：如果第一个请求处理需要较长时间，响应较慢，将会“拖累”其他后续请求的响应，这是一种队头阻塞。\n                    </p>\n                    <p data-nodeid=\"4628\">\n                      HTTP 2 采用了<strong data-nodeid=\"4715\"\n                        >二进制分帧和多路复用</strong\n                      >等方法，同域名下的通信都在同一个连接上完成，在这个连接上可以并行请求和响应，而互不干扰。\n                    </p>\n                    <p data-nodeid=\"4629\">\n                      在框架层面，堆栈和队列的应用更是比比皆是。比如 React 的\n                      Context 特性，参考以下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React from \"react\";\n</div></li><li><div class=\"code-word\">const ContextValue = React.createContext();\n</div></li><li><div class=\"code-word\">export default function App() {\n</div></li><li><div class=\"code-word\">  return (\n</div></li><li><div class=\"code-word\">    &lt;ContextValue.Provider value={1}&gt;\n</div></li><li><div class=\"code-word\">      &lt;ContextValue.Consumer&gt;\n</div></li><li><div class=\"code-word\">        {(value1) =&gt; (\n</div></li><li><div class=\"code-word\">          &lt;ContextValue.Provider value={2}&gt;\n</div></li><li><div class=\"code-word\">            &lt;ContextValue.Consumer&gt;\n</div></li><li><div class=\"code-word\">              {(value2) =&gt; (\n</div></li><li><div class=\"code-word\">                &lt;span&gt;\n</div></li><li><div class=\"code-word\">                  {value1}-{value2}\n</div></li><li><div class=\"code-word\">                &lt;/span&gt;\n</div></li><li><div class=\"code-word\">              )}\n</div></li><li><div class=\"code-word\">            &lt;/ContextValue.Consumer&gt;\n</div></li><li><div class=\"code-word\">          &lt;/ContextValue.Provider&gt;\n</div></li><li><div class=\"code-word\">        )}\n</div></li><li><div class=\"code-word\">      &lt;/ContextValue.Consumer&gt;\n</div></li><li><div class=\"code-word\">    &lt;/ContextValue.Provider&gt;\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4631\">\n                      对于以上代码，React 内部就是通过一个栈结构，在构造 Fiber\n                      树时的 beginWork 阶段，将 Context.Provider\n                      数据状态入栈（此时 value1：1 和 value2：2 分别入栈），在\n                      completeWork 阶段，将栈中的数据状态出栈，以供给\n                      Context.Consumer 消费。关于 React\n                      源码中，栈的实现，你可以参考<a\n                        href=\"https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberStack.old.js\"\n                        data-nodeid=\"4720\"\n                        >这部分源码。</a\n                      >\n                    </p>\n                    <h3 data-nodeid=\"6141\" class=\"\">链表的应用</h3>\n\n                    <p data-nodeid=\"4633\">\n                      React 的核心算法<strong data-nodeid=\"4731\"\n                        >Fiber 的实现就是链表</strong\n                      >。React 最早开始使用大名鼎鼎的 Stack Reconciler\n                      调度算法，Stack Reconciler\n                      调度算法最大的问题在于：它就像函数调用栈一样，递归地、自顶向下进行\n                      diff 和 render 相关操作，在 Stack Reconciler\n                      执行的过程中，该调度算法始终会占据浏览器主线程。也就是说<strong\n                        data-nodeid=\"4732\"\n                        >在此期间，用户的交互所触发的布局行为、动画执行任务都不会得到立即响应，从而影响用户体验</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"4634\">\n                      因此 React Fiber\n                      将渲染和更新过程进行了拆解，简单来说，就是每次检查虚拟 DOM\n                      的一小部分，在检查间隙会检查“是否还有时间继续执行下一个虚拟\n                      DOM\n                      树上某个分支任务”，同时观察是否有更优先的任务需要响应。如果“没有时间执行下一个虚拟\n                      DOM 树上某个分支任务”，且某项任务有更高优先级，React\n                      就会让出主线程，直到主线程“不忙”的时候继续执行任务。\n                    </p>\n                    <p data-nodeid=\"4635\">\n                      React Fiber 的实现也很简单，它将 Stack Reconciler\n                      过程分成块，一次执行一块，执行完一块需要将结果保存起来，根据是否还有空闲的响应时间（requestIdleCallback）来决定下一步策略。当所有的块都已经执行完，就进入提交阶段，这个阶段需要更新\n                      DOM，它是一口气完成的。\n                    </p>\n                    <p data-nodeid=\"4636\">\n                      以上是比较主观的介绍，下面我们来看更具体的实现。\n                    </p>\n                    <p data-nodeid=\"4637\">\n                      为了达到“随意中断调用栈并手动操作调用栈”，React Fiber\n                      专门用于 React 组件堆栈调用的重新实现，也就是说一个 Fiber\n                      就是一个虚拟堆栈帧，一个 Fiber 的结构类似：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">FiberNode</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">  tag: WorkTag,\n</div></li><li><div class=\"code-word\">  pendingProps: mixed,\n</div></li><li><div class=\"code-word\">  key: <span class=\"hljs-keyword\">null</span> | string,\n</div></li><li><div class=\"code-word\">  mode: TypeOfMode,\n</div></li><li><div class=\"code-word\">) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// Instance</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.tag = tag;                       \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// Fiber</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.return = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.child = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.sibling = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.index = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.ref = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.pendingProps = pendingProps;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.memoizedProps = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.updateQueue = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.memoizedState = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.dependencies = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// Effects</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.alternate = <span class=\"hljs-keyword\">null</span>; \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4639\">\n                      这么看<strong data-nodeid=\"4746\"\n                        >Fiber 就是一个对象，通过 parent、children、sibling\n                        维护一个树形关系</strong\n                      >，同时 parent、children、sibling 也都是一个 Fiber\n                      结构，FiberNode.alternate\n                      这个属性来存储上一次渲染过的结果，事实上<strong\n                        data-nodeid=\"4747\"\n                        >整个 Fiber 模式就是一个链表</strong\n                      >。React\n                      也借此，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型了。\n                    </p>\n                    <p data-nodeid=\"4640\">具体的渲染过程：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"> <span class=\"hljs-function\">function <span class=\"hljs-title\">renderNode</span><span class=\"hljs-params\">(node)</span> </span>{\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 判断是否需要渲染该节点，如果 props 发生变化，则调用 render</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> (node.memoizedProps !== node.pendingProps) {\n</div></li><li><div class=\"code-word\">      render(node)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 是否有子节点，进行子节点渲染</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> (node.child !== <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> node.child\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 是否有兄弟节点，进行兄弟点渲染</span>\n</div></li><li><div class=\"code-word\">   } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.sibling !== <span class=\"hljs-keyword\">null</span>){\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> node.sibling\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 没有子节点和兄弟节点</span>\n</div></li><li><div class=\"code-word\">   } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node.return !== <span class=\"hljs-keyword\">null</span>){\n</div></li><li><div class=\"code-word\">      return node.return\n</div></li><li><div class=\"code-word\">   } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      return <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">workloop</span><span class=\"hljs-params\">(root)</span> </span>{\n</div></li><li><div class=\"code-word\">   nextNode = <span class=\"hljs-function\">root\n</span></div></li><li><div class=\"code-word\">   <span class=\"hljs-title\">while</span> <span class=\"hljs-params\">(nextNode !== <span class=\"hljs-keyword\">null</span> &amp;&amp; (no other high priority task)</span>) {\n</div></li><li><div class=\"code-word\">      nextNode = renderNode(nextNode)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4642\">\n                      注意在 Workloop 当中，while 条件<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"4750\"\n                        >nextNode !== null &amp;&amp; (no other high priority\n                        task)</code\n                      >，这是<strong data-nodeid=\"4756\"\n                        >描述 Fiber 工作原理的关键伪代码</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"4643\">下面我们换个角度再次说明。</p>\n                    <p data-nodeid=\"4644\">\n                      在 Fiber 之前，React 递归遍历虚拟\n                      DOM，在遍历过程中找到前后两颗虚拟 DOM 的差异，并生成一个\n                      Mutation。这种递归遍历有一个局限性：每次递归都会在栈中<strong\n                        data-nodeid=\"4763\"\n                        >添加一个同步帧</strong\n                      >，因此无法将遍历过程拆分为粒度更小的工作单元，也就无法暂停组件的更新，并在未来的某段时间恢复更新。\n                    </p>\n                    <p data-nodeid=\"7021\" class=\"\">\n                      如何不通过递归的形式去遍历呢？基于链表的 Fiber\n                      模型应运而生。最早的原始模型你可以在 2016 年的\n                      <a\n                        href=\"https://github.com/facebook/react/issues/7942?source=post_page---------------------------#issue-182373497\"\n                        data-nodeid=\"7025\"\n                        >issue</a\n                      >\n                      中找到。另外，React 中的\n                      Hooks，也是通过链表这个数据结构实现的。\n                    </p>\n\n                    <h3 data-nodeid=\"7463\" class=\"\">树的应用</h3>\n\n                    <p data-nodeid=\"4647\">\n                      从应用上来看，我们前端开发离不开的 DOM\n                      就是一个树状结构；同理，不管是 React 还是 Vue 的虚拟 DOM\n                      也都是树。\n                    </p>\n                    <p data-nodeid=\"4648\">\n                      上文中我们提到了 React Element 树和 Fiber 树，React\n                      Element 树其实就是各级组件渲染，调用 React.createElement\n                      返回 React Element 之后（每一个 React 组件，不管是 class\n                      组件或 functional 组件，调用一次 render 或执行一次\n                      function，就会生成 React Element 节点）的总和。\n                    </p>\n                    <p data-nodeid=\"8348\" class=\"\">\n                      React Element 树和 Fiber 树是在 reconciler\n                      过程中，相互交替，逐级构造进行的。这个生成过程，就<strong\n                        data-nodeid=\"8358\"\n                        >采用了 DFS 遍历</strong\n                      >，主要源码位于\n                      <a\n                        href=\"https://github.com/facebook/react/blob/v17.0.1/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L1558\"\n                        data-nodeid=\"8356\"\n                        >ReactFiberWorkLoop.js</a\n                      >\n                      中。我这里进行简化，你可以清晰看到 DFS 过程：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">workLoopSync</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 开始循环</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (workInProgress !== <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    performUnitOfWork(workInProgress);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">performUnitOfWork</span><span class=\"hljs-params\">(unitOfWork: Fiber)</span>: <span class=\"hljs-keyword\">void</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> current = unitOfWork.alternate;\n</div></li><li><div class=\"code-word\">  let next;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// beginWork 阶段，向下遍历子孙组件</span>\n</div></li><li><div class=\"code-word\">  next = beginWork(current, unitOfWork, subtreeRenderLanes);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (next === <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// completeUnitOfWork 是向上回溯树阶段</span>\n</div></li><li><div class=\"code-word\">    completeUnitOfWork(unitOfWork);\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    workInProgress = next;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8795\" class=\"\">\n                      另外，React 中，当 context 数据状态改变时，需要<strong\n                        data-nodeid=\"8805\"\n                        >找出依赖该 context\n                        数据状态的所有子节点，以进行状态变更和渲染</strong\n                      >。这个过程，也是一个 DFS，源码你可以参考\n                      <a\n                        href=\"https://github.com/facebook/react/blob/v17.0.1/packages/react-reconciler/src/ReactFiberNewContext.old.js#L182-L295\"\n                        data-nodeid=\"8803\"\n                        >ReactFiberNewContext.js</a\n                      >。\n                    </p>\n\n                    <p data-nodeid=\"4652\">\n                      继续树的应用这个话题，上一讲中我们介绍了二叉搜索树，这里我们来介绍字典树这个概念，并说明其应用场景。\n                    </p>\n                    <p data-nodeid=\"4653\">\n                      字典树（Trie）是针对特定类型的搜索而优化的树数据结构。典型的例子是\n                      AutoComplete（自动填充），也就是说它适合实现“<strong\n                        data-nodeid=\"4798\"\n                        >通过部分值得到完整值</strong\n                      >”的场景。因此字典树也是一种搜索树，我们有时候也叫作前缀树，因为任意一个节点的后代都存在共同的前缀。当然，更多基础概念需要你提前了解。\n                    </p>\n                    <p data-nodeid=\"4654\">我们总结一下它的特点：</p>\n                    <ul data-nodeid=\"4655\">\n                      <li data-nodeid=\"4656\">\n                        <p data-nodeid=\"4657\">\n                          字典树能做到高效查询和插入，时间复杂度为 O(k)，k\n                          为字符串长度；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4658\">\n                        <p data-nodeid=\"4659\">\n                          但是如果大量字符串没有共同前缀，就很耗内存，你可以想象一下最极端的情况，所有单词都没有共同前缀时，这颗字典树会是什么样子；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4660\">\n                        <p data-nodeid=\"4661\">\n                          字典树的核心就是<strong data-nodeid=\"4807\"\n                            >减少不必要的字符比较，提高查询效率</strong\n                          >，也就是说用空间换时间，再利用共同前缀来提高查询效率。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"4662\">\n                      除了我们刚刚提到的 AutoComplete\n                      自动填充的情况，字典树还有很多其他应用场景：\n                    </p>\n                    <ul data-nodeid=\"4663\">\n                      <li data-nodeid=\"4664\">\n                        <p data-nodeid=\"4665\">搜索</p>\n                      </li>\n                      <li data-nodeid=\"4666\">\n                        <p data-nodeid=\"4667\">分类</p>\n                      </li>\n                      <li data-nodeid=\"4668\">\n                        <p data-nodeid=\"4669\">IP 地址检索</p>\n                      </li>\n                      <li data-nodeid=\"4670\">\n                        <p data-nodeid=\"4671\">电话号码检索</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"4672\">\n                      字典树的实现也不复杂，我们可以一步步来，首先实现一个字典树上的节点，如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrefixTreeNode</span> </span>{\n</div></li><li><div class=\"code-word\">  constructor(value) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 存储子节点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.children = {}\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.isEnd = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.value = value\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4674\">\n                      一个字典树继承 PrefixTreeNode 类，如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrefixTree</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PrefixTreeNode</span> </span>{\n</div></li><li><div class=\"code-word\">  constructor() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-keyword\">null</span>)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4676\">我们可以通过下述方法实现：</p>\n                    <ul data-nodeid=\"4677\">\n                      <li data-nodeid=\"4678\">\n                        <p data-nodeid=\"4679\">\n                          addWord：创建一个字典树节点，如下代码：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">addWord(str) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> addWordHelper = (node, str) =&gt; {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 当前 node 不含当前 str 开头的目标</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!node.children[str[<span class=\"hljs-number\">0</span>]]) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 以当前 str 开头的第一个字母，创建一个 PrefixTreeNode 实例</span>\n</div></li><li><div class=\"code-word\">            node.children[str[<span class=\"hljs-number\">0</span>]] = <span class=\"hljs-keyword\">new</span> PrefixTreeNode(str[<span class=\"hljs-number\">0</span>])\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (str.length === <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">                node.children[str[<span class=\"hljs-number\">0</span>]].isEnd = <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">            } \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (str.length &gt; <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">                addWordHelper(node.children[str[<span class=\"hljs-number\">0</span>]], str.slice(<span class=\"hljs-number\">1</span>))\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    addWordHelper(<span class=\"hljs-keyword\">this</span>, str)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"4681\">\n                      <li data-nodeid=\"4682\">\n                        <p data-nodeid=\"4683\">\n                          predictWord：给定一个字符串，返回字典树中以该字符串开头的所有单词，如下代码：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">predictWord(str) {\n</div></li><li><div class=\"code-word\">    let getRemainingTree = function(str, tree) {\n</div></li><li><div class=\"code-word\">      let node = <span class=\"hljs-function\">tree\n</span></div></li><li><div class=\"code-word\">      <span class=\"hljs-title\">while</span> <span class=\"hljs-params\">(str)</span> {\n</div></li><li><div class=\"code-word\">        node = node.children[str[<span class=\"hljs-number\">0</span>]]\n</div></li><li><div class=\"code-word\">        str = str.substr(<span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> node\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 该数组维护所有以 str 开头的单词</span>\n</div></li><li><div class=\"code-word\">    let allWords = []\n</div></li><li><div class=\"code-word\">    let allWordsHelper = function(stringSoFar, tree) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (let k in tree.children) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> child = tree.children[k]\n</div></li><li><div class=\"code-word\">        let newString = stringSoFar + child.<span class=\"hljs-function\">value\n</span></div></li><li><div class=\"code-word\">        <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(child.endWord)</span> {\n</div></li><li><div class=\"code-word\">          allWords.push(newString)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        allWordsHelper(newString, child)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    let remainingTree = getRemainingTree(str, <span class=\"hljs-keyword\">this</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (remainingTree) {\n</div></li><li><div class=\"code-word\">      allWordsHelper(str, remainingTree)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> allWords\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4685\">\n                      至此，我们实现了一个字典树的数据结构。\n                    </p>\n                    <h3 data-nodeid=\"9682\" class=\"te-preview-highlight\">\n                      总结\n                    </h3>\n\n                    <p data-nodeid=\"4687\">\n                      这一讲，我们针对上一讲中的经典数据结构，结合前端应用场景进行了逐一分析。我们能够看到，无论是框架还是业务代码，都离不开数据结构的支持。数据结构也是计算机编程领域中一个最基础也是最重要的概念，它既是重点，也是难点。\n                    </p>\n                    <p data-nodeid=\"4688\">本讲内容总结如下：</p>\n                    <p data-nodeid=\"9242\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/04/F9/CioPOWAvaxqAbp7IAAFyTqrjeO4673.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"9245\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"4690\">\n                      说到底，数据结构的真正意义在于应用，这里给大家留一个思考题，你还在哪些场景看见过数据结构呢？欢迎在留言区和我分享你的观点。\n                    </p>\n                    <p data-nodeid=\"4691\">\n                      下一讲，我们就正式进入前端架构设计的实战部分，这也是本专栏的核心环节，是对之前所学知识的综合运用和设计，请继续保持学习！\n                    </p>\n            "}