{"title":"11 | 类型守卫：如何有效地保障类型的安全性？","context":"\n                    <p data-nodeid=\"95576\">\n                      在前面 10 讲中，我们学习了如何选择 TypeScript IDE\n                      和搭建开发环境，也学习了原始类型、字面量类型、数组类型、函数类型、类类型、接口类型、类型别名、联合与交叉类型、枚举类型、泛型等类型元素，以及类型推断、类型断言、类型缩小、类型放大等特性。这些类型元素和特性，构成了\n                      TypeScript 的基础认知。\n                    </p>\n\n                    <p data-nodeid=\"94831\">\n                      接下来我们将通过学习 TypeScript\n                      进阶和业务实战两个模块的内容提升对 TypeScript\n                      的理解，其中有 5 讲会介绍 TypeScript\n                      应用较为广泛的进阶知识点，剩余 6 讲则围绕 TypeScript\n                      在业务中的实践进行展开。\n                    </p>\n                    <p data-nodeid=\"94832\">\n                      接下来我们开始聊聊TypeScript 进阶的第一讲——类型守卫 。\n                    </p>\n                    <blockquote data-nodeid=\"94833\">\n                      <p data-nodeid=\"94834\">\n                        学习建议：使用 VS Code 新建一个 11.ts\n                        文件，并尝试这一讲中出现的所有示例。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"94835\">类型守卫</h3>\n                    <p data-nodeid=\"94836\">\n                      JavaScript\n                      作为一种动态语言，意味着其中的参数、值可以是多态（多种类型）。因此，我们需要区别对待每一种状态，以此确保对参数、值的操作合法。\n                    </p>\n                    <p data-nodeid=\"94837\">\n                      举一个常见的场景为例，如下我们定义了一个可以接收字符串或者字符串数组的参数\n                      toUpperCase，并将参数转成大写格式输出的函数\n                      convertToUpperCase。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> convertToUpperCase = <span class=\"hljs-function\">(<span class=\"hljs-params\">strOrArray</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> strOrArray === <span class=\"hljs-string\">'string'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> strOrArray.toUpperCase();\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(strOrArray)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> strOrArray.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.toUpperCase());\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94839\">\n                      在示例中的第 3 行、第 5 行，我们分别使用了\n                      typeof、Array.isArray\n                      确保字符串和字符串数组类型的入参在运行时分别进入正确的分支，而不至于入参是数组类型时，调用数组类型并不存在的\n                      toUpperCase 方法，从而抛出一个“strOrArray.toUpperCase is\n                      not a function”的错误。\n                    </p>\n                    <p data-nodeid=\"94840\">\n                      在 TypeScript\n                      中，因为受静态类型检测约束，所以在编码阶段我们必须使用类似的手段确保当前的数据类型支持相应的操作。当然，前提条件是已经显式地注解了类型的多态。\n                    </p>\n                    <p data-nodeid=\"94841\">\n                      比如如果我们将上边示例中的 convertToUpperCase 函数使用\n                      TypeScript 实现，那么就需要显示地标明 strOrArray\n                      的类型就是 string 和 string[]\n                      类型组成的联合类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> convertToUpperCase = <span class=\"hljs-function\">(<span class=\"hljs-params\">strOrArray: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">string</span>[]</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> strOrArray === <span class=\"hljs-string\">'string'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> strOrArray.toUpperCase();\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(strOrArray)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> strOrArray.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.toUpperCase());\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94843\">\n                      在示例中，convertToUpperCase 函数的主体逻辑与 JavaScript\n                      中的逻辑完全一致（除了添加的参数类型注解）。\n                    </p>\n                    <p data-nodeid=\"94844\">\n                      在 TypeScript 中，第 3 行和第 5 行的 typeof、Array.isArray\n                      条件判断，除了可以保证转译为 JavaScript\n                      运行后类型是正确的，还可以保证第 4 行和第 6\n                      行在静态类型检测层面是正确的。\n                    </p>\n                    <p data-nodeid=\"94845\">\n                      很明显，第 4 行中入参 strOrArray 的类型因为 typeof\n                      条件判断变成了 string，第 6 行入参 strOrArray 的类型因为\n                      Array.isArray 变成了\n                      string[]，所以没有提示类型错误。而这个类型变化就是 04\n                      讲中学习的类型缩小，这里的 typeof、Array.isArray\n                      条件判断就是类型守卫。\n                    </p>\n                    <p data-nodeid=\"94846\">\n                      从示例中，我们可以看到<strong data-nodeid=\"94952\"\n                        >类型守卫的作用在于触发类型缩小。实际上，它还可以用来区分类型集合中的不同成员。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"94847\">\n                      类型集合一般包括联合类型和枚举类型，下面我们看看如何区分联合类型。\n                    </p>\n                    <h3 data-nodeid=\"94848\">如何区分联合类型？</h3>\n                    <p data-nodeid=\"94849\">\n                      首先，我们看一下如何使用类型守卫来区分联合类型的不同成员，常用的类型守卫包括<strong\n                        data-nodeid=\"94960\"\n                        >switch、字面量恒等、typeof、instanceof、in\n                        和自定义类型守卫</strong\n                      >这几种。\n                    </p>\n                    <h4 data-nodeid=\"96072\" class=\"\">1. switch</h4>\n\n                    <p data-nodeid=\"94853\">\n                      我们往往会使用 switch\n                      类型守卫来处理联合类型中成员或者成员属性可枚举的场景，即字面量值的集合，如以下示例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> convert = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: 'a' | 1</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">switch</span> (c) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> c.toFixed(); <span class=\"hljs-comment\">// c is 1</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'a'</span>:\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> c.toLowerCase(); <span class=\"hljs-comment\">// c is 'a'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> feat = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: { animal: 'panda'; name: 'China' } | { feat: 'video'; name: 'Japan' }</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">switch</span> (c.name) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'China'</span>:\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> c.animal; <span class=\"hljs-comment\">// c is \"{ animal: 'panda'; name: 'China' }\"</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'Japan'</span>:\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> c.feat; <span class=\"hljs-comment\">// c is \"{ feat: 'video'; name: 'Japan' }\"</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"97070\">\n                      在上述示例中，因为 convert 函数的参数及 feat 函数参数的\n                      name 属性都是一个可被枚举的集合，所以我们可以使用 switch\n                      来缩小类型。\n                    </p>\n                    <p data-nodeid=\"97071\">\n                      比如第 5 行中 c 的类型被缩小为数字 1，第 7 行的 c\n                      被缩小为字符串 'Japan'，第 13 和 15 行的 c\n                      也被缩小为相应的接口类型。因此，我们对参数 c\n                      进行相关操作时，也就不会提示类型错误了。\n                    </p>\n\n                    <h4 data-nodeid=\"97568\" class=\"\">2. 字面量恒等</h4>\n\n                    <p data-nodeid=\"94859\">\n                      switch\n                      适用的场景往往也可以直接使用字面量恒等比较进行替换，比如前边的\n                      convert 函数可以改造成以下示例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> convert = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: 'a' | 1</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (c === <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> c.toFixed(); <span class=\"hljs-comment\">// c is 1</span>\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (c === <span class=\"hljs-string\">'a'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> c.toLowerCase(); <span class=\"hljs-comment\">// c is 'a'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94861\" class=\"\">\n                      在以上示例中，第 3 行、第 5 行的类型相应都缩小为了字面量 1\n                      和 'a'。\n                    </p>\n                    <blockquote data-nodeid=\"94862\">\n                      <p data-nodeid=\"94863\" class=\"\">\n                        建议：一般来说，如果可枚举的值和条件分支越多，那么使用\n                        switch\n                        就会让代码逻辑更简洁、更清晰；反之，则推荐使用字面量恒等进行判断。\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"98056\" class=\"\">3. typeof</h4>\n\n                    <p data-nodeid=\"94867\">\n                      反过来，当联合类型的成员不可枚举，比如说是字符串、数字等原子类型组成的集合，这个时候就需要使用\n                      typeof。\n                    </p>\n                    <p data-nodeid=\"94868\">\n                      typeof 是一个比较特殊的操作符（15\n                      讲中会再详细地介绍它），我们可以使用它对 convert\n                      函数进行改造，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> convert = <span class=\"hljs-function\">(<span class=\"hljs-params\">c: 'a' | 1</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> c === <span class=\"hljs-string\">'number'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> c.toFixed(); <span class=\"hljs-comment\">// c is 1</span>\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> c === <span class=\"hljs-string\">'string'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> c.toLowerCase(); <span class=\"hljs-comment\">// c is 'a'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94870\">\n                      在上述示例中，因为 typeof c\n                      表达式的返回值类型是字面量联合类型 'string' | 'number' |\n                      'bigint' | 'boolean' | 'symbol' | 'undefined' | 'object' |\n                      'function'，所以通过字面量恒等判断我们把在第 2 行和第 4\n                      行的 typeof c 表达式值类型进行了缩小，进而将 c\n                      的类型缩小为明确的 string、number 等原子类型。\n                    </p>\n                    <h4 data-nodeid=\"98540\" class=\"\">4. instanceof</h4>\n\n                    <p data-nodeid=\"94874\">\n                      此外，联合类型的成员还可以是类。比如以下示例中的第 9\n                      行和第 11 行，我们使用了 instanceof 来判断 param 是 Dog\n                      还是 Cat 类。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">class</span> Dog {\n</div></li><li><div class=\"code-word\">    wang = <span class=\"hljs-string\">'wangwang'</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">class</span> Cat {\n</div></li><li><div class=\"code-word\">    miao = <span class=\"hljs-string\">'miaomiao'</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (animal <span class=\"hljs-keyword\">instanceof</span> Dog) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> animal.wang;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (animal <span class=\"hljs-keyword\">instanceof</span> Cat) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> animal.miao;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94876\">\n                      这里我们可以看到，第 10 行、第 12 行的 animal\n                      的类型也缩小为 Dog、Cat\n                      了。接下来我们看看更复杂的情况——in。\n                    </p>\n                    <h4 data-nodeid=\"99020\" class=\"\">5. in</h4>\n\n                    <p data-nodeid=\"94880\">\n                      当联合类型的成员包含接口类型（对象），并且接口之间的属性不同，如下示例中的接口类型\n                      Dog、Cat，我们不能直接通过“ . ”操作符获取 param 的\n                      wang、miao 属性，从而区分它是 Dog 还是 Cat。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">interface</span> Dog {\n</div></li><li><div class=\"code-word\">    wang: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">interface</span> Cat {\n</div></li><li><div class=\"code-word\">    miao: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> animal.wang == <span class=\"hljs-string\">'string'</span>) { <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (animal.miao) { <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94882\">\n                      这里我们看到，在第 9~12 行都提示了一个 ts(2339) Dog | Cat\n                      联合类型没有 wang、miao 属性的错误。\n                    </p>\n                    <p data-nodeid=\"94883\">\n                      这个时候我们就需要使用 in 操作符来改造一下 getName 函数，\n                      这样就不会提示类型错误了，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'wang'</span> <span class=\"hljs-keyword\">in</span> animal) { <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'miao'</span> <span class=\"hljs-keyword\">in</span> animal) { <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"99968\">\n                      这里我们可以看到，第 3 行、第 4 行中的 animal\n                      的类型也缩小成 Dog 和 Cat 了。\n                    </p>\n                    <p data-nodeid=\"99969\">\n                      最后我们要介绍的是自定义类型守卫，确切地讲是自定义函数，\n                    </p>\n\n                    <h4 data-nodeid=\"99496\" class=\"\">6. 自定义类型守卫</h4>\n\n                    <p data-nodeid=\"94889\">\n                      这时我们将使用 05 讲中学习过的类型谓词 is，比如封装一个\n                      isDog 函数来区分 Dog 和 Cat，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> isDog = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">animal: Dog | Cat</span>): <span class=\"hljs-title\">animal</span> <span class=\"hljs-title\">is</span> <span class=\"hljs-title\">Dog</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'wang'</span> <span class=\"hljs-keyword\">in</span> animal;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> getName = <span class=\"hljs-function\">(<span class=\"hljs-params\">animal: Dog | Cat</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (isDog(animal)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> animal.wang;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94891\">\n                      这里我们在 getName 函数第 5 行的条件判断中使用了 isDog 将\n                      animal 的类型缩小为 Dog，这样第 6 行就可以直接获取 wang\n                      属性了，而不会提示一个 ts(2339) 的错误。\n                    </p>\n                    <p data-nodeid=\"94892\">\n                      除了联合类型之外，另外一个类型集合是枚举类型，下面我们聊聊如何区别枚举类型。\n                    </p>\n                    <h3 data-nodeid=\"94893\">如何区别枚举类型？</h3>\n                    <p data-nodeid=\"94894\">\n                      如 09\n                      讲中介绍，枚举类型是命名常量的集合，所以我们也需要使用类型守卫区分枚举类型的成员。\n                    </p>\n                    <p data-nodeid=\"94895\">\n                      先回想一下枚举类型的若干特性，因为这将决定使用哪几种类型守卫来区分枚举既是可行的，又是安全的。\n                    </p>\n                    <p data-nodeid=\"94896\">\n                      <strong data-nodeid=\"95037\">特性 1</strong\n                      >：枚举和其他任何枚举、类型都不可比较，除了数字枚举可以与数字类型比较之外；\n                    </p>\n                    <p data-nodeid=\"94897\">\n                      <strong data-nodeid=\"95042\">特性 2</strong\n                      >：数字枚举极其不稳定。\n                    </p>\n                    <p data-nodeid=\"94898\">\n                      熟悉了这些特性后，得出一个结论：最佳实践时，我们永远不要拿枚举和除了自身之外的任何枚举、类型进行比较。\n                    </p>\n                    <p data-nodeid=\"94899\">下面我们看一个具体的示例：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">enum</span> A {\n</div></li><li><div class=\"code-word\">    one,\n</div></li><li><div class=\"code-word\">    two\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">enum</span> B {\n</div></li><li><div class=\"code-word\">    one,\n</div></li><li><div class=\"code-word\">    two\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> cpWithNumber = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: A</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (param === <span class=\"hljs-number\">1</span>) { <span class=\"hljs-comment\">// bad</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> param;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> cpWithOtherEnum = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: A</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (param === B.two <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> A) { <span class=\"hljs-comment\">// ALERT bad</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> param;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> cpWithSelf = <span class=\"hljs-function\">(<span class=\"hljs-params\">param: A</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (param === A.two) { <span class=\"hljs-comment\">// good</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> param;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94901\">\n                      在第 10～14 行的函数 cpWithNumber 中，第 11\n                      行我们将类型是枚举 A 的入参 param 和数字字面量 1\n                      进行比较，因为 A 是数字枚举，所以 param 可以和 1\n                      进行比较，而不会提示一个 ts(2367) 条件判断恒为 false\n                      的错误。\n                    </p>\n                    <p data-nodeid=\"94902\">\n                      因为数字枚举不稳定，所以默认情况下 A.two 的值会是\n                      1，因此第 11 行的条件判断在入参为 A.two\n                      的时候为真。但是，如果我们给枚举 A 的成员 one 指定初始值\n                      1，第 11 行的条件判断在入参为 A.two 的时候就为否了，因为\n                      A.two 值变成了 2，所以这不是一个安全的实践。\n                    </p>\n                    <blockquote data-nodeid=\"94903\">\n                      <p data-nodeid=\"94904\">\n                        顺带再复习一下，在调用函数 cpWithNumber\n                        的时候，我们使用数字类型做入参也是一种不安全的实践，原因同上。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"94905\">\n                      示例中第 15 ～ 19 行的函数\n                      cpWithOtherEnum，我们使用了双重类型断言将枚举类型 B 转换为\n                      A，主要是为了避免第 16 行提示一个 ts(2367)\n                      错误，所以这同样也是一种不安全的实践。因为一旦 A 和 B\n                      的结构出现了任何差异（比如给成员指定了不同的初始值、改变了成员的顺序或者个数），都会导致第\n                      16 行的条件判断逻辑时真时否。\n                    </p>\n                    <blockquote data-nodeid=\"94906\">\n                      <p data-nodeid=\"94907\">\n                        注意：有时候我们确实避免不了像示例中第 16\n                        行这样使用双重类型断言来绕过 TypeScript\n                        静态类型检测，比如使用基于同一个 Swagger\n                        定义自动生成的两个枚举类型。此时，我们就需要极其谨慎，而且还需要添加警示信息进行说明，比如第\n                        16 行添加的 \"ALERT\" 注释。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"94908\">\n                      最安全的实践是使用第 21 行区分枚举成员的判断方式。\n                    </p>\n                    <p data-nodeid=\"94909\">\n                      以上结论，同样适用于使用其他类型守卫（例如\n                      switch）来区分枚举成员的场景。\n                    </p>\n                    <blockquote data-nodeid=\"94910\">\n                      <p data-nodeid=\"94911\">\n                        注意：你应该还记得字面量成员枚举可等价为字面量成员类型组成的联合类型，所以类型守卫可以让字面量成员枚举发生类型缩小。比如第\n                        22 行中 param 的类型是 A.two，此时如果我们在 VS Code 中\n                        hover 到 param 变量上，则会看到一个信息验证提示。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"94912\">\n                      以上就是 TypeScript 中尽职尽责的类型守卫。\n                    </p>\n                    <p data-nodeid=\"94913\">\n                      不过，类型守卫实际上也会有力不足心的时候，下面我们一起看看失效的类型守卫。\n                    </p>\n                    <h3 data-nodeid=\"94914\">失效的类型守卫</h3>\n                    <p data-nodeid=\"94915\">\n                      失效的类型守卫指的是某些类型守卫应用在泛型函数中时不能缩小类型，即失效了。比如我们改造了一个可以接受泛型入参的\n                      getName 函数，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> getName = &lt;T <span class=\"hljs-keyword\">extends</span> Dog | Cat&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">animal: T</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'wang'</span> <span class=\"hljs-keyword\">in</span> animal) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"100442\">\n                      在上述示例中，虽然我们在第 2 行使用了 in\n                      类型守卫，但是它并没有让 animal 的类型如预期那样缩小为 Dog\n                      的子类型，所以第 3 行的 T 类型上没有 wang\n                      属性，从而提示一个 ts(2339) 的错误。所以第 5 行的 animal\n                      也不会缩小为 Cat 的子类型，从而也会提示一个 ts(2339)\n                      的错误。\n                    </p>\n                    <p data-nodeid=\"100443\">\n                      可一旦我们把 in 操作换成自定义类型守卫 isDog 或者使用\n                      instanceOf，animal 的类型就会缩小成了 Dog 的子类型（T\n                      &amp; Dog），所以第 3 行不会提示 ts(2339)\n                      的错误。由此可见，in 和\n                      instanceOf、类型谓词在泛型类型缩小上是有区别的。\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> getName = &lt;T <span class=\"hljs-keyword\">extends</span> Dog | Cat&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">animal: T</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (isDog(animal)) { <span class=\"hljs-comment\">// instanceOf 亦可</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> animal.miao; <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"100918\">\n                      但是，在缺省的 else 条件分支里，animal 的类型并没有缩小成\n                      Cat 的子类型，所以第 5 行依旧会提示一个 ts(2339)\n                      的错误（这是一个不太科学的设计，所幸在 TypeScript 4.3.2\n                      里已经修改了）。\n                    </p>\n                    <p data-nodeid=\"100919\">\n                      这个时候，就需要使用类型断言，如下代码所示：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> getName = &lt;T <span class=\"hljs-keyword\">extends</span> Dog | Cat&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">animal: T</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (isDog(animal)) { <span class=\"hljs-comment\">// instanceOf 亦可</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> animal.wang; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> (animal <span class=\"hljs-keyword\">as</span> Cat).miao; <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"94921\">\n                      在第 5 行，我们把 animal 的类型断言为 Cat，并获取了它的\n                      miao 属性。\n                    </p>\n                    <h3 data-nodeid=\"94922\">小结和预告</h3>\n                    <p data-nodeid=\"94923\">好了，以上就是这一讲的主要内容。</p>\n                    <p data-nodeid=\"94924\">\n                      可能你已经发现，所谓的高阶内容并不仅仅指新增了多少高难度的知识点，还包括对之前所学的知识的综合回顾。因为任何进阶的知识、技能都是建立在之前打下坚实的基础之上。\n                    </p>\n                    <p data-nodeid=\"94925\">\n                      插播一道思考题：如何区分不同的接口对象类型？欢迎你在留言区交流、互动？\n                    </p>\n                    <p data-nodeid=\"94926\">\n                      12\n                      讲我们将学习类型的兼容性，了解如何判定一个类型能否赋值给其他类型，敬请期待~\n                    </p>\n                    <p data-nodeid=\"94927\">\n                      另外，如果你觉得本专栏有价值，欢迎分享给更多好友~\n                    </p>\n            "}