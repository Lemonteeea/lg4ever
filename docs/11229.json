{"title":"27 | 同构渲染架构：实现一个 SSR 应用","context":"\n                    <p data-nodeid=\"27568\" class=\"\">\n                      从这一讲开始，我们正式进入 Node.js 主题学习。作为 Node.js\n                      技术的重要应用场景，同构渲染 SSR\n                      应用尤其重要。不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27570\"\n                        >renderToString</code\n                      >（React 中）类似的 API 吗？\n                    </p>\n\n                    <p data-nodeid=\"25341\">\n                      讲道理，确实如此，但同构应用也不只是这么简单。就拿面试来说，同构应用的考察点不是“纸上谈兵”的理论，而是实际实施时的细节。这一讲我们就来一步步实现一个\n                      SSR 应用，并分析 SSR\n                      应用的重点环节。相关内容你可以参考：<a\n                        href=\"https://github.com/HOUCe/ssr\"\n                        data-nodeid=\"25454\"\n                        >实现一个简易 ssr</a\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"25342\">实现一个简易 SSR 应用</h3>\n                    <p data-nodeid=\"25343\">\n                      SSR 渲染架构的优势已经非常明显了，不管是对SEO\n                      友好还是性能提升，大部分开发者已经耳熟能详了。这一部分，我们以\n                      React 技术栈为背景，实现一个 SSR 应用。\n                    </p>\n                    <p data-nodeid=\"25344\">首先启动项目：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">npm init --yes\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25346\">\n                      配置 Babel 和Webpack，目的是将ESM 和React编译为\n                      Node.js和浏览器能够理解的代码。相关<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25460\"\n                        >.babelrc</code\n                      >内容如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"presets\"</span>: [<span class=\"hljs-string\">\"@babel/env\"</span>, <span class=\"hljs-string\">\"@babel/react\"</span>]\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25348\">\n                      如上代码，我们直接使用了<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25463\"\n                        >@babel/env</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"25465\"\n                        >@babel/react</code\n                      >作为 presets。相关<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25467\"\n                        >webpack.config.js</code\n                      >内容如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> path = require(<span class=\"hljs-string\">'path'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n</div></li><li><div class=\"code-word\">    entry: {\n</div></li><li><div class=\"code-word\">        client: <span class=\"hljs-string\">'./src/client.js'</span>,\n</div></li><li><div class=\"code-word\">        bundle: <span class=\"hljs-string\">'./src/bundle.js'</span>\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    output: {\n</div></li><li><div class=\"code-word\">        path: path.resolve(__dirname, <span class=\"hljs-string\">'assets'</span>),\n</div></li><li><div class=\"code-word\">        filename: <span class=\"hljs-string\">\"[name].js\"</span>\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">module</span>: {\n</div></li><li><div class=\"code-word\">        rules: [\n</div></li><li><div class=\"code-word\">            { test: /\\.js$/, exclude: /node_modules/, loader: <span class=\"hljs-string\">\"babel-loader\"</span> }\n</div></li><li><div class=\"code-word\">        ]\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25350\">\n                      配置入口文件为<code data-backticks=\"1\" data-nodeid=\"25470\"\n                        >./src/client.js</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"25472\"\n                        >./src/bundle.js</code\n                      >，打包结果如下。\n                    </p>\n                    <ul data-nodeid=\"25351\">\n                      <li data-nodeid=\"25352\">\n                        <p data-nodeid=\"25353\">\n                          <code data-backticks=\"1\" data-nodeid=\"25474\"\n                            >assets/bundle.js</code\n                          >：CSR 架构下浏览器端脚本。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25354\">\n                        <p data-nodeid=\"25355\">\n                          <code data-backticks=\"1\" data-nodeid=\"25476\"\n                            >assets/client.js</code\n                          >：SSR 架构下浏览器端脚本，衔接 SSR 部分。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25356\">\n                      <code data-backticks=\"1\" data-nodeid=\"25478\">src/</code\n                      >文件夹包含所有源码，Babel 将会编译该文件内代码到<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25480\"\n                        >views/</code\n                      >目录。这里需要你思考：为什么我们要编译源码呢？\n                    </p>\n                    <p data-nodeid=\"25357\">\n                      业务源码中，我们使用 ESM 编写 React 和 Redux 代码，<strong\n                        data-nodeid=\"25491\"\n                        >对于低版本 Node.js来说，并不能直接支持 ESM 规范</strong\n                      >，因此需要使用 Babel 将<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25487\"\n                        >src/</code\n                      >文件夹内代码编译到<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25489\"\n                        >views/</code\n                      >目录中。相关命令如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-string\">\"babel\"</span>: <span class=\"hljs-string\">\"babel src -d views\"</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25359\">我们对项目目录进行说明：</p>\n                    <ul data-nodeid=\"25360\">\n                      <li data-nodeid=\"25361\">\n                        <p data-nodeid=\"25362\">\n                          <code data-backticks=\"1\" data-nodeid=\"25493\"\n                            >src/components</code\n                          >中我们存放 React 组件；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25363\">\n                        <p data-nodeid=\"25364\">\n                          <code data-backticks=\"1\" data-nodeid=\"25495\"\n                            >src/redux/</code\n                          >中我们存放 Redux 相关代码；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25365\">\n                        <p data-nodeid=\"25366\">\n                          <code data-backticks=\"1\" data-nodeid=\"25497\"\n                            >assets/</code\n                          >和<code data-backticks=\"1\" data-nodeid=\"25499\"\n                            >media/</code\n                          >中我们存放样式文件及图片；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25367\">\n                        <p data-nodeid=\"25368\">\n                          <code data-backticks=\"1\" data-nodeid=\"25501\"\n                            >src/server.js</code\n                          >和<code data-backticks=\"1\" data-nodeid=\"25503\"\n                            >src/template.js</code\n                          >是 Node.js环境相关脚本。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25369\">\n                      接下来，我们进入 Node.js相关的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25506\"\n                        >src/server.js</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"25508\"\n                        >src/template.js</code\n                      >脚本的编写。\n                    </p>\n                    <p data-nodeid=\"25370\">\n                      <code data-backticks=\"1\" data-nodeid=\"25510\"\n                        >src/server.js</code\n                      >如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React from 'react';\n</div></li><li><div class=\"code-word\">import { renderToString } from 'react-dom/server';\n</div></li><li><div class=\"code-word\">import { Provider } from 'react-redux';\n</div></li><li><div class=\"code-word\">import configureStore from './redux/configureStore';\n</div></li><li><div class=\"code-word\">import App from './components/app';\n</div></li><li><div class=\"code-word\">module.exports = function render(initialState) {\n</div></li><li><div class=\"code-word\">\t// 初始化 redux store\n</div></li><li><div class=\"code-word\">  const store = configureStore(initialState);\n</div></li><li><div class=\"code-word\">  let content = renderToString(&lt;Provider store={store} &gt;&lt;App /&gt;&lt;/Provider&gt;);\n</div></li><li><div class=\"code-word\">  const preloadedState = store.getState();\n</div></li><li><div class=\"code-word\">  return {\n</div></li><li><div class=\"code-word\">    content,\n</div></li><li><div class=\"code-word\">    preloadedState\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25372\">我们展开具体分析：</p>\n                    <ul data-nodeid=\"25373\">\n                      <li data-nodeid=\"25374\">\n                        <p data-nodeid=\"25375\">\n                          <code data-backticks=\"1\" data-nodeid=\"25513\"\n                            >initialState</code\n                          >作为参数传递给<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"25515\"\n                            >configureStore()</code\n                          >方法，并实例化一个新的Store；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25376\">\n                        <p data-nodeid=\"25377\">\n                          调用<code data-backticks=\"1\" data-nodeid=\"25518\"\n                            >renderToString()</code\n                          >方法，得到服务端渲染的 HTML 字符串<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"25520\"\n                            >content</code\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25378\">\n                        <p data-nodeid=\"25379\">\n                          调用 Redux<code data-backticks=\"1\" data-nodeid=\"25523\"\n                            >getState()</code\n                          >方法，得到状态为<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"25525\"\n                            >preloadedState</code\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25380\">\n                        <p data-nodeid=\"25381\">\n                          返回 HTML 字符串<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"25528\"\n                            >content</code\n                          >和 preloadedState。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25382\">\n                      <code data-backticks=\"1\" data-nodeid=\"25530\"\n                        >src/template.js</code\n                      >代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export default function template(title, initialState = {}, content = \"\") {\n</div></li><li><div class=\"code-word\">  let scripts = ''; \n</div></li><li><div class=\"code-word\">  // 是否有 content 内容\n</div></li><li><div class=\"code-word\">  if (content) {\n</div></li><li><div class=\"code-word\">    scripts = \\` &lt;script&gt;\n</div></li><li><div class=\"code-word\">                   window.__STATE__ = ${JSON.stringify(initialState)}\n</div></li><li><div class=\"code-word\">                &lt;/script&gt;\n</div></li><li><div class=\"code-word\">                &lt;script src=\"assets/client.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">                \\`\n</div></li><li><div class=\"code-word\">  } else {\n</div></li><li><div class=\"code-word\">    scripts = \\` &lt;script src=\"assets/bundle.js\"&gt; &lt;/script&gt; \\`\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  let page = \\`&lt;!DOCTYPE html&gt;\n</div></li><li><div class=\"code-word\">              &lt;html lang=\"en\"&gt;\n</div></li><li><div class=\"code-word\">              &lt;head&gt;\n</div></li><li><div class=\"code-word\">                &lt;meta charset=\"utf-8\"&gt;\n</div></li><li><div class=\"code-word\">                &lt;title&gt; ${title} &lt;/title&gt;\n</div></li><li><div class=\"code-word\">                &lt;link rel=\"stylesheet\" href=\"assets/style.css\"&gt;\n</div></li><li><div class=\"code-word\">              &lt;/head&gt;\n</div></li><li><div class=\"code-word\">              &lt;body&gt;\n</div></li><li><div class=\"code-word\">                &lt;div class=\"content\"&gt;\n</div></li><li><div class=\"code-word\">                   &lt;div id=\"app\" class=\"wrap-inner\"&gt;\n</div></li><li><div class=\"code-word\">                      ${content}\n</div></li><li><div class=\"code-word\">                   &lt;/div&gt;\n</div></li><li><div class=\"code-word\">                &lt;/div&gt;\n</div></li><li><div class=\"code-word\">                  ${scripts}\n</div></li><li><div class=\"code-word\">              &lt;/body&gt;\n</div></li><li><div class=\"code-word\">              \\`;\n</div></li><li><div class=\"code-word\">  return page;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25384\">\n                      我们对上述代码进行解读：<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25533\"\n                        >template</code\n                      >函数接受<code data-backticks=\"1\" data-nodeid=\"25535\"\n                        >title</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"25537\"\n                        >state</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"25539\"\n                        >content</code\n                      >作为参数，拼凑成最终的 HTML 文档，并将<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25541\"\n                        >state</code\n                      >挂载到<code data-backticks=\"1\" data-nodeid=\"25543\"\n                        >window.__STATE__</code\n                      >中，作为 script 标签内联到 HTML 文档，同时将 SSR\n                      架构下<code data-backticks=\"1\" data-nodeid=\"25545\"\n                        >assets/client.js</code\n                      >脚本或<code data-backticks=\"1\" data-nodeid=\"25547\"\n                        >assets/bundle.js</code\n                      >嵌入。\n                    </p>\n                    <p data-nodeid=\"25385\">\n                      下面，我们再聚焦同构部分的浏览器端脚本。\n                    </p>\n                    <p data-nodeid=\"25386\">\n                      在CSR 架构下，<code data-backticks=\"1\" data-nodeid=\"25551\"\n                        >src/bundle.js</code\n                      >代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React from 'react';\n</div></li><li><div class=\"code-word\">import { render } from 'react-dom';\n</div></li><li><div class=\"code-word\">import { Provider } from 'react-redux';\n</div></li><li><div class=\"code-word\">import configureStore from './redux/configureStore';\n</div></li><li><div class=\"code-word\">import App from './components/app';\n</div></li><li><div class=\"code-word\">// 获取 store\n</div></li><li><div class=\"code-word\">const store = configureStore();\n</div></li><li><div class=\"code-word\">render(\n</div></li><li><div class=\"code-word\">  &lt;Provider store={store} &gt; &lt;App /&gt; &lt;/Provider&gt;,\n</div></li><li><div class=\"code-word\">  document.querySelector('#app')\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25388\">\n                      而 SSR 架构下，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25554\"\n                        >src/client.js</code\n                      >代码类似：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React from 'react';\n</div></li><li><div class=\"code-word\">import { hydrate } from 'react-dom';\n</div></li><li><div class=\"code-word\">import { Provider } from 'react-redux';\n</div></li><li><div class=\"code-word\">import configureStore from './redux/configureStore';\n</div></li><li><div class=\"code-word\">import App from './components/app';\n</div></li><li><div class=\"code-word\">const state = window.__STATE__;\n</div></li><li><div class=\"code-word\">delete window.__STATE__;\n</div></li><li><div class=\"code-word\">const store = configureStore(state);\n</div></li><li><div class=\"code-word\">hydrate(\n</div></li><li><div class=\"code-word\">  &lt;Provider store={store} &gt; &lt;App /&gt; &lt;/Provider&gt;,\n</div></li><li><div class=\"code-word\">  document.querySelector('#app')\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25390\">\n                      <code data-backticks=\"1\" data-nodeid=\"25556\"\n                        >src/client.js</code\n                      >对比<code data-backticks=\"1\" data-nodeid=\"25558\"\n                        >src/bundle.js</code\n                      >，比较关键的不同点在于<strong data-nodeid=\"25573\"\n                        >使用了</strong\n                      ><code data-backticks=\"1\" data-nodeid=\"25563\"\n                        >window.__STATE__.</code\n                      ><strong data-nodeid=\"25574\"\n                        >获取初始状态，同时使用了</strong\n                      ><code data-backticks=\"1\" data-nodeid=\"25567\"\n                        >hydrate()</code\n                      ><strong data-nodeid=\"25575\">方法代替了</strong\n                      ><code data-backticks=\"1\" data-nodeid=\"25571\"\n                        >render()</code\n                      >。\n                    </p>\n                    <p data-nodeid=\"25391\">\n                      至此，我们就实现了一个简易的 SSR\n                      应用。虽然简单，但完全体现了 SSR\n                      架构的原理。然而生产情况复杂多变，我们继续往下看。\n                    </p>\n                    <h3 data-nodeid=\"25392\">同构应用中你容易忽略的细节</h3>\n                    <p data-nodeid=\"25393\">\n                      接下来，我们对几个更细节的问题加以分析。这些问题的处理，不再是代码层面的解决方案，更是工程化方向的设计。\n                    </p>\n                    <h4 data-nodeid=\"25394\">环境区分</h4>\n                    <p data-nodeid=\"25395\">\n                      我们知道，同构应用实现了客户端代码和服务端代码的基本统一，我们只需要编写一种组件，就能生成适用于服务端和客户端的组件案例。可是你是否知道，大多数情况下服务端代码和客户端代码需要单独处理？下面我简单举几个例子。\n                    </p>\n                    <ul data-nodeid=\"25396\">\n                      <li data-nodeid=\"25397\">\n                        <p data-nodeid=\"25398\">\n                          <strong data-nodeid=\"25584\">路由代码差别</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25399\">\n                      服务端需要根据请求路径，匹配页面组件；客户端需要通过浏览器中的地址，匹配页面组件。\n                    </p>\n                    <p data-nodeid=\"25400\">客户端代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  const App = () =&gt; {\n</div></li><li><div class=\"code-word\">    return (\n</div></li><li><div class=\"code-word\">      &lt;Provider store={store}&gt;\n</div></li><li><div class=\"code-word\">        &lt;BrowserRouter&gt;\n</div></li><li><div class=\"code-word\">          &lt;div&gt;\n</div></li><li><div class=\"code-word\">            &lt;Route path='/' component={Home}&gt;\n</div></li><li><div class=\"code-word\">            &lt;Route path='/product' component={Product}&gt;\n</div></li><li><div class=\"code-word\">          &lt;/div&gt;\n</div></li><li><div class=\"code-word\">        &lt;/BrowserRouter&gt;\n</div></li><li><div class=\"code-word\">      &lt;/Provider&gt;\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  ReactDom.render(&lt;App/&gt;, document.querySelector('#root'))\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25402\">\n                      BrowserRouter 组件根据 window.location 以及 history API\n                      实现页面切换，而服务端肯定是无法获取 window.location 的。\n                    </p>\n                    <p data-nodeid=\"25403\">服务端代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  const App = () =&gt; {\n</div></li><li><div class=\"code-word\">    return \n</div></li><li><div class=\"code-word\">      &lt;Provider store={store}&gt;\n</div></li><li><div class=\"code-word\">        &lt;StaticRouter location={req.path} context={context}&gt;\n</div></li><li><div class=\"code-word\">          &lt;div&gt;\n</div></li><li><div class=\"code-word\">            &lt;Route path='/' component={Home}&gt;\n</div></li><li><div class=\"code-word\">          &lt;/div&gt;\n</div></li><li><div class=\"code-word\">        &lt;/StaticRouter&gt;\n</div></li><li><div class=\"code-word\">      &lt;/Provider&gt;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  Return ReactDom.renderToString(&lt;App/&gt;)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25405\">\n                      在服务端，需要<strong data-nodeid=\"25594\"\n                        >使用 StaticRouter 组件</strong\n                      >，并将请求地址和上下文信息作为 location 和 context\n                      这两个props 传入 StaticRouter 中。\n                    </p>\n                    <ul data-nodeid=\"25406\">\n                      <li data-nodeid=\"25407\">\n                        <p data-nodeid=\"25408\">\n                          <strong data-nodeid=\"25598\">打包差别</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"28847\" class=\"\">\n                      服务端运行的代码如果需要依赖 Node\n                      核心模块或者第三方模块，就不再需要把这些模块代码打包到最终代码中了。因为环境已经安装这些依赖，可以直接引用。这样一来，就需要我们<strong\n                        data-nodeid=\"28853\"\n                        >在 Webpack 中配置 target：node</strong\n                      >，并借助 webpack-node-externals\n                      插件，解决第三方依赖打包的问题。\n                    </p>\n\n                    <h4 data-nodeid=\"25410\">注水和脱水</h4>\n                    <p data-nodeid=\"25411\">\n                      什么叫作注水和脱水呢？这个和同构应用中数据的获取有关：在服务器端渲染时，首先服务端请求接口拿到数据，并处理准备好数据状态（如果使用\n                      Redux，就是进行Store\n                      的更新），为了减少客户端的请求，我们需要保留住这个状态。\n                    </p>\n                    <p data-nodeid=\"25412\">\n                      一般做法是在服务器端返回 HTML 字符串的时候，将数据\n                      JSON.stringify\n                      一并返回，这个过程，叫作脱水（dehydrate）；在客户端，就不再需要进行数据的请求了，可以直接使用服务端下发下来的数据，这个过程叫注水（hydrate）。\n                    </p>\n                    <p data-nodeid=\"25413\">\n                      响应代码前面已经有所体现了，但是在服务端渲染时，服务端如何能够请求所有的\n                      APIs，保障数据全部已经请求呢？\n                    </p>\n                    <p data-nodeid=\"25414\">一般有两种方法进行服务端请求。</p>\n                    <ul data-nodeid=\"25415\">\n                      <li data-nodeid=\"25416\">\n                        <p data-nodeid=\"25417\">\n                          react-router 的解决方案是配置路由route-config，结合\n                          matchRoutes，找到页面上相关组件所需的请求接口的方法并执行请求。这就要求开发者通过路由配置信息，显式地告知服务端请求内容。如下代码：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  const routes = [\n</div></li><li><div class=\"code-word\">    {\n</div></li><li><div class=\"code-word\">      path: \"/\",\n</div></li><li><div class=\"code-word\">      component: Root,\n</div></li><li><div class=\"code-word\">      loadData: () =&gt; getSomeData()\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    // etc.\n</div></li><li><div class=\"code-word\">  ]\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  import { routes } from \"./routes\"\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  function App() {\n</div></li><li><div class=\"code-word\">    return (\n</div></li><li><div class=\"code-word\">      &lt;Switch&gt;\n</div></li><li><div class=\"code-word\">        {routes.map(route =&gt; (\n</div></li><li><div class=\"code-word\">          &lt;Route {...route} /&gt;\n</div></li><li><div class=\"code-word\">        ))}\n</div></li><li><div class=\"code-word\">      &lt;/Switch&gt;\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25419\">在服务端代码中：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> { matchPath } from <span class=\"hljs-string\">\"react-router-dom\"</span>\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> promises = []\n</div></li><li><div class=\"code-word\">  routes.some(route =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> match = matchPath(req.path, route)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (match) promises.push(route.loadData(match))\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> match\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  Promise.all(promises).then(data =&gt; {\n</div></li><li><div class=\"code-word\">    putTheDataSomewhereTheClientCanFindIt(data)\n</div></li><li><div class=\"code-word\">  })\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"25421\">\n                      <li data-nodeid=\"25422\">\n                        <p data-nodeid=\"25423\">\n                          另外一种思路类似 Next.js，我们需要在 React\n                          组件上<strong data-nodeid=\"25617\">定义静态方法</strong\n                          >。比如定义静态 loadData\n                          方法，在服务端渲染时，我们可以遍历所有组件的\n                          loadData，获取需要请求的接口。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"25424\">安全问题</h4>\n                    <p data-nodeid=\"25425\">\n                      安全问题非常关键，尤其是涉及服务端渲染，开发者要格外小心。这里提出一个点：我们前面提到了注水和脱水过程，其中的代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">ctx.body = \\`\n</div></li><li><div class=\"code-word\">  &lt;!DOCTYPE html&gt;\n</div></li><li><div class=\"code-word\">  &lt;html lang=\"en\"&gt;\n</div></li><li><div class=\"code-word\">    &lt;head&gt;\n</div></li><li><div class=\"code-word\">      &lt;meta charset=\"UTF-8\"&gt;\n</div></li><li><div class=\"code-word\">    &lt;/head&gt;\n</div></li><li><div class=\"code-word\">    &lt;body&gt;\n</div></li><li><div class=\"code-word\">        &lt;script&gt;\n</div></li><li><div class=\"code-word\">        window.context = {\n</div></li><li><div class=\"code-word\">          initialState: ${JSON.stringify(store.getState())}\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      &lt;/script&gt;\n</div></li><li><div class=\"code-word\">      &lt;div id=\"app\"&gt;\n</div></li><li><div class=\"code-word\">          // ...\n</div></li><li><div class=\"code-word\">      &lt;/div&gt;\n</div></li><li><div class=\"code-word\">    &lt;/body&gt;\n</div></li><li><div class=\"code-word\">  &lt;/html&gt;\n</div></li><li><div class=\"code-word\">\\`\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25427\">\n                      非常容易遭受 XSS 攻击，JSON.stringify 可能会造成 script\n                      注入。因此，我们需要<strong data-nodeid=\"25625\"\n                        >严格清洗 JSON 字符串中的 HTML\n                        标签和其他危险的字符</strong\n                      >。我习惯使用 serialize-javascript\n                      库进行处理，这也是同构应用中最容易被忽视的细节。\n                    </p>\n                    <p data-nodeid=\"25428\">\n                      这里给大家留一个思考题，React<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25627\"\n                        >dangerouslySetInnerHTML</code\n                      >API 也有类似风险，React 是怎么处理这个安全隐患的呢？\n                    </p>\n                    <h4 data-nodeid=\"25429\">请求认证处理</h4>\n                    <p data-nodeid=\"25430\">\n                      上面讲到服务端预先请求数据，那么请你思考这样一个场景：某个请求依赖\n                      cookie\n                      表明的用户信息，比如请求“我的学习计划列表”。这种情况下服务端请求是不同于客户端的，不会有浏览器添加\n                      cookie 以及不含有其他相关的 header\n                      信息。这个请求在服务端发送时，一定不会拿到预期的结果。\n                    </p>\n                    <p data-nodeid=\"25431\">\n                      解决办法也很简单：服务端请求时需要保留客户端页面请求的信息（一般是\n                      cookie），并在 API 请求时携带并透传这个信息（cookie）。\n                    </p>\n                    <h4 data-nodeid=\"25432\">样式问题处理</h4>\n                    <p data-nodeid=\"25433\">\n                      同构应用的样式处理容易被开发者忽视，而一旦忽略，就会掉到坑里。比如，我们不能再使用\n                      style-loader 了，因为这个WebpackLoader\n                      会在编译时将样式模块载入到 HTML header\n                      中。但是在服务端渲染环境下，没有Window\n                      对象，style-loader就会报错。一般我们使用\n                      isomorphic-style-loader 来实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">    test: /\\.css$/,\n</div></li><li><div class=\"code-word\">    use: [\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">'isomorphic-style-loader'</span>,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">'css-loader'</span>,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">'postcss-loader'</span>\n</div></li><li><div class=\"code-word\">    ],\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25435\">\n                      isomorphic-style-loader 的原理是什么呢？\n                    </p>\n                    <p data-nodeid=\"25436\">\n                      我们知道，对于Webpack\n                      来说，所有的资源都是模块。WebpackLoader\n                      在编译过程中可以将导入的 CSS\n                      文件转换成对象，拿到样式信息。因此<strong\n                        data-nodeid=\"25640\"\n                        >isomorphic-style-loader\n                        可以获取页面中所有组件样式</strong\n                      >。为了实现得更加通用化，isomorphic-style-loader 利用\n                      context API，在渲染页面组件时获取所有 React\n                      组件的样式信息，最终插入 HTML 字符串中。\n                    </p>\n                    <p data-nodeid=\"25437\">\n                      在服务端渲染时，我们需要加入这样的逻辑：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import express from 'express'\n</div></li><li><div class=\"code-word\">import React from 'react'\n</div></li><li><div class=\"code-word\">import ReactDOM from 'react-dom'\n</div></li><li><div class=\"code-word\">import StyleContext from 'isomorphic-style-loader/StyleContext'\n</div></li><li><div class=\"code-word\">import App from './App.js'\n</div></li><li><div class=\"code-word\">const server = express()\n</div></li><li><div class=\"code-word\">const port = process.env.PORT || 3000\n</div></li><li><div class=\"code-word\">server.get('*', (req, res, next) =&gt; {\n</div></li><li><div class=\"code-word\">  //  css Set 类型来存储页面所有的样式\n</div></li><li><div class=\"code-word\">  const css = new Set()\n</div></li><li><div class=\"code-word\">  const insertCss = (...styles) =&gt; styles.forEach(style =&gt; css.add(style._getCss()))\n</div></li><li><div class=\"code-word\">  const body = ReactDOM.renderToString(\n</div></li><li><div class=\"code-word\">    &lt;StyleContext.Provider value={{ insertCss }}&gt;\n</div></li><li><div class=\"code-word\">      &lt;App /&gt;\n</div></li><li><div class=\"code-word\">    &lt;/StyleContext.Provider&gt;\n</div></li><li><div class=\"code-word\">  )\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  const html = \\`&lt;!doctype html&gt;\n</div></li><li><div class=\"code-word\">    &lt;html&gt;\n</div></li><li><div class=\"code-word\">      &lt;head&gt;\n</div></li><li><div class=\"code-word\">        &lt;script src=\"client.js\" defer&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">        // 将样式内连进 html 当中\n</div></li><li><div class=\"code-word\">        &lt;style&gt;${[...css].join('')}&lt;/style&gt;\n</div></li><li><div class=\"code-word\">      &lt;/head&gt;\n</div></li><li><div class=\"code-word\">      &lt;body&gt;\n</div></li><li><div class=\"code-word\">        &lt;div id=\"root\"&gt;${body}&lt;/div&gt;\n</div></li><li><div class=\"code-word\">      &lt;/body&gt;\n</div></li><li><div class=\"code-word\">    &lt;/html&gt;\\`\n</div></li><li><div class=\"code-word\">  res.status(200).send(html)\n</div></li><li><div class=\"code-word\">})\n</div></li><li><div class=\"code-word\">server.listen(port, () =&gt; {\n</div></li><li><div class=\"code-word\">  console.log(\\`Node.js app is running at http://localhost:${port}/\\`)\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25439\">\n                      分析上面代码，我们定义了 css Set\n                      类型来存储页面所有的样式，并定义了 insertCss\n                      方法。该方法通过 context 传给每个 React\n                      组件，这样每个组件就可以调用 insertCss\n                      方法。该方法调用时，会将组件样式加入 css Set 当中。\n                    </p>\n                    <p data-nodeid=\"25440\">\n                      最后我们用<code data-backticks=\"1\" data-nodeid=\"25644\"\n                        >[...css].join('')</code\n                      >就可以获取页面的所有样式字符串。\n                    </p>\n                    <p data-nodeid=\"25441\">\n                      强调一下，<a\n                        href=\"https://github.com/kriasoft/isomorphic-style-loader\"\n                        data-nodeid=\"25649\"\n                        >isomorphic-style-loader 的源码</a\n                      >目前已经更新，采用了最新的 ReactHooks API，我推荐给 React\n                      开发者阅读，相信你一定收获很多！\n                    </p>\n                    <h3 data-nodeid=\"25442\">总结</h3>\n                    <p data-nodeid=\"25443\">\n                      本小节前半部分我们“手把手”教你实现服务端渲染的同构应用，因为这些知识并不困难，社区上资料也很多。后半部分我们从更高的角度出发，剖析同构应用中那些关键的细节点和疑难问题的解决方案，这些经验源于真刀真枪的线上案例，即使你没有开发过同构应用，也能从中全方位地了解关键信息，一旦掌握了这些细节，同构应用的实现就会更稳、更可靠。\n                    </p>\n                    <p data-nodeid=\"25444\">本讲内容总结如下：</p>\n                    <p data-nodeid=\"29488\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/16/ED/CioPOWBHGf-ANBuWAAJkpsrE7fA808.png\"\n                        alt=\"同构渲染架构： 实现一个 SSR 应用.png\"\n                        data-nodeid=\"29491\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"25446\">\n                      同构应用其实远比理论复杂，绝对不是几个 APIs\n                      和几台服务器就能完成的，希望大家多思考、多动手，一定会更有体会。下一讲，我们进入\n                      CI/CD 流程，设计一个性能守卫系统，以此帮助你了解：Node.js\n                      除了同构直出、数据聚合以外，还能做一些重要的，且有趣的服务。\n                    </p>\n            "}