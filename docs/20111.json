{"title":"10 | Context：你必须掌握的多线程并发控制神器","context":"\n                    <p data-nodeid=\"18663\">\n                      在上一节课中我留了一个作业，也就是让你自己练习使用\n                      sync.Map，相信你已经做出来了。现在我为你讲解 sync.Map\n                      的方法。\n                    </p>\n\n                    <ol data-nodeid=\"17741\">\n                      <li data-nodeid=\"17742\">\n                        <p data-nodeid=\"17743\">\n                          <strong data-nodeid=\"17871\">Store</strong>：存储一对\n                          key-value 值。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17744\">\n                        <p data-nodeid=\"17745\">\n                          <strong data-nodeid=\"17876\">Load</strong>：根据 key\n                          获取对应的 value 值，并且可以判断 key 是否存在。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17746\">\n                        <p data-nodeid=\"17747\">\n                          <strong data-nodeid=\"17881\">LoadOrStore</strong>：如果\n                          key 对应的 value 存在，则返回该\n                          value；如果不存在，存储相应的 value。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17748\">\n                        <p data-nodeid=\"17749\">\n                          <strong data-nodeid=\"17886\">Delete</strong>：删除一个\n                          key-value 键值对。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17750\">\n                        <p data-nodeid=\"17751\">\n                          <strong data-nodeid=\"17891\">Range</strong>：循环迭代\n                          sync.Map，效果与 for range 一样。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"17752\">\n                      相信有了这些方法的介绍，你对 sync.Map\n                      会有更深入的理解。下面开始今天的课程：如何通过 Context\n                      更好地控制并发。\n                    </p>\n                    <h3 data-nodeid=\"19277\" class=\"\">协程如何退出</h3>\n\n                    <p data-nodeid=\"17754\">\n                      一个协程启动后，大部分情况需要等待里面的代码执行完毕，然后协程会自行退出。但是如果有一种情景，需要让协程提前退出怎么办呢？在下面的代码中，我做了一个监控狗用来监控程序：\n                    </p>\n                    <p data-nodeid=\"17755\">\n                      <em data-nodeid=\"17899\"\n                        ><strong data-nodeid=\"17898\">ch10/main.go</strong></em\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">var</span> wg sync.WaitGroup\n</div></li><li><div class=\"code-word\">   wg.Add(<span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">defer</span> wg.Done()\n</div></li><li><div class=\"code-word\">      watchDog(<span class=\"hljs-string\">\"【监控狗1】\"</span>)\n</div></li><li><div class=\"code-word\">   }()\n</div></li><li><div class=\"code-word\">   wg.Wait()\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">watchDog</span><span class=\"hljs-params\">(name <span class=\"hljs-keyword\">string</span>)</span></span>{\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//开启for select循环，一直后台监控</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">for</span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">select</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">default</span>:\n</div></li><li><div class=\"code-word\">         fmt.Println(name,<span class=\"hljs-string\">\"正在监控……\"</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      time.Sleep(<span class=\"hljs-number\">1</span>*time.Second)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"17757\">\n                      我通过 watchDog\n                      函数实现了一个监控狗，它会一直在后台运行，每隔一秒就会打印\"监控狗正在监控……\"的文字。\n                    </p>\n                    <p data-nodeid=\"17758\">\n                      如果需要让监控狗停止监控、退出程序，一个办法是定义一个全局变量，其他地方可以通过修改这个变量发出停止监控狗的通知。然后在协程中先检查这个变量，如果发现被通知关闭就停止监控，退出当前协程。\n                    </p>\n                    <p data-nodeid=\"17759\">\n                      但是这种方法需要通过加锁来保证多协程下并发的安全，基于这个思路，有个升级版的方案：用\n                      select+channel 做检测，如下面的代码所示：\n                    </p>\n                    <p data-nodeid=\"17760\">\n                      <em data-nodeid=\"17911\"\n                        ><strong data-nodeid=\"17910\">ch10/main.go</strong></em\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">var</span> wg sync.WaitGroup\n</div></li><li><div class=\"code-word\">   wg.Add(<span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">   stopCh := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">bool</span>) <span class=\"hljs-comment\">//用来停止监控狗</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">defer</span> wg.Done()\n</div></li><li><div class=\"code-word\">      watchDog(stopCh,<span class=\"hljs-string\">\"【监控狗1】\"</span>)\n</div></li><li><div class=\"code-word\">   }()\n</div></li><li><div class=\"code-word\">   time.Sleep(<span class=\"hljs-number\">5</span> * time.Second) <span class=\"hljs-comment\">//先让监控狗监控5秒</span>\n</div></li><li><div class=\"code-word\">   stopCh &lt;- <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">//发停止指令</span>\n</div></li><li><div class=\"code-word\">   wg.Wait()\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">watchDog</span><span class=\"hljs-params\">(stopCh <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">bool</span>,name <span class=\"hljs-keyword\">string</span>)</span></span>{\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//开启for select循环，一直后台监控</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">for</span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">select</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">case</span> &lt;-stopCh:\n</div></li><li><div class=\"code-word\">         fmt.Println(name,<span class=\"hljs-string\">\"停止指令已收到，马上停止\"</span>)\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">default</span>:\n</div></li><li><div class=\"code-word\">         fmt.Println(name,<span class=\"hljs-string\">\"正在监控……\"</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      time.Sleep(<span class=\"hljs-number\">1</span>*time.Second)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"17762\">\n                      这个示例是使用 select+channel 的方式改造的 watchDog\n                      函数，实现了通过 channel\n                      发送指令让监控狗停止，进而达到协程退出的目的。以上示例主要有两处修改，具体如下：\n                    </p>\n                    <ol data-nodeid=\"17763\">\n                      <li data-nodeid=\"17764\">\n                        <p data-nodeid=\"17765\">\n                          为 watchDog 函数增加 stopCh 参数，用于接收停止指令；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17766\">\n                        <p data-nodeid=\"17767\">\n                          在 main 函数中，声明用于停止的 stopCh，传递给 watchDog\n                          函数，然后通过 stopCh&lt;-true\n                          发送停止指令让协程退出。\n                        </p>\n                      </li>\n                    </ol>\n                    <h3 data-nodeid=\"19891\" class=\"\">初识 Context</h3>\n\n                    <p data-nodeid=\"17769\">\n                      以上示例是 select+channel\n                      比较经典的使用场景，这里也顺便复习了 select 的知识。\n                    </p>\n                    <p data-nodeid=\"17770\">\n                      通过 select+channel\n                      让协程退出的方式比较优雅，但是如果我们希望做到同时取消很多个协程呢？如果是定时取消协程又该怎么办？这时候\n                      select+channel 的局限性就凸现出来了，即使定义了多个\n                      channel 解决问题，代码逻辑也会非常复杂、难以维护。\n                    </p>\n                    <p data-nodeid=\"17771\">\n                      要解决这种复杂的协程问题，必须有一种可以跟踪协程的方案，只有跟踪到每个协程，才能更好地控制它们，这种方案就是\n                      Go 语言标准库为我们提供的 Context，也是这节课的主角。\n                    </p>\n                    <p data-nodeid=\"17772\">\n                      现在我通过 Context\n                      重写上面的示例，实现让监控狗停止的功能，如下所示：\n                    </p>\n                    <p data-nodeid=\"17773\">\n                      <em data-nodeid=\"17926\"\n                        ><strong data-nodeid=\"17925\">ch10/main.go</strong></em\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">var</span> wg sync.WaitGroup\n</div></li><li><div class=\"code-word\">   wg.Add(<span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">   ctx,stop:=context.WithCancel(context.Background())\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">defer</span> wg.Done()\n</div></li><li><div class=\"code-word\">      watchDog(ctx,<span class=\"hljs-string\">\"【监控狗1】\"</span>)\n</div></li><li><div class=\"code-word\">   }()\n</div></li><li><div class=\"code-word\">   time.Sleep(<span class=\"hljs-number\">5</span> * time.Second) <span class=\"hljs-comment\">//先让监控狗监控5秒</span>\n</div></li><li><div class=\"code-word\">   stop() <span class=\"hljs-comment\">//发停止指令</span>\n</div></li><li><div class=\"code-word\">   wg.Wait()\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">watchDog</span><span class=\"hljs-params\">(ctx context.Context,name <span class=\"hljs-keyword\">string</span>)</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//开启for select循环，一直后台监控</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">for</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">select</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">case</span> &lt;-ctx.Done():\n</div></li><li><div class=\"code-word\">         fmt.Println(name,<span class=\"hljs-string\">\"停止指令已收到，马上停止\"</span>)\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">default</span>:\n</div></li><li><div class=\"code-word\">         fmt.Println(name,<span class=\"hljs-string\">\"正在监控……\"</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      time.Sleep(<span class=\"hljs-number\">1</span> * time.Second)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"17775\">\n                      相比 select+channel 的方案，Context 方案主要有 4\n                      个改动点。\n                    </p>\n                    <ol data-nodeid=\"17776\">\n                      <li data-nodeid=\"17777\">\n                        <p data-nodeid=\"17778\">\n                          watchDog 的 stopCh 参数换成了 ctx，类型为\n                          context.Context。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17779\">\n                        <p data-nodeid=\"17780\">\n                          原来的 case &lt;-stopCh 改为 case\n                          &lt;-ctx.Done()，用于判断是否停止。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17781\">\n                        <p data-nodeid=\"17782\">\n                          使用 context.WithCancel(context.Background())\n                          函数生成一个可以取消的\n                          Context，用于发送停止指令。这里的 context.Background()\n                          用于生成一个空 Context，一般作为整个 Context\n                          树的根节点。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17783\">\n                        <p data-nodeid=\"17784\">\n                          原来的 stopCh &lt;- true 停止指令，改为\n                          context.WithCancel 函数返回的取消函数 stop()。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"17785\">\n                      可以看到，这和修改前的整体代码结构一样，只不过从 channel\n                      换成了 Context。以上示例只是 Context\n                      的一种使用场景，它的能力不止于此，现在我来介绍什么是\n                      Context。\n                    </p>\n                    <h2 data-nodeid=\"17786\">什么是 Context</h2>\n                    <p data-nodeid=\"17787\">\n                      一个任务会有很多个协程协作完成，一次 HTTP\n                      请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。\n                    </p>\n                    <p data-nodeid=\"17788\">\n                      如果因为某些原因导致任务终止了，HTTP\n                      请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的\n                      Bug。\n                    </p>\n                    <p data-nodeid=\"17789\">\n                      Context\n                      就是用来简化解决这些问题的，并且是并发安全的。Context\n                      是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被\n                      Context\n                      跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。\n                    </p>\n                    <p data-nodeid=\"17790\">\n                      Context\n                      接口只有四个方法，下面进行详细介绍，在开发中你会经常使用它们，你可以结合下面的代码来看。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">type</span> Context <span class=\"hljs-keyword\">interface</span> {\n</div></li><li><div class=\"code-word\">   Deadline() (deadline time.Time, ok <span class=\"hljs-keyword\">bool</span>)\n</div></li><li><div class=\"code-word\">   Done() &lt;-<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{}\n</div></li><li><div class=\"code-word\">   Err() error\n</div></li><li><div class=\"code-word\">   Value(key <span class=\"hljs-keyword\">interface</span>{}) <span class=\"hljs-keyword\">interface</span>{}\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <ol data-nodeid=\"17792\">\n                      <li data-nodeid=\"17793\">\n                        <p data-nodeid=\"17794\">\n                          Deadline 方法可以获取设置的截止时间，第一个返回值\n                          deadline 是截止时间，到了这个时间点，Context\n                          会自动发起取消请求，第二个返回值 ok\n                          代表是否设置了截止时间。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17795\">\n                        <p data-nodeid=\"17796\">\n                          Done 方法返回一个只读的 channel，类型为\n                          struct{}。在协程中，如果该方法返回的 chan\n                          可以读取，则意味着 Context 已经发起了取消信号。通过\n                          Done\n                          方法收到这个信号后，就可以做清理操作，然后退出协程，释放资源。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17797\">\n                        <p data-nodeid=\"17798\">\n                          Err 方法返回取消的错误原因，即因为什么原因 Context\n                          被取消。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17799\">\n                        <p data-nodeid=\"17800\">\n                          Value 方法获取该 Context\n                          上绑定的值，是一个键值对，所以要通过一个 key\n                          才可以获取对应的值。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"17801\">\n                      Context 接口的四个方法中最常用的就是 Done\n                      方法，它返回一个只读的 channel，用于接收取消信号。当\n                      Context 取消的时候，会关闭这个只读\n                      channel，也就等于发出了取消信号。\n                    </p>\n                    <h3 data-nodeid=\"20505\" class=\"\">Context 树</h3>\n\n                    <p data-nodeid=\"17804\">\n                      我们不需要自己实现 Context 接口，Go\n                      语言提供了函数可以帮助我们生成不同的\n                      Context，通过这些函数可以生成一颗 Context 树，这样 Context\n                      才可以关联起来，父 Context 发出取消信号的时候，子 Context\n                      也会发出，这样就可以控制不同层级的协程退出。\n                    </p>\n                    <p data-nodeid=\"17805\">\n                      从使用功能上分，有四种实现好的 Context。\n                    </p>\n                    <ol data-nodeid=\"17806\">\n                      <li data-nodeid=\"17807\">\n                        <p data-nodeid=\"17808\">\n                          <strong data-nodeid=\"17956\">空 Context</strong\n                          >：不可取消，没有截止时间，主要用于 Context\n                          树的根节点。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17809\">\n                        <p data-nodeid=\"17810\">\n                          <strong data-nodeid=\"17961\">可取消的 Context</strong\n                          >：用于发出取消信号，当取消的时候，它的子 Context\n                          也会取消。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17811\">\n                        <p data-nodeid=\"17812\">\n                          <strong data-nodeid=\"17966\"\n                            >可定时取消的 Context</strong\n                          >：多了一个定时的功能。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17813\">\n                        <p data-nodeid=\"17814\">\n                          <strong data-nodeid=\"17971\">值 Context</strong\n                          >：用于存储一个 key-value 键值对。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"21711\">\n                      从下图 Context 的衍生树可以看到，最顶部的是空\n                      Context，它作为整棵 Context 树的根节点，在 Go\n                      语言中，可以通过 context.Background() 获取一个根节点\n                      Context。\n                    </p>\n                    <p data-nodeid=\"21712\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/D3/CgqCHl_EyHOARbBqAAKzKmhclWo807.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"21716\"\n                      />\n                    </p>\n\n                    <div data-nodeid=\"22319\" class=\"\">\n                      <p style=\"text-align: center\">\n                        （四种 Context 的衍生树）\n                      </p>\n                    </div>\n\n                    <p data-nodeid=\"17819\">\n                      有了根节点 Context 后，这颗 Context\n                      树要怎么生成呢？需要使用 Go 语言提供的四个函数。\n                    </p>\n                    <ol data-nodeid=\"17820\">\n                      <li data-nodeid=\"17821\">\n                        <p data-nodeid=\"17822\">\n                          <strong data-nodeid=\"17985\"\n                            >WithCancel(parent Context)</strong\n                          >：生成一个可取消的 Context。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17823\">\n                        <p data-nodeid=\"17824\">\n                          <strong data-nodeid=\"17990\"\n                            >WithDeadline(parent Context, d time.Time)</strong\n                          >：生成一个可定时取消的 Context，参数 d\n                          为定时取消的具体时间。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17825\">\n                        <p data-nodeid=\"17826\">\n                          <strong data-nodeid=\"17995\"\n                            >WithTimeout(parent Context, timeout\n                            time.Duration)</strong\n                          >：生成一个可超时取消的 Context，参数 timeout\n                          用于设置多久后取消\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17827\">\n                        <p data-nodeid=\"17828\">\n                          <strong data-nodeid=\"18000\"\n                            >WithValue(parent Context, key, val\n                            interface{})</strong\n                          >：生成一个可携带 key-value 键值对的 Context。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"17829\">\n                      以上四个生成 Context 的函数中，前三个都属于可取消的\n                      Context，它们是一类函数，最后一个是值\n                      Context，用于存储一个 key-value 键值对。\n                    </p>\n                    <h3 data-nodeid=\"22920\" class=\"\">\n                      使用 Context 取消多个协程\n                    </h3>\n\n                    <p data-nodeid=\"17831\">\n                      取消多个协程也比较简单，把 Context\n                      作为参数传递给协程即可，还是以监控狗为例，如下所示：\n                    </p>\n                    <p data-nodeid=\"17832\">\n                      <em data-nodeid=\"18008\"\n                        ><strong data-nodeid=\"18007\">ch10/main.go</strong></em\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\">wg.Add(<span class=\"hljs-number\">3</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">defer</span> wg.Done()\n</div></li><li><div class=\"code-word\">   watchDog(ctx,<span class=\"hljs-string\">\"【监控狗2】\"</span>)\n</div></li><li><div class=\"code-word\">}()\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">defer</span> wg.Done()\n</div></li><li><div class=\"code-word\">   watchDog(ctx,<span class=\"hljs-string\">\"【监控狗3】\"</span>)\n</div></li><li><div class=\"code-word\">}()\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"17834\">\n                      示例中增加了两个监控狗，也就是增加了两个协程，这样一个\n                      Context 就同时控制了三个协程，一旦 Context\n                      发出取消信号，这三个协程都会取消退出。\n                    </p>\n                    <p data-nodeid=\"24704\">\n                      以上示例中的 Context 没有子 Context，如果一个 Context 有子\n                      Context，在该 Context\n                      取消时会发生什么呢？下面通过一幅图说明：\n                    </p>\n                    <p data-nodeid=\"24705\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/C7/Ciqc1F_EyIyAAO_TAADuPjzGt5U321.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"24710\"\n                      />\n                    </p>\n                    <div data-nodeid=\"24706\">\n                      <p style=\"text-align: center\">（Context 取消）</p>\n                    </div>\n\n                    <p data-nodeid=\"17839\">\n                      可以看到，当节点 Ctx2 取消时，它的子节点 Ctx4、Ctx5\n                      都会被取消，如果还有子节点的子节点，也会被取消。也就是说根节点为\n                      Ctx2 的所有节点都会被取消，其他节点如 Ctx1、Ctx3 和 Ctx6\n                      则不会。\n                    </p>\n                    <h3 data-nodeid=\"25301\" class=\"\">Context 传值</h3>\n\n                    <p data-nodeid=\"17841\">\n                      Context 不仅可以取消，还可以传值，通过这个能力，可以把\n                      Context 存储的值供其他协程使用。我通过下面的代码来说明：\n                    </p>\n                    <p data-nodeid=\"17842\">\n                      <em data-nodeid=\"18025\"\n                        ><strong data-nodeid=\"18024\">ch10/main.go</strong></em\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   wg.Add(<span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">//记得这里要改为4，原来是3，因为要多启动一个协程</span>\n</div></li><li><div class=\"code-word\">   \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//省略其他无关代码</span>\n</div></li><li><div class=\"code-word\">   valCtx:=context.WithValue(ctx,<span class=\"hljs-string\">\"userId\"</span>,<span class=\"hljs-number\">2</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">defer</span> wg.Done()\n</div></li><li><div class=\"code-word\">      getUser(valCtx)\n</div></li><li><div class=\"code-word\">   }()\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//省略其他无关代码</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(ctx context.Context)</span></span>{\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">for</span>  {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">select</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">case</span> &lt;-ctx.Done():\n</div></li><li><div class=\"code-word\">         fmt.Println(<span class=\"hljs-string\">\"【获取用户】\"</span>,<span class=\"hljs-string\">\"协程退出\"</span>)\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">default</span>:\n</div></li><li><div class=\"code-word\">         userId:=ctx.Value(<span class=\"hljs-string\">\"userId\"</span>)\n</div></li><li><div class=\"code-word\">         fmt.Println(<span class=\"hljs-string\">\"【获取用户】\"</span>,<span class=\"hljs-string\">\"用户ID为：\"</span>,userId)\n</div></li><li><div class=\"code-word\">         time.Sleep(<span class=\"hljs-number\">1</span> * time.Second)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"17844\">\n                      这个示例是和上面的示例放在一起运行的，所以我省略了上面实例的重复代码。其中，通过\n                      context.WithValue 函数存储一个 userId 为 2\n                      的键值对，就可以在 getUser 函数中通过 ctx.Value(\"userId\")\n                      方法把对应的值取出来，达到传值的目的。\n                    </p>\n                    <h3 data-nodeid=\"25893\" class=\"\">Context 使用原则</h3>\n\n                    <p data-nodeid=\"17846\">\n                      Context\n                      是一种非常好的工具，使用它可以很方便地控制取消多个协程。在\n                      Go 语言标准库中也使用了它们，比如 net/http 中使用 Context\n                      取消网络的请求。\n                    </p>\n                    <p data-nodeid=\"17847\">\n                      要更好地使用 Context，有一些使用原则需要尽可能地遵守。\n                    </p>\n                    <ol data-nodeid=\"17848\">\n                      <li data-nodeid=\"17849\">\n                        <p data-nodeid=\"17850\">\n                          Context 不要放在结构体中，要以参数的方式传递。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17851\">\n                        <p data-nodeid=\"17852\">\n                          Context\n                          作为函数的参数时，要放在第一位，也就是第一个参数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17853\">\n                        <p data-nodeid=\"17854\">\n                          要使用 context.Background 函数生成根节点的\n                          Context，也就是最顶层的 Context。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17855\">\n                        <p data-nodeid=\"17856\">\n                          Context\n                          传值要传递必须的值，而且要尽可能地少，不要什么都传。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"17857\">\n                        <p data-nodeid=\"17858\">\n                          Context 多协程安全，可以在多个协程中放心使用。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"17859\">\n                      以上原则是规范类的，Go\n                      语言的编译器并不会做这些检查，要靠自己遵守。\n                    </p>\n                    <h3 data-nodeid=\"26485\" class=\"\">总结</h3>\n\n                    <p data-nodeid=\"27659\">\n                      Context 通过 With 系列函数生成 Context 树，把相关的\n                      Context 关联起来，这样就可以统一进行控制。一声令下，关联的\n                      Context 都会发出取消信号，使用这些 Context\n                      的协程就可以收到取消信号，然后清理退出。你在定义函数的时候，如果想让外部给你的函数发取消信号，就可以为这个函数增加一个\n                      Context 参数，让外部的调用者可以通过 Context\n                      进行控制，比如下载一个文件超时退出的需求。\n                    </p>\n                    <p data-nodeid=\"27660\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/C8/Ciqc1F_EyKiAUdQMAAVK80mD2bY940.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"27664\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"17863\">\n                      这节课的最后留一个思考题给你：假如一个用户请求访问我们的网站，如何通过\n                      Context 实现日志跟踪？先自己想想，下节课我会揭晓思路。\n                    </p>\n                    <p data-nodeid=\"17864\">\n                      下节课将学习“并发模式：Go\n                      语言中即学即用的高效并发模式”，记得来听课！\n                    </p>\n            "}