{"title":"05 | 指标采集：白屏、卡顿、网络环境指标采集方法","context":"\n                    <p data-nodeid=\"34141\">\n                      上一讲我们介绍了首屏时间的指标采集，这一讲我们来聊聊前端其他的性能指标采集，比如白屏、卡顿和网络环境。\n                    </p>\n\n                    <p data-nodeid=\"33783\">\n                      你乘火车、地铁、飞机都走过安检吧？如果说首屏时间类似你过安检的时刻，那么，白屏时间就是你排队到安检点的时间，而卡顿，就是你排的队伍停止了，前面人的不动了。本来，大家都希望过安检的时间越快越好，结果，排队花时间，停滞不动更耗时间，这无疑会让人越来越没有耐心。\n                    </p>\n                    <p data-nodeid=\"33784\">\n                      浏览器的白屏和卡顿也是如此，它们直接影响用户的体验，影响用户对平台的信任。而网络环境呢，它的影响更大，同时也是性能优化的盲区，这一点我在之前的移动端\n                      M\n                      站性案例分析里面就中介绍过。所以，这一讲，我们就专门聊聊这三方面的指标采集。\n                    </p>\n                    <h3 data-nodeid=\"33785\">白屏指标采集</h3>\n                    <p data-nodeid=\"33786\">\n                      白屏时间是指从输入内容回车（包括刷新、跳转等方式）后，到页面开始出现第一个字符的时间。白屏时间的长短会影响用户对\n                      App 或站点的第一印象。\n                    </p>\n                    <p data-nodeid=\"33787\">\n                      白屏指标怎么采集呢？我们先来回顾一下前面讲过的浏览器的页面加载过程：\n                    </p>\n                    <p data-nodeid=\"33788\">\n                      客户端发起请求 -&gt; 下载 HTML 及 JS/CSS 资源 -&gt; 解析\n                      JS 执行 -&gt; JS 请求数据 -&gt; 客户端解析 DOM 并渲染\n                      -&gt; 下载渲染图片-&gt; 完成渲整体染。\n                    </p>\n                    <p data-nodeid=\"33789\">\n                      在这个过程中，客户端解析 DOM\n                      并渲染之前的时间，都算白屏时间。所以，白屏时间的采集思路如下：白屏时间\n                      = 页面开始展示时间点 -\n                      开始请求时间点。如果你是借助浏览器的 Performance API\n                      工具来采集，那么可以使用公式：白屏时间 FP = domLoading -\n                      navigationStart。\n                    </p>\n                    <p data-nodeid=\"33790\">\n                      这是浏览器页面加载过程，如果放在\n                      App场景下，就不太一样了，App下的页面加载过程：\n                    </p>\n                    <p data-nodeid=\"33791\">\n                      初始化 WebView -&gt; 客户端发起请求 -&gt; 下载 HTML 及\n                      JS/CSS 资源 -&gt; 解析 JS 执行 -&gt; JS 请求数据 -&gt;\n                      服务端处理并返回数据 -&gt; 客户端解析 DOM 并渲染 -&gt;\n                      下载渲染图片 -&gt; 完成整体渲染。\n                    </p>\n                    <p data-nodeid=\"33792\">\n                      App下的白屏时间，多了启动浏览器内核，也就是 Webview\n                      初始化的时间。这个时间必须通过手动采集的方式来获得，而且因为线上线下时间差别不大，线下采集即可。具体来说，在\n                      App 测试版本中，程序在 App 创建 WebView\n                      时打一个点，然后在开始建立网络连接打一个点，这两个点的时间差就是\n                      Webview 初始化的时间。\n                    </p>\n                    <h3 data-nodeid=\"33793\">卡顿指标采集</h3>\n                    <p data-nodeid=\"34379\" class=\"\">\n                      <strong data-nodeid=\"34384\"\n                        >所谓卡顿，简单来说就是页面出现卡住了的不流畅的情况。</strong\n                      >\n                      提到它的指标，你是不是会一下就想到 FPS（Frames Per\n                      Second，每秒显示帧数）？FPS\n                      多少算卡顿？网上有很多资料，大多提到 FPS 在 60\n                      以上，页面流畅，不卡顿。但事实上并非如此，比如我们看电影或者动画时，素虽然\n                      FPS 是 30 （低于60），但我们觉得很流畅，并不卡顿。\n                    </p>\n\n                    <p data-nodeid=\"33795\">\n                      FPS 低于 60 并不意味着卡顿，那 FPS 高于 60\n                      是否意味着一定不卡顿呢？比如前 60 帧渲染很快（10ms 渲染 1\n                      帧），后面的 3 帧渲染很慢（ 20ms 渲染 1 帧），这样平均起来\n                      FPS 为95，高于 60\n                      的标准。这种情况会不会卡顿呢？实际效果是卡顿的。因为卡顿与否的关键点在于单帧渲染耗时是否过长。\n                    </p>\n                    <p data-nodeid=\"33796\">\n                      但难点在于，在浏览器上，我们没办法拿到单帧渲染耗时的接口，所以这时候，只能拿\n                      FPS 来计算，只要 FPS\n                      保持稳定，且值比较低，就没问题。它的标准是多少呢？<strong\n                        data-nodeid=\"33850\"\n                        >连续 3 帧不低于 20 FPS，且保持恒定。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"33797\">\n                      以 H5 为例，H5 场景下获取 FPS 方案如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> fps_compatibility= function () {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; window.requestAnimationFrame ||\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; window.webkitRequestAnimationFrame ||\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; function (callback) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; window.setTimeout(callback, <span class=\"hljs-number\">1000</span> / <span class=\"hljs-number\">60</span>);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; );\n</div></li><li><div class=\"code-word\">}();\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> fps_config={\n</div></li><li><div class=\"code-word\">  lastTime:performance.now(),\n</div></li><li><div class=\"code-word\">  lastFameTime : performance.now(),\n</div></li><li><div class=\"code-word\">  frame:<span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> fps_loop = function() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> _first =  performance.now(),_diff = (_first&nbsp;- fps_config.lastFameTime);\n</div></li><li><div class=\"code-word\">    fps_config.lastFameTime = _first;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> fps = Math.round(<span class=\"hljs-number\">1000</span>/_diff);\n</div></li><li><div class=\"code-word\">    fps_config.frame++;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (_first&nbsp;&gt; <span class=\"hljs-number\">1000</span> + fps_config.lastTime) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> fps = Math.round( ( fps_config.frame * <span class=\"hljs-number\">1000</span> ) / ( _first&nbsp;- fps_config.lastTime ) );\n</div></li><li><div class=\"code-word\">        console.log(\\`time: ${<span class=\"hljs-keyword\">new</span> Date()} fps is：\\`, fps);\n</div></li><li><div class=\"code-word\">        fps_config.frame = <span class=\"hljs-number\">0</span>;    \n</div></li><li><div class=\"code-word\">        fps_config.lastTime = _first&nbsp;;    \n</div></li><li><div class=\"code-word\">    };           \n</div></li><li><div class=\"code-word\">    fps_compatibility(fps_loop);   \n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">fps_loop();\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">isBlocking</span><span class=\"hljs-params\">(fpsList, below=<span class=\"hljs-number\">20</span>, last=<span class=\"hljs-number\">3</span>)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> count = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; fpsList.length; i++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (fpsList[i] &amp;&amp; fpsList[i] &lt; below) {\n</div></li><li><div class=\"code-word\">      count++;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      count = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (count &gt;= last) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"33799\">\n                      利用 requestAnimationFrame 在一秒内执行 60\n                      次（在不卡顿的情况下）这一点，假设页面加载用时 X\n                      ms，这期间 requestAnimationFrame 执行了 N\n                      次，则帧率为1000* N/X，也就是FPS。\n                    </p>\n                    <p data-nodeid=\"33800\">\n                      由于用户客户端差异很大，我们要考虑兼容性，在这里我们定义\n                      fps_compatibility 表示兼容性方面的处理，在浏览器不支持\n                      requestAnimationFrame 时，利用 setTimeout 来模拟实现，在\n                      fps_loop 里面完成 FPS 的计算，最终通过遍历 fpsList\n                      来判断是否连续三次 fps 小于20。\n                    </p>\n                    <p data-nodeid=\"33801\">\n                      如果连续判断 3次 FPS 都小于20，就认为是卡顿。\n                    </p>\n                    <p data-nodeid=\"33802\">\n                      那么，在 App 侧，怎么采集卡顿指标呢？\n                    </p>\n                    <p data-nodeid=\"33803\">\n                      App 侧可以拿到单帧渲染时长，直接让 App\n                      取到单帧渲染时长，如果在 Android\n                      环境下，可以直接取到单帧渲染时长。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">calculateLag</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">long</span> frameTimeNanos)</span></span>{\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/*final long frameTimeNanos = mChoreographer.getFrameTimeNanos();*/</span>\n</div></li><li><div class=\"code-word\">mLastFrameTimeNanos = System.nanoTime();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (mLastFrameTimeNanos != <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">long</span> costTime= (frameTimeNanos - mLastFrameTimeNanos)/ <span class=\"hljs-number\">1000000.0F</span>;<span class=\"hljs-comment\">//计算成毫秒</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//严重卡顿，单帧超过250ms</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (costTime&gt;= bigJankTime) {\n</div></li><li><div class=\"code-word\">            bJank = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (costTime&gt;= criticalBlockTime) {<span class=\"hljs-comment\">//超过50ms</span>\n</div></li><li><div class=\"code-word\">                mCriticalBlockCount++;\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (bJank) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">//严重卡顿上报逻辑</span>\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (mCriticalBlockCount &gt;= cStuckThreshold) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">//卡顿上报逻辑，5次50ms</span>\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    mLastFrameTimeNanos = frameTimeNanos;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"33805\">\n                      通过 mChoreographer.getFrameTimeNanos 和 System.nanoTime\n                      计算出单帧渲染时长，如果单帧渲染时长超过\n                      250ms，则严重卡断，反之连续 5 次超过 50ms，判定为卡顿。\n                    </p>\n                    <p data-nodeid=\"33806\">\n                      如果是 iOS 场景，要复杂一些，需要借助 CFRunLoop\n                      来取到单帧渲染时长（CFRunLoop，它负责监听输入源，并调度处理）。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">runLoopObserverCallBack</span><span class=\"hljs-params\">(CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class=\"hljs-keyword\">void</span> *info)</span>\n</span></div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; MyClass *object = (__bridge MyClass*)info;&nbsp;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 记录状态值</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; object-&gt;activity = activity; &nbsp; &nbsp;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 发送信号</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; dispatch_semaphore_signal(semaphore);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">- (<span class=\"hljs-keyword\">void</span>)registerObserver\n</div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; CFRunLoopObserverContext context = {<span class=\"hljs-number\">0</span>,(__bridge <span class=\"hljs-keyword\">void</span>*)self,NULL,NULL};\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,<span class=\"hljs-number\">0</span>,&amp;runLoopObserverCallBack,&amp;context);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 创建信号</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; semaphore = dispatch_semaphore_create(<span class=\"hljs-number\">0</span>);&nbsp; &nbsp;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 在子线程监控时长</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; dispatch_async(dispatch_get_global_queue(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>), ^{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (YES)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">long</span> st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class=\"hljs-number\">50</span>*NSEC_PER_MSEC));\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (st != <span class=\"hljs-number\">0</span>)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (++timeoutCount &lt; <span class=\"hljs-number\">5</span>)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">continue</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 检测到卡顿，进行卡顿上报</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeoutCount = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; });\n</div></li><li><div class=\"code-word\">}&nbsp;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"34623\">\n                      通过 CFRunLoopObserverContext 将休眠、唤醒的状态通知\n                      Observer，然后通过 dispatch_async\n                      在子线程时监控节点之间的时间，来计算主线程的时长。\n                    </p>\n                    <p data-nodeid=\"34624\">\n                      这里监控主线程是否卡顿这块儿，借鉴了导航 App\n                      对交通堵塞问题的判断逻辑。\n                    </p>\n\n                    <p data-nodeid=\"33809\">\n                      导航 App\n                      无法判断某个地点是否出了问题，如车坏在当路，正在施工，或者发生事故剐蹭了这些，但可以借助\n                      GPS\n                      和定位仪，拿到你两个节点之间的行驶速度，就可以推断出这个地点是否拥堵。这里的监控思路也正是如此，使用状态kCFRunLoopBeforeSources&nbsp;和&nbsp;kCFRunLoopAfterWaiting&nbsp;两个节点之间的运行时间，和某个阈值（250ms）做比较，根据比较结果判定主线程是否出现卡顿。\n                    </p>\n                    <p data-nodeid=\"33810\">\n                      为什么会出现 App 白屏时间过长或卡顿问题呢？一般 WebView\n                      初始化慢、DNS\n                      解析慢、视图树过于复杂和主线程被阻塞等都会导致问题出现，但很多情况下白屏时间和卡顿都和网络环境有关。为了保证页面顺畅，我们需要做一些服务降级处理，比如对电商网站来说，高清图可以用文本代替，仅展示购买按钮和价格等核心内容。而要实现这个功能，就必须先做好网络环境采集。\n                    </p>\n                    <h3 data-nodeid=\"33811\">网络环境采集</h3>\n                    <p data-nodeid=\"33812\">\n                      为什么不能直接拿到网络环境数据呢？如果在 App 内，\n                      我们可以通过 App 提供的接口获取到网络情况，但在端外（App\n                      外部环境，比如微信里面的页面，或者PC站、手机浏览器下的页面）我们就没法直接拿到当前网络情况了。这时怎么办呢？\n                    </p>\n                    <p data-nodeid=\"33813\">\n                      一个做法是拿到两张不同尺寸图片的加载时间，通过计算结果来判定当前网络环境。\n                    </p>\n                    <p data-nodeid=\"33814\">\n                      具体来说，我们在每次页面加载时，通过客户端向服务端发送图片请求，比如，请求一张\n                      1<em data-nodeid=\"33880\">1 像素的图片和一张 3</em>3\n                      像素的图片，然后在图片请求之初打一个时间点，在图片 onLoad\n                      完成后打一个时间点，两个时间点之差，就是图片的加载时间。\n                    </p>\n                    <p data-nodeid=\"33815\">\n                      接着，我们用文件体积除以加载时间，就能得出两张图片的加载速度，然后把两张图片的加载速度求平均值，这个结果就可以当作网络速度了。\n                    </p>\n                    <p data-nodeid=\"33816\">\n                      因为每个单页面启动时，都会做一次网速采集，得到一个网络速度，我们可以把这些网络速度做概率分布，就能得出当前网络情况是\n                      2G （750-1400ms）、3G\n                      （230-750ms）、4G或者WiFi（0-230ms）。\n                    </p>\n                    <p data-nodeid=\"33817\">\n                      下面这张图是 2016 年我在做移动端 M\n                      站性能优化项目时，做的图片测速结果分布。横坐标是速度，纵坐标是网速在分布中的分位值，最左侧是\n                      wifi网络，中间是 3G 网络，最右侧是 2G 网络。\n                    </p>\n                    <p data-nodeid=\"35104\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/2E/CioPOWBB3_uAM53JAABIZ7HhMWA539.png\"\n                        alt=\"image (4).png\"\n                        data-nodeid=\"35112\"\n                      />\n                    </p>\n                    <div data-nodeid=\"35105\">\n                      <p style=\"text-align: center\">图片测速结果分布</p>\n                    </div>\n\n                    <p data-nodeid=\"33820\">\n                      根据这张图，你会发现自己的用户都停留在什么网段。比如，我在\n                      2016 年发现，58 同城的用户测速分布，50% 的用户停留在 2G\n                      水平。知道了这点，我们后续针对的优化手段就会更多侧重 2G\n                      下的网络优化方案了。\n                    </p>\n                    <h3 data-nodeid=\"33821\">小结</h3>\n                    <p data-nodeid=\"35357\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/31/Cgp9HWBB4AOAUUkHAAFD-5Vtth4452.png\"\n                        alt=\"溪风的思维导图05.png\"\n                        data-nodeid=\"35360\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"33823\">\n                      前面我们详细讲了白屏时间采集、卡顿指标采集和网络环境采集，有了这个采集，我们就能很容易定位用户体验层的很多问题，比如加载感受、交互感受和弱网下的服务降级处理，等等。\n                    </p>\n                    <p data-nodeid=\"33824\">\n                      在白屏部分，里面提到的更偏加载阶段的白屏，实际工作中我们会遇到不少广义上的白屏，比如后端接口异常导致的白屏，数据加载中产生的白屏，甚至还有图片与视频加载过程或等待过程中的白屏。\n                    </p>\n                    <p data-nodeid=\"33825\">\n                      那么，现在就给你留一个问题：这些广义的白屏问题怎么采集监控呢？\n                    </p>\n                    <p data-nodeid=\"33826\">\n                      欢迎在评论区和我沟通。下一讲，我们进入上报\n                      SDK及策略设计部分。\n                    </p>\n                    <p data-nodeid=\"33827\">\n                      源码地址：<a\n                        href=\"https://github.com/lagoueduCol/WebPerformanceOptimization-xifeng/tree/master/chapter5\"\n                        data-nodeid=\"33900\"\n                        >https://github.com/lagoueduCol/WebPerformanceOptimization-xifeng/tree/master/chapter5</a\n                      >\n                    </p>\n            "}