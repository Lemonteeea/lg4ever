{"title":"16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？","context":"\n                    <p data-nodeid=\"8221\" class=\"\">\n                      面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。\n                    </p>\n                    <p data-nodeid=\"8222\">\n                      但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成<strong\n                        data-nodeid=\"8692\"\n                        >从题目出发，去考虑如何破解一个题</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8223\">本讲将会重点学习：</p>\n                    <ul data-nodeid=\"8224\">\n                      <li data-nodeid=\"8225\">\n                        <p data-nodeid=\"8226\">如何挖掘题目的特点</p>\n                      </li>\n                      <li data-nodeid=\"8227\">\n                        <p data-nodeid=\"8228\">\n                          如何利用特点匹配到数据结构和算法知识点\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8229\">\n                      完成这两步动作，需要你熟练地掌握前面“一解多题”模块介绍的数据结构与算法知识点。养兵千日，用在一时，是时候派上用场了。\n                    </p>\n                    <h3 data-nodeid=\"8230\">最大矩形</h3>\n                    <p data-nodeid=\"8231\">\n                      【<strong data-nodeid=\"8707\">题目</strong\n                      >】给定一个数组，里面有<em data-nodeid=\"8708\">n</em\n                      >个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为\n                      1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。\n                    </p>\n                    <p data-nodeid=\"8232\">输入：[2,1,5,6,2,3]</p>\n                    <p data-nodeid=\"8233\">输出：10</p>\n                    <p data-nodeid=\"8234\">\n                      解释：柱状图的示例，其中每个柱子的宽度为\n                      1，给定的高度为<code data-backticks=\"1\" data-nodeid=\"8715\"\n                        >[2,1,5,6,2,3]</code\n                      >。\n                    </p>\n                    <p data-nodeid=\"8235\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__gKAfuSVAAJVGh0lZ7k739.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"8719\"\n                      />\n                    </p>\n                    <div data-nodeid=\"8236\">\n                      <p style=\"text-align: center\">输入 最大矩形</p>\n                    </div>\n                    <h3 data-nodeid=\"8237\">暴力算法</h3>\n                    <p data-nodeid=\"8238\">\n                      当拿到题目之后，一种最简单、最暴力的算法立马会出现在我们脑海里面。那就是：\n                    </p>\n                    <ul data-nodeid=\"8239\">\n                      <li data-nodeid=\"8240\">\n                        <p data-nodeid=\"8241\">\n                          分别选定两个柱子，然后计算这两个柱子为边界，构成的最大矩形的面积；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8242\">\n                        <p data-nodeid=\"8243\">\n                          取出所有的矩形面积中的最大面积。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8244\">\n                      那么根据这个思路，可以得到代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minHeight</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> h = Integer.MAX_VALUE;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = l; k &lt;= r; k++) {\n</div></li><li><div class=\"code-word\">            h = Math.min(h, A[k]);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> h;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = i; j &lt; N; j++) {\n</div></li><li><div class=\"code-word\">                ans = Math.max(ans,\n</div></li><li><div class=\"code-word\">                   minHeight(A, i, j) * (j - i + <span class=\"hljs-number\">1</span>));\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8246\">\n                      但是，这个代码的时间复杂度实在太高，达到\n                      O(N<sup>3</sup>)，在面试中并不能给你加分。那么有没有什么更好的办法呢？\n                    </p>\n                    <h3 data-nodeid=\"8247\">特点 1：区间</h3>\n                    <p data-nodeid=\"8248\">\n                      可以发现，求解的时候，我们非常依赖一个区域里面的最小值：就是\n                      minHeight() 函数。\n                    </p>\n                    <p data-nodeid=\"8249\">\n                      那么，有没有什么办法，可以<strong data-nodeid=\"8737\"\n                        >快速地</strong\n                      >获取：一个数组区间里面的最小值呢？此时问题破解的关键聚焦到下面这个问题上。\n                    </p>\n                    <blockquote data-nodeid=\"8250\">\n                      <p data-nodeid=\"8251\">\n                        给定一个数组：如何快速地查询一个区间里面的最小值？\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8252\">\n                      如果我们能在 O(1)\n                      的时间得到一个区间里面的最小值，那么就可以把暴力算法的时间复杂度优化到\n                      O(N<sup>2</sup>)。\n                    </p>\n                    <p data-nodeid=\"8253\">\n                      因此，此时我们需要快速匹配到一个算法和数据结构来满足这样的特点。想到这里，你的脑海里面应该浮现如下的场景：\n                    </p>\n                    <p data-nodeid=\"8254\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__hyAKNRHAADJi9Tt1Jc075.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"8747\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8255\">\n                      那么，我们需要什么样的数据结构/算法呢？\n                    </p>\n                    <ul data-nodeid=\"8256\">\n                      <li data-nodeid=\"8257\">\n                        <p data-nodeid=\"8258\">\n                          如果是在面试中，你发现脑海里面空空如也，一点也想不到有什么办法可以处理这个区间查询问题，就需要立马转换思路，尝试寻找别的破题办法。因为很有可能，这里踩了你的知识盲区，要在短时间发现一种算法解决这个问题的可能性还是挺小的。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8259\">\n                        <p data-nodeid=\"8260\">\n                          如果是在准备面试阶段，那么你应该立马搜索一下有什么样的数据结构可以满足这样的要求。大概率情况下，这种基础问题已经有很多现成的数据结构来支撑了，所以不需要你再去“挠破脑袋”当发明家了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8261\">\n                      就现在而言，我们肯定是处在一个准备面试的阶段。所以，下面我会带你走一遍“搜索”的步骤。\n                    </p>\n                    <p data-nodeid=\"8262\">\n                      求解区间的最小值/最大值问题，一般有 2 类算法与数据结构：\n                    </p>\n                    <ul data-nodeid=\"8263\">\n                      <li data-nodeid=\"8264\">\n                        <p data-nodeid=\"8265\">ST（Sparse Table）算法</p>\n                      </li>\n                      <li data-nodeid=\"8266\">\n                        <p data-nodeid=\"8267\">线段树（Segment Tree）</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8268\">\n                      接下来，我们分别介绍一下这两种算法（说不定哪天你在面试中碰到这个关键问题，就轻而易举答出来了）。\n                    </p>\n                    <h4 data-nodeid=\"8269\">ST 算法</h4>\n                    <p data-nodeid=\"8270\">\n                      在面试时，我们总是先看到问题，然后希望匹配到一个算法，能够刚好满足我们期望的时间复杂度。那么\n                      ST 算法可以满足我们的要求吗？\n                    </p>\n                    <p data-nodeid=\"10275\" class=\"\">\n                      先来看一下\n                      <strong data-nodeid=\"10281\">ST 算法的特点</strong>：\n                    </p>\n\n                    <ul data-nodeid=\"8272\">\n                      <li data-nodeid=\"8273\">\n                        <p data-nodeid=\"8274\">\n                          ST 算法需要预处理，并且在预处理阶段，时间复杂度为\n                          O(NlgN)，空间复杂度为 O(NlgN)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8275\">\n                        <p data-nodeid=\"8276\">\n                          ST 算法预处理结束之后，在查询阶段，时间复杂度为 O(1)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8277\">\n                      如果我们用上 ST 算法，那么时间复杂度可以从\n                      O(N<sup>3</sup>) 变为 O(N<sup>2</sup> + NlgN) =\n                      O(N<sup>2</sup>)。这样一来复杂度就下降了一个数量级，还是非常值得一试的。\n                    </p>\n                    <p data-nodeid=\"14390\" class=\"\">\n                      下面我们讲一下 ST 算法\n                      <strong data-nodeid=\"14396\">2 个核心思想</strong>。\n                    </p>\n\n                    <h5 data-nodeid=\"8279\">1. 一分为二</h5>\n                    <p data-nodeid=\"30859\" class=\"\">\n                      任何一个区间都可以分为<strong data-nodeid=\"30869\"\n                        >两个可能重合的区间</strong\n                      >。比如给定的区间为 [start, end]，那么：\n                    </p>\n\n                    <ul data-nodeid=\"8281\">\n                      <li data-nodeid=\"8282\">\n                        <p data-nodeid=\"8283\">\n                          这个区间可以分为 [start, end1], [start2,\n                          end]，即第一个区间必须以 start\n                          为起点，第二个区间必须以 end 为终点；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8284\">\n                        <p data-nodeid=\"8285\">\n                          两个区间<strong data-nodeid=\"8813\">可以重合</strong>；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8286\">\n                        <p data-nodeid=\"8287\">\n                          两个区间的长度<strong data-nodeid=\"8823\">必须</strong\n                          >是 2<sup>p</sup> 长度（p 是非负整数）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8288\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__iqAUkNNAABpKQ8hpO8389.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"8826\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8289\">\n                      【<strong data-nodeid=\"8852\">例 1</strong>】比如有一个区间\n                      [10, 17]，长度为 8，那么可以拆分为 [10, 13], [14,17]\n                      长度为 2<sup>2</sup> 的两个区间。下图是拆分之后<strong\n                        data-nodeid=\"8853\"\n                        >不存在重合</strong\n                      >的情况：\n                    </p>\n                    <p data-nodeid=\"8290\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__jGAJ-BPAAB07QZeoiU141.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"8856\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8291\">\n                      【<strong data-nodeid=\"8882\">例 2</strong>】比如有一个区间\n                      [10, 18]，长度为 9。那么可以拆分为 [10, 17] 和 [11, 18]\n                      长度为 2<sup>3</sup> 的两个区间。下图是拆分之后存在<strong\n                        data-nodeid=\"8883\"\n                        >部分重合</strong\n                      >的情况：\n                    </p>\n                    <p data-nodeid=\"8292\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__jiAOH3WAABwKY4dT9s988.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"8886\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8293\">\n                      【<strong data-nodeid=\"8912\">例 3</strong>】比如有一个区间\n                      [10, 10]，长度为 1，那么可以拆分为 [10, 10] 和 [10,\n                      10]，这两个区间完全重合，且长度为 2<sup>0</sup>\n                      的两个区间。这是拆分之后<strong data-nodeid=\"8913\"\n                        >完全重合</strong\n                      >的情况。\n                    </p>\n                    <p data-nodeid=\"8294\">\n                      基于此，我们可以得到<strong data-nodeid=\"8919\"\n                        >结论 1</strong\n                      >。\n                    </p>\n                    <blockquote data-nodeid=\"8295\">\n                      <p data-nodeid=\"8296\">\n                        给定一个数组，这个数组里面的任意一个有效区间<strong\n                          data-nodeid=\"8929\"\n                          >总是</strong\n                        >可以表达为：可能重叠的两个 2<sup>p</sup> 长度区间。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8297\">\n                      那么，假设我们已经得到所有 2<sup>p</sup>\n                      长度的区间的信息。那么“区间 [start, end]\n                      上的最小值：可以先取出两个长度为 2<sup>p</sup>\n                      的子区间的最小值，再从中选择最小的即可。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">区间[start, end]上的最小值 = min(区间[l, l+2&lt;sup&gt;p&lt;/sup&gt;)上的最小值\n</div></li><li><div class=\"code-word\">                         区间[r-2&lt;sup&gt;p&lt;/sup&gt;+1, r]上的最小值)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8299\">\n                      基于结论 1，我们可以得到<strong data-nodeid=\"8948\"\n                        >结论 2</strong\n                      >。\n                    </p>\n                    <blockquote data-nodeid=\"8300\">\n                      <p data-nodeid=\"8301\">计算顺序：</p>\n                      <ol data-nodeid=\"8302\">\n                        <li data-nodeid=\"8303\">\n                          <p data-nodeid=\"8304\">\n                            先计算出长度为 2<sup>0</sup> 的所有区间的最小值；\n                          </p>\n                        </li>\n                        <li data-nodeid=\"8305\">\n                          <p data-nodeid=\"8306\">\n                            再计算长度为 2<sup>1</sup> 的所有区间的最小值；\n                          </p>\n                        </li>\n                        <li data-nodeid=\"8307\">\n                          <p data-nodeid=\"8308\">\n                            然后计算长度为 2<sup>2</sup> 的所有区间的最小值；\n                          </p>\n                        </li>\n                        <li data-nodeid=\"8309\">\n                          <p data-nodeid=\"8310\">\n                            直到长度为 2<sup>x</sup> 的区间的最小值。\n                          </p>\n                        </li>\n                      </ol>\n                      <blockquote data-nodeid=\"8311\">\n                        <p data-nodeid=\"8312\">\n                          其中 2<sup>x</sup> 刚好大于等于给定的数组长度。\n                        </p>\n                      </blockquote>\n                    </blockquote>\n                    <h5 data-nodeid=\"8313\">2. 指数表示法</h5>\n                    <p data-nodeid=\"8314\">\n                      当拆分完成之后，原本一个区间的表示是 [start,\n                      end]，分为两个长度（len）一样的区间。更进一步，这两个区间可以表示为\n                      &lt;start1, len&gt;, &lt;start2, len&gt;。\n                    </p>\n                    <p data-nodeid=\"34976\" class=\"\">\n                      例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10,\n                      len=8&gt;, &lt;start2=11, len=8&gt;。\n                    </p>\n\n                    <p data-nodeid=\"8316\">\n                      例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10,\n                      len=4&gt;, &lt;start2=14,len=4&gt;。\n                    </p>\n                    <p data-nodeid=\"8317\">\n                      重新表示之后，区间 &lt;start, len&gt; 中，由于长度信息 len\n                      总是 2<sup>p</sup>，因此我们可以只记录<strong\n                        data-nodeid=\"9016\"\n                        >指数 p</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8318\">\n                      例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10,\n                      p=3&gt;, &lt;start2=11, p=3&gt;。\n                    </p>\n                    <p data-nodeid=\"8319\">\n                      例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10,\n                      p=2&gt;, &lt;start2=14,p=2&gt;。\n                    </p>\n                    <p data-nodeid=\"8320\">\n                      如果我们将区间采用指数 p 表示之后，就只需要使用空间\n                      st[N][log2(N)+1]，也就是空间复杂度为 O(NlgN)。\n                    </p>\n                    <p data-nodeid=\"8321\">\n                      那么基于以上两个核心思想，我们可以写出 ST\n                      算法的代码了。这里可以分为两步，一步是预处理，另一步是查询。\n                    </p>\n                    <p data-nodeid=\"8322\">\n                      <strong data-nodeid=\"9062\"\n                        >预处理构建 st[][] 数组代码如下</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buildST</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span>[][] st)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 第一步：</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//    - 处理长度为1的区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//      即[i, i + 1)</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 区间的表示：</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">    st[i][<span class=\"hljs-number\">0</span>] = A[i];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 递推：</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; j) &lt;= N; j++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里要处理的区间[i, i + (1&lt;&lt;j)]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// last = i + (1&lt;&lt;j)</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 根据左闭右开原则，last是可以取到n的。这点要注意。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; (i + (<span class=\"hljs-number\">1</span> &lt;&lt; j)) &lt;= N; i++) {\n</div></li><li><div class=\"code-word\">      st[i][j] = Math.min(st[i][j - <span class=\"hljs-number\">1</span>], \n</div></li><li><div class=\"code-word\">                          st[i + (<span class=\"hljs-number\">1</span> &lt;&lt; (j - <span class=\"hljs-number\">1</span>))][j - <span class=\"hljs-number\">1</span>]);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8324\">\n                      <strong data-nodeid=\"9066\">查询阶段的代码如下：</strong>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minHeight</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] st, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r)</span>\n</span></div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里我们将区间[l, r]分为两个区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// [l, l+log2(len)] =&gt; [l, len=log2(len)]</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> len = r - l + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> j = log2(len);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> Math.min(st[l][j], st[r - (<span class=\"hljs-number\">1</span> &lt;&lt; j) + <span class=\"hljs-number\">1</span>][j]);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8326\">\n                      需要注意的是，在查询阶段，如果一个区间的长度本来就是\n                      2<sup>p</sup>，那么就可以拆分成两个完全重合的区间。\n                    </p>\n                    <p data-nodeid=\"8327\">\n                      得到 ST\n                      算法的代码之后，我们就可以开始解决这道题目了。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">log2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> N)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">int</span>)(Math.log(N) / Math.log(<span class=\"hljs-number\">2</span>));\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[][] createST(<span class=\"hljs-keyword\">int</span> N) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> powerOf2 = log2(N);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span>[][] st = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N][powerOf2 + <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">            st[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[powerOf2+<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> st;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buildST</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span>[][] st)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 第一步：</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//    - 处理长度为1的区间</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//      即[i, i + 1)</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 区间的表示：</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">            st[i][<span class=\"hljs-number\">0</span>] = A[i];\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 递推：</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; j) &lt;= N; j++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 这里要处理的区间[i, i + (1&lt;&lt;j)]</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// last = i + (1&lt;&lt;j)</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 根据左闭右开原则，last是可以取到n的。这点要注意。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; (i + (<span class=\"hljs-number\">1</span> &lt;&lt; j)) &lt;= N; i++) {\n</div></li><li><div class=\"code-word\">                st[i][j] = Math.min(st[i][j - <span class=\"hljs-number\">1</span>],\n</div></li><li><div class=\"code-word\">                                    st[i + (<span class=\"hljs-number\">1</span> &lt;&lt; (j - <span class=\"hljs-number\">1</span>))][j - <span class=\"hljs-number\">1</span>]);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minHeight</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] st, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> r)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 这里我们将区间[l, r]分为两个区间</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// [l, l+log2(len)] =&gt; [l, len=log2(len)]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> len = r - l + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> j = log2(len);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> Math.min(st[l][j], st[r - (<span class=\"hljs-number\">1</span> &lt;&lt; j) + <span class=\"hljs-number\">1</span>][j]);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span>[][] st = createST(N);\n</div></li><li><div class=\"code-word\">        buildST(A, st);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = i; j &lt; N; j++) {\n</div></li><li><div class=\"code-word\">                ans = Math.max(ans, \n</div></li><li><div class=\"code-word\">                  minHeight(st, i, j) * (j - i + <span class=\"hljs-number\">1</span>));\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8329\">\n                      <p data-nodeid=\"8330\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9076\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9080\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9084\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8331\">\n                      不过，这种算法的时间复杂度仍然是\n                      O(N<sup>2</sup>)。这里请你思考一下，还有没有更好的办法呢？\n                    </p>\n                    <h4 data-nodeid=\"8332\">线段树</h4>\n                    <p data-nodeid=\"8333\">\n                      不妨尝试一下线段树。在处理区间信息的时候，线段树是一个非常有用的数据结构。下面我们来了解一下它的特点（可以先不管它长什么样）：\n                    </p>\n                    <ul data-nodeid=\"8334\">\n                      <li data-nodeid=\"8335\">\n                        <p data-nodeid=\"8336\">\n                          构建线段树，时间复杂度为 O(NlgN)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8337\">\n                        <p data-nodeid=\"8338\">\n                          查询阶段，时间复杂度为 O(lgN)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8339\">\n                        <p data-nodeid=\"8340\">空间复杂度为 O(4N)。</p>\n                      </li>\n                    </ul>\n                    <h5 data-nodeid=\"8341\">1. 线段树的思想</h5>\n                    <p data-nodeid=\"8342\">\n                      <strong data-nodeid=\"9102\">线段树的思想</strong\n                      >是用一棵平衡二叉树来表示一个数组区间上的信息：\n                    </p>\n                    <ul data-nodeid=\"8343\">\n                      <li data-nodeid=\"8344\">\n                        <p data-nodeid=\"8345\">根结点记录整个数组的信息；</p>\n                      </li>\n                      <li data-nodeid=\"8346\">\n                        <p data-nodeid=\"8347\">左子树记录数组左半部分的信息；</p>\n                      </li>\n                      <li data-nodeid=\"8348\">\n                        <p data-nodeid=\"8349\">右子树记录数组右半部分的信息。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8350\">\n                      <strong data-nodeid=\"9113\">【例 1】</strong>\n                      假设给定的数组为 A[] = {1, 2, 3,\n                      4}，需要记录的信息为区间里面的最小值。那么线段树构成如下：\n                    </p>\n                    <p data-nodeid=\"8351\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__nKANd_2AACTipb_MQs065.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"9116\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8352\">\n                      那么查询的时候，就需要从根结点开始往下查。假设我们要基于这棵树查询区间\n                      [1, 3] 的最小值信息。\n                    </p>\n                    <ul data-nodeid=\"8353\">\n                      <li data-nodeid=\"8354\">\n                        <p data-nodeid=\"8355\">\n                          <strong data-nodeid=\"9125\">第 1 步</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8356\">\n                      首先，我们访问到根结点，可以发现 [0, 3] 区间与 [1, 3]\n                      区间处于相交的情况，因此根结点的信息，对于我们要查询的结果是没有帮助的，所以需要将\n                      [0, 3] 区间拆分为 [0, 1] 和 [2,3] 区间。\n                    </p>\n                    <p data-nodeid=\"8357\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__nyAG63XAACqx6B5uVU521.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"9149\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8358\">\n                      这里我们得到<strong data-nodeid=\"9155\">原则 1</strong>：\n                    </p>\n                    <blockquote data-nodeid=\"8359\">\n                      <p data-nodeid=\"8360\">\n                        区间相交的时候，需要拆分树结点区间，然后分别看左右子树。\n                      </p>\n                    </blockquote>\n                    <ul data-nodeid=\"8361\">\n                      <li data-nodeid=\"8362\">\n                        <p data-nodeid=\"8363\">\n                          <strong data-nodeid=\"9160\">第 2 步</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8364\">\n                      接下来，我们先看左子树，可以发现区间 [0, 1] 与区间 [1,3]\n                      仍然是处于相交的状态。\n                    </p>\n                    <p data-nodeid=\"8365\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__oKAY7Z0AACvIcu60-4225.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"9172\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8366\">\n                      因此还需要再次利用原则\n                      1，分别观察它们的左右子树，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8367\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__oiAT5PpAACwh7u3Cyk265.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"9176\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8368\">\n                      我们再接着遍历左右子树的时候，不难发现有以下两种情况:\n                    </p>\n                    <p data-nodeid=\"8369\">\n                      Case 1. [0,0] 与区间 [1,3] 不相交，无视 [0,0]\n                      区间上的信息；\n                    </p>\n                    <p data-nodeid=\"8370\">\n                      Case 2. [1,1] 被区间 [1,3]\n                      包含，需要保留这个区间上的信息。\n                    </p>\n                    <p data-nodeid=\"39092\" class=\"\">\n                      由此，我们就得到<strong data-nodeid=\"39102\"\n                        >原则 2</strong\n                      >\n                      和<strong data-nodeid=\"39103\">原则 3</strong>。\n                    </p>\n\n                    <blockquote data-nodeid=\"8372\">\n                      <p data-nodeid=\"8373\">\n                        <strong data-nodeid=\"9218\"\n                          >原则\n                          2：树结点区间与查询区间不相交时，无视树结点的信息。</strong\n                        ><br />\n                        <strong data-nodeid=\"9219\"\n                          >原则\n                          3：树结点区间包含查询区间内部时，保留树结点的信息。</strong\n                        >\n                      </p>\n                    </blockquote>\n                    <ul data-nodeid=\"8374\">\n                      <li data-nodeid=\"8375\">\n                        <p data-nodeid=\"8376\">\n                          <strong data-nodeid=\"9223\">第 3 步</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8377\">\n                      最后，看一下右边子树，我们发现 [2, 3]\n                      树结点区间包含查询区间，因此，需要使用原则 3。\n                    </p>\n                    <p data-nodeid=\"8378\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__piAASjRAACwfmU76M4079.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"9231\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"8379\">\n                      <li data-nodeid=\"8380\">\n                        <p data-nodeid=\"8381\">\n                          <strong data-nodeid=\"9235\">第 4 步</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8382\">\n                      那么最终，我们只选取两个树结点的信息，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8383\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__p-AaesyAADICuyRzZ8398.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"9239\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8384\">\n                      那么我们可以得到区间 [1,3] 上的最小值：\n                    </p>\n                    <blockquote data-nodeid=\"8385\">\n                      <p data-nodeid=\"8386\">\n                        min([1,1] 区间上的最小值，[2,3] 区间上的最小值) = 2\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8387\">\n                      经过上面的查询，这里我总结了 3 个原则。\n                    </p>\n                    <blockquote data-nodeid=\"8388\">\n                      <p data-nodeid=\"8389\">\n                        原则\n                        1：区间相交的时候，需要拆分树结点区间，然后分别看左右子树。<br />\n                        原则\n                        2：树结点区间与查询区间不相交时，无视树结点的信息。<br />\n                        原则 3：树结点区间包含查询区间内部时，保留树结点的信息。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8390\">\n                      3\n                      个原则分别代表区间之间的三种关系。你不需要去死记这个关系，只需要注意以下两点：\n                    </p>\n                    <ul data-nodeid=\"8391\">\n                      <li data-nodeid=\"8392\">\n                        <p data-nodeid=\"8393\">树中的结点的区间会不停地拆分；</p>\n                      </li>\n                      <li data-nodeid=\"8394\">\n                        <p data-nodeid=\"8395\">查询区间一直固定不变。</p>\n                      </li>\n                    </ul>\n                    <h5 data-nodeid=\"8396\">2. 查询的本质</h5>\n                    <p data-nodeid=\"8397\">\n                      似乎让你单纯地记录这个查询流程太枯燥了，因此我们还需要更深入地去想一下线段树查询的本质，理解之后再去记忆就比较简单了。你可以这样想，给定一个二叉树，然后又给了一个查询区间，那么可以把查询的过程表示成\n                      2 步。\n                    </p>\n                    <ul data-nodeid=\"8398\">\n                      <li data-nodeid=\"8399\">\n                        <p data-nodeid=\"8400\">第 1 步：裁剪</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8401\">\n                      我们修剪一下这棵二叉树，让所有的叶子结点都在查询区间范围内。\n                    </p>\n                    <p data-nodeid=\"8402\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__q2APtnlAADfBsWCUTs679.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"9271\"\n                      />\n                    </p>\n                    <p data-nodeid=\"84386\">\n                      需要注意的是，当区间 [2,3]\n                      已经包含查询区间的时候，其子树上的结点就没有必要保留了。最终，我们将灰色的树结点都去掉，只保留：<br />\n                      1） “包含”查询区间的叶结点；<br />\n                      2）根结点到这些叶结点的<strong data-nodeid=\"84403\"\n                        >路径</strong\n                      >。\n                    </p>\n                    <ul data-nodeid=\"84387\">\n                      <li data-nodeid=\"84388\">\n                        <p data-nodeid=\"84389\">第 2 步：收集叶子结点的信息</p>\n                      </li>\n                    </ul>\n\n                    <p data-nodeid=\"8411\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__rWAFHv2AACwSnQB1C4869.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"9286\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8412\">\n                      当裁剪完成之后，只需要再查看存留的二叉树的叶结点信息就可以了。\n                    </p>\n                    <p data-nodeid=\"8413\">\n                      不过我们这里并不真正地去裁剪这棵二叉树，而是在遍历的时候，只提取出相应的信息（区间上的最小值）即可。\n                    </p>\n                    <p data-nodeid=\"8414\">\n                      下面是一道关于二叉树的裁剪的练习题，希望你可以尝试解决一下。\n                    </p>\n                    <p data-nodeid=\"86457\" class=\"\">\n                      <strong data-nodeid=\"86466\">练习题 1</strong>：\n                      给你二叉搜索树的根结点 root ，同时给定最小边界 low\n                      和最大边界 high。通过修剪二叉搜索树，使所有结点的值在\n                      [low, high]\n                      中。修剪树不应该改变保留在树中的元素的相对结构（如果没有被移除，原有的父代子代关系都应当保留）。可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根结点。注意，根结点可能会根据给定的边界发生改变。\n                    </p>\n\n                    <p data-nodeid=\"8416\">\n                      输入如下所示的二叉搜索树，并且 low = 1，high = 3。\n                    </p>\n                    <p data-nodeid=\"8417\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__r6AYsviAACOtqFSsXc299.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"9302\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8418\">输出：</p>\n                    <p data-nodeid=\"8419\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__sWAaVRCAABqvED48GE222.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"9306\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"8420\">\n                      <p data-nodeid=\"8421\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9310\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9314\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9318\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8422\">\n                      完成练习题之后，你可以想一下，线段树查询与练习题 1\n                      的裁剪有什么异同点？可以把你的思考写在留言区，我们一起讨论。\n                    </p>\n                    <h5 data-nodeid=\"8423\">3. 线段树的更新</h5>\n                    <p data-nodeid=\"8424\">\n                      虽然这道题没有用到<strong data-nodeid=\"9328\"\n                        >线段树的更新</strong\n                      >，但是面试的时候你可能会用到，所以我们还是要讲一下，\n                    </p>\n                    <p data-nodeid=\"8425\">\n                      当我们要更新某个区间上的值时，需要将线段树路径上所有的点的区间信息都更新掉（更新的时候，采用后续遍历即可），如下图所示：\n                    </p>\n                    <p data-nodeid=\"8426\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__tGALBeoAADYdvwyPEo939.png\"\n                        alt=\"Drawing 15.png\"\n                        data-nodeid=\"9332\"\n                      />\n                    </p>\n                    <h5 data-nodeid=\"8427\">4. 线段树的存储</h5>\n                    <p data-nodeid=\"8428\">\n                      可能现在你准备开始用包含左右指针的二叉树写线段树了，不过还有更高效的方式——用数组表示一棵二叉树。\n                    </p>\n                    <p data-nodeid=\"8429\">\n                      你可以回忆一下，“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"9342\"\n                        >03 | 优先级队列：堆与优先级队列，筛选最优元素</a\n                      >”学习堆的时候，我们已经用过一个数组来表示二叉树了，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8430\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__t2AaDg8AADItUzBiIo402.png\"\n                        alt=\"Drawing 16.png\"\n                        data-nodeid=\"9346\"\n                      />\n                    </p>\n                    <p data-nodeid=\"94677\" class=\"\">\n                      这里也可以用数组来表示线段树，主要是因为：\n                    </p>\n\n                    <ul data-nodeid=\"8432\">\n                      <li data-nodeid=\"8433\">\n                        <p data-nodeid=\"8434\">数组具有更好的内存连续性；</p>\n                      </li>\n                      <li data-nodeid=\"8435\">\n                        <p data-nodeid=\"8436\">内存连续性对 CPU 缓存更友好；</p>\n                      </li>\n                      <li data-nodeid=\"8437\">\n                        <p data-nodeid=\"8438\">\n                          对 CPU 缓存更友好的数据结构能够运行得更快。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8439\">\n                      但是，通常我们学习的二叉树表示，会不停地 new TreeNode()\n                      导致内存特别碎片化，因此对 CPU\n                      缓存并不友好，导致运行得变慢。\n                    </p>\n                    <p data-nodeid=\"8440\">\n                      当给定一个数组的时候，我们需要利用这个树创建一个线段树。根据线段树的定义：\n                    </p>\n                    <ul data-nodeid=\"8441\">\n                      <li data-nodeid=\"8442\">\n                        <p data-nodeid=\"8443\">根结点记录整个数组的信息；</p>\n                      </li>\n                      <li data-nodeid=\"8444\">\n                        <p data-nodeid=\"8445\">左子树记录数组左半部分的信息；</p>\n                      </li>\n                      <li data-nodeid=\"8446\">\n                        <p data-nodeid=\"8447\">右子树记录数组右半部分的信息。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8448\">\n                      这里我们可以肯定的是，根结点的信息，实际上需要依赖左子树的信息，以及右子树的信息才能够生成的。所以，这个二叉树的创建肯定是一个后序遍历。\n                    </p>\n                    <p data-nodeid=\"8449\">\n                      然后再根据数组表示二叉树的方法，有以下 3 种：\n                    </p>\n                    <ul data-nodeid=\"8450\">\n                      <li data-nodeid=\"8451\">\n                        <p data-nodeid=\"8452\">i 结点的父结点 par = (i-1)/2；</p>\n                      </li>\n                      <li data-nodeid=\"8453\">\n                        <p data-nodeid=\"8454\">i 结点的左子结点 2 * i + 1；</p>\n                      </li>\n                      <li data-nodeid=\"8455\">\n                        <p data-nodeid=\"8456\">i 结点的右子结点 2 * i + 2。</p>\n                      </li>\n                    </ul>\n                    <h5 data-nodeid=\"8457\">5. 线段树的模板代码</h5>\n                    <p data-nodeid=\"8458\">\n                      此时，我们可以写出线段树的模板代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 表示线段树的数组treeArray[]</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 数组里面的值表示区间里面的最小值</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] treeArray = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">leftNodePos</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> rootPos)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (rootPos &lt;&lt; <span class=\"hljs-number\">1</span>) + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">rightNodePos</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> rootPos)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (rootPos &lt;&lt; <span class=\"hljs-number\">1</span>) + <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// treeArray[rootPos] 将会记录数组[start, end]</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 这个区间上的信息。在本题中，信息为区间上的最小值</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buildTree</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> rootPos, <span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 范围为空</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (start &gt; end)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果区间：只有一个数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (start == end) {\n</div></li><li><div class=\"code-word\">        treeArray[rootPos] = A[start];\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 否则需要将区间分为两半</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mid = start + ((end - start) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        buildTree(leftNodePos(rootPos), A, start, mid);\n</div></li><li><div class=\"code-word\">        buildTree(rightNodePos(rootPos), A, mid + <span class=\"hljs-number\">1</span>, end);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 构建成功之后，需要利用左子树的信息和右子树的信息来</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 来更新 [start, end] rootNode 的信息</span>\n</div></li><li><div class=\"code-word\">        treeArray[rootPos] =\n</div></li><li><div class=\"code-word\">            Math.min(treeArray[leftNodePos(rootPos)], \n</div></li><li><div class=\"code-word\">                     treeArray[rightNodePos(rootPos)]);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * 查询区间[queryStart, queryEnd]这个区间上的最小值信息\n</div></li><li><div class=\"code-word\"> *\n</div></li><li><div class=\"code-word\"> * treeArray[rootPos]表示区间 [start, end]上的最小值。\n</div></li><li><div class=\"code-word\"> * 可以把前面的三个参数看成\n</div></li><li><div class=\"code-word\"> * class TreeNode {\n</div></li><li><div class=\"code-word\"> *      int val;        &lt;-- arg: treeArray[rootPos];\n</div></li><li><div class=\"code-word\"> *      int rangeStart; &lt;-- arg: start\n</div></li><li><div class=\"code-word\"> *      int rangeEnd:   &lt;-- arg: end\n</div></li><li><div class=\"code-word\"> *      TreeNode left;  &lt;-- leftNodePos(rootPos);\n</div></li><li><div class=\"code-word\"> *      TreeNode right: &lt;-- rightNodePos(rootPos);\n</div></li><li><div class=\"code-word\"> * }\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">queryTree</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> rootPos, <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end,\n</span></span></div></li><li><div class=\"code-word\">                      <span class=\"hljs-keyword\">int</span> queryStart, <span class=\"hljs-keyword\">int</span> queryEnd) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 无效区间，返回最大值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (start &gt; end || queryStart &gt; queryEnd) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> Integer.MAX_VALUE;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 原则1： 包含于查询区间内部</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (queryStart &lt;= start &amp;&amp; end &lt;= queryEnd) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> treeArray[rootPos];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 原则2：不相交时，放弃区间信息，这里我们返回最大值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (end &lt; queryStart || queryEnd &lt; start) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> Integer.MAX_VALUE;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 原则3：当相交的时候，需要将[start, end]进行拆分</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 由于我们建树的时候，都是平分，所以这里将区间也进行平分</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mid = start + ((end - start) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> Math.min(queryTree(leftNodePos(rootPos),\n</div></li><li><div class=\"code-word\">                               start, mid, queryStart, queryEnd),\n</div></li><li><div class=\"code-word\">                    queryTree(rightNodePos(rootPos),\n</div></li><li><div class=\"code-word\">                               mid + <span class=\"hljs-number\">1</span>, end, queryStart, queryEnd));\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 当我们要更新数组中A[inx] = value的时候</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 线段树中存储的区间的信息，也是需要更新的</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">updateTree</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> rootPos, <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end,\n</span></span></div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">int</span> idx, <span class=\"hljs-keyword\">int</span> value) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果树中的结点不在我们的更新路径上</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (start &gt; end || idx &lt; start || idx &gt; end) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果已经找到了叶子结点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (start == idx &amp;&amp; idx == end) {\n</div></li><li><div class=\"code-word\">        treeArray[rootPos] = value;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里后序遍历</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果是非叶子结点，那么</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 先更新左右子结点，再更新根结点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mid = start + ((end - start) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 更新左子树</span>\n</div></li><li><div class=\"code-word\">    updateTree(leftNodePos(rootPos), start, mid, idx, value);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 更新右子树</span>\n</div></li><li><div class=\"code-word\">    updateTree(rightNodePos(rootPos), mid + <span class=\"hljs-number\">1</span>, end, idx, value);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 更新根结点</span>\n</div></li><li><div class=\"code-word\">    treeArray[rootPos] =\n</div></li><li><div class=\"code-word\">        Math.min(treeArray[leftNodePos(rootPos)],\n</div></li><li><div class=\"code-word\">                 treeArray[rightNodePos(rootPos)]);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8460\">\n                      <p data-nodeid=\"8461\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9372\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9376\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9380\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8462\">\n                      那么我们通过使用线段树，就写出求解的代码了，如下所示（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ... 并查集的模板代码....</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] heights)</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = heights == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : heights.length;\n</div></li><li><div class=\"code-word\">        treeArray = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N &lt;&lt; <span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">        buildTree(<span class=\"hljs-number\">0</span>, heights, <span class=\"hljs-number\">0</span>, N - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = i; j &lt; N; j++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// rootPos = 0表示根结点</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// [0, N-1]表示根结点代表：[0, N-1]这个区间上的最小值信息</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> minHeight = queryTree(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, N - <span class=\"hljs-number\">1</span>, i, j);\n</div></li><li><div class=\"code-word\">                ans = Math.max(ans, minHeight * (j - i + <span class=\"hljs-number\">1</span>));\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8464\">\n                      <p data-nodeid=\"8465\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9385\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9389\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9393\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8466\">\n                      接下来，我们分析一下时间复杂度，一共会有 N x N\n                      个区间需要查询，每次查询的时间复杂度为\n                      O(lgN)，所以时间复杂度为 O(N<sup>2</sup>\n                      lgN)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"8467\">\n                      到这里，我们利用一些区间信息查找常用的手段进行了优化：\n                    </p>\n                    <ul data-nodeid=\"8468\">\n                      <li data-nodeid=\"8469\">\n                        <p data-nodeid=\"8470\">\n                          使用 ST 算法将时间复杂度优化到 O(N<sup>2</sup>)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8471\">\n                        <p data-nodeid=\"8472\">\n                          使用线段树将时间复杂度优化到O(N<sup>2</sup> lgN)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8473\">\n                      可是，这两种算法都还是会超时，接下来应该怎么办呢？\n                    </p>\n                    <p data-nodeid=\"8474\">\n                      其实，真正面试的时候，你应该注意，一开始找到的题目特点是基于区间查询的方式，实际上就把优化的上限限定死了。一共有\n                      N x N 个区间要查，无论查多快，时间复杂度都不会比 O(N x N)\n                      更好。\n                    </p>\n                    <p data-nodeid=\"8475\">\n                      这就意味着，一开始，我们破题的大方向就是错的。当然，在这里我是发扬了要把一个题的特点深挖到底的精神，在练习的时候可以这么操作。如果是在面试中，还没有走到使用\n                      ST 算法，线段树，就应该尝试寻找题目的其他特点了。\n                    </p>\n                    <h3 data-nodeid=\"8476\">特点 2：选与不选</h3>\n                    <p data-nodeid=\"8477\">\n                      首先，我们假设问题是有一个最优解的，而这个<strong\n                        data-nodeid=\"9423\"\n                        >最优解</strong\n                      >肯定是<strong data-nodeid=\"9424\"\n                        >原始数组的一个连续子数组</strong\n                      >。那么，对于数组中的元素而言，就存在 2 种可能：\n                    </p>\n                    <ul data-nodeid=\"8478\">\n                      <li data-nodeid=\"8479\">\n                        <p data-nodeid=\"8480\">被最优解选中</p>\n                      </li>\n                      <li data-nodeid=\"8481\">\n                        <p data-nodeid=\"8482\">没有被最优解选中</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8483\">\n                      但是，如果我们去讨论每个元素的选/不选，时间复杂度就会瞬间爆炸到\n                      O(2<sup>N</sup>)。但是你先别着急放弃这个特点，我们决心把这个特点死磕到底。\n                    </p>\n                    <p data-nodeid=\"8484\">\n                      接着看题目，由于最大矩形的制约因素是被选中<strong\n                        data-nodeid=\"9441\"\n                        >区域的最小值</strong\n                      >制约的。那么当给定一个区域 [start, end]\n                      的时候，对于这个区间里面的最小值而言，只有两种可能。\n                    </p>\n                    <p data-nodeid=\"8485\">\n                      第一种可能：被最优解选中，此时解为 area = minHeight * (end\n                      - start + 1)。\n                    </p>\n                    <p data-nodeid=\"8486\">\n                      第二种可能：没有被最优解选中，那么可以利用最小值，将区域切分为两半：\n                    </p>\n                    <ul data-nodeid=\"98783\">\n                      <li data-nodeid=\"98784\">\n                        <p data-nodeid=\"98785\" class=\"\">\n                          计算左边区域的最大矩形的面积；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"98786\">\n                        <p data-nodeid=\"98787\">\n                          计算右边区域的最大矩形的面积。\n                        </p>\n                      </li>\n                    </ul>\n\n                    <p data-nodeid=\"8492\">然后再取这两种可能的最大矩形面积。</p>\n                    <p data-nodeid=\"8493\">\n                      我们发现，利用区间里面的最小值（选/不选），可以将区间切分为更小的区间。\n                    </p>\n                    <p data-nodeid=\"8494\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__vmAdDMGAAX2VnfI0w8074.png\"\n                        alt=\"Drawing 17.png\"\n                        data-nodeid=\"9452\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8495\">此时，我们就可以使用分治算法了。</p>\n                    <h4 data-nodeid=\"8496\">分治算法 1</h4>\n                    <p data-nodeid=\"8497\">\n                      根据前面的思路，我们可以写出分治的代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里得到一个区域里面的最大矩形面积</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这个区间域为[b, e)</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意e是取不到的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getRangeMaxArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] heights, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果为空区间</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果区间中只有一个元素</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (b + <span class=\"hljs-number\">1</span> == e) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> heights[b];\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果有多个元素。那么找到范围里面的最小值</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果有多个最小值，那么我们就找离中心最近的那个，尽量把区域进行等分</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> mid = b + ((e-b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> minIndex = b;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = b + <span class=\"hljs-number\">1</span>; i &lt; e; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (heights[i] &lt; heights[minIndex]) {\n</div></li><li><div class=\"code-word\">                minIndex = i;\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (heights[i] == heights[minIndex]) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 多个最小值，那么谁离mid更近，我们用谁</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {\n</div></li><li><div class=\"code-word\">                    minIndex = i;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 在使用 最小值 情况下的面积</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> useMinIndexArea = heights[minIndex] * (e - b);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 不用 minIndex 那么就会把区间分为两部分</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> leftMaxArea = getRangeMaxArea(heights, b, minIndex);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> rightMaxArea = getRangeMaxArea(heights, minIndex + <span class=\"hljs-number\">1</span>, e);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> Math.max(useMinIndexArea,\n</div></li><li><div class=\"code-word\">                         Math.max(leftMaxArea, rightMaxArea));\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] heights)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = heights == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : heights.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> getRangeMaxArea(heights, <span class=\"hljs-number\">0</span>, N);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8499\">\n                      <p data-nodeid=\"8500\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9459\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9463\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9467\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8501\">\n                      <strong data-nodeid=\"9476\">复杂度分析</strong\n                      >：正常情况下，时间复杂度为\n                      O(NlgN)，最差情况下，比如数组是一个已排序的数组，并且里面元素都不相同，那么时间复杂度会变为\n                      O(N<sup>2</sup>)，空间复杂度为 O(lgN)。\n                    </p>\n                    <p data-nodeid=\"8502\">\n                      【<strong data-nodeid=\"9488\">小结</strong\n                      >】这里你可以回想一下我们在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6697&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"9486\"\n                        >08 |\n                        排序：如何利用合并与快排的小技巧，解决算法难题？</a\n                      >”学习的排序技巧，原来我们学习快速排序的时候，会用“三路切分”将区间分为三部分。而在这里，我们是用最小值将区间切分成两半。\n                    </p>\n                    <p data-nodeid=\"8503\">\n                      那么有没有办法可以进一步优化呢？我们可以看到，分治的核心代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> mid = b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> minIndex = b;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = b + <span class=\"hljs-number\">1</span>; i &lt; e; i++) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (heights[i] &lt; heights[minIndex]) {\n</div></li><li><div class=\"code-word\">    minIndex = i;\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (heights[i] == heights[minIndex]) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 多个最小值，那么谁离mid更近，我们用谁</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {\n</div></li><li><div class=\"code-word\">      minIndex = i;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8505\">\n                      这段代码本质就是在搜索一个区间里面的最小值。如果你还有印象，寻找一个区间的信息，我们可以得到如下信息：\n                    </p>\n                    <ul data-nodeid=\"8506\">\n                      <li data-nodeid=\"8507\">\n                        <p data-nodeid=\"8508\">\n                          ST 算法预处理时间复杂度 O(NlgN)，查询区间最小值\n                          O(1)，空间复杂度 O(NlgN)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8509\">\n                        <p data-nodeid=\"8510\">\n                          线段树建树 O(NlgN)，查询区间最小值 O(lgN)，空间复杂度\n                          O(N)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8511\">\n                      下面我再给你留两个练习题，请你分别用这两个算法再优化一下分治算法。如果有什么疑问，可以写在留言区，我会逐一为你解答。\n                    </p>\n                    <p data-nodeid=\"8512\">\n                      <strong data-nodeid=\"9498\">练习题 2</strong>：请使用 ST\n                      算法优化分治算法。并且分析优化之后的时间/空间复杂度。\n                    </p>\n                    <blockquote data-nodeid=\"8513\">\n                      <p data-nodeid=\"8514\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9502\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9506\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9510\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8515\">\n                      <strong data-nodeid=\"9515\">练习题 3</strong\n                      >：请使用线段树算法优化我们的分治算法，并且分析优化之后时间/空间复杂度。\n                    </p>\n                    <blockquote data-nodeid=\"8516\">\n                      <p data-nodeid=\"8517\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9519\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9523\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9527\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"8518\">分治算法 2</h4>\n                    <p data-nodeid=\"8519\">\n                      在前面的分治算法中，我们在切分数组的时候，采用了一个区域里面的最小值进行切分。在最差情况下（数组元素不同且有序），会得到\n                      O(N<sup>2</sup>) 时间复杂度。\n                    </p>\n                    <p data-nodeid=\"8520\">\n                      不知道你有没有想起我们切分数组的算法。\n                    </p>\n                    <ul data-nodeid=\"8521\">\n                      <li data-nodeid=\"8522\">\n                        <p data-nodeid=\"8523\">\n                          合并排序：切分的时候，直接从数组的中间开始切分。时间复杂度最差也为\n                          O(NlgN)。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8524\">\n                        <p data-nodeid=\"8525\">\n                          快速排序：切分的时候，采用数组中的随机值进行切分。时间复杂度最差也为O(N<sup>2</sup>)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8526\">\n                      于是，我们可以得到一个<strong data-nodeid=\"9545\"\n                        >结论。</strong\n                      >\n                    </p>\n                    <blockquote data-nodeid=\"8527\">\n                      <p data-nodeid=\"8528\">\n                        我们在切分数组的时候：如果采用值进行切分，那么最差情况下的时间复杂度会掉到\n                        O(N<sup>2</sup>)；如果采用中间的下标进行切分，那么时间复杂度为\n                        O(NlgN)。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8529\">\n                      就这道题而言，如果我们想把分治算法变成\n                      O(NlgN)，应该怎么办？相信你已经想到了方向，那就是切分的时候，采用下标进行切分。\n                    </p>\n                    <p data-nodeid=\"8530\">\n                      到这里，我们已经可以写出伪代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMaxRangeArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] heights, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果只有一个元素</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (b + <span class=\"hljs-number\">1</span> == e) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> heights[b];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 用数组中间的那个元素将数组分为两半</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mid = b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> leftMaxArea = getMaxRangeArea(heights, b, mid);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> rightMaxArea = getMaxRangeArea(heights, mid + <span class=\"hljs-number\">1</span>, e);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果一定要包含heights[mid]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 求出containsMidIndexArea; &lt;-- 那么这里怎么求?</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> Math.max(containsMidIndexArea,\n</div></li><li><div class=\"code-word\">                    Math.max(leftMaxArea, rightMaxArea));\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8532\">\n                      接下来，我们看一下问题的核心部分，当包含 heights[mid]\n                      的时候，应该如何计算？共有两种情况。\n                    </p>\n                    <ul data-nodeid=\"8533\">\n                      <li data-nodeid=\"8534\">\n                        <p data-nodeid=\"8535\">\n                          Case 1：其他元素都比 heights[mid] 大，heights[mid]\n                          成了短板。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8536\">\n                        <p data-nodeid=\"8537\">\n                          Case 2：存在比 heights[mid] 小的元素，heights[mid]\n                          只是参与一下。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8538\">\n                      关于这两种情况的处理， 核心代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> minHeight = heights[mid];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> containsMidIndexArea = minHeight;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> left = m - <span class=\"hljs-number\">1</span>, right = m + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> (left &gt;= b || right &lt; e) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (right &gt;= e || left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {\n</div></li><li><div class=\"code-word\">        minHeight = min(minHeight, heights[left]);\n</div></li><li><div class=\"code-word\">        left--;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        minHeight = min(minHeight, heights[right]);\n</div></li><li><div class=\"code-word\">        right++;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> tmp = minHeight * (right - left - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    containsMidIndexArea = max(containsMidIndexArea, tmp);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8540\">\n                      那么，到此为止，我们就可以写出完全是 O(NlgN) 的代码了。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMaxRangeArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] heights, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果只有一个元素</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (b + <span class=\"hljs-number\">1</span> == e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> heights[b];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 用数组中间的那个元素将数组分为两半</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mid = b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> leftMaxArea = getMaxRangeArea(heights, b, mid);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> rightMaxArea = getMaxRangeArea(heights, mid + <span class=\"hljs-number\">1</span>, e);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果一定要包含heights[mid]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 那么就有两种情况。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> minHeight = heights[mid];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> containsMidIndexArea = minHeight;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> left = mid - <span class=\"hljs-number\">1</span>, right = mid + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (left &gt;= b || right &lt; e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (right &gt;= e || \n</div></li><li><div class=\"code-word\">          left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {\n</div></li><li><div class=\"code-word\">        minHeight = Math.min(minHeight, heights[left]);\n</div></li><li><div class=\"code-word\">        left--;\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        minHeight = Math.min(minHeight, heights[right]);\n</div></li><li><div class=\"code-word\">        right++;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> tmp = minHeight * (right - left - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">      containsMidIndexArea = Math.max(containsMidIndexArea, tmp);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> Math.max(containsMidIndexArea,\n</div></li><li><div class=\"code-word\">                    Math.max(leftMaxArea, rightMaxArea));\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] heights)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = heights == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : heights.length;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> getMaxRangeArea(heights, <span class=\"hljs-number\">0</span>, N);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8542\">\n                      <p data-nodeid=\"8543\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9581\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9585\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9589\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8544\">\n                      <strong data-nodeid=\"9594\">复杂度分析</strong>：时间复杂度\n                      O(NlgN)，空间复杂度 O(1)（不算栈空间）。\n                    </p>\n                    <p data-nodeid=\"8545\">\n                      【<strong data-nodeid=\"9600\">小结</strong\n                      >】在写这个算法的时候，我们需要注意两个地方。\n                    </p>\n                    <p data-nodeid=\"8546\">\n                      <strong data-nodeid=\"9613\">其一</strong>：在处理\n                      heights[mid] 的时候，将<strong data-nodeid=\"9614\"\n                        >包含</strong\n                      >关系分为以下 2 种：\n                    </p>\n                    <ul data-nodeid=\"8547\">\n                      <li data-nodeid=\"8548\">\n                        <p data-nodeid=\"8549\">\n                          包含 heights[mid]，并且找到的区域内的元素都比\n                          heights[mid] 大；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8550\">\n                        <p data-nodeid=\"8551\">\n                          不包含 heights[mid]，这种情况需要递归处理 [b, mid) 和\n                          [mid + 1, e)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8552\">\n                      容易出错的地方在于，包含 heights[mid]\n                      的时候，实际上有两种情况的（前面我们提到的Case 1 和 Case\n                      2）。这里只处理了 Case 1，但是没有处理 Case 2。\n                    </p>\n                    <p data-nodeid=\"8553\">\n                      <strong data-nodeid=\"9646\">其二</strong\n                      >：采用这种分治算法，包含 heights[mid]\n                      的时候，采用了双指针的做法，left 和 right\n                      分别向两边推进。但是你需要格外注意，推进的时候，哪边大，则移动哪边的指针。\n                    </p>\n                    <p data-nodeid=\"8554\">\n                      你能想想为什么吗？请你完成下面的练习题\n                      4，期待看到你理解与思考。\n                    </p>\n                    <p data-nodeid=\"8555\">\n                      <strong data-nodeid=\"9658\">练习题 4</strong\n                      >：这里的分治算法在往左右两边推进的时候，为什么哪边大就往哪边移动呢？你能再想一下，这与“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"9656\"\n                        >11 | 贪心：这种思想，没有模板，如何才能掌握它？</a\n                      >”介绍的贪心算法的例 1 有什么异同吗？\n                    </p>\n                    <h3 data-nodeid=\"8556\">特点 3：左右两边较小的数</h3>\n                    <p data-nodeid=\"8557\">\n                      构成一个矩形的面积的时候，有宽和高。无论是特点 1，还是特点\n                      2，它们都有一个共同点：先固定矩形的宽，再去选择高。\n                    </p>\n                    <p data-nodeid=\"8558\">\n                      有没有可能反过来呢？我们先去固定高度，再去决定宽度。当我们选择数组中的元素\n                      heights[i]\n                      作为矩形的高度时。寻找宽度需要满足以下两个条件：\n                    </p>\n                    <ul data-nodeid=\"8559\">\n                      <li data-nodeid=\"8560\">\n                        <p data-nodeid=\"8561\">i 元素必须要在这个范围内；</p>\n                      </li>\n                      <li data-nodeid=\"8562\">\n                        <p data-nodeid=\"8563\">\n                          这个范围内的元素都必须要大于等于 heights[i]。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8564\">\n                      那么我们就可以称 heights[i] 决定了这个最大范围的面积。\n                    </p>\n                    <h4 data-nodeid=\"8565\">小于我的位置</h4>\n                    <p data-nodeid=\"8566\">\n                      那么这也就意味着，我们需要解决如下的问题。\n                    </p>\n                    <ul data-nodeid=\"8567\">\n                      <li data-nodeid=\"8568\">\n                        <p data-nodeid=\"8569\">\n                          数组中元素右边离我最近且比我小的元素的位置\n                        </p>\n                      </li>\n                    </ul>\n                    <blockquote data-nodeid=\"8570\">\n                      <p data-nodeid=\"8571\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9683\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9687\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9691\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <ul data-nodeid=\"8572\">\n                      <li data-nodeid=\"8573\">\n                        <p data-nodeid=\"8574\">\n                          数组中元素左边离我最近且比我小的元素的位置\n                        </p>\n                      </li>\n                    </ul>\n                    <blockquote data-nodeid=\"8575\">\n                      <p data-nodeid=\"8576\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9696\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9700\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9704\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8577\">\n                      实际上，这两个问题，我们已经在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"9710\"\n                        >01 | 栈：从简单栈到单调栈，解决经典栈问题</a\n                      >”介绍单调栈时学过了。那么你现在解决起来，应该是很容易了吧。本讲不再过多叙述，直接给出如下代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LeftSmall</span>\n</span></div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 当我们要找左边比我小的元素的时候，需要用递增栈</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] findLeftSmall(<span class=\"hljs-keyword\">int</span>[] A)\n</div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (A == <span class=\"hljs-keyword\">null</span> || A.length == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 结果数组</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[A.length];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意，栈中的元素记录的是下标</span>\n</div></li><li><div class=\"code-word\">    Stack&lt;Integer&gt; t = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意这里的遍历方向发生了变化，因为我们是要找到左边比我小的元素的位置</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = A.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = A[i];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 每个元素都遍历栈中的元素完成消除动作</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 这里是递减栈</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果发现进来的元素x与栈中元素相比</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果大于栈中的元素，那么要把栈中的元素弹出去</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 消除的时候，记录一下被谁消除了</span>\n</div></li><li><div class=\"code-word\">        ans[t.peek()] = i;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 消除时候，值更大的需要从栈中消失</span>\n</div></li><li><div class=\"code-word\">        t.pop();\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 剩下的入栈</span>\n</div></li><li><div class=\"code-word\">      t.push(i);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (!t.empty()) {\n</div></li><li><div class=\"code-word\">      ans[t.peek()] = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      t.pop();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RightSmall</span>\n</span></div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] findRightSmall(<span class=\"hljs-keyword\">int</span>[] A)\n</div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 结果数组</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[A.length];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意，栈中的元素记录的是下标</span>\n</div></li><li><div class=\"code-word\">    Stack&lt;Integer&gt; t = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.length; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = A[i];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 每个元素都向左遍历栈中的元素完成消除动作</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 消除的时候，记录一下被谁消除了</span>\n</div></li><li><div class=\"code-word\">        ans[t.peek()] = i;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 消除时候，值更大的需要从栈中消失</span>\n</div></li><li><div class=\"code-word\">        t.pop();\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 剩下的入栈</span>\n</div></li><li><div class=\"code-word\">      t.push(i);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (!t.empty()) {\n</div></li><li><div class=\"code-word\">      ans[t.peek()] = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      t.pop();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span>\n</span></div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span>\n</span></div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] leftSmall = LeftSmall.findLeftSmall(A);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] rightSmall = RightSmall.findRightSmall(A);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> height = A[i];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 左边比我小的位置</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 右边比我小的位置</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> leftPos = leftSmall[i];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> rightPos = rightSmall[i] == -<span class=\"hljs-number\">1</span> ? N : rightSmall[i];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 现在我们确定区间(leftPos, rightPos)</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 注意两边都是开区间。在这个区间里面，所有的数肯定都是 &gt;= A[i]的。</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 那么底部的宽度就是</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> width = rightPos - leftPos - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> area = height * width;\n</div></li><li><div class=\"code-word\">      ans = Math.max(ans, area);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8579\">\n                      <p data-nodeid=\"8580\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9715\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9719\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9723\"\n                          >python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8581\">\n                      <strong data-nodeid=\"9728\">复杂度分析</strong>：时间复杂度\n                      O(N)，空间复杂度 O(N)。\n                    </p>\n                    <p data-nodeid=\"8582\">\n                      【<strong data-nodeid=\"9740\">小结</strong\n                      >】如果你看到这里，突然感觉代码都很神奇，充满了魔法，就是时候温习一下“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"9738\"\n                        >01 | 栈：从简单栈到单调栈，解决经典栈问题</a\n                      >”中单调栈的“魔法技能”部分了。通过复习有时候也能唤醒你算法的巨龙哦。\n                    </p>\n                    <h4 data-nodeid=\"8583\">单调栈的性质</h4>\n                    <p data-nodeid=\"8584\">\n                      我们来看递增栈（不是严格递增），栈中元素存放的是数组 A[]\n                      的下标。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8585\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__xWAW9DWAAFqqPVJeyA651.png\"\n                        alt=\"Drawing 18.png\"\n                        data-nodeid=\"9748\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8586\">\n                      说明：在这个图中，左边是栈底，右边是栈增长的方向。栈中不同的矩形表示相应\n                      A[]\n                      数组中下标位置相应值的大小。那么，首先基于递增栈的定义，我们可以知道它有如下<strong\n                        data-nodeid=\"9757\"\n                        >特性</strong\n                      >：\n                    </p>\n                    <blockquote data-nodeid=\"8587\">\n                      <p data-nodeid=\"8588\">\n                        栈中存放的下标，如果 i 在 j 之前入栈，那么必然满足 A[i]\n                        &lt;= A[j]。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"119325\" class=\"\">\n                      “<strong data-nodeid=\"119335\">削</strong>”<strong\n                        data-nodeid=\"119336\"\n                        >的定义</strong\n                      >：当需要把一个更小的元素入栈的时候，这个更小的元素就会把栈中大的元素出栈，直到栈为空，或者栈顶元素更小，再入栈。\n                    </p>\n\n                    <p data-nodeid=\"8590\">\n                      例如：当栈中已经有 &lt;i, j&gt;，现在需要将 A[k]\n                      入栈，但是 A[i] &lt; A[k] &amp;&amp; A[k] &lt; A[j]。那么\n                      A[k] 就会把 A[j] 削出栈。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8591\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__x2AMAmBAAGTLBc-_M4399.png\"\n                        alt=\"Drawing 19.png\"\n                        data-nodeid=\"9820\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8592\">\n                      根据这个特性，我们肯定可以得到 A[i] &lt;= A[k] &lt;\n                      A[j]。基于这个特性，还可以得出 3 个有用的性质。\n                    </p>\n                    <p data-nodeid=\"8593\">\n                      <strong data-nodeid=\"9841\">性质 1</strong>\n                    </p>\n                    <p data-nodeid=\"8594\">如下图所示：</p>\n                    <p data-nodeid=\"8595\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__yOANThzAAFyvMYvHNg791.png\"\n                        alt=\"Drawing 20.png\"\n                        data-nodeid=\"9845\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"8596\">\n                      <p data-nodeid=\"8597\">\n                        假设 i, j 这两个下标在单调栈中相邻，那么在原数组 A[]\n                        中， (i, j) 这个开区间里面的数都大于 A[j]。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8598\">\n                      这里我们采用反证法来证明这个性质。首先给出反证法的条件：\n                    </p>\n                    <ul data-nodeid=\"8599\">\n                      <li data-nodeid=\"8600\">\n                        <p data-nodeid=\"8601\">\n                          单调栈中连续存放着下标 i, j（但并不代表下标 i,j\n                          是连续的，也就是说 i + 1 不一定等于j）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8602\">\n                        <p data-nodeid=\"8603\">\n                          假设 A[] 数组在 (i, j) 范围中存在 1 个下标 k，即 i\n                          &lt; k &lt; j，并且使得 A[k] &lt; A[j] 成立。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8604\">\n                      证明：如果 A[k] &lt; A[j]，那么将 A[k]\n                      放入单调队列之后，由于 (k, j) 范围里面的数组都大于\n                      A[j]。那么当 A[j] 入栈之后，应该位于 A[k]\n                      之后。于是栈中会形成 &lt;i, k, j&gt;\n                      三个数。但实际上栈中只存放了 &lt;i, j&gt; 两个数，并且 i\n                      &lt; k &lt; j，这里存在矛盾。所以在 (i, j)\n                      这个开区间范围里面的数，都必须大于 A[j]。\n                    </p>\n                    <p data-nodeid=\"8605\">\n                      之所以这些大于 A[j] 的元素没有出现在栈中，是因为这些元素在\n                      A[j] 入栈时可能都在栈中，但是立马都被 A[j] 削出栈了。\n                    </p>\n                    <p data-nodeid=\"8606\">\n                      <strong data-nodeid=\"9929\">性质 2</strong>\n                    </p>\n                    <p data-nodeid=\"8607\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__yuAfVYwAAFqqPVJeyA829.png\"\n                        alt=\"Drawing 21.png\"\n                        data-nodeid=\"9932\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8608\">\n                      然后，基于性质 1，当单调栈中有 &lt;i, j, k&gt;3\n                      个原数组的下标。那么可以得到性质 2：\n                    </p>\n                    <blockquote data-nodeid=\"8609\">\n                      <p data-nodeid=\"8610\">\n                        当单调栈中有 &lt;i, j, k&gt; 3 个数组下标时，其中 (i, k]\n                        这个范围里面的元素，肯定 &gt;= A[j]。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8611\">证明如下：</p>\n                    <ul data-nodeid=\"8612\">\n                      <li data-nodeid=\"8613\">\n                        <p data-nodeid=\"8614\">\n                          根据性质 1，可以得到 (i, j) 里面的元素都大于 A[j]，即\n                          A[(i,j)] &gt; A[j]；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8615\">\n                        <p data-nodeid=\"8616\">\n                          根据性质 1，还可以得到 (j, k) 里面的元素都大于\n                          A[k]，即 A[(j,k)] &gt; A[k]；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8617\">\n                        <p data-nodeid=\"8618\">\n                          由于 j 在 k 之前入栈，所以可以肯定 A[j] &lt;= A[k]。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8619\">\n                      综上，A[(j,k)] &gt; A[k] &gt;= A[j]，所以可以得出结论 (i,\n                      k] 里面的元素肯定 &gt;= A[j]。\n                    </p>\n                    <p data-nodeid=\"8620\">\n                      <strong data-nodeid=\"10005\">性质 3</strong>\n                    </p>\n                    <p data-nodeid=\"8621\">\n                      现在我们遇到下面这种场景。在单调栈中，已经存放了原数组的两个下标\n                      &lt;i, j&gt;，其中 j 是栈顶元素，现在要把一个更小的值 A[k]\n                      对应的下标 k 入栈。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8622\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__zSAIgpuAAGDndzxWPI670.png\"\n                        alt=\"Drawing 22.png\"\n                        data-nodeid=\"10015\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8623\">\n                      此时，根据单调栈的性质，需要将 A[j] 弹出栈（有可能 A[k]\n                      已经削除了栈中的很多元素，现在轮到削除 A[j]\n                      了）。那么此时我们可以得到一个<strong data-nodeid=\"10033\"\n                        >性质 3</strong\n                      >：\n                    </p>\n                    <blockquote data-nodeid=\"8624\">\n                      <p data-nodeid=\"8625\">\n                        原数组 (j, k) 范围里面的数，都大于 A[j]。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8626\">\n                      同样，我们可以采用反证法。先给出反证法的条件：\n                    </p>\n                    <ul data-nodeid=\"8627\">\n                      <li data-nodeid=\"8628\">\n                        <p data-nodeid=\"8629\">\n                          当 k 要入栈时，单调栈中连续存放着下标 i,\n                          j（但并不代表下标 i,j 是连续的，也就是说 i + 1\n                          不一定等于 j）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8630\">\n                        <p data-nodeid=\"8631\">\n                          假设范围 (j, k) 中存在<strong data-nodeid=\"10046\"\n                            >1 个</strong\n                          >下标 x；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8632\">\n                        <p data-nodeid=\"8633\">使得 A[x] &lt;= A[j] 成立。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8634\">\n                      如果有 j &lt; x &lt; k，并且 A[x] &lt;= A[j]\n                      成立，那么单调栈中现在必然存在 A[x]\n                      元素。但是现在栈中存放着 A[j]，并且没有 A[x]\n                      元素。所以得出矛盾。所以性质 3 成立。\n                    </p>\n                    <p data-nodeid=\"8635\">\n                      其实性质 2 和性质 3 有个比较好记的地方。如果你将范围\n                      (i,j), (j, k) 看成两个“空档”。那么 A[j]\n                      就好像总是挑着两座大山，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8636\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__zuAUKHIAAGwv8-dDjM339.png\"\n                        alt=\"Drawing 23.png\"\n                        data-nodeid=\"10092\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8637\">\n                      至于 A[j] 和 A[k] 值的大小，当然是比较容易判断的：\n                    </p>\n                    <ul data-nodeid=\"8638\">\n                      <li data-nodeid=\"8639\">\n                        <p data-nodeid=\"8640\">\n                          如果栈中 j 在 k 之前（且相邻），那么 A[j] &lt; A[k]；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8641\">\n                        <p data-nodeid=\"8642\">\n                          如果 A[k] 要削 A[j] 出栈，那么 A[k] &lt; A[j]。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8643\">\n                      到这里，我们就可以写出代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 虽然可以用Stack&lt;Integer&gt;，但是这里我们为了更快地操作，我们用</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 数组模拟栈来运行，因为我们知道最多存放的内容实际上就是N个</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> top = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// s[top-1]表示栈顶元素</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span>[] s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 注意，这里我们取到了i == N</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 按理说，不应该取到i == N的。但是这时候，主要是为了处理这种数组</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// A = [1, 2, 3]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 没有任何元素会出栈。</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 那么最后我们用一个0元素，把所有的元素都削出栈。</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 这样代码就可以统一处理掉。</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= N; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 注意：当i == N的时候，x = -1;</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 比数组中的元素都要小。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = i == N ? -<span class=\"hljs-number\">1</span> : A[i];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">while</span> (top &gt; <span class=\"hljs-number\">0</span> &amp;&amp; A[s[top - <span class=\"hljs-number\">1</span>]] &gt; x) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 计算以A[s[top]]的元素的高度的矩形。</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> height = A[s[--top]];\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// i元素要将index = s[top-1]的元素出栈。</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 那么根据性质2/3：</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 此时A[s[top-1] .... i) 这个区间里面的元素都是</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 大于A[s[top-1]]的</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> rightPos = i;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 这里需要使用性质1.</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 注意：当栈中一个元素都没有的时候，要取-1</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> leftPos = top &gt; <span class=\"hljs-number\">0</span> ? s[top - <span class=\"hljs-number\">1</span>] : -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> width = rightPos - leftPos - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> area = height * width;\n</div></li><li><div class=\"code-word\">                ans = Math.max(ans, area);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            s[top++] = i;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8645\">\n                      <p data-nodeid=\"8646\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10136\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10140\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10144\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8647\">\n                      <strong data-nodeid=\"10149\">复杂度分析</strong\n                      >：时间复杂度 O(N)，空间复杂度 O(N)。\n                    </p>\n                    <h4 data-nodeid=\"8648\">DP</h4>\n                    <p data-nodeid=\"8649\">\n                      前面我们使用单调栈来求解一个左右两边第一个较小的元素的位置。现在我们重新来考虑一下这个问题。\n                    </p>\n                    <p data-nodeid=\"8650\">\n                      <strong data-nodeid=\"10156\">题目</strong\n                      >：数组中左边离我最近且比我小的元素的位置。\n                    </p>\n                    <p data-nodeid=\"8651\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__0WATqoPAACmXg-WF6E452.png\"\n                        alt=\"Drawing 24.png\"\n                        data-nodeid=\"10159\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8652\" class=\"\">\n                      我们在考虑的时候，直接考虑最后一个元素的情况（不知道你是否还记得我们<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6703&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"10163\"\n                        >DP 的最后一步</a\n                      >），也就是求解 A[k+1] 左边第一个比较小元素的位置。假设\n                      [0, k] 这个范围元素的解都放在 dp[] 数组里面。如果我们要求\n                      A[k+1] 左边第一个比较小元素的位置。通常的写法如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> pre = k; pre &gt;= <span class=\"hljs-number\">0</span>; pre--) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (A[pre] &lt; A[k+<span class=\"hljs-number\">1</span>]) {\n</div></li><li><div class=\"code-word\">    dp[k+<span class=\"hljs-number\">1</span>] = pre;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8654\">\n                      但是这么写，时间复杂度就变成\n                      O(N)。如果要求解“数组中元素左边离我最近且比我小的元素的位置”，问题就秒变\n                      O(N<sup>2</sup>)。而我们知道，如果使用单调栈，是可以在\n                      O(N) 时间复杂度解决的。\n                    </p>\n                    <p data-nodeid=\"8655\">\n                      我们立马会发现，求解 A[k+1] 的时候，还没有用上 dp[]\n                      数组。那么我们可以这样操作：\n                    </p>\n                    <ul data-nodeid=\"8656\">\n                      <li data-nodeid=\"8657\">\n                        <p data-nodeid=\"8658\">\n                          首先 A[k] 与 A[k+1] 比较，如果 A[k] &gt;=\n                          A[k+1]，那么直接跳到下标 j = dp[k] 这个位置；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8659\">\n                        <p data-nodeid=\"8660\">\n                          重复上述步骤，直到找到一个元素比 A[k+1]\n                          小，或者没有任何元素为止。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8661\">\n                      通过这样的方式，我们可以快速跳过一些元素，使时间复杂度变为\n                      O(lgN)。于是代码可以长成这样：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> pre = k + <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> (pre != -<span class=\"hljs-number\">1</span> &amp;&amp; A[pre] &gt;= A[k+<span class=\"hljs-number\">1</span>]) {\n</div></li><li><div class=\"code-word\">    pre = dp[pre];\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">dp[k+<span class=\"hljs-number\">1</span>] = pre;\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8663\">\n                      <p data-nodeid=\"8664\">\n                        联想 1：你可以想一下，这和 KMP\n                        算法有没有什么相似的地方？<br />\n                        联想\n                        2：你可以再想一下，这和我们学过的并查集有没有什么相似的地方？\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8665\">\n                      那么我们的求解最大矩形的代码，就可以利用这个思想，写出代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">largestRectangleArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> [] A)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (N == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span>[] lm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N]; <span class=\"hljs-comment\">// left min的位置</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span>[] rm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N]; <span class=\"hljs-comment\">// right min的位置</span>\n</div></li><li><div class=\"code-word\">        lm[<span class=\"hljs-number\">0</span>] = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> idx = i - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">while</span> (idx != -<span class=\"hljs-number\">1</span> &amp;&amp; A[idx] &gt;= A[i]) {\n</div></li><li><div class=\"code-word\">                idx = lm[idx];\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            lm[i] = idx;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        rm[N - <span class=\"hljs-number\">1</span>] = N;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = N - <span class=\"hljs-number\">2</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> idx = i + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">while</span> (idx != N &amp;&amp; A[idx] &gt;= A[i]) {\n</div></li><li><div class=\"code-word\">                idx = rm[idx];\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            rm[i] = idx;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">            ans = Math.max(ans, A[i] * (rm[i] - lm[i] - <span class=\"hljs-number\">1</span>));\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8667\">\n                      <p data-nodeid=\"8668\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10227\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10231\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10235\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8669\">\n                      <strong data-nodeid=\"10240\">复杂度分析</strong\n                      >：时间复杂度\n                      O(NlgN)，时间复杂度可以类比并查集的跳跃方式，空间复杂度\n                      O(N)。\n                    </p>\n                    <h3 data-nodeid=\"8670\">总结</h3>\n                    <p data-nodeid=\"8671\">在这一讲里面，我们采用的总方针是：</p>\n                    <ul data-nodeid=\"8672\">\n                      <li data-nodeid=\"8673\">\n                        <p data-nodeid=\"8674\">深挖题目的特点；</p>\n                      </li>\n                      <li data-nodeid=\"8675\">\n                        <p data-nodeid=\"8676\">对标数据结构/算法特点；</p>\n                      </li>\n                      <li data-nodeid=\"8677\">\n                        <p data-nodeid=\"8678\">\n                          将特点进行结合，创造出新的解法。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8679\">\n                      我们再将本讲介绍的题目进行一个总结和归纳，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8680\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__1KAJ88RAAEz0wn26MU790.png\"\n                        alt=\"Drawing 25.png\"\n                        data-nodeid=\"10249\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"8681\">思考题</h3>\n                    <p data-nodeid=\"8682\">\n                      这里我再给你留了一下思考题：给定一个仅包含<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"10252\"\n                        >0</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"10254\">1</code\n                      >、大小为<code data-backticks=\"1\" data-nodeid=\"10256\"\n                        >rows x cols</code\n                      >的二维二进制矩阵，找出只包含<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"10258\"\n                        >1</code\n                      >的最大矩形，并返回其面积。\n                    </p>\n                    <blockquote data-nodeid=\"8683\">\n                      <p data-nodeid=\"8684\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10263\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10267\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"10271\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"127549\" class=\"te-preview-highlight\">\n                      关于最大矩形这一道题，我们就介绍到这里。如果你发现这个题目还有新的特点，还能匹配到新的算法，那么有可能你还会发现新的解法哦。接下来我们将进入\n                      17 | 深度思考子集：如何掌握 5 种通用解法？记得按时来探险。\n                    </p>\n            "}