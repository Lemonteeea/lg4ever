{"title":"21&nbsp;| 安排会议室：如何利用多种方法安排会议室？","context":"\n                    <p data-nodeid=\"3\">\n                      本讲是一题多解模块的最后一讲，之所以安排这一讲，是因为通常情况下，一道算法题目有多种的解法。我们与别人交流时，大家的思路和解题方法可能不同，每个人写出来的代码差异巨大。那么这些不同的<strong\n                        data-nodeid=\"176\"\n                        >正确解法</strong\n                      >，可以理解成“一题多解”吗？换句话说，你能分清什么是真正的“多解”，什么是“伪多解”吗？\n                    </p>\n                    <p data-nodeid=\"4\">\n                      通过这些“伪多解”，有助于我们看透题目的本质，从而掌握核心知识点，同时也可以降低我们需要理解和记忆的知识量。\n                    </p>\n                    <p data-nodeid=\"5\">\n                      所以，在本讲，你将掌握以下三种思考方法：\n                    </p>\n                    <ul data-nodeid=\"6\">\n                      <li data-nodeid=\"7\">\n                        <p data-nodeid=\"8\">\n                          如何通过“多解”看透知识点的本质（分清“伪多解”“真多解”）？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9\">\n                        <p data-nodeid=\"10\">如何用多种技巧满足题目要求？</p>\n                      </li>\n                      <li data-nodeid=\"11\">\n                        <p data-nodeid=\"12\">\n                          如何深挖题目特点，达到一题多解的目标？\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"13\">题目</h3>\n                    <p data-nodeid=\"14\">\n                      给定一系列的会议，时间间隔intervals，包括起始和结束时间<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"184\"\n                        >[[s\\`\\`1\\`\\`,e1],[s\\`\\`2\\`\\`,e2],\\`\\`...\\`\\`]\\`\\`\\`\\`(\\`\\`s\\`\\`i &lt;\n                        ei)</code\n                      >，找到所需的最小的会议室数量。\n                    </p>\n                    <p data-nodeid=\"15\">\n                      输入：会议时间表 [[0, 30],[5, 10],[15, 20]]\n                    </p>\n                    <p data-nodeid=\"16\">输出：最少需要的会议室数量 2</p>\n                    <blockquote data-nodeid=\"17\">\n                      <p data-nodeid=\"18\">\n                        注意：如果有两个会议 [6,8] 和\n                        [8,10]，我们认为这两个会议不冲突。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"19\">特点 1：时间分布</h3>\n                    <p data-nodeid=\"20\">拿到这个题时，我们要特别注意一点：</p>\n                    <blockquote data-nodeid=\"21\">\n                      <p data-nodeid=\"22\">\n                        如果有两个会议，其中一个会议结束于时间点x，下一个会议同时从时间点y\n                        开始，这两个会议可以用同一个会议室。也就是说，这两个时间段并不重合（虽然在时间点\n                        x 相接）。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"23\">\n                      我们从<strong data-nodeid=\"218\">时间点</strong\n                      >出发来考虑这个问题，有以下 3 种情况。\n                    </p>\n                    <h4 data-nodeid=\"24\">情况 1：需 1 个会议室</h4>\n                    <p data-nodeid=\"25\">\n                      首先我们考虑一种简单的情况，假设会议与会议之间均没有重合的情况。比如输入如下：\n                    </p>\n                    <blockquote data-nodeid=\"26\">\n                      <p data-nodeid=\"27\">intervals=[0,1],[1,2],[2, 3]</p>\n                    </blockquote>\n                    <p data-nodeid=\"28\">\n                      在下图中，x 轴表示会议的时间表，y\n                      轴表示将哪些会议放在哪个会议室，蓝色、橘色和红色分别表示不同的会议。\n                    </p>\n                    <p data-nodeid=\"4429\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3D/CC/CioPOWCWS3qAAHo4AADc4BKJoU0568.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"4432\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"32\">\n                      在这种情况下，每个时间点只可以被染上一种颜色，时间衔接得非常好，此时只需要一个会议室。接下来我们再看一下衔接得不那么好的情况。\n                    </p>\n                    <p data-nodeid=\"5685\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3D/C4/Cgp9HWCWS4GAbC39AACrd4MbmYc760.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"5688\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"35\">\n                      在这种情况下，每个时间点只可以被染上一种颜色，或者没有染上颜色，同样此时最多也只需要一个会议室。\n                    </p>\n                    <p data-nodeid=\"36\">\n                      不过，我们还需要处理一种很麻烦的情况，此时 [6, 8] 和 [8,\n                      10] 两个会议的时间点都会将时间点 8\n                      进行染色。那岂不是时间点 8\n                      会有两种颜色？针对这种情况，我们在染色的时候，可以做一点更正。\n                    </p>\n                    <blockquote data-nodeid=\"37\">\n                      <p data-nodeid=\"38\">\n                        针对会议时间[start,end]染色时，只需要渲染[start,end)，不需要将end点进行染色。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"39\">此时，即可满足：</p>\n                    <blockquote data-nodeid=\"40\">\n                      <p data-nodeid=\"41\">区间 [6,8)与区间[8,10)不相交。</p>\n                    </blockquote>\n                    <p data-nodeid=\"42\">\n                      并且，我们不需要再对这种前后时间相接的情况做特殊判断。\n                    </p>\n                    <h4 data-nodeid=\"43\">情况 2：需 2 个会议室</h4>\n                    <p data-nodeid=\"44\">\n                      前面我们考虑的都是没有重合的情况，接下来，再看一下两个会议室\n                      [0, 2) 和 [1, 4) 有重合的情况。\n                    </p>\n                    <p data-nodeid=\"6933\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3D/C4/Cgp9HWCWS4uACkpsAAE9Ulp4bYY214.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"6936\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"46\">\n                      此时，只需要对 [0, 2) 和区间 [1, 4)\n                      进行染色。我们发现，如果在时刻\n                      1画一条竖线，会分别遇到两种颜色：蓝色和红色。\n                    </p>\n                    <h4 data-nodeid=\"47\">情况 3：需多个会议室</h4>\n                    <p data-nodeid=\"48\">\n                      前面考虑了需要 1 个和 2\n                      个会议室的情况，接下来我们看一下稍微复杂一点的场景。\n                    </p>\n                    <p data-nodeid=\"8175\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3D/C4/Cgp9HWCWS5KAbk7KAAMAlgj142s581.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"8178\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"10634\" class=\"\">\n                      通过画图可以发现规律，y\n                      轴的会议室的数目与某个点染色的次数相关。那么，我们可以把这个题转换为一个<strong\n                        data-nodeid=\"10640\"\n                        >更加容易理解的题目</strong\n                      >：\n                    </p>\n\n                    <blockquote data-nodeid=\"52\">\n                      <p data-nodeid=\"53\">\n                        给定一个数组A[]，再给定一系列区间[start,\n                        end)，我们将此区间中A[start...end)都加上1。最后求数组\n                        A[] 中的最大值。\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"54\">差分数组</h4>\n                    <p data-nodeid=\"55\">\n                      差分数组是一种求解区间累加的有效手段。我们先考虑只有一个区间\n                      [start, end) 的情况。\n                    </p>\n                    <p data-nodeid=\"56\">一种暴力的写法是下面这样：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 给定数组A[]已经初始化为0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 处理一个区间的情况</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start; i &lt; end; i++) {\n</div></li><li><div class=\"code-word\">  A[i]++;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 这里是累加之后的A[]数组</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"58\">\n                      我们可以通过画图表示操作后的结果，如下图所示：\n                    </p>\n                    <p data-nodeid=\"11859\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3D/CD/CioPOWCWS6CAMsbXAACSuolYP0Y214.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"11862\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"61\">\n                      如果我们只关心每个时间点的涨幅与跌幅，那么可以对每个点进行标注，如下图所示：\n                    </p>\n                    <p data-nodeid=\"13073\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3D/C4/Cgp9HWCWS6eAWdrcAACUf94Rarg748.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"13076\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"64\">\n                      你可以按照如下操作，得到任意时刻的累计值（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 给定数组A[]已初始化全为0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 处理一个区间</span>\n</div></li><li><div class=\"code-word\">A[start] += <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">A[end] -= <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 最后求前缀和，得到任意时刻的值</span>\n</div></li><li><div class=\"code-word\">pre = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start; i &lt; end; i++) {\n</div></li><li><div class=\"code-word\">  pre += A[i];\n</div></li><li><div class=\"code-word\">  A[i] += pre;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"66\">\n                      无论是一个区间还是多个区间，我们都可以参考上述方式进行处理，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 给定数组A[]已初始化全为0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (Interval range: intervals) {\n</div></li><li><div class=\"code-word\">  A[range.start] += <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  A[range.end] -= <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 最后求前缀和，得到任意时刻的值</span>\n</div></li><li><div class=\"code-word\">pre = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start; i &lt; end; i++) {\n</div></li><li><div class=\"code-word\">  pre += A[i];\n</div></li><li><div class=\"code-word\">  A[i] += pre;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"68\">\n                      基于这个知识点，我还给你留了一个练习题。\n                    </p>\n                    <p data-nodeid=\"69\">\n                      <strong data-nodeid=\"360\">练习题 1</strong\n                      >：假设你有一个长度为<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"346\"\n                        >n</code\n                      >的数组，数组的所有元素初始化为<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"348\"\n                        >0</code\n                      >，并且给定<code data-backticks=\"1\" data-nodeid=\"350\"\n                        >k</code\n                      >个更新操作。每个更新操作表示为一个三元组：<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"352\"\n                        >[startIndex, endIndex, inc]</code\n                      >。这个更新操作给子数组<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"354\"\n                        >A[start\\`\\`I\\`\\`ndex\\`\\`\\`\\`... endIndex]</code\n                      >（包括startIndex和endIndex）中的每一个元素增加<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"356\"\n                        >inc</code\n                      >。返回执行<code data-backticks=\"1\" data-nodeid=\"358\"\n                        >k</code\n                      >个更新操作后的新数组。\n                    </p>\n                    <blockquote data-nodeid=\"70\">\n                      <p data-nodeid=\"71\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/903.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"364\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/903.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"368\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/903.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"372\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"72\">改进 1： 哈希表</h4>\n                    <p data-nodeid=\"73\">\n                      如果我们直接使用差分数组，好像无法直接破解这个题，因为题目中并没有约定所有整数的范围。比如，如果给定的某个会议时间段是\n                      [0, 10000000000]，就无法直接申请 A[10000000000]\n                      这么大的数组。\n                    </p>\n                    <p data-nodeid=\"74\">\n                      因此，我们还需要对差分数组做一点改进：可以尝试用哈希表来表示数组。\n                    </p>\n                    <h4 data-nodeid=\"75\">改进 2：范围</h4>\n                    <p data-nodeid=\"76\">\n                      在标准的差分数组中，我们需要返回的是一个操作之后的数组，也就是求出每一个\n                      A[i]\n                      的值。但是在这个题中，只需要拿到数组的最大值就可以了。因此，我们也没有必要求出每一个\n                      A[i] 的值。\n                    </p>\n                    <p data-nodeid=\"77\">\n                      综上，可以写出基于差分数组的改进的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HashMap</span>&lt;<span class=\"hljs-title\">Integer</span>, <span class=\"hljs-title\">Integer</span>&gt; </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(Integer k)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> containsKey(k) ? <span class=\"hljs-keyword\">super</span>.get(k) : <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(Integer k, <span class=\"hljs-keyword\">int</span> v)</span> </span>{\n</div></li><li><div class=\"code-word\">        put(k, get(k) + v);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\">   * <span class=\"hljs-doctag\">@param</span> intervals: an array of meeting time intervals\n</div></li><li><div class=\"code-word\">   * <span class=\"hljs-doctag\">@return</span>: the minimum number of conference rooms required\n</div></li><li><div class=\"code-word\">   */\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minMeetingRooms</span><span class=\"hljs-params\">(List&lt;Interval&gt; intervals)</span> </span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// Write your code here</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 利用Hash表生成A[]数组</span>\n</div></li><li><div class=\"code-word\">      Counter A = <span class=\"hljs-keyword\">new</span> Counter();\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (Interval range: intervals) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> start = range.start;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> end = range.end;\n</div></li><li><div class=\"code-word\">        A.add(start, <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        A.add(end, -<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      List&lt;Integer&gt; idx = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(A.keySet());\n</div></li><li><div class=\"code-word\">      Collections.sort(idx);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">int</span> pre = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (Integer i: idx) {\n</div></li><li><div class=\"code-word\">        pre += A.get(i);\n</div></li><li><div class=\"code-word\">        ans = Math.max(ans, pre);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"16702\">\n                      <p data-nodeid=\"16703\" class=\"\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%86.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"16707\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%86.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"16711\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%86.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"16715\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n\n                    <p data-nodeid=\"81\">\n                      <strong data-nodeid=\"420\">复杂度分析</strong\n                      >：时间复杂度为 O(NlgN)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"82\">\n                      我们发现，这个题目的考点就是在差分数组上的两点变化：\n                    </p>\n                    <ul data-nodeid=\"83\">\n                      <li data-nodeid=\"84\">\n                        <p data-nodeid=\"85\">利用哈希表表示数组；</p>\n                      </li>\n                      <li data-nodeid=\"86\">\n                        <p data-nodeid=\"87\">\n                          由于只需要求最大值，因此我们求出区间端点的值就可以了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"88\">接下来，我们来看另外一种思路。</p>\n                    <h3 data-nodeid=\"89\">特点 2：变招 1</h3>\n                    <p data-nodeid=\"90\">\n                      我们继续讨论一下差分数组的解法。在本题中，我们需要的并不是一个标准的差分解法。经过分析之后，实际上只需要处理以下情况：\n                    </p>\n                    <ul data-nodeid=\"91\">\n                      <li data-nodeid=\"92\">\n                        <p data-nodeid=\"93\">给定区间 [start, end)；</p>\n                      </li>\n                      <li data-nodeid=\"94\">\n                        <p data-nodeid=\"95\">只需要遇到 start 时 +1；</p>\n                      </li>\n                      <li data-nodeid=\"96\">\n                        <p data-nodeid=\"97\">只需要遇到 end时 -1；</p>\n                      </li>\n                      <li data-nodeid=\"98\">\n                        <p data-nodeid=\"99\">\n                          然后再利用累计求和的方式计算每个位置的值。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"100\">\n                      在前面我们用了哈希数组的办法，那么，哈希数组就是必需的吗？\n                    </p>\n                    <p data-nodeid=\"101\">\n                      由于我们并不像差分数组一样返回操作之后的整个数组，而是返回最大值。因此只需要经过以下两步，就可以得到最大值。\n                    </p>\n                    <ul data-nodeid=\"102\">\n                      <li data-nodeid=\"103\">\n                        <p data-nodeid=\"104\">\n                          Step 1. 将所有的下标放到一个数组中，并且进行排序。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"105\">\n                        <p data-nodeid=\"106\">\n                          Step 2. 从头倒尾遍历下标，如果遇到区间的起始点，那么\n                          +1；如果遇到区间的终点，那么 -1。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"107\">操作伪代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">item = [收集了所有的下标]\n</div></li><li><div class=\"code-word\">sort(item)\n</div></li><li><div class=\"code-word\">ans = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">pre = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> 坐标 in item:\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> 坐标是区间的起始点:\n</div></li><li><div class=\"code-word\">        pre += <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">        pre -= <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    ans = max(ans, pre)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> ans\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"109\">这里还有两个地方需要处理：</p>\n                    <p data-nodeid=\"20278\" class=\"\">\n                      1 )\n                      如何判断经过排序之后的下标，是区间的终点还是一个区间的起始点？\n                    </p>\n\n                    <p data-nodeid=\"113\">\n                      解决方法：在放到 item\n                      里面的时候，我们可以将起始点设置为正值，终点设置为负值。\n                    </p>\n                    <p data-nodeid=\"21460\" class=\"\">\n                      2\n                      ）如果经过排序之后的下标分了正负，那么一个区间的终点将会位于\n                      x 轴的负半轴，起始点位于 x\n                      轴的正半轴，这并没有按照原本的坐标排序。\n                    </p>\n\n                    <p data-nodeid=\"115\">\n                      解决方法：排序时，我们只需要按照下标的绝对值排序即可。\n                    </p>\n                    <p data-nodeid=\"116\">\n                      基于这样的处理技巧，可以写出代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\">   * <span class=\"hljs-doctag\">@param</span> intervals: an array of meeting time intervals\n</div></li><li><div class=\"code-word\">   * <span class=\"hljs-doctag\">@return</span>: the minimum number of conference rooms required\n</div></li><li><div class=\"code-word\">   */\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minMeetingRooms</span><span class=\"hljs-params\">(List&lt;Interval&gt; intervals)</span> </span>{\n</div></li><li><div class=\"code-word\">    List&lt;Integer&gt; item = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (Interval range: intervals) {\n</div></li><li><div class=\"code-word\">      item.add(range.start);\n</div></li><li><div class=\"code-word\">      item.add(<span class=\"hljs-number\">0</span> - range.end);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    Collections.sort(item, <span class=\"hljs-keyword\">new</span> Comparator&lt;Integer&gt;() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(Integer a, Integer b)</span> </span>{\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> Math.abs(a) - Math.abs(b);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> pre = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; item.size(); i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (item.get(i) &gt;= <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">        pre++;\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        pre--;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      ans = Math.max(ans, pre);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"26230\">\n                      <p data-nodeid=\"26231\" class=\"\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%862.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"26235\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%862.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"26239\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%862.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"26243\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n\n                    <p data-nodeid=\"120\">\n                      <strong data-nodeid=\"466\">复杂度分析</strong\n                      >：时间复杂度为 O(NlgN)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"121\">\n                      在这里，我们已经快找不到差分数组的影子了，但是本质上还是基于差分数组进行求解。那么，还有其他的解法吗？\n                    </p>\n                    <h3 data-nodeid=\"122\">特点 3：变招 2</h3>\n                    <p data-nodeid=\"123\">\n                      前面在处理区间的时候：是将所有区间的起始点标记为非负，区间的终点标记为负数；排序时按照绝对值进行排序。然后再利用<strong\n                        data-nodeid=\"474\"\n                        >差分数组的核心思想</strong\n                      >：遇到区间的起始点 +1；遇到区间的终点 -1。\n                    </p>\n                    <p data-nodeid=\"124\">\n                      那么还有没有其他的招法呢？我们再认真地研究一下这个题目，不难发现，破题的关键就在两处条件：\n                    </p>\n                    <ol data-nodeid=\"28586\">\n                      <li data-nodeid=\"28587\">\n                        <p data-nodeid=\"28588\" class=\"\">\n                          需要将所有的坐标排序，并且需要知道每个坐标是属于一个区间的起始点还是终点。<strong\n                            data-nodeid=\"28596\"\n                            >即顺序遍历坐标，知道每个坐标是起始点还是终点</strong\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"28589\">\n                        <p data-nodeid=\"28590\">\n                          利用差分数组的核心思想，然后求出最大值。\n                        </p>\n                      </li>\n                    </ol>\n\n                    <p data-nodeid=\"130\">\n                      根据条件 2，我们已知可以利用差分数组的思路，那么条件 1\n                      这里还可以用别的方法吗？下面我们尝试完成条件 1 。\n                    </p>\n                    <p data-nodeid=\"131\">\n                      首先将所有区间的起始点坐标放到 starts\n                      数组中，将所有区间的终点坐标放到 end 数组中。然后，再将\n                      starts 和 end 采用<strong data-nodeid=\"495\"\n                        >合并排序</strong\n                      >的方法进行合并（注意，此时我们不是直接使用合并排序，准确来说是使用合并排序中的合并的技巧）。\n                    </p>\n                    <p data-nodeid=\"132\">\n                      此时，我们可以达成条件 1 的两个目的：\n                    </p>\n                    <ul data-nodeid=\"133\">\n                      <li data-nodeid=\"134\">\n                        <p data-nodeid=\"135\">顺序遍历每个坐标；</p>\n                      </li>\n                      <li data-nodeid=\"136\">\n                        <p data-nodeid=\"137\">\n                          知道每个坐标是区间起始坐标，还是终点坐标。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"138\">伪代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">starts = [...区间的起始点...]\n</div></li><li><div class=\"code-word\">ends = [...区间的终点...]\n</div></li><li><div class=\"code-word\">sort(start);\n</div></li><li><div class=\"code-word\">sort(ends);\n</div></li><li><div class=\"code-word\">slen = len(starts)\n</div></li><li><div class=\"code-word\">elen = len(ends)\n</div></li><li><div class=\"code-word\">i = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">j = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> i &lt; slen || j &lt; elen:\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> j &gt;= elen || i &lt; slen:\n</div></li><li><div class=\"code-word\">        遍历到了start[i]；并且我们知道这个坐标是区间的起始点\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">        遍历到了end[i]；并且我们知道这个坐标是区间的终点\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"140\">\n                      基于这样的思想，再加上我们的差分核心思路，那么就可以写出如下代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@param</span> intervals: an array of meeting time intervals\n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@return</span>: the minimum number of conference rooms required\n</div></li><li><div class=\"code-word\">     */\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minMeetingRooms</span><span class=\"hljs-params\">(List&lt;Interval&gt; intervals)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// Write your code here</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = intervals == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : intervals.size();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span>[] start = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span>[] end = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (Interval range: intervals) {\n</div></li><li><div class=\"code-word\">          start[i] = range.start;\n</div></li><li><div class=\"code-word\">          end[i] = range.end;\n</div></li><li><div class=\"code-word\">          i++;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        Arrays.sort(start);\n</div></li><li><div class=\"code-word\">        Arrays.sort(end);\n</div></li><li><div class=\"code-word\">        i = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> pre = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (i &lt; N || j &lt; N) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (j &gt;= N || i &lt; N &amp;&amp; start[i] &lt; end[j]) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 是个坐标的起始点</span>\n</div></li><li><div class=\"code-word\">            pre++;\n</div></li><li><div class=\"code-word\">            i++;\n</div></li><li><div class=\"code-word\">          } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 是个坐标的终点</span>\n</div></li><li><div class=\"code-word\">            pre--;\n</div></li><li><div class=\"code-word\">            j++;\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">          ans = Math.max(ans, pre);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"142\">\n                      <p data-nodeid=\"143\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%863.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"504\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%863.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"508\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%863.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"512\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"144\">\n                      <strong data-nodeid=\"517\">复杂度分析</strong\n                      >：时间复杂度为 O(NlgN)，空间复杂度为O(N)。\n                    </p>\n                    <p data-nodeid=\"145\">\n                      接下来，我们再看看有没有其他的解法。\n                    </p>\n                    <h3 data-nodeid=\"146\">特点 4：最少</h3>\n                    <p data-nodeid=\"147\">\n                      再回到原始题目，要想会议室最少，那么我们在拿到一个 meeting\n                      = [start,end] 的时候，尽量不去开新的会议室，而是<strong\n                        data-nodeid=\"530\"\n                        >选择一个已有会议结束时间</strong\n                      >&lt;= start 的会议室开会。\n                    </p>\n                    <p data-nodeid=\"148\">\n                      要做到这一点，我们需要记录每个会议室的结束时间；当给定\n                      meeting = [start,end] 的时候，就需要找到一个 &lt;= start\n                      的会议室提供给这个 meeting使用。\n                    </p>\n                    <p data-nodeid=\"30910\" class=\"\">\n                      到这里，不知道你是否想起了我们在<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"30914\"\n                        >《03 | 优先级队列：堆与优先级队列，筛选最优元素》</a\n                      >中介绍的“例\n                      3”。我们可以把会议室也放到优先级队列中，每次总是取出结束时间最早的会议室。\n                    </p>\n\n                    <p data-nodeid=\"150\">\n                      由于给定的所有的 meeting\n                      并没有排好序。因此，我们还需要做一点预处理——对\n                      meeting进行排序。此时你还会面临一个问题，在排序的时候，meeting有\n                      [start,end]，那么应该按照 start 值来排序，还是按照 end\n                      来排序呢？\n                    </p>\n                    <p data-nodeid=\"151\">\n                      答案是按照 start\n                      值来排序。因为我们在选择会议室的时候，需要两个输入，分别是\n                      meeting 的开始时间 start 和会议室的结束时间。\n                    </p>\n                    <p data-nodeid=\"152\">\n                      基于这样的思想，我们就可以写出如下的代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minMeetingRooms</span><span class=\"hljs-params\">(List&lt;Interval&gt; intervals)</span> </span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = intervals == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : intervals.size();\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 把所有的会议时间段都按start来排序</span>\n</div></li><li><div class=\"code-word\">      Collections.sort(intervals, <span class=\"hljs-keyword\">new</span> Comparator&lt;Interval&gt;() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(Interval a, Interval b)</span> </span>{\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> a.start - b.start;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      });\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 这里要按照会议室的结束时间来排序</span>\n</div></li><li><div class=\"code-word\">      Queue&lt;Integer&gt; meetingRooms = \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v1 - v2);\n</div></li><li><div class=\"code-word\">          \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (Interval meeting : intervals) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!meetingRooms.isEmpty() &amp;&amp;\n</div></li><li><div class=\"code-word\">              meetingRooms.peek() &lt;= meeting.start) {\n</div></li><li><div class=\"code-word\">              \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 我们需要把这个会议室的结束时间修改一下</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 当然，优先级队列里面是不好直接修改元素值的</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 那我们只能采用先出队，再把当前会议结束时间入队的方式</span>\n</div></li><li><div class=\"code-word\">          meetingRooms.poll();\n</div></li><li><div class=\"code-word\">          meetingRooms.add(meeting.end);\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 如果找不到会议室，那么新开一间</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 标记其结束时间</span>\n</div></li><li><div class=\"code-word\">          meetingRooms.add(meeting.end);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> meetingRooms.size();\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"32048\">\n                      <p data-nodeid=\"32049\" class=\"\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.PQ.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"32053\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.PQ.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"32057\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.PQ.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"32061\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n\n                    <p data-nodeid=\"156\">\n                      <strong data-nodeid=\"581\">复杂度分析</strong\n                      >：时间复杂度为O(NlgN)，空间复杂度为 O(N)。\n                    </p>\n                    <h3 data-nodeid=\"157\">总结</h3>\n                    <p data-nodeid=\"158\">\n                      最后，我将本讲用到的知识整理成在一张思维导图中，方便你复习。\n                    </p>\n                    <p data-nodeid=\"33188\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3D/CD/CioPOWCWTAeAaIcSAAGls-nmvb0606.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"33191\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"161\">\n                      通过总结我们发现，这个题目的核心解法实际上只有两种，但是基于差分方法又出现了三种“伪多解”的做法，我们一一进行了分析，透过代码，相信你也学会了如何运用多种技巧来满足题目的条件。\n                    </p>\n                    <p data-nodeid=\"162\">\n                      当然，在面试中，如果你遇到这道题之后，面试官有可能还会深入地问你一些问题，比如下面这道一个思考题。\n                    </p>\n                    <p data-nodeid=\"163\">\n                      题目仍然不变，要求输出最少会议室的个数，并且还要输出每个会议室里面召开哪些会议。\n                    </p>\n                    <p data-nodeid=\"164\">\n                      输入：会议时间表[[0,30],[5,10],[15,20]]\n                    </p>\n                    <p data-nodeid=\"165\">\n                      输出：最少需要的会议室数量 2，[[0,30]] 放到会议室\n                      1，[[5,10], [15,20]] 放到会议室 2。\n                    </p>\n                    <blockquote data-nodeid=\"166\">\n                      <p data-nodeid=\"167\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/ans.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"627\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/ans.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"631\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/ans.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"635\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"168\">\n                      你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于这道会议室的题目就介绍到这里。接下来，下一讲介绍“22|数据结构模板：如何让解题变成搭积木？”，让我们继续前进。\n                    </p>\n            "}