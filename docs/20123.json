{"title":"22 | 网络编程：Go 语言如何通过 RPC 实现跨平台服务？","context":"\n                    <p data-nodeid=\"3404\" class=\"\">\n                      在上一讲中，我为你讲解了 RESTful API\n                      的规范以及实现，并且留了两个作业，它们分别是删除和修改用户，现在我为你讲解这两个作业。\n                    </p>\n                    <p data-nodeid=\"3405\">\n                      删除一个用户比较简单，它的 API\n                      格式和获取一个用户一样，但是 HTTP\n                      方法换成了DELETE。删除一个用户的示例代码如下所示：\n                    </p>\n                    <p data-nodeid=\"3406\">\n                      <em data-nodeid=\"3545\">ch21/main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//省略没有修改的代码</span>\n</div></li><li><div class=\"code-word\">   r.DELETE(<span class=\"hljs-string\">\"/users/:id\"</span>, deleteUser)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">deleteUser</span><span class=\"hljs-params\">(c *gin.Context)</span></span> {\n</div></li><li><div class=\"code-word\">   id := c.Param(<span class=\"hljs-string\">\"id\"</span>)\n</div></li><li><div class=\"code-word\">   i := <span class=\"hljs-number\">-1</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//类似于数据库的SQL查询</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">for</span> index, u := <span class=\"hljs-keyword\">range</span> users {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> strings.EqualFold(id, strconv.Itoa(u.ID)) {\n</div></li><li><div class=\"code-word\">         i = index\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">break</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> i &gt;= <span class=\"hljs-number\">0</span> {\n</div></li><li><div class=\"code-word\">      users = <span class=\"hljs-built_in\">append</span>(users[:i], users[i+<span class=\"hljs-number\">1</span>:]...)\n</div></li><li><div class=\"code-word\">      c.JSON(http.StatusNoContent, <span class=\"hljs-string\">\"\"</span>)\n</div></li><li><div class=\"code-word\">   } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      c.JSON(http.StatusNotFound, gin.H{\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"用户不存在\"</span>,\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3408\">\n                      这个示例的逻辑就是注册 DELETE\n                      方法，达到删除用户的目的。删除用户的逻辑是通过ID 查询：\n                    </p>\n                    <ul data-nodeid=\"3409\">\n                      <li data-nodeid=\"3410\">\n                        <p data-nodeid=\"3411\">\n                          如果可以找到要删除的用户，记录索引并跳出循环，然后根据索引删除该用户；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3412\">\n                        <p data-nodeid=\"3413\">\n                          如果找不到要删除的用户，则返回 404。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3414\">\n                      实现了删除用户的逻辑后，相信你已经会修改一个用户的名字了，因为它和删除一个用户非常像，实现代码如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//省略没有修改的代码</span>\n</div></li><li><div class=\"code-word\">   r.PATCH(<span class=\"hljs-string\">\"/users/:id\"</span>,updateUserName)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">updateUserName</span><span class=\"hljs-params\">(c *gin.Context)</span></span> {\n</div></li><li><div class=\"code-word\">   id := c.Param(<span class=\"hljs-string\">\"id\"</span>)\n</div></li><li><div class=\"code-word\">   i := <span class=\"hljs-number\">-1</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//类似于数据库的SQL查询</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">for</span> index, u := <span class=\"hljs-keyword\">range</span> users {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> strings.EqualFold(id, strconv.Itoa(u.ID)) {\n</div></li><li><div class=\"code-word\">         i = index\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">break</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> i &gt;= <span class=\"hljs-number\">0</span> {\n</div></li><li><div class=\"code-word\">      users[i].Name = c.DefaultPostForm(<span class=\"hljs-string\">\"name\"</span>,users[i].Name)\n</div></li><li><div class=\"code-word\">      c.JSON(http.StatusOK, users[i])\n</div></li><li><div class=\"code-word\">   } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      c.JSON(http.StatusNotFound, gin.H{\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"用户不存在\"</span>,\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3416\">\n                      整体代码逻辑和删除的差不多的，只不过这里使用的是\n                      PATCH方法。\n                    </p>\n                    <h3 data-nodeid=\"3417\">什么是RPC 服务</h3>\n                    <p data-nodeid=\"3418\">\n                      RPC，也就是<strong data-nodeid=\"3557\">远程过程调用</strong\n                      >，是分布式系统中不同节点调用的方式（进程间通信），属于\n                      C/S 模式。RPC\n                      由客户端发起，调用服务端的方法进行通信，然后服务端把结果返回给客户端。\n                    </p>\n                    <p data-nodeid=\"3419\">\n                      RPC的核心有两个：<strong data-nodeid=\"3567\"\n                        >通信协议</strong\n                      >和<strong data-nodeid=\"3568\">序列化</strong>。在 HTTP 2\n                      之前，一般采用自定义 TCP 协议的方式进行通信，HTTP 2\n                      出来后，也有采用该协议的，比如流行的gRPC。\n                    </p>\n                    <p data-nodeid=\"3420\">\n                      <strong data-nodeid=\"3577\">序列化</strong>和<strong\n                        data-nodeid=\"3578\"\n                        >反序列化</strong\n                      >是一种把传输内容编码和解码的方式，常见的编解码方式有\n                      JSON、Protobuf 等。\n                    </p>\n                    <p data-nodeid=\"4534\">\n                      在大多数 RPC的架构设计中，都有<strong data-nodeid=\"4554\"\n                        >Client</strong\n                      >、<strong data-nodeid=\"4555\">Client Stub</strong\n                      >、<strong data-nodeid=\"4556\">Server</strong>、<strong\n                        data-nodeid=\"4557\"\n                        >Server Stub</strong\n                      >这四个组件，Client 和 Server 之间通过 Socket\n                      进行通信。RPC 架构如下图所示：\n                    </p>\n                    <p data-nodeid=\"4535\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8D/45/CgqCHl_8K6eADlRHAAFxSlJHXWc596.png\"\n                        alt=\"图片2.png\"\n                        data-nodeid=\"4560\"\n                      />\n                    </p>\n                    <div data-nodeid=\"4536\">\n                      <p style=\"text-align: center\">\n                        （图片来自于 Google 搜索）\n                      </p>\n                    </div>\n\n                    <p data-nodeid=\"3424\">下面我为你总结下 RPC 调用的流程：</p>\n                    <ul data-nodeid=\"3425\">\n                      <li data-nodeid=\"3426\">\n                        <p data-nodeid=\"3427\">\n                          客户端（Client）调用客户端存根（Client\n                          Stub），同时把参数传给客户端存根；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3428\">\n                        <p data-nodeid=\"3429\">\n                          客户端存根将参数打包编码，并通过系统调用发送到服务端；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3430\">\n                        <p data-nodeid=\"3431\">\n                          客户端本地系统发送信息到服务器；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3432\">\n                        <p data-nodeid=\"3433\">\n                          服务器系统将信息发送到服务端存根（Server Stub）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3434\">\n                        <p data-nodeid=\"3435\">\n                          服务端存根解析信息，也就是解码；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3436\">\n                        <p data-nodeid=\"3437\">\n                          服务端存根调用真正的服务端程序（Sever）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3438\">\n                        <p data-nodeid=\"3439\">\n                          服务端（Server）处理后，通过同样的方式，把结果再返回给客户端（Client）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3440\">\n                      RPC\n                      调用常用于大型项目，也就是我们现在常说的微服务，而且还会包含服务注册、治理、监控等功能，是一套完整的体系。\n                    </p>\n                    <h3 data-nodeid=\"3441\">Go 语言 RPC 简单入门</h3>\n                    <p data-nodeid=\"3442\">\n                      RPC这么流行，Go 语言当然不会错过，在 Go SDK\n                      中，已经<strong data-nodeid=\"3618\"\n                        >内置了 net/rpc 包</strong\n                      >来帮助开发者实现 RPC。简单来说，net/rpc\n                      包提供了通过网络访问服务端对象方法的能力。\n                    </p>\n                    <p data-nodeid=\"3443\">\n                      现在我通过一个加法运算来演示\n                      RPC的使用，它的服务端代码如下所示：\n                    </p>\n                    <p data-nodeid=\"3444\">\n                      <em data-nodeid=\"3625\">ch22/server/math_service.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">package</span> server\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">type</span> MathService <span class=\"hljs-keyword\">struct</span> {\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">type</span> Args <span class=\"hljs-keyword\">struct</span> {\n</div></li><li><div class=\"code-word\">   A, B <span class=\"hljs-keyword\">int</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(m *MathService)</span> <span class=\"hljs-title\">Add</span><span class=\"hljs-params\">(args Args, reply *<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">error</span></span> {\n</div></li><li><div class=\"code-word\">   *reply = args.A + args.B\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3446\">在以上代码中：</p>\n                    <ul data-nodeid=\"3447\">\n                      <li data-nodeid=\"3448\">\n                        <p data-nodeid=\"3449\">\n                          定义了<strong data-nodeid=\"3632\">MathService</strong\n                          >，用于表示一个远程服务对象；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3450\">\n                        <p data-nodeid=\"3451\">Args 结构体用于表示参数；</p>\n                      </li>\n                      <li data-nodeid=\"3452\">\n                        <p data-nodeid=\"3453\">\n                          Add 这个方法实现了加法的功能，加法的结果通过\n                          replay这个指针变量返回。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3454\">\n                      有了这个定义好的服务对象，就可以把它注册到暴露的服务列表中，以供其他客户端使用了。在Go\n                      语言中，要注册一个一个RPC 服务对象还是比较简单的，通过\n                      RegisterName 方法即可，示例代码如下所示：\n                    </p>\n                    <p data-nodeid=\"3455\">\n                      <em data-nodeid=\"3641\">ch22/server_main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">package</span> main\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> (\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"gotour/ch22/server\"</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"log\"</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"net\"</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"net/rpc\"</span>\n</div></li><li><div class=\"code-word\">)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n</div></li><li><div class=\"code-word\">   rpc.RegisterName(<span class=\"hljs-string\">\"MathService\"</span>,<span class=\"hljs-built_in\">new</span>(server.MathService))\n</div></li><li><div class=\"code-word\">   l, e := net.Listen(<span class=\"hljs-string\">\"tcp\"</span>, <span class=\"hljs-string\">\":1234\"</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> e != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">      log.Fatal(<span class=\"hljs-string\">\"listen error:\"</span>, e)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   rpc.Accept(l)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3457\">\n                      以上示例代码中，通过 RegisterName\n                      函数注册了一个服务对象，该函数接收两个参数：\n                    </p>\n                    <ul data-nodeid=\"3458\">\n                      <li data-nodeid=\"3459\">\n                        <p data-nodeid=\"3460\">服务名称（MathService）；</p>\n                      </li>\n                      <li data-nodeid=\"3461\">\n                        <p data-nodeid=\"3462\">\n                          具体的服务对象，也就是我刚刚定义好的MathService\n                          这个结构体。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3463\">\n                      然后通过 net.Listen 函数建立一个TCP 链接，在 1234\n                      端口进行监听，最后通过 rpc.Accept 函数在该 TCP 链接上提供\n                      MathService 这个 RPC\n                      服务。现在客户端就可以看到MathService这个服务以及它的Add\n                      方法了。\n                    </p>\n                    <p data-nodeid=\"3464\">\n                      任何一个框架都有自己的规则，net/rpc 这个 Go 语言提供的RPC\n                      框架也不例外。要想把一个对象注册为 RPC 服务，可以让<strong\n                        data-nodeid=\"3651\"\n                        >客户端远程访问</strong\n                      >，那么该对象（类型）的方法必须满足如下条件：\n                    </p>\n                    <ul data-nodeid=\"3465\">\n                      <li data-nodeid=\"3466\">\n                        <p data-nodeid=\"3467\">\n                          方法的类型是可导出的（公开的）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3468\">\n                        <p data-nodeid=\"3469\">方法本身也是可导出的；</p>\n                      </li>\n                      <li data-nodeid=\"3470\">\n                        <p data-nodeid=\"3471\">\n                          方法必须有 2 个参数，并且参数类型是可导出或者内建的；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3472\">\n                        <p data-nodeid=\"3473\">方法必须返回一个 error 类型。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3474\">总结下来，该方法的格式如下所示：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t *T)</span> <span class=\"hljs-title\">MethodName</span><span class=\"hljs-params\">(argType T1, replyType *T2)</span> <span class=\"hljs-title\">error</span></span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3476\">\n                      这里面的 T1、T2都是可以被 encoding/gob 序列化的。\n                    </p>\n                    <ul data-nodeid=\"3477\">\n                      <li data-nodeid=\"3478\">\n                        <p data-nodeid=\"3479\">\n                          第一个参数 argType 是调用者（客户端）提供的；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3480\">\n                        <p data-nodeid=\"3481\">\n                          第二个参数\n                          replyType是返回给调用者结果，必须是指针类型。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3482\">\n                      有了提供好的RPC\n                      服务，现在再来看下客户端如何调用，它的代码如下所示：\n                    </p>\n                    <p data-nodeid=\"3483\">\n                      <em data-nodeid=\"3666\">ch22/client_main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">package</span> main\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> (\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"fmt\"</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"gotour/ch22/server\"</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"log\"</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-string\">\"net/rpc\"</span>\n</div></li><li><div class=\"code-word\">)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n</div></li><li><div class=\"code-word\">   client, err := rpc.Dial(<span class=\"hljs-string\">\"tcp\"</span>,  <span class=\"hljs-string\">\"localhost:1234\"</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">      log.Fatal(<span class=\"hljs-string\">\"dialing:\"</span>, err)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   args := server.Args{A:<span class=\"hljs-number\">7</span>,B:<span class=\"hljs-number\">8</span>}\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">var</span> reply <span class=\"hljs-keyword\">int</span>\n</div></li><li><div class=\"code-word\">   err = client.Call(<span class=\"hljs-string\">\"MathService.Add\"</span>, args, &amp;reply)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">      log.Fatal(<span class=\"hljs-string\">\"MathService.Add error:\"</span>, err)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   fmt.Printf(<span class=\"hljs-string\">\"MathService.Add: %d+%d=%d\"</span>, args.A, args.B, reply)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3485\">\n                      在以上实例代码中，首先通过 rpc.Dial 函数建立 TCP\n                      链接，需要注意的是这里的 IP、端口要和RPC\n                      服务提供的一致，确保可以建立 RCP 链接。\n                    </p>\n                    <p data-nodeid=\"3486\">\n                      TCP\n                      链接建立成功后，就需要准备远程方法需要的参数，也就是示例中的args\n                      和 reply。参数准备好之后，就可以通过 Call\n                      方法调用远程的RPC 服务了。Call 方法有 3\n                      个参数，它们的作用分别如下所示：\n                    </p>\n                    <ol data-nodeid=\"3487\">\n                      <li data-nodeid=\"3488\">\n                        <p data-nodeid=\"3489\">\n                          调用的远程方法的名字，这里是MathService.Add，点前面的部分是<strong\n                            data-nodeid=\"3678\"\n                            >注册的服务的名称</strong\n                          >，点后面的部分是<strong data-nodeid=\"3679\"\n                            >该服务的方法</strong\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3490\">\n                        <p data-nodeid=\"3491\">\n                          客户端为了<strong data-nodeid=\"3685\"\n                            >调用远程方法</strong\n                          >提供的参数，示例中是args；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3492\">\n                        <p data-nodeid=\"3493\">\n                          为了接收远程方法返回的结果，必须是一个指针，也就是示例中的&amp;\n                          replay，这样客户端就可以获得服务端返回的结果了。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"3494\">\n                      服务端和客户端的代码都写好了，现在就可以运行它们，测试\n                      RPC调用的效果了。\n                    </p>\n                    <p data-nodeid=\"3495\">\n                      首先运行服务端的代码，提供 RPC 服务，运行命令如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"shell\"><ol><li><div class=\"code-word\">➜&nbsp;go run ch22/server_main.go\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3497\">\n                      然后运行客户端代码，测试调用 RPC的结果，运行命令如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"shell\"><ol><li><div class=\"code-word\">➜&nbsp;go run ch22/client_main.go\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3499\">\n                      如果你看到了 MathService.Add:\n                      7+8=15的结果，那么恭喜你，你完成了一个完整的RPC 调用。\n                    </p>\n                    <h3 data-nodeid=\"3500\">基于 HTTP的RPC</h3>\n                    <p data-nodeid=\"3501\">\n                      RPC 除了可以通过 TCP 协议调用之外，还可以通过HTTP\n                      协议进行调用，而且内置的net/rpc\n                      包已经支持，现在我修改以上示例代码，支持 HTTP\n                      协议的调用，服务端代码如下所示：\n                    </p>\n                    <p data-nodeid=\"3502\">\n                      <em data-nodeid=\"3700\">ch22/server_main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   rpc.RegisterName(<span class=\"hljs-string\">\"MathService\"</span>, <span class=\"hljs-built_in\">new</span>(server.MathService))\n</div></li><li><div class=\"code-word\">   rpc.HandleHTTP()<span class=\"hljs-comment\">//新增的</span>\n</div></li><li><div class=\"code-word\">   l, e := net.Listen(<span class=\"hljs-string\">\"tcp\"</span>, <span class=\"hljs-string\">\":1234\"</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> e != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">      log.Fatal(<span class=\"hljs-string\">\"listen error:\"</span>, e)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   http.Serve(l, <span class=\"hljs-literal\">nil</span>)<span class=\"hljs-comment\">//换成http的服务</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3504\">\n                      以上是服务端代码的修改，只需修改两处，我已经在代码中标注出来了，很容易理解。\n                    </p>\n                    <p data-nodeid=\"3505\">\n                      服务端修改的代码不算多，客户端修改的代码就更少了，只需要修改一处即可，修改的部分如下所示：\n                    </p>\n                    <p data-nodeid=\"3506\">\n                      <em data-nodeid=\"3708\">ch22/client_main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n</div></li><li><div class=\"code-word\">   client, err := rpc.DialHTTP(<span class=\"hljs-string\">\"tcp\"</span>,  <span class=\"hljs-string\">\"localhost:1234\"</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//省略了其他没有修改的代码</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3508\">\n                      从以上代码可以看到，只需要把建立链接的方法从 Dial 换成\n                      DialHTTP 即可。\n                    </p>\n                    <p data-nodeid=\"3509\">\n                      现在分别运行服务端和客户端代码，就可以看到输出的结果了，和上面使用TCP\n                      链接时是一样的。\n                    </p>\n                    <p data-nodeid=\"3510\">\n                      此外，Go 语言 net/rpc 包提供的 HTTP 协议的 RPC\n                      还有一个调试的 URL，运行服务端代码后，在浏览器中输入\n                      http://localhost:1234/debug/rpc\n                      回车，即可看到服务端注册的RPC\n                      服务，以及每个服务的方法，如下图所示：\n                    </p>\n                    <p data-nodeid=\"3511\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8D/2F/Ciqc1F_7zbWAb5PXAAA7zm9tcRE148.png\"\n                        alt=\"image (3).png\"\n                        data-nodeid=\"3714\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3512\">\n                      如上图所示，<strong data-nodeid=\"3728\"\n                        >注册的 RPC 服务</strong\n                      >、<strong data-nodeid=\"3729\">方法的签名</strong>、<strong\n                        data-nodeid=\"3730\"\n                        >已经被调用的次数</strong\n                      >都可以看到。\n                    </p>\n                    <h3 data-nodeid=\"3513\">JSON RPC 跨平台通信</h3>\n                    <p data-nodeid=\"3514\">\n                      以上我实现的RPC 服务是基于 gob\n                      编码的，这种编码在跨语言调用的时候比较困难，而当前在微服务架构中，RPC\n                      服务的实现者和调用者都可能是不同的编程语言，因此我们实现的\n                      RPC 服务要支持多语言的调用。\n                    </p>\n                    <h4 data-nodeid=\"3515\">基于 TCP 的 JSON RPC</h4>\n                    <p data-nodeid=\"3516\">\n                      实现跨语言 RPC 服务的核心在于选择一个<strong\n                        data-nodeid=\"3739\"\n                        >通用的编码</strong\n                      >，这样大多数语言都支持，比如常用的JSON。在 Go\n                      语言中，实现一个 JSON RPC 服务非常简单，只需要使用\n                      net/rpc/jsonrpc 包即可。\n                    </p>\n                    <p data-nodeid=\"3517\">\n                      同样以上面的示例为例，我把它改造成支持 JSON的RPC\n                      服务，服务端代码如下所示：\n                    </p>\n                    <p data-nodeid=\"3518\">\n                      <em data-nodeid=\"3746\">ch22/server_main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   rpc.RegisterName(<span class=\"hljs-string\">\"MathService\"</span>, <span class=\"hljs-built_in\">new</span>(server.MathService))\n</div></li><li><div class=\"code-word\">   l, e := net.Listen(<span class=\"hljs-string\">\"tcp\"</span>, <span class=\"hljs-string\">\":1234\"</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> e != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">      log.Fatal(<span class=\"hljs-string\">\"listen error:\"</span>, e)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">for</span> {\n</div></li><li><div class=\"code-word\">      conn, err := l.Accept()\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">         log.Println(<span class=\"hljs-string\">\"jsonrpc.Serve: accept:\"</span>, err.Error())\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">//json rpc</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">go</span> jsonrpc.ServeConn(conn)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3520\">\n                      从以上代码可以看到，相比 gob 编码的RPC 服务，JSON 的 RPC\n                      服务是把链接交给了jsonrpc.ServeConn这个函数处理，达到了基于\n                      JSON 进行 RPC 调用的目的。\n                    </p>\n                    <p data-nodeid=\"3521\">\n                      JSON RPC\n                      的客户端代码也非常少，只需要修改一处，修改的部分如下所示：\n                    </p>\n                    <p data-nodeid=\"3522\">\n                      <em data-nodeid=\"3754\">ch22/client_main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n</div></li><li><div class=\"code-word\">   client, err := jsonrpc.Dial(<span class=\"hljs-string\">\"tcp\"</span>,  <span class=\"hljs-string\">\"localhost:1234\"</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//省略了其他没有修改的代码</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3524\">\n                      从以上代码可以看到，只需要把建立链接的 Dial方法换成\n                      jsonrpc 包中的即可。\n                    </p>\n                    <p data-nodeid=\"3525\">\n                      以上是使用 Go 语言作为客户端调用 RPC\n                      服务的示例，其他编程语言也是类似的，只需要遵守\n                      <a\n                        href=\"https://www.jsonrpc.org/specification\"\n                        data-nodeid=\"3759\"\n                        >JSON-RPC 规范</a\n                      >即可。\n                    </p>\n                    <h4 data-nodeid=\"3526\">基于 HTTP的JSON RPC</h4>\n                    <p data-nodeid=\"3527\">\n                      相比基于 TCP 调用的RPC 来说，使用\n                      HTTP肯定会更方便，也更通用。Go 语言内置的jsonrpc\n                      并没有实现基于\n                      HTTP的传输，所以就需要自己来实现，这里我参考 gob\n                      编码的HTTP RPC 实现方式，来<strong data-nodeid=\"3767\"\n                        >实现基于 HTTP的JSON RPC 服务</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"3528\">\n                      还是上面的示例，我改造下让其支持 HTTP 协议，RPC\n                      服务端代码如下所示：\n                    </p>\n                    <p data-nodeid=\"3529\">\n                      <em data-nodeid=\"3774\">ch22/server_main.go</em>\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n</div></li><li><div class=\"code-word\">   rpc.RegisterName(<span class=\"hljs-string\">\"MathService\"</span>, <span class=\"hljs-built_in\">new</span>(server.MathService))\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">//注册一个path，用于提供基于http的json rpc服务</span>\n</div></li><li><div class=\"code-word\">   http.HandleFunc(rpc.DefaultRPCPath, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(rw http.ResponseWriter, r *http.Request)</span></span> {\n</div></li><li><div class=\"code-word\">      conn, _, err := rw.(http.Hijacker).Hijack()\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">         log.Print(<span class=\"hljs-string\">\"rpc hijacking \"</span>, r.RemoteAddr, <span class=\"hljs-string\">\": \"</span>, err.Error())\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">var</span> connected = <span class=\"hljs-string\">\"200 Connected to JSON RPC\"</span>\n</div></li><li><div class=\"code-word\">      io.WriteString(conn, <span class=\"hljs-string\">\"HTTP/1.0 \"</span>+connected+<span class=\"hljs-string\">\"\\n\\n\"</span>)\n</div></li><li><div class=\"code-word\">      jsonrpc.ServeConn(conn)\n</div></li><li><div class=\"code-word\">   })\n</div></li><li><div class=\"code-word\">   l, e := net.Listen(<span class=\"hljs-string\">\"tcp\"</span>, <span class=\"hljs-string\">\":1234\"</span>)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> e != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">      log.Fatal(<span class=\"hljs-string\">\"listen error:\"</span>, e)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   http.Serve(l, <span class=\"hljs-literal\">nil</span>)<span class=\"hljs-comment\">//换成http的服务</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3531\">\n                      以上代码的实现基于 HTTP 协议的核心，即使用 http.HandleFunc\n                      注册了一个 path，对外提供基于 HTTP 的 JSON RPC\n                      服务。在这个 HTTP\n                      服务的实现中，通过Hijack方法劫持链接，然后转交给 jsonrpc\n                      处理，这样就实现了基于 HTTP 协议的 JSON RPC 服务。\n                    </p>\n                    <p data-nodeid=\"3532\">\n                      实现了服务端的代码后，现在开始实现客户端调用，它的代码如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"go\"><ol><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n</div></li><li><div class=\"code-word\">     client, err := DialHTTP(<span class=\"hljs-string\">\"tcp\"</span>,  <span class=\"hljs-string\">\"localhost:1234\"</span>)\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">        log.Fatal(<span class=\"hljs-string\">\"dialing:\"</span>, err)\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">     args := server.Args{A:<span class=\"hljs-number\">7</span>,B:<span class=\"hljs-number\">8</span>}\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">var</span> reply <span class=\"hljs-keyword\">int</span>\n</div></li><li><div class=\"code-word\">     err = client.Call(<span class=\"hljs-string\">\"MathService.Add\"</span>, args, &amp;reply)\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">        log.Fatal(<span class=\"hljs-string\">\"MathService.Add error:\"</span>, err)\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">     fmt.Printf(<span class=\"hljs-string\">\"MathService.Add: %d+%d=%d\"</span>, args.A, args.B, reply)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// DialHTTP connects to an HTTP RPC server at the specified network address</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// listening on the default HTTP RPC path.</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">DialHTTP</span><span class=\"hljs-params\">(network, address <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(*rpc.Client, error)</span></span> {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> DialHTTPPath(network, address, rpc.DefaultRPCPath)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// DialHTTPPath connects to an HTTP RPC server</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// at the specified network address and path.</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">DialHTTPPath</span><span class=\"hljs-params\">(network, address, path <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(*rpc.Client, error)</span></span> {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">var</span> err error\n</div></li><li><div class=\"code-word\">     conn, err := net.Dial(network, address)\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">     io.WriteString(conn, <span class=\"hljs-string\">\"GET \"</span>+path+<span class=\"hljs-string\">\" HTTP/1.0\\n\\n\"</span>)\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-comment\">// Require successful HTTP response</span>\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-comment\">// before switching to RPC protocol.</span>\n</div></li><li><div class=\"code-word\">     resp, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request{Method: <span class=\"hljs-string\">\"GET\"</span>})\n</div></li><li><div class=\"code-word\">     connected := <span class=\"hljs-string\">\"200 Connected to JSON RPC\"</span>\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> &amp;&amp; resp.Status == connected {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> jsonrpc.NewClient(conn), <span class=\"hljs-literal\">nil</span>\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> {\n</div></li><li><div class=\"code-word\">        err = errors.New(<span class=\"hljs-string\">\"unexpected HTTP response: \"</span> + resp.Status)\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">     conn.Close()\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, &amp;net.OpError{\n</div></li><li><div class=\"code-word\">        Op:   <span class=\"hljs-string\">\"dial-http\"</span>,\n</div></li><li><div class=\"code-word\">        Net:  network + <span class=\"hljs-string\">\" \"</span> + address,\n</div></li><li><div class=\"code-word\">        Addr: <span class=\"hljs-literal\">nil</span>,\n</div></li><li><div class=\"code-word\">        Err:  err,\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3534\">\n                      以上这段代码的核心在于通过建立好的TCP 链接，发送 HTTP\n                      请求调用远程的HTTP JSON RPC 服务，这里使用的是 HTTP GET\n                      方法。\n                    </p>\n                    <p data-nodeid=\"3535\">\n                      分别运行服务端和客户端，就可以看到正确的HTTP JSON RPC\n                      调用结果了。\n                    </p>\n                    <h3 data-nodeid=\"3536\">总结</h3>\n                    <p data-nodeid=\"3537\">\n                      这一讲基于 Go 语言自带的RPC 框架，讲解了 RPC\n                      服务的实现以及调用。通过这一讲的学习相信你可以很好地了解什么是\n                      RPC 服务，基于 TCP 和 HTTP 实现的RPC\n                      服务有什么不同，它们是如何实现的等等。\n                    </p>\n                    <p data-nodeid=\"3538\">\n                      不过在实际的项目开发中，使用Go 语言自带的 RPC\n                      框架并不多，但是这里我还是以自带的框架为例进行讲解，这样可以更好地理解\n                      RPC\n                      的使用以及实现原理。如果你可以很好地掌握它们，那么你使用第三方的\n                      RPC 框架也可以很快上手。\n                    </p>\n                    <p data-nodeid=\"3539\" class=\"\">\n                      在实际的项目中，比较常用的是Google的gRPC\n                      框架，它是通过Protobuf 序列化的，是基于 HTTP/2\n                      协议的二进制传输，并且支持很多编程语言，效率也比较高。关于\n                      gRPC的使用可以看官网的文档，入门是很容易的。\n                    </p>\n            "}