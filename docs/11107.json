{"title":"06 | 类类型：如何高效使用类型化的面向对象编程利器？","context":"\n                    <p data-nodeid=\"973\" class=\"\">【黑马】2</p>\n                    <p data-nodeid=\"5638\" class=\"te-preview-highlight\">\n                      05 讲我们学习了 TypeScript\n                      中抽象、封装的利器——函数类型，接下来我们将学习另一个集面向对象继承、封装、多态三要素为一体的编程利器，类类型。\n                    </p>\n\n                    <blockquote data-nodeid=\"975\">\n                      <p data-nodeid=\"976\">\n                        学习建议：请使用 VS Code，新建一个 06.ts\n                        文件尝试以下所有示例，以便帮助你更好地理解、吸收知识。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"977\">\n                      在JavaScript（ES5）中仅支持通过函数和原型链继承模拟类的实现（用于抽象业务模型、组织数据结构并创建可重用组件），自\n                      ES6 引入 class 关键字后，它才开始支持使用与<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1068\"\n                        >Java</code\n                      >类似的语法定义声明类。\n                    </p>\n                    <p data-nodeid=\"978\">\n                      TypeScript 作为 JavaScript 的超集，自然也支持 class\n                      的全部特性，并且还可以对类的属性、方法等进行静态类型检测。\n                    </p>\n                    <h3 data-nodeid=\"979\">类</h3>\n                    <p data-nodeid=\"980\">\n                      在实际业务中，任何实体都可以被抽象为一个使用类表达的类似对象的数据结构，且这个数据结构既包含属性，又包含方法，比如我们在下方抽象了一个狗的类。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Dog {\n</div></li><li><div class=\"code-word\"> &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"> &nbsp;bark() {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog(<span class=\"hljs-string\">'Q'</span>);\n</div></li><li><div class=\"code-word\">dog.bark(); <span class=\"hljs-comment\">// =&gt; 'Woof! Woof!'</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"982\">\n                      首先，我们定义了一个 class Dog ，它拥有 string 类型的 name\n                      属性（见第 2 行）、bark 方法（见第 7\n                      行）和一个构造器函数（见第 3 行）。然后，我们通过 new\n                      关键字创建了一个 Dog 的实例，并把实例赋值给变量 dog（见 12\n                      行）。最后，我们通过实例调用了类中定义的 bark 方法（见 13\n                      行）。\n                    </p>\n                    <p data-nodeid=\"983\">\n                      如果使用传统的 JavaScript\n                      代码定义类，我们需要使用函数+原型链的形式进行模拟，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Dog</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) </span>{\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">this</span>.name = name; <span class=\"hljs-comment\">// ts(2683) 'this' implicitly has type 'any' because it does not have a type annotation.</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">Dog.prototype.bark = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n</div></li><li><div class=\"code-word\">};\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog(<span class=\"hljs-string\">'Q'</span>); <span class=\"hljs-comment\">// ts(7009) 'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.</span>\n</div></li><li><div class=\"code-word\">dog.bark(); <span class=\"hljs-comment\">// =&gt; 'Woof! Woof!'</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"985\">\n                      在第 1～ 3 行，我们定义了 Dog\n                      类的构造函数，并在构造函数内部定义了 name 属性，再在第 4\n                      行通过 Dog 的原型链添加 bark 方法。\n                    </p>\n                    <p data-nodeid=\"986\">\n                      和通过 class\n                      方式定义类相比，这种方式明显麻烦不少，而且还缺少静态类型检测。因此，类是\n                      TypeScript 编程中十分有用且不得不掌握的工具。\n                    </p>\n                    <p data-nodeid=\"987\">\n                      下面我们看一下关于类最主要的特性——继承，也是面向对象编程三大要素之一。\n                    </p>\n                    <h3 data-nodeid=\"988\">继承</h3>\n                    <p data-nodeid=\"989\">\n                      在 TypeScript 中，使用 extends\n                      关键字就能很方便地定义类继承的抽象模式，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Animal {\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">type</span> = <span class=\"hljs-string\">'Animal'</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;say(name: <span class=\"hljs-built_in\">string</span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`I'm <span class=\"hljs-subst\">${name}</span>!\\`</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n</div></li><li><div class=\"code-word\"> &nbsp;bark() {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> Dog();\n</div></li><li><div class=\"code-word\">dog.bark(); <span class=\"hljs-comment\">// =&gt; 'Woof! Woof!'</span>\n</div></li><li><div class=\"code-word\">dog.say(<span class=\"hljs-string\">'Q'</span>); <span class=\"hljs-comment\">// =&gt; I'm Q!</span>\n</div></li><li><div class=\"code-word\">dog.type; <span class=\"hljs-comment\">// =&gt; Animal</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"991\">\n                      上面的例子展示了类最基本的继承用法。比如第 8 ～12\n                      行定义的<code data-backticks=\"1\" data-nodeid=\"1081\"\n                        >Dog</code\n                      >是派生类，它派生自第 1～6 行定义的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1083\"\n                        >Animal</code\n                      >基类，此时<code data-backticks=\"1\" data-nodeid=\"1085\"\n                        >Dog</code\n                      >实例继承了基类<code data-backticks=\"1\" data-nodeid=\"1087\"\n                        >Animal</code\n                      >的属性和方法。因此，在第 15～17 行我们可以看到，实例 dog\n                      支持 bark、say、type 等属性和方法。\n                    </p>\n                    <blockquote data-nodeid=\"992\">\n                      <p data-nodeid=\"993\">\n                        说明：派生类通常被称作子类，基类也被称作超类（或者父类）。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"994\">\n                      细心的你可能发现了，这里的 Dog\n                      基类与第一个例子中的类相比，少了一个构造函数。<strong\n                        data-nodeid=\"1094\"\n                        >这是因为派生类如果包含一个构造函数，则必须在构造函数中调用\n                        super() 方法，这是 TypeScript\n                        强制执行的一条重要规则。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"995\">\n                      如下示例，因为第 1～10 行定义的 Dog 类构造函数中没有调用\n                      super 方法，所以提示了一个 ts(2377) 的错误；而第 12～22\n                      行定义的 Dog 类构造函数中添加了 super\n                      方法调用，所以可以通过类型检测。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n</div></li><li><div class=\"code-word\"> &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) { <span class=\"hljs-comment\">// ts(2377) Constructors for derived classes must contain a 'super' call.</span>\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"> &nbsp;bark() {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n</div></li><li><div class=\"code-word\"> &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">super</span>(); <span class=\"hljs-comment\">// 添加 super 方法</span>\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"> &nbsp;bark() {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"997\">\n                      有些同学可能会好奇，这里的 super() 是什么作用？其实这里的\n                      super 函数会调用基类的构造函数，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Animal {\n</div></li><li><div class=\"code-word\"> &nbsp;weight: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">type</span> = <span class=\"hljs-string\">'Animal'</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">weight: <span class=\"hljs-built_in\">number</span></span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.weight = weight;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"> &nbsp;say(name: <span class=\"hljs-built_in\">string</span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`I'm <span class=\"hljs-subst\">${name}</span>!\\`</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n</div></li><li><div class=\"code-word\"> &nbsp;name: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">super</span>(); <span class=\"hljs-comment\">// ts(2554) Expected 1 arguments, but got 0.</span>\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.name = name;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"> &nbsp;bark() {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Woof! Woof!'</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"999\">\n                      将鼠标放到第 15 行 Dog 类构造函数调用的 super\n                      函数上，我们可以看到一个提示，它的类型是基类 Animal\n                      的构造函数：constructor Animal(weight: number): Animal\n                      。并且因为 Animal 类的构造函数要求必须传入一个数字类型的\n                      weight 参数，而第 15 行实际入参为空，所以提示了一个\n                      ts(2554) 的错误；如果我们显式地给 super 函数传入一个\n                      number 类型的值，比如说 super(20)，则不会再提示错误了。\n                    </p>\n                    <h3 data-nodeid=\"1000\">公共、私有与受保护的修饰符</h3>\n                    <p data-nodeid=\"1001\">\n                      类属性和方法除了可以通过 extends\n                      被继承之外，还可以通过修饰符控制可访问性。\n                    </p>\n                    <p data-nodeid=\"1002\">\n                      在 TypeScript 中就支持 3 种访问修饰符，分别是\n                      public、private、protected。\n                    </p>\n                    <ul data-nodeid=\"1003\">\n                      <li data-nodeid=\"1004\">\n                        <p data-nodeid=\"1005\">\n                          public 修饰的是在任何地方可见、公有的属性或方法；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1006\">\n                        <p data-nodeid=\"1007\">\n                          private 修饰的是仅在同一类中可见、私有的属性或方法；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1008\">\n                        <p data-nodeid=\"1009\">\n                          protected\n                          修饰的是仅在类自身及子类中可见、受保护的属性或方法。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1010\">\n                      在之前的代码中，示例类并没有用到可见性修饰符，在缺省情况下，类的属性或方法默认都是\n                      public。如果想让有些属性对外不可见，那么我们可以使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1105\"\n                        >private</code\n                      >进行设置，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Son {\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">public</span> firstName: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">private</span> lastName: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Stark'</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.firstName = firstName;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.lastName; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> son = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">'Tony'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(son.firstName); <span class=\"hljs-comment\">//  =&gt; \"Tony\"</span>\n</div></li><li><div class=\"code-word\">son.firstName = <span class=\"hljs-string\">'Jack'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(son.firstName); <span class=\"hljs-comment\">//  =&gt; \"Jack\"</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(son.lastName); <span class=\"hljs-comment\">// ts(2341) Property 'lastName' is private and only accessible within class 'Son'.</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1012\">\n                      在上面的例子中我们可以看到，第 3 行 Son 类的 lastName\n                      属性是私有的，只在 Son 类中可见；第 2 行定义的 firstName\n                      属性是公有的，在任何地方都可见。因此，我们既可以通过第 10\n                      行创建的 Son 类的实例 son 获取或设置公共的 firstName\n                      的属性（如第 11 行所示），还可以操作更改 firstName\n                      的值（如第 12 行所示）。\n                    </p>\n                    <p data-nodeid=\"1013\">\n                      不过，对于 private\n                      修饰的私有属性，只可以在类的内部可见。比如第 6\n                      行，私有属性 lastName 仅在 Son\n                      类中可见，如果其他地方获取了 lastName ，TypeScript\n                      就会提示一个 ts(2341) 的错误（如第 14 行）。\n                    </p>\n                    <blockquote data-nodeid=\"1014\">\n                      <p data-nodeid=\"1015\">\n                        <strong data-nodeid=\"1113\">注意</strong>：TypeScript\n                        中定义类的私有属性仅仅代表静态类型检测层面的私有。如果我们强制忽略\n                        TypeScript 类型的检查错误，转译且运行 JavaScript\n                        时依旧可以获取到 lastName 属性，这是因为 JavaScript\n                        并不支持真正意义上的私有属性。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1016\">\n                      目前，JavaScript 类支持 private 修饰符的提案已经到 stage 3\n                      了。相信在不久的将来，私有属性在类型检测和运行阶段都可以被限制为仅在类的内部可见。如果你感兴趣的话，可以在<a\n                        href=\"https://github.com/tc39/proposal-private-methods?fileGuid=KLALBzHdpAQfyj7n\"\n                        data-nodeid=\"1117\"\n                        >proposal-private-methods</a\n                      >中进行查看。\n                    </p>\n                    <p data-nodeid=\"1017\">\n                      接下来我们再看一下受保护的属性和方法，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Son {\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">public</span> firstName: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">protected</span> lastName: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Stark'</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">this</span>.firstName = firstName;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.lastName; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> GrandSon <span class=\"hljs-keyword\">extends</span> Son {\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">super</span>(firstName);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">public</span> getMyLastName() {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.lastName;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> grandSon = <span class=\"hljs-keyword\">new</span> GrandSon(<span class=\"hljs-string\">'Tony'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(grandSon.getMyLastName()); <span class=\"hljs-comment\">// =&gt; \"Stark\"</span>\n</div></li><li><div class=\"code-word\">grandSon.lastName; <span class=\"hljs-comment\">// ts(2445) Property 'lastName' is protected and only accessible within class 'Son' and its subclasses.</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1019\">\n                      在第 3 行，修改 Son 类的 lastName 属性可见修饰符为\n                      protected，表明此属性在 Son 类及其子类中可见。如示例第 6\n                      行和第 16 行所示，我们既可以在父类 Son 的构造器中获取\n                      lastName 属性值，又可以在继承自 Son 的子类 GrandSon 的\n                      getMyLastName 方法获取 lastName 属性的值。\n                    </p>\n                    <blockquote data-nodeid=\"1020\">\n                      <p data-nodeid=\"1021\">\n                        <strong data-nodeid=\"1127\">需要注意</strong\n                        >：虽然我们不能通过派生类的实例访问<code\n                          data-backticks=\"1\"\n                          data-nodeid=\"1125\"\n                          >protected</code\n                        >修饰的属性和方法，但是可以通过派生类的实例方法进行访问。比如示例中的第\n                        21 行，通过实例的 getMyLastName 方法获取受保护的属性\n                        lastName 是 ok 的，而第 22\n                        行通过实例直接获取受保护的属性 lastName 则提示了一个\n                        ts(2445) 的错误。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"1022\">只读修饰符</h3>\n                    <p data-nodeid=\"1023\">\n                      在前面的例子中，Son 类 public\n                      修饰的属性既公开可见，又可以更改值，如果我们不希望类的属性被更改，则可以使用\n                      readonly 只读修饰符声明类的属性，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Son {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">public</span> readonly firstName: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.firstName = firstName;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> son = <span class=\"hljs-keyword\">new</span> Son(<span class=\"hljs-string\">'Tony'</span>);\n</div></li><li><div class=\"code-word\">son.firstName = <span class=\"hljs-string\">'Jack'</span>; <span class=\"hljs-comment\">// ts(2540) Cannot assign to 'firstName' because it is a read-only property.</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1025\">\n                      在第 2 行，我们给公开可见属性 firstName\n                      指定了只读修饰符，这个时候如果再更改 firstName\n                      属性的值，TypeScript 就会提示一个 ts(2540) 的错误（参见第\n                      9\n                      行）。这是因为只读属性修饰符保证了该属性只能被读取，而不能被修改。\n                    </p>\n                    <blockquote data-nodeid=\"1026\">\n                      <p data-nodeid=\"1027\">\n                        注意：如果只读修饰符和可见性修饰符同时出现，我们需要将只读修饰符写在可见修饰符后面。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"1028\">存取器</h3>\n                    <p data-nodeid=\"1029\">\n                      除了上边提到的修饰符之外，在 TypeScript 中还可以通过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1134\"\n                        >getter</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"1136\"\n                        >setter</code\n                      >截取对类成员的读写访问。\n                    </p>\n                    <p data-nodeid=\"1030\">\n                      通过对类属性访问的截取，我们可以实现一些特定的访问控制逻辑。下面我们把之前的示例改造一下，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Son {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">public</span> firstName: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">protected</span> lastName: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Stark'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.firstName = firstName;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> GrandSon <span class=\"hljs-keyword\">extends</span> Son {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">firstName: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">super</span>(firstName);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">get</span> myLastName() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.lastName;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">set</span> myLastName(name: <span class=\"hljs-built_in\">string</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.firstName === <span class=\"hljs-string\">'Tony'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">this</span>.lastName = name;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">'Unable to change myLastName'</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> grandSon = <span class=\"hljs-keyword\">new</span> GrandSon(<span class=\"hljs-string\">'Tony'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(grandSon.myLastName); <span class=\"hljs-comment\">// =&gt; \"Stark\"</span>\n</div></li><li><div class=\"code-word\">grandSon.myLastName = <span class=\"hljs-string\">'Rogers'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(grandSon.myLastName); <span class=\"hljs-comment\">// =&gt; \"Rogers\"</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> grandSon1 = <span class=\"hljs-keyword\">new</span> GrandSon(<span class=\"hljs-string\">'Tony1'</span>);\n</div></li><li><div class=\"code-word\">grandSon1.myLastName = <span class=\"hljs-string\">'Rogers'</span>; <span class=\"hljs-comment\">// =&gt; \"Unable to change myLastName\"</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1032\">\n                      在第 14～24 行，我们使用 myLastName 的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1140\"\n                        >getter</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"1142\"\n                        >setter</code\n                      >重写了之前的 GrandSon 类的方法，在 getter 中实际返回的是\n                      lastName 属性。然后，在 setter 中，我们限定仅当 lastName\n                      属性值为 'Tony' ，才把入参 name\n                      赋值给它，否则打印错误。<br />\n                      在第 28 行中，我们可以像访问类属性一样访问<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1150\"\n                        >getter</code\n                      >，同时也可以像更改属性值一样给<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1152\"\n                        >setter</code\n                      >赋值，并执行一些自定义逻辑。\n                    </p>\n                    <p data-nodeid=\"1033\">\n                      在第 27 行，因为 grandSon 实例的 lastName 属性被初始化成了\n                      'Tony'，所以在第 29 行我们可以把 'Rogers' 赋值给 setter\n                      。而 grandSon1 实例的 lastName 属性在第 32 行被初始化为\n                      'Tony1'，所以在第 33 行把 'Rogers' 赋值给 setter\n                      时，打印了我们自定义的错误信息。\n                    </p>\n                    <h3 data-nodeid=\"1034\">静态属性</h3>\n                    <p data-nodeid=\"1035\">\n                      以上介绍的关于类的所有属性和方法，只有类在实例化时才会被初始化。实际上，我们也可以给类定义静态属性和方法。\n                    </p>\n                    <p data-nodeid=\"1036\">\n                      因为这些属性存在于类这个特殊的对象上，而不是类的实例上，所以我们可以直接通过类访问静态属性，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> MyArray {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">static</span> displayName = <span class=\"hljs-string\">'MyArray'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">static</span> isArray(obj: unknown) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj).slice(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">-1</span>) === <span class=\"hljs-string\">'Array'</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(MyArray.displayName); <span class=\"hljs-comment\">// =&gt; \"MyArray\"</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(MyArray.isArray([])); <span class=\"hljs-comment\">// =&gt; true</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(MyArray.isArray({})); <span class=\"hljs-comment\">// =&gt; false</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1038\">\n                      在第 2～3 行，通过 static 修饰符，我们给 MyArray\n                      类分别定义了一个静态属性 displayName 和静态方法\n                      isArray。之后，我们无须实例化 MyArray\n                      就可以直接访问类上的静态属性和方法了，比如第 8\n                      行访问的是静态属性 displayName，第 9～10\n                      行访问的是静态方法 isArray。\n                    </p>\n                    <p data-nodeid=\"1039\">\n                      基于静态属性的特性，我们往往会把与类相关的常量、不依赖实例\n                      this\n                      上下文的属性和方法定义为静态属性，从而避免数据冗余，进而提升运行性能。\n                    </p>\n                    <blockquote data-nodeid=\"1040\">\n                      <p data-nodeid=\"1041\">\n                        <strong data-nodeid=\"1179\"\n                          >注意：上边我们提到了不依赖实例 this\n                          上下文的方法就可以定义成静态方法，这就意味着需要显式注解\n                          this 类型才可以在静态方法中使用\n                          this；非静态方法则不需要显式注解 this 类型，因为 this\n                          的指向默认是类的实例。</strong\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"1042\">抽象类</h3>\n                    <p data-nodeid=\"1043\">\n                      接下来我们看看关于类的另外一个特性——抽象类，它是一种不能被实例化仅能被子类继承的特殊类。\n                    </p>\n                    <p data-nodeid=\"1044\">\n                      我们可以使用抽象类定义派生类需要实现的属性和方法，同时也可以定义其他被继承的默认属性和方法，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> Adder {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">abstract</span> x: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">abstract</span> y: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">abstract</span> add(): <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">  displayName = <span class=\"hljs-string\">'Adder'</span>;\n</div></li><li><div class=\"code-word\">  addTwice(): <span class=\"hljs-built_in\">number</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y) * <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> NumAdder <span class=\"hljs-keyword\">extends</span> Adder {\n</div></li><li><div class=\"code-word\">  x: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">  y: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">super</span>();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.x = x;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.y = y;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  add(): <span class=\"hljs-built_in\">number</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> numAdder = <span class=\"hljs-keyword\">new</span> NumAdder(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(numAdder.displayName); <span class=\"hljs-comment\">// =&gt; \"Adder\"</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(numAdder.add()); <span class=\"hljs-comment\">// =&gt; 3</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(numAdder.addTwice()); <span class=\"hljs-comment\">// =&gt; 6</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1046\">\n                      在第 1～10 行，通过 abstract 关键字，我们定义了一个抽象类\n                      Adder，并通过<code data-backticks=\"1\" data-nodeid=\"1184\"\n                        >abstract</code\n                      >关键字定义了抽象属性<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1186\"\n                        >x</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"1188\">y</code\n                      >及方法<code data-backticks=\"1\" data-nodeid=\"1190\"\n                        >add</code\n                      >，而且任何继承 Adder\n                      的派生类都需要实现这些抽象属性和方法。\n                    </p>\n                    <p data-nodeid=\"1047\">\n                      同时，我们还在抽象类 Adder\n                      中定义了可以被派生类继承的非抽象属性<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1193\"\n                        >displayName</code\n                      >和方法<code data-backticks=\"1\" data-nodeid=\"1195\"\n                        >addTwice</code\n                      >。\n                    </p>\n                    <p data-nodeid=\"1048\">\n                      然后，我们在第 12～23 行定义了继承抽象类的派生类\n                      NumAdder， 并实现了抽象类里定义的 x、y 抽象属性和 add\n                      抽象方法。如果派生类中缺少对 x、y、add\n                      这三者中任意一个抽象成员的实现，那么第 12 行就会提示一个\n                      ts(2515) 错误，关于这点你可以亲自验证一下。\n                    </p>\n                    <p data-nodeid=\"1049\">\n                      抽象类中的其他非抽象成员则可以直接通过实例获取，比如第\n                      26～28 行中，通过实例 numAdder，我们获取了 displayName\n                      属性和 addTwice 方法。\n                    </p>\n                    <p data-nodeid=\"1050\">\n                      因为抽象类不能被实例化，并且派生类必须实现继承自抽象类上的抽象属性和方法定义，所以抽象类的作用其实就是对基础逻辑的封装和抽象。\n                    </p>\n                    <p data-nodeid=\"1051\">\n                      实际上，我们也可以定义一个描述对象结构的接口类型（详见 07\n                      讲）抽象类的结构，并通过 implements 关键字约束类的实现。\n                    </p>\n                    <p data-nodeid=\"1052\">\n                      使用接口与使用抽象类相比，区别在于接口只能定义类成员的类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">interface</span> IAdder {\n</div></li><li><div class=\"code-word\">&nbsp; x: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">&nbsp; y: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">&nbsp; add: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> NumAdder <span class=\"hljs-keyword\">implements</span> IAdder {\n</div></li><li><div class=\"code-word\">&nbsp; x: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">&nbsp; y: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span>, y: <span class=\"hljs-built_in\">number</span></span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">this</span>.x = x;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">this</span>.y = y;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; add() {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; addTwice() {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.x + <span class=\"hljs-keyword\">this</span>.y) * <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1054\">\n                      在第 1～5 行，我们定义了一个包含 x、y、add\n                      属性和方法的接口类型（详见 07 讲），然后在第 6～12\n                      行实现了拥有接口约定的x、y 属性和 add\n                      方法，以及接口未约定的 addTwice 方法的NumAdder类 。\n                    </p>\n                    <h3 data-nodeid=\"1055\">类的类型</h3>\n                    <p data-nodeid=\"1056\">\n                      类的最后一个特性——类的类型和函数类似，即在声明类的时候，其实也同时声明了一个特殊的类型（确切地讲是一个接口类型），这个类型的名字就是类名，表示类实例的类型；在定义类的时候，我们声明的除构造函数外所有属性、方法的类型就是这个特殊类型的成员。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> A {\n</div></li><li><div class=\"code-word\">  name: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">string</span></span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.name = name;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> a1: A = {}; <span class=\"hljs-comment\">// ts(2741) Property 'name' is missing in type '{}' but required in type 'A'.</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> a2: A = { name: <span class=\"hljs-string\">'a2'</span> }; <span class=\"hljs-comment\">// ok</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1058\">\n                      在第 1～6 行，我们在定义类 A\n                      ，也说明我们同时定义了一个包含字符串属性 name\n                      的同名接口类型 A。因此，在第 7 行把一个空对象赋值给类型是\n                      A 的变量 a1 时，TypeScript 会提示一个 ts(2741)\n                      错误，因为缺少 name 属性。在第 8 行把对象{ name: 'a2'\n                      }赋值给类型同样是 A 的变量 a2 时，TypeScript\n                      就直接通过了类型检查，因为有 name 属性。\n                    </p>\n                    <h3 data-nodeid=\"1059\">小结与预告</h3>\n                    <p data-nodeid=\"1060\">\n                      在 TypeScript 中，因为我们需要实践 OOP\n                      编程思想，所以离不开类的支撑。在实际工作中，类与函数一样，都是极其有用的抽象、封装利器。\n                    </p>\n                    <p data-nodeid=\"1061\">\n                      这里插播一道思考题：public、private、protected\n                      属性的区别是什么？欢迎你在留言区互动、交流。\n                    </p>\n                    <p data-nodeid=\"1062\">\n                      07\n                      讲我们将详细介绍这一讲中重度涉及和依赖的接口类型，敬请期待。\n                    </p>\n                    <p data-nodeid=\"1063\" class=\"\">\n                      另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~\n                    </p>\n            "}