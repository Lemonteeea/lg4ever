{"title":"19&nbsp;| 最小体力消耗路径：如何突破经典题型，掌握解题模板？","context":"\n                    <p data-nodeid=\"4\">\n                      今天我们继续从多个角度去求解一个题目，尝试运用丰富的解题工具，比如我们的“老熟人”BFS/DFS/Dijkstra\n                      算法，帮助你巩固和应用已经学习过的知识点。除此之外，本讲还会重点介绍一些在“一题多解”中尚未覆盖到的算法：\n                    </p>\n                    <ul data-nodeid=\"5\">\n                      <li data-nodeid=\"6\">\n                        <p data-nodeid=\"7\">并查集</p>\n                      </li>\n                      <li data-nodeid=\"8\">\n                        <p data-nodeid=\"9\">二分搜索</p>\n                      </li>\n                      <li data-nodeid=\"10\">\n                        <p data-nodeid=\"11\">动态规划（Bellman-Ford 算法）</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"12\">\n                      通过“一题多解”的训练，拓展我们的思维，一起去探索“五彩缤纷”的解题技巧。让我们马上开始。\n                    </p>\n                    <h3 data-nodeid=\"13\">题目</h3>\n                    <p data-nodeid=\"14\">\n                      你准备参加一场远足活动。给你一个二维 rows x columns 的地图\n                      heights ，其中 heights[row][col] 表示格子 (row, col)\n                      的高度。\n                    </p>\n                    <ul data-nodeid=\"15\">\n                      <li data-nodeid=\"16\">\n                        <p data-nodeid=\"17\">\n                          一开始你在最左上角的格子 (0, 0)\n                          ，且你希望去最右下角的格子 (rows-1, columns-1)\n                          （注意下标从 0 开始编号）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"18\">\n                        <p data-nodeid=\"19\">\n                          你每次可以往 上、下、左、右<strong data-nodeid=\"306\"\n                            >四个方向</strong\n                          >之一移动，你想要找到耗费体力最小的一条路径。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"20\">\n                      <strong data-nodeid=\"323\">一条路径耗费的体力值</strong\n                      >是由路径上相邻格子之间<strong data-nodeid=\"324\"\n                        >高度差绝对值</strong\n                      >的<strong data-nodeid=\"325\">最大值</strong\n                      >决定的。请你返回从左上角走到右下角的最小体力消耗值\n                      。矩阵中最大值不超过 10<sup>6</sup>。\n                    </p>\n                    <p data-nodeid=\"21\">例如给定如下地图：</p>\n                    <p data-nodeid=\"5191\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbuSAJ2gJAAPuzNBJ23A021.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"5194\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"23\">\n                      <strong data-nodeid=\"347\">输入</strong>：heights =\n                      [[1,2,2],[3,8,2],[5,3,5]]\n                    </p>\n                    <p data-nodeid=\"24\">\n                      <strong data-nodeid=\"352\">输出</strong>：2\n                    </p>\n                    <p data-nodeid=\"25\">\n                      <strong data-nodeid=\"365\">解释</strong>：路径 [1,3,5,3,5]\n                      连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5]\n                      更优，因为另一条路径差值最大值为 3 。\n                    </p>\n                    <p data-nodeid=\"26\">\n                      注意：我们在处理这个题目的时候，一定要注意题目要求的结果是：\n                    </p>\n                    <blockquote data-nodeid=\"27\">\n                      <p data-nodeid=\"28\">\n                        从左上角走到右下，路径上<strong data-nodeid=\"380\"\n                          >高度差绝对值</strong\n                        >的<strong data-nodeid=\"381\">最大值</strong>要<strong\n                          data-nodeid=\"382\"\n                          >最小</strong\n                        >。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"29\">即不是求路径和，也不是求最短路径。</p>\n                    <h3 data-nodeid=\"30\">预处理</h3>\n                    <p data-nodeid=\"31\">\n                      当拿到这个题之后，我们发现，与脑海里熟悉的题目还是有点差异的。因此需要对题目进行一些预处理，尽量将题目转换成为我们熟悉的题目。\n                    </p>\n                    <h4 data-nodeid=\"32\">点的处理</h4>\n                    <p data-nodeid=\"33\">\n                      首先，如果我们把矩阵中的每个位置都当成一个图（算法中的图\n                      Graph）中的一个点。那么可以将点表示如下：\n                    </p>\n                    <p data-nodeid=\"7265\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbuuAUw3wAABvcGwSSqs667.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"7268\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"35\">\n                      这里，为了表示方便，我们将每个点独立进行编号。当然，这种编号只是为了方便我们索引每个点的具体信息。\n                    </p>\n                    <blockquote data-nodeid=\"36\">\n                      <p data-nodeid=\"37\">\n                        如果我们想用一维数组存放点的信息，就需要将点编号为一维的整数。<br />\n                        如果我们想用二维数组存放点的信息，就需要用 &lt;row,\n                        col&gt; 来表示一个点的编号。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"38\">\n                      至于使用一维数组还是二维数组，要根据具体的算法和题目进行分析。我们来看下面两种情况。\n                    </p>\n                    <ul data-nodeid=\"39\">\n                      <li data-nodeid=\"40\">\n                        <p data-nodeid=\"41\">\n                          因为我们平常使用的并查集便是在一维数组上操作，那么把点编号为一维的整数无疑更方便。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"42\">\n                        <p data-nodeid=\"43\">\n                          DFS/BFS\n                          遍历的时候，对于矩阵而言，二维的信息遍历时更方便，因此搜索时，我们经常使用\n                          &lt;row, col&gt; 来表示一个点的编号。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"44\">边的处理</h4>\n                    <p data-nodeid=\"45\">\n                      通常图的题目，都会直接给出边的\n                      &lt;出发点，终点，权重&gt;，但是这道题却没有直接给出来。当然，在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"408\"\n                        >18 | 单词接龙：如何巧用深搜与广搜的变形？</a\n                      >”中，我们也遇到过没有直接给出边的信息的情况。当时的处理方式是采用“预处理”挖掘出图中边的信息。\n                    </p>\n                    <p data-nodeid=\"46\">\n                      于是，需要我们把这边的信息给挖掘出来。那么，在这个题中，边的信息是什么？根据题目的定义，当我们从结点\n                      A&lt;r 行,c 列&gt; 走到结点 B&lt;nr 行, nc 列&gt;\n                      的时候，消耗的体力值是：\n                    </p>\n                    <blockquote data-nodeid=\"47\">\n                      <p data-nodeid=\"48\">\n                        Math.abs(heights[r][c] - heights[nr][nc])\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"49\">因此，边可以表示为：</p>\n                    <blockquote data-nodeid=\"50\">\n                      <p data-nodeid=\"51\">\n                        edge = [&lt;r,c&gt; &lt;nr,nc&gt;, cost]<br />\n                        cost = Math.abs(heights[r][c] - heights[nr][nc])\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"52\">加上边之后，图问题就可以表示如下：</p>\n                    <p data-nodeid=\"9339\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbvSAD3NzAAB-KL3zX7g895.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"9342\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"54\">\n                      根据上述分析，题目就可以转换成我们非常熟悉的题目：\n                    </p>\n                    <blockquote data-nodeid=\"55\">\n                      <p data-nodeid=\"56\">\n                        给定图的点和边，以及出发点和终点，找出一条路径，使得这条路径上边的权重的最大值尽可能最小。输出这个最小值。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"57\">特点 1：连通性</h3>\n                    <p data-nodeid=\"58\">\n                      题目要求找一个最小的值\n                      ans，并且出发点和终点必须在一条路径上，这条路径上所有的边的权重都\n                      &lt;= ans。\n                    </p>\n                    <p data-nodeid=\"59\">\n                      那么反过来说，如果我们把权重大于 ans\n                      的边都删除，出发点与终点的这条路径仍然是存在的。\n                    </p>\n                    <p data-nodeid=\"11413\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/91/Cgp9HWCLbvuAHbqbAATbsJyOIcc083.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"11416\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"61\">\n                      既然如此，那么我们采用如下动图所示的方式应该也可以工作：\n                    </p>\n                    <p data-nodeid=\"13487\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbwOAWL-qAAv2KyBnV5o934.gif\"\n                        alt=\"1.gif\"\n                        data-nodeid=\"13490\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"64\">\n                      通过这种方式，我们需要解决的问题，可以表示如下：\n                    </p>\n                    <ol data-nodeid=\"65\">\n                      <li data-nodeid=\"66\">\n                        <p data-nodeid=\"67\">\n                          取出所有的边，并且按权重排序（因为我们要按权重加入图）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68\">\n                        <p data-nodeid=\"69\">\n                          当加入一条边之后，我们需要查看一下图中的两点是否连通。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"70\">\n                      其中第一个问题比较容易处理。现在问题的核心与重点就是需要<strong\n                        data-nodeid=\"481\"\n                        >尽快判断两个点是否连通</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"71\">\n                      根据我们之前学过的知识，判断图中两个点是否连通，可以使用：\n                    </p>\n                    <ul data-nodeid=\"72\">\n                      <li data-nodeid=\"73\">\n                        <p data-nodeid=\"74\">并查集</p>\n                      </li>\n                      <li data-nodeid=\"75\">\n                        <p data-nodeid=\"76\">BFS</p>\n                      </li>\n                      <li data-nodeid=\"77\">\n                        <p data-nodeid=\"78\">DFS</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"79\">\n                      但是，BFS/DFS\n                      如果需要每加入一条边都进行判断，很明显是不适合的。当有一个\n                      N x N 的矩阵，每次 BFS/DFS 的时间复杂度为 O(N x\n                      N)，整个算法的时间复杂度就达到 O(E x N x N)。\n                    </p>\n                    <p data-nodeid=\"80\">\n                      那么只能使用并查集，因为我们知道，并查集检查两个点是否连通的时候，时间杂度可以达到\n                      O(lgN)。因此，这里我们需要使用并查集来判断出发点与终点的连通性。\n                    </p>\n                    <p data-nodeid=\"81\">至此，我们可以写出伪代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">edges = getAllEdges();\n</div></li><li><div class=\"code-word\">sort(edges);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> edge in edges:\n</div></li><li><div class=\"code-word\">     addEdge(edge);\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">if</span> (connected(start, endNode)):\n</div></li><li><div class=\"code-word\">       <span class=\"hljs-keyword\">return</span> edge.cost;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"83\">\n                      有了以上的思路，我们就可以写出并查集的求解代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 并查集类</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UnionFind</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">UnionFind</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">    Init(n);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">    F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\n</div></li><li><div class=\"code-word\">      F[i] = i;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (x == F[x]) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    F[x] = Find(F[x]);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> F[x];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{\n</div></li><li><div class=\"code-word\">    F[Find(x)] = Find(y);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span>\n</span></div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 行数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Rows = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 列数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Cols = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 四个方向</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[][] dir = { { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span> }, { <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span> },\n</div></li><li><div class=\"code-word\">                           { <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> }, { -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> } };\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 由于并查集是一维的，我们需要将二维的点映射到</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 一维的点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getPointMapping</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> r, <span class=\"hljs-keyword\">int</span> c)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> r * Cols + c;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这个函数并不是把edge加到图中，而是在收集一条边</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// edge: startNode = &lt;r,c&gt;, toNode=&lt;nr,nc&gt;, cost</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 加入边数组中</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">putEdge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] edges,\n</span></span></div></li><li><div class=\"code-word\">                       <span class=\"hljs-keyword\">int</span> iter,\n</div></li><li><div class=\"code-word\">                       <span class=\"hljs-keyword\">int</span> r, <span class=\"hljs-keyword\">int</span> c,\n</div></li><li><div class=\"code-word\">                       <span class=\"hljs-keyword\">int</span> nr, <span class=\"hljs-keyword\">int</span> nc,\n</div></li><li><div class=\"code-word\">                       <span class=\"hljs-keyword\">int</span> cost) {\n</div></li><li><div class=\"code-word\">    edges[iter][<span class=\"hljs-number\">0</span>] = getPointMapping(r, c);\n</div></li><li><div class=\"code-word\">    edges[iter][<span class=\"hljs-number\">1</span>] = getPointMapping(nr, nc);\n</div></li><li><div class=\"code-word\">    edges[iter][<span class=\"hljs-number\">2</span>] = cost;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理的主函数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minimumEffortPath</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] heights)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (heights == <span class=\"hljs-keyword\">null</span> || heights[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 收集行数</span>\n</div></li><li><div class=\"code-word\">    Rows = heights.length;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 收集列数</span>\n</div></li><li><div class=\"code-word\">    Cols = heights[<span class=\"hljs-number\">0</span>].length;\n</div></li><li><div class=\"code-word\">   \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果只有一个点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (Rows == <span class=\"hljs-number\">1</span> &amp;&amp; Cols == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">   \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 采用并查集的做法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 横向的无向边的数目</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> hNumber = Rows * (Cols - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 纵向的无向边的数目</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> vNumber = Cols * (Rows - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 无向边</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录起点，终点，权重</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[][] edges = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[hNumber + vNumber][<span class=\"hljs-number\">3</span>];\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 得到所有的边</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> edgeIter = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; Rows; r++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; Cols; c++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 看一下 右边的点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (c + <span class=\"hljs-number\">1</span> &lt; Cols) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 得到边的权重</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">int</span> edgeCost =\n</div></li><li><div class=\"code-word\">            Math.abs(heights[r][c] - heights[r][c + <span class=\"hljs-number\">1</span>]);\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 将边放到边集中</span>\n</div></li><li><div class=\"code-word\">          putEdge(edges, edgeIter,\n</div></li><li><div class=\"code-word\">            r, c, r, c + <span class=\"hljs-number\">1</span>, edgeCost);\n</div></li><li><div class=\"code-word\">          \n</div></li><li><div class=\"code-word\">          edgeIter++;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (r + <span class=\"hljs-number\">1</span> &lt; Rows) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 得到一条向下的边的权重</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">int</span> edgeCost =\n</div></li><li><div class=\"code-word\">            Math.abs(heights[r][c] - heights[r + <span class=\"hljs-number\">1</span>][c]);\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 将边放到边集中</span>\n</div></li><li><div class=\"code-word\">          putEdge(edges, edgeIter,\n</div></li><li><div class=\"code-word\">            r, c, r + <span class=\"hljs-number\">1</span>, c, edgeCost);\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">          edgeIter++;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 再将边进行排序</span>\n</div></li><li><div class=\"code-word\">    Arrays.sort(edges, <span class=\"hljs-keyword\">new</span> Comparator&lt;<span class=\"hljs-keyword\">int</span>[]&gt;() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] b)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> a[<span class=\"hljs-number\">2</span>] - b[<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 排序结束之后，再使用并查集，依次加入边</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> totalNodes = Rows * Cols;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 并查集</span>\n</div></li><li><div class=\"code-word\">    UnionFind uf = <span class=\"hljs-keyword\">new</span> UnionFind(totalNodes);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> src = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> dst = getPointMapping(Rows - <span class=\"hljs-number\">1</span>, Cols - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span>[] edge : edges) {\n</div></li><li><div class=\"code-word\">      uf.Union(edge[<span class=\"hljs-number\">0</span>], edge[<span class=\"hljs-number\">1</span>]);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果能让 src dst连通</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 那么就是当前的cost</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (uf.Find(src) == uf.Find(dst)) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> edge[<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-number\">0</span> &gt; -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Should not reach here!</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"85\">\n                      <p data-nodeid=\"86\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"493\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"497\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"501\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"87\">\n                      <strong data-nodeid=\"506\">复杂度分析</strong>：一个 N x M\n                      的数组，可以认为一共有 O(N x M)\n                      条边，收集到这些边之后，然后进行排序，排序的时间复杂度为\n                      O(N x M x lg(N x M))，存放边的空间复杂度为 O(N x\n                      M)。接下来，我们需要利用并查集进行处理，一共有 O(N x M)\n                      个点，O(N x M) 条边。那么并查集处理的时间复杂度为 O(N x M\n                      x lg(N x M))。所以，整个问题时间复杂度为 O(N x M x lg(N x\n                      M))，空间复杂度为 O(N x M)。\n                    </p>\n                    <p data-nodeid=\"88\">\n                      当你看完这个题，你还可以回过头去看看“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6696&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"510\"\n                        >07 | 并查集：如何利用两行代码写并查集？</a\n                      >”里面的例\n                      1，在那里，我们同样用到了相同的方法进行处理——最小生成树的思想。通过这些比较，可以发现我们可以通过掌握一种算法思想，在不同的题目中游刃有余。\n                    </p>\n                    <h3 data-nodeid=\"89\">特点 2：最小值</h3>\n                    <p data-nodeid=\"90\">\n                      我们再回到题目，题目要求的是最小值。那么我们想一想：最小值\n                      ans 肯定是一个分界，这个分界体现在两个方向：\n                    </p>\n                    <ul data-nodeid=\"91\">\n                      <li data-nodeid=\"92\">\n                        <p data-nodeid=\"93\">\n                          比 ans 更小的值，不会让出发点和终点之间可以连通；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"94\">\n                        <p data-nodeid=\"95\">\n                          大于等于 ans\n                          的值，那么肯定可以让出发点与终点可以连通。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"96\">\n                      如果我们用数组进行表示，那么可以达到如下图所示的效果：\n                    </p>\n                    <p data-nodeid=\"15557\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/91/Cgp9HWCLbxKAEgdXAAA4xI3NFuI649.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"15560\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"98\">\n                      如果我们分别用 -1 表示 NO，0 表示\n                      OK。那么问题转变成下面这样：\n                    </p>\n                    <p data-nodeid=\"17627\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbyKAejCRAAA2P_x4DC8327.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"17630\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"100\">\n                      我们需要在一个左边为 -1，右边为 0 的数组中，找到第一个为 0\n                      的下标的位置。那么，最适合解决这个问题的算法就是<strong\n                        data-nodeid=\"529\"\n                        >二分搜索</strong\n                      >了。\n                    </p>\n                    <h4 data-nodeid=\"101\">四步法</h4>\n                    <p data-nodeid=\"102\">\n                      现在算法方向已经确定了，是时候拿出我们的“二分搜索四步法”了。如果你对这个方法还不太熟悉，可以先回到“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6698&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"534\"\n                        >09 | 二分搜索：为什么说有序皆可用二分？</a\n                      >”复习一下二分搜索的内容，再来看接下来的分析。\n                    </p>\n                    <ul data-nodeid=\"103\">\n                      <li data-nodeid=\"104\">\n                        <p data-nodeid=\"105\">\n                          <strong data-nodeid=\"540\">第一步</strong\n                          >：要什么，什么就是 x。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"106\">\n                        <p data-nodeid=\"107\">\n                          <strong data-nodeid=\"545\">第二步</strong\n                          >：满足约束条件的 f(x) = 0。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"108\">\n                        <p data-nodeid=\"109\">\n                          <strong data-nodeid=\"554\">第三步</strong>：<strong\n                            data-nodeid=\"555\"\n                            >不满足</strong\n                          >约束条件的 f(x) 设置为 -1 或者 1。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"110\">\n                        <p data-nodeid=\"111\">\n                          <strong data-nodeid=\"563\">第四步</strong>：最优解 0 在\n                          C[] 的最左边还是最右边，决定使用 lowerBound 还是\n                          upperBound。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"112\">接下来，我们一步一步展开。</p>\n                    <p data-nodeid=\"113\">\n                      <strong data-nodeid=\"568\">第一步</strong>\n                    </p>\n                    <p data-nodeid=\"114\">\n                      我们的问题是要输出一个最小体力消耗值，也就是 x。确定 x\n                      之后，我们还需要确定 x\n                      的范围。在这个题中，所有的边都加上之后，出发点与终点是肯定有路径的。所以\n                      x 的范围就确定了：\n                    </p>\n                    <ul data-nodeid=\"115\">\n                      <li data-nodeid=\"116\">\n                        <p data-nodeid=\"117\">\n                          x 的最小值，就是图中边的权重的最小值\n                        </p>\n                      </li>\n                      <li data-nodeid=\"118\">\n                        <p data-nodeid=\"119\">\n                          x 的最大值，就是图中边的权重的最大值\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"120\">\n                      <strong data-nodeid=\"575\">第二步</strong>\n                    </p>\n                    <p data-nodeid=\"121\">\n                      这里需要确定 f(x) =\n                      0。根据题意，当我们得到最小消耗的体力值 x\n                      之后，在遍历图的时候，当发现边的权重大于\n                      x，直接把这条边禁用即可。当发现出发点与终点之间存在通路，我们就可以认为\n                      f(x) = 0。\n                    </p>\n                    <p data-nodeid=\"122\">\n                      <strong data-nodeid=\"580\">第三步</strong>\n                    </p>\n                    <p data-nodeid=\"123\">\n                      得到最小消耗体力值 x 之后，在遍历时，把权重大于 x\n                      的边禁用，如果发现出发点与终点之间不存在通路，此时设置\n                      f(x) = -1。\n                    </p>\n                    <p data-nodeid=\"124\">\n                      在这个题中，由于出发点与终点只有连通与不连通两种情况。所以我们“二分搜索”映射之后的数组里面只会有\n                      -1 和 0。\n                    </p>\n                    <p data-nodeid=\"125\">\n                      <strong data-nodeid=\"586\">第四步</strong>\n                    </p>\n                    <p data-nodeid=\"19697\">\n                      在本题中，当映射到一个数组之后，我们要求的是满足 f(x) = 0\n                      的最小值。\n                    </p>\n                    <p data-nodeid=\"19698\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbyyALJXRAAA2NUdivXw497.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"19702\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"128\">\n                      也就是求数组中值为 0 的第一个下标，那么肯定应该使用\n                      lowerBound。\n                    </p>\n                    <h4 data-nodeid=\"129\">f 函数</h4>\n                    <p data-nodeid=\"130\">\n                      根据前面四步分析法，我们已经可以写出二分搜索的伪代码了：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">l = minCost\n</div></li><li><div class=\"code-word\">r = maxCost\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> l &lt; r:\n</div></li><li><div class=\"code-word\">    mid = l + ((r-l)&gt;&gt;<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// mid表示x</span>\n</div></li><li><div class=\"code-word\">    mv = f(mid) <span class=\"hljs-comment\">// 调用f(x)</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (mv &lt; <span class=\"hljs-number\">0</span>):\n</div></li><li><div class=\"code-word\">        l = mid + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">        r = mid\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"132\">\n                      不过在正式写代码之前，还是要想一下 f\n                      函数如何写。我们可以先回想一下 f(x) 要解决的问题：\n                    </p>\n                    <blockquote data-nodeid=\"133\">\n                      <p data-nodeid=\"134\">\n                        禁用所有权重大于 x\n                        的边之后，图中出发点与终点之间是否还有路径。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"135\">\n                      我们可以把禁用权重大于 x\n                      的边，看成是利用一个旧图，生成了一张新图。比如：\n                    </p>\n                    <p data-nodeid=\"21769\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbzOAbNdGAACu5sMfhbM647.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"21772\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"137\">\n                      <strong data-nodeid=\"604\"\n                        >那么 f(x)\n                        的本质就是在一个新图上判断两点之间的连通性</strong\n                      >。关于连通性的判定，我们前面提到过，有 3 种办法：\n                    </p>\n                    <ul data-nodeid=\"138\">\n                      <li data-nodeid=\"139\">\n                        <p data-nodeid=\"140\">并查集</p>\n                      </li>\n                      <li data-nodeid=\"141\">\n                        <p data-nodeid=\"142\">BFS</p>\n                      </li>\n                      <li data-nodeid=\"143\">\n                        <p data-nodeid=\"144\">DFS</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"145\">\n                      在特点 1 中，我们说明了只能选用并查集，不能使用 BFS 与\n                      DFS，还给出了时间复杂度上的证明。在这里，恰恰相反，三种办法都是可以使用的。下面我们一起证明一下。\n                    </p>\n                    <p data-nodeid=\"146\">假设给定了 N x M 大小的矩阵。</p>\n                    <ul data-nodeid=\"147\">\n                      <li data-nodeid=\"148\">\n                        <p data-nodeid=\"149\">\n                          并查集：一共有 O(N x M) 条边，时间复杂度主要由并查集的\n                          Union 决定，一共需要 Union O(N x M) 次，每次 Union\n                          时间复杂度为 O(lg(N x M)（因为一共有 O(N x M)\n                          个点）。所以总共的时间复杂度为 O(N x M lg(N x M))。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"150\">\n                        <p data-nodeid=\"151\">\n                          BFS：一共有 O(N x M)\n                          个点，最差情况下，每个点都会遍历，所以时间复杂度为 O(N\n                          x M)。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"152\">\n                        <p data-nodeid=\"153\">\n                          DFS：一共有 O(N x M)\n                          个点，最差情况下，每个点都会遍历，所以时间复杂度为 O(N\n                          x M)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"154\">\n                      也就是说，f(x) 函数的时间复杂度都差不多（并查集多了一个\n                      O(lg)）。\n                    </p>\n                    <p data-nodeid=\"155\">\n                      如果再算上最外层二分搜索的时间复杂度，由于最大的数为\n                      10<sup>6</sup>，所以整个二分搜索的时间复杂度为：\n                    </p>\n                    <ul data-nodeid=\"156\">\n                      <li data-nodeid=\"157\">\n                        <p data-nodeid=\"158\">\n                          O(lg(10<sup>6</sup>) N x M) ← 二分 + BFS/DFS；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"159\">\n                        <p data-nodeid=\"160\">\n                          或者 O(lg(10<sup>6</sup>) N x M x lg (N x M)) ← 二分 +\n                          并查集。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"161\">\n                      基于这样的思路，我们就可以写出二分搜索的代码了（二分搜索 +\n                      DFS）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//  二分搜索</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 行数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Rows = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 列数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Cols = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 一个点周围的四个方向</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span>[][] dir = { { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span> }, { <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span> }, { <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> }, { -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> } };\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">boolean</span>[][] vis = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clearVisRecord</span><span class=\"hljs-params\">()</span>\n</span></div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; Rows; r++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; Cols; c++) {\n</div></li><li><div class=\"code-word\">        vis[r][c] = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里采用DFS来寻路</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// &lt;r,c&gt;是当前的出发点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] heights, <span class=\"hljs-keyword\">int</span> maxValue,\n</span></span></div></li><li><div class=\"code-word\">                      <span class=\"hljs-keyword\">int</span> r, <span class=\"hljs-keyword\">int</span> c) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果已经走到了目标点&lt;rows-1, cols-1&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (r == Rows - <span class=\"hljs-number\">1</span> &amp;&amp; c == Cols - <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 查看 &lt;r,c&gt;点的四周</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-number\">0</span>; d &lt; <span class=\"hljs-number\">4</span>; d++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nr = r + dir[d][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nc = c + dir[d][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果周边的点有效，并且没有被访问过</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> ((!(nr &lt; <span class=\"hljs-number\">0</span> || nc &lt; <span class=\"hljs-number\">0</span> || nr &gt;= Rows || nc &gt;= Cols))\n</div></li><li><div class=\"code-word\">           &amp;&amp; !vis[nr][nc]) {\n</div></li><li><div class=\"code-word\">           \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 获取边的代价</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> cost =\n</div></li><li><div class=\"code-word\">            Math.abs(heights[r][c] - heights[nr][nc]);\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 在走的时候，如果比midValue大，那么这条路就不能走了</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (cost &lt;= maxValue) {\n</div></li><li><div class=\"code-word\">          vis[nr][nc] = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (dfs(heights, maxValue, nr, nc)) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// f(x)函数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 重新映射之的一维数组</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// midValue是在二分的时候给定的值</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 我们在进行搜索的时候，路径上的绝对值不能比这个大</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 只能是 &lt;= midValue.</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 此时我们只需要寻找看看是否存在一条路径即可</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果存在一条路径，上面的绝对值 &lt;= midValue</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 那么满足条件-&gt; 返回0</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果没有这样的路径，那么返回-1</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getC</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] heights, <span class=\"hljs-keyword\">int</span> midValue)</span> </span>{\n</div></li><li><div class=\"code-word\">    clearVisRecord();\n</div></li><li><div class=\"code-word\">    vis[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> dfs(heights, midValue, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-number\">0</span> : -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minimumEffortPath</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] heights)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (heights == <span class=\"hljs-keyword\">null</span> || heights[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    Rows = heights.length;\n</div></li><li><div class=\"code-word\">    Cols = heights[<span class=\"hljs-number\">0</span>].length;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// if just one node</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (Rows == <span class=\"hljs-number\">1</span> &amp;&amp; Cols == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生成vis数组</span>\n</div></li><li><div class=\"code-word\">    vis = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">boolean</span>[Rows][Cols];\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 二分搜索</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 找到搜索范围里：最大值/最小值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> minCost = Integer.MAX_VALUE;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> maxCost = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; Rows; r++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; Cols; c++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 看一下 右边的点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (c + <span class=\"hljs-number\">1</span> &lt; Cols) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">int</span> rightValue =\n</div></li><li><div class=\"code-word\">              Math.abs(heights[r][c] - heights[r][c + <span class=\"hljs-number\">1</span>]);\n</div></li><li><div class=\"code-word\">          minCost = Math.min(minCost, rightValue);\n</div></li><li><div class=\"code-word\">          maxCost = Math.max(maxCost, rightValue);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (r + <span class=\"hljs-number\">1</span> &lt; Rows) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">int</span> downValue =\n</div></li><li><div class=\"code-word\">              Math.abs(heights[r][c] - heights[r + <span class=\"hljs-number\">1</span>][c]);\n</div></li><li><div class=\"code-word\">          minCost = Math.min(minCost, downValue);\n</div></li><li><div class=\"code-word\">          maxCost = Math.max(maxCost, downValue);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 那么应该有一个值 target</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 当 路径的最大绝对值差为 x</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 并且 x &gt;= target的时候</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 总是可以走通的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 所以我们二分搜索的范围就为[minCost, maxCost + 1)</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 我们定义-1: 表示左上角与右下有没有通路</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">//        0: 表示左上角与右下角有通路</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 那么形成的C数组就是[-1,-1,-1,-1, 0, 0, 0, 0]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这样的结构</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 因此，我们在利用二分搜索的时候，只需要找到最左边的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 0的位置就可以了。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> l = minCost, r = maxCost + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (l &lt; r) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mid = l + ((r - l) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mv = getC(heights, mid);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (mv &lt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">        l = mid + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        r = mid;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> l;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"163\">\n                      <p data-nodeid=\"164\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"633\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"637\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"641\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"165\">\n                      <strong data-nodeid=\"650\">复杂度分析</strong\n                      >：时间复杂度O(lg(10<sup>6</sup>) N x M)，空间复杂度为O(N\n                      x M)。\n                    </p>\n                    <p data-nodeid=\"166\">\n                      <strong data-nodeid=\"655\">练习题 1</strong\n                      >：在文中，我们已经证明了这道题还可以使用二分搜索 + BFS /\n                      并查集来解决。你能写一下代码吗？\n                    </p>\n                    <blockquote data-nodeid=\"167\">\n                      <p data-nodeid=\"168\">\n                        二分 + BFS：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"659\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"663\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"667\"\n                          >Python</a\n                        ><br />\n                        二分 + 并查集：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"672\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"676\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"680\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"169\">特点 3：再看最小值</h3>\n                    <p data-nodeid=\"170\">\n                      谈到图中两点之间路径的最小值，有没有觉得很熟悉？我们在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"685\"\n                        >18 | 单词接龙：如何巧用深搜与广搜的变形？</a\n                      >”中刚刚介绍过“<strong data-nodeid=\"691\"\n                        >求解两个点的最短路径</strong\n                      >”的方法：\n                    </p>\n                    <ul data-nodeid=\"171\">\n                      <li data-nodeid=\"172\">\n                        <p data-nodeid=\"173\">\n                          两点之间的最短路径（BFS 算法/Dijkstra 算法/BF 算法，即\n                          Bellman-Ford 算法）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"174\">\n                        <p data-nodeid=\"175\">\n                          一个点到其他所有点的最短路径（Dijkstra 算法/BF\n                          算法）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"176\">\n                        <p data-nodeid=\"177\">\n                          <strong data-nodeid=\"698\">每两点</strong\n                          >之间的最短路径（Floyd 算法）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"23839\" class=\"\">\n                      在这里，<strong data-nodeid=\"23849\"\n                        >一个点到其他所有点的最短路径</strong\n                      >当然是包含了“两点之间的最短路径”的情况。所以后面我们在讨论的时候，都是<strong\n                        data-nodeid=\"23850\"\n                        >一个点到其他所有点的最短路径</strong\n                      >场景下的 BF 算法。\n                    </p>\n\n                    <p data-nodeid=\"179\">\n                      下面尝试一下 BF 算法（我们讲的场）。在“1<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"716\"\n                        >8 | 单词接龙：如何巧用深搜与广搜的变形？</a\n                      >”的“练习题 1”里提到了可以用 BF\n                      算法进行求解，但是没有详细介绍如何用 BF\n                      算法。这里我们详细介绍一下。\n                    </p>\n                    <p data-nodeid=\"180\">\n                      如果直接看BF\n                      算法的代码，容易看得一头雾水，但其实这是一种比较容易理解的算法。在拿出BF算法的模板代码前，我们先讲一下这个算法的本质（下图中橙色点表示出发点）。注意：是<strong\n                        data-nodeid=\"723\"\n                        >本质</strong\n                      >！并不完全是一个计算过程的模拟。\n                    </p>\n                    <p data-nodeid=\"25911\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLclCAcTHPAACthA1b_fY994.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"25914\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"182\">\n                      Step 0. 首先我们有一些离散的点， 此时还没有加入任何边。\n                    </p>\n                    <p data-nodeid=\"27975\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcluAc9DMAADTk0wp1dQ877.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"27978\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"184\">\n                      Step 1. 把<strong data-nodeid=\"740\">所有的边</strong\n                      >加入图中。只有一部分点（绿色）会在这一轮迭代中得到<strong\n                        data-nodeid=\"741\"\n                        >最终的</strong\n                      >src 出发的最短路径。\n                    </p>\n                    <blockquote data-nodeid=\"185\">\n                      <p data-nodeid=\"186\">\n                        注意：有一些点，经过这一轮的操作之后，虽然会与出发点 src\n                        连通，但并没有得到<strong data-nodeid=\"747\">最终</strong\n                        >最短路径，在图中我们就没有画出这些点与 src 的连线。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"187\">\n                      此时，我们可以再次从绿色点（因为它们已经是<strong\n                        data-nodeid=\"753\"\n                        >最终的</strong\n                      >最短路径了）出发，如果再次利用所有的边，应该可以再更新一波，得到一些新的最短路径的点。\n                    </p>\n                    <p data-nodeid=\"30039\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/92/Cgp9HWCLcmKAARFYAADrQRM28nQ863.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"30042\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"189\">\n                      Step 2.\n                      再次把所有的边加入图中，得到第二波最短路径的点（紫色）。\n                    </p>\n                    <p data-nodeid=\"32103\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcmmAPC1XAAD3iedUdk4707.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"32106\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"191\">\n                      Step 3:\n                      如果我们再从紫色点出发，把所有的边加到图中，那么可以得到最后一波最短路径的点（红色）。\n                    </p>\n                    <p data-nodeid=\"192\">\n                      这里只是假设更新 3\n                      次就结束了，实际上有可能更多。那么问题来了，到底要把所有的边用来更新多少次呢？\n                    </p>\n                    <p data-nodeid=\"193\">这里可以有两种办法。</p>\n                    <ul data-nodeid=\"194\">\n                      <li data-nodeid=\"195\">\n                        <p data-nodeid=\"196\">\n                          积极的办法：当发现不能更新出一波新的最短路径的点的时候，就应该停止了。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"197\">\n                        <p data-nodeid=\"198\">\n                          消极的办法：假设每一波最差情况下只有一个点得到了最终的最短路径，那么一共需要更新\n                          N-1 轮（在有 N 个点的情况下）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"199\">\n                      那么问题的时间复杂度为 O(E x N)，其中 E 为边的数目，N\n                      表示最差情况下更新的次数。\n                    </p>\n                    <p data-nodeid=\"200\">\n                      基于这种思想，我们就可以写出 BF\n                      算法的代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; m; j++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//对m条边进行循环</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> edge = edges[j];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 松弛操作</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(distance[edge.to] &gt;\n</div></li><li><div class=\"code-word\">          distance[edge.from] + edge.weight ) {\n</div></li><li><div class=\"code-word\">            distance[edge.to] = distance[edge.from] + edge.weight;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"202\">\n                      不过，要解决本题，还需要注意，<strong data-nodeid=\"778\"\n                        >经典的 BF 算法的最短路径是最小路径和为度量的，<strong\n                          data-nodeid=\"777\"\n                          >而在本题中，是以</strong\n                        >一条路径上的最大权重</strong\n                      >进行度量的，所以我们还需要对 BF\n                      算法做度量函数的微调，调整之后的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 行数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Rows = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 列数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Cols = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 一个点周围的四个方向</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span>[][] dir = { { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span> }, { <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span> },\n</div></li><li><div class=\"code-word\">                  { <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> }, { -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> } };\n</div></li><li><div class=\"code-word\">                  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minimumEffortPath</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] heights)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (heights == <span class=\"hljs-keyword\">null</span> || heights[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    Rows = heights.length;\n</div></li><li><div class=\"code-word\">    Cols = heights[<span class=\"hljs-number\">0</span>].length;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果只有一个结点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (Rows == <span class=\"hljs-number\">1</span> &amp;&amp; Cols == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 采用BF算法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 从左上角走到右下角，最多只需要走Rows + Cols次</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 所以我们在更新的时候，最多只需要更新Rows + Cols次</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 并且，在更新的过程中，如果我们发现，没有任何一个点被更新的时候</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 我们就可以退出来了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> maxDist = Integer.MAX_VALUE &gt;&gt; <span class=\"hljs-number\">4</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[][] dist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[Rows][Cols];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 初始化整个距离</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; Rows; r++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; Cols; c++) {\n</div></li><li><div class=\"code-word\">        dist[r][c] = maxDist;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    dist[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> maxUpdateTimes = Rows + Cols;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 用BF算法来更新</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> updateTimes = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        updateTimes &lt; maxUpdateTimes; updateTimes++) {\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">boolean</span> hasUpdateItem = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 用所有的边来进行更新</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; Rows; r++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; Cols; c++) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-number\">0</span>; d &lt; <span class=\"hljs-number\">4</span>; d++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> nr = r + dir[d][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> nc = c + dir[d][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (!(nr &lt; <span class=\"hljs-number\">0</span> || nc &lt; <span class=\"hljs-number\">0</span> ||\n</div></li><li><div class=\"code-word\">                  nr &gt;= Rows || nc &gt;= Cols)) {\n</div></li><li><div class=\"code-word\">                  \n</div></li><li><div class=\"code-word\">              <span class=\"hljs-comment\">// 拿到边的代价</span>\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> cost =\n</div></li><li><div class=\"code-word\">                  Math.abs(heights[r][c] - heights[nr][nc]);\n</div></li><li><div class=\"code-word\">                  \n</div></li><li><div class=\"code-word\">              <span class=\"hljs-comment\">// 这条路径走过来的最大代价</span>\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nextCost = Math.max(dist[r][c], cost);\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-keyword\">if</span> (nextCost &lt; dist[nr][nc]) {\n</div></li><li><div class=\"code-word\">                dist[nr][nc] = nextCost;\n</div></li><li><div class=\"code-word\">                hasUpdateItem = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">              }\n</div></li><li><div class=\"code-word\">              \n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果没有更新</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (!hasUpdateItem) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> dist[Rows - <span class=\"hljs-number\">1</span>][Cols - <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"204\">\n                      <p data-nodeid=\"205\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"782\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"786\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"790\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"206\">\n                      写完代码之后，我们再考虑一下 BF 算法与 Dijkstra\n                      算法的联系与区别。\n                    </p>\n                    <ol data-nodeid=\"207\">\n                      <li data-nodeid=\"208\">\n                        <p data-nodeid=\"209\">\n                          <strong data-nodeid=\"796\">联系</strong>：BF 算法与\n                          Dijkstra 算法都会用更小的“最短路径”来更新。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"210\">\n                        <p data-nodeid=\"211\">\n                          <strong data-nodeid=\"801\">区别</strong>：BF\n                          算法属于动态规划算法，而 Dijkstra\n                          算法则是属于贪心算法。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"212\">\n                      1）相对来说，BF\n                      算法在每一轮的更新中，都会得到一波点，这些点有最终的最短路径。但是更新的时候，需要用到所有的边。\n                    </p>\n                    <p data-nodeid=\"213\">\n                      2）Dijkstra\n                      算法在更新点的距离时，则是从点的角度出发。既然每一波点都会得到最短距离，那么我就利用这波点去更新别的点的最短距离。\n                    </p>\n                    <h3 data-nodeid=\"214\">特点 4: 又看最小值</h3>\n                    <p data-nodeid=\"215\">\n                      谈到图中两点之间关于路径的最小值。在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"808\"\n                        >第 18 讲</a\n                      >”中我们讲过，在求两个点的最短路径的时候，可以有 3\n                      种情况：两点最短、点与其他点最短路径、每两点之间的最短路径。我们接触的最短路径的题目中，很多题目都是将“<strong\n                        data-nodeid=\"814\"\n                        >最短</strong\n                      >”定义为：\n                    </p>\n                    <blockquote data-nodeid=\"216\">\n                      <p data-nodeid=\"217\">\n                        一条路径上所有边的权重之和，要最小！\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"218\">\n                      但是，在<strong data-nodeid=\"821\">本题</strong\n                      >中却不是这样，我们要求的是：\n                    </p>\n                    <blockquote data-nodeid=\"219\">\n                      <p data-nodeid=\"220\">\n                        一条路径上所有边的权重的最大值，要最小！\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"221\">\n                      那么，当这个“<strong data-nodeid=\"828\">最短</strong\n                      >”定义发生变化的时候，我们是否还可以使用 BFS/Dijkstra/BF\n                      算法呢？\n                    </p>\n                    <p data-nodeid=\"222\">\n                      这里我们先回顾一下原始 Dijkstra 算法。\n                    </p>\n                    <ul data-nodeid=\"223\">\n                      <li data-nodeid=\"224\">\n                        <p data-nodeid=\"225\">\n                          在 Dijkstra 算法中，我们需要用一个 dist\n                          数组来记录“最短路径”和。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"226\">\n                        <p data-nodeid=\"227\">\n                          当出发点 src 走到点 x，导致 dist[x] 有<strong\n                            data-nodeid=\"840\"\n                            >更新</strong\n                          >的时候，那么点 x\n                          还可以走到它周围的点，进一步更新周围的点。因此，需要将点\n                          x 放到一个优先级队列中。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"228\">\n                        <p data-nodeid=\"229\">\n                          每次从优先级队列中取出最值得更新的点，作为出发点，用来<strong\n                            data-nodeid=\"846\"\n                            >更新</strong\n                          >其周围的点。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"230\">\n                      如果将 Dijkstra 算法迁移到这个题目，我们只需要改变 dist[]\n                      数组的含义就可以了。\n                    </p>\n                    <ul data-nodeid=\"231\">\n                      <li data-nodeid=\"232\">\n                        <p data-nodeid=\"233\">\n                          原始的 Dijkstra 算法的 dist[x] 表示：从出发点 src\n                          走到点 x 的最小路径和。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"234\">\n                        <p data-nodeid=\"235\">\n                          本题的 Dijkstra 中的 dist[x] 的含义：从出发点 src\n                          走到点 x 路径上<strong data-nodeid=\"865\"\n                            >边的权重的最大值</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"236\">\n                      基于这个微小的改动，我们就可以利用 Dijkstra\n                      算法解决这道题目了。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 行数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Rows = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 列数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> Cols = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 四个方向</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[][] dir = { { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span> }, { <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span> },\n</div></li><li><div class=\"code-word\">                           { <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> }, { -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> } };\n</div></li><li><div class=\"code-word\">                           \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minimumEffortPath</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] heights)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (heights == <span class=\"hljs-keyword\">null</span> || heights[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    Rows = heights.length;\n</div></li><li><div class=\"code-word\">    Cols = heights[<span class=\"hljs-number\">0</span>].length;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 设置矩阵的最大距离</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> maxDist = Integer.MAX_VALUE &gt;&gt; <span class=\"hljs-number\">4</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[][] dist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[Rows][Cols];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; Rows; r++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; Cols; c++) {\n</div></li><li><div class=\"code-word\">        dist[r][c] = maxDist;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    dist[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// java小堆</span>\n</div></li><li><div class=\"code-word\">    Queue&lt;<span class=\"hljs-keyword\">int</span>[]&gt; Q =\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt;\n</div></li><li><div class=\"code-word\">            dist[v1[<span class=\"hljs-number\">0</span>]][v1[<span class=\"hljs-number\">1</span>]] - dist[v2[<span class=\"hljs-number\">0</span>]][v2[<span class=\"hljs-number\">1</span>]]);\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 放入出发点</span>\n</div></li><li><div class=\"code-word\">    Q.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> });\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (!Q.isEmpty()) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 取出最近的点</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">int</span>[] topNode = Q.poll();\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> r = topNode[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> c = topNode[<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 我们看一下这个点四周的点</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-number\">0</span>; d &lt; <span class=\"hljs-number\">4</span>; d++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//  找到周边的下一个点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nr = r + dir[d][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nc = c + dir[d][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 看一下这个点的权重是否会更新</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!(nr &lt; <span class=\"hljs-number\">0</span> || nc &lt; <span class=\"hljs-number\">0</span> || nr &gt;= Rows || nc &gt;= Cols)) {\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 如果要走过去的点是合法的点</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 点之间的边上的权重</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 是由点与点之间的abs()决定的</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> weight =\n</div></li><li><div class=\"code-word\">              Math.abs(heights[r][c] - heights[nr][nc]);\n</div></li><li><div class=\"code-word\">              \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 注意，题目要求是取整条路径上的绝对值的最大值</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nextDist = Math.max(dist[r][c], weight);\n</div></li><li><div class=\"code-word\">          \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (nextDist &lt; dist[nr][nc]) {\n</div></li><li><div class=\"code-word\">            dist[nr][nc] = nextDist;\n</div></li><li><div class=\"code-word\">            Q.offer(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { nr, nc });\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">          \n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> dist[Rows - <span class=\"hljs-number\">1</span>][Cols - <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"238\">\n                      <p data-nodeid=\"239\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"870\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"874\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"878\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"240\">\n                      <strong data-nodeid=\"883\">复杂度分析</strong>：当给定图为\n                      N x M 时，时间复杂度为 O(N x M x lg(N x\n                      M))，空间复杂度最差情况下，所有的元素都在队列中 O(N x M)。\n                    </p>\n                    <h3 data-nodeid=\"241\">总结</h3>\n                    <p data-nodeid=\"242\">\n                      在这一讲中，我们通过题目<strong data-nodeid=\"890\"\n                        >两方面的特点：连通性、最小值</strong\n                      >展开，介绍了以下算法：\n                    </p>\n                    <ul data-nodeid=\"243\">\n                      <li data-nodeid=\"244\">\n                        <p data-nodeid=\"245\">并查集</p>\n                      </li>\n                      <li data-nodeid=\"246\">\n                        <p data-nodeid=\"247\">二分搜索</p>\n                      </li>\n                      <li data-nodeid=\"248\">\n                        <p data-nodeid=\"249\">动态规划</p>\n                      </li>\n                      <li data-nodeid=\"250\">\n                        <p data-nodeid=\"251\">Dijkstra 算法</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"34167\">\n                      这里我将这些知识点浓缩在一张思维导图里面，有助于帮助你总结和复习。\n                    </p>\n                    <p data-nodeid=\"34168\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/92/Cgp9HWCLcnuABwKAAADpTh1CXZI925.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"34172\"\n                      />\n                    </p>\n\n                    <h3 data-nodeid=\"254\">思考题</h3>\n                    <p data-nodeid=\"255\">\n                      给定一个包含非负整数的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"901\"\n                        >m x n</code\n                      >网格<code data-backticks=\"1\" data-nodeid=\"903\">grid</code\n                      >，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n                    </p>\n                    <p data-nodeid=\"36233\" class=\"\">\n                      <strong data-nodeid=\"36238\">说明：</strong>\n                      每次只能向下或者向右移动一步。\n                    </p>\n\n                    <p data-nodeid=\"38301\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcoSATajPAAEcd1cL5m8325.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"38304\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"258\">\n                      输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n                    </p>\n                    <p data-nodeid=\"259\">输出：7</p>\n                    <p data-nodeid=\"260\">\n                      解释：因为路径 1→3→1→1→1 的总和最小。\n                    </p>\n                    <blockquote data-nodeid=\"261\">\n                      <p data-nodeid=\"262\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"931\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"935\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"939\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"263\">\n                      你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于最小体力消耗题目就介绍到这里。接下来，下一讲介绍“20\n                      | 5\n                      种解法，如何利用常量空间求解最长有效括号长度？”，让我们继续前进。\n                    </p>\n                    <h3 data-nodeid=\"264\">附录：题目出处和代码汇总</h3>\n                    <table data-nodeid=\"40368\">\n                      <thead data-nodeid=\"40369\">\n                        <tr data-nodeid=\"40370\">\n                          <th data-nodeid=\"40372\">题目</th>\n                          <th data-nodeid=\"40373\">\n                            <a\n                              href=\"https://leetcode-cn.com/problems/path-with-minimum-effort/description/?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40386\"\n                              >测试平台</a\n                            >\n                          </th>\n                          <th data-nodeid=\"40374\">\n                            并查集：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40390\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40394\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40398\"\n                              >Python</a\n                            ><br />二分 + DFS：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40403\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40407\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40411\"\n                              >Python</a\n                            ><br />二分 + BFS：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40416\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40420\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40424\"\n                              >Python</a\n                            ><br />二分 + 并查集：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40429\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40433\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40437\"\n                              >Python</a\n                            ><br /><br />BF 算法：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40443\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40447\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40451\"\n                              >Python</a\n                            ><br /><br />Dijkstra 算法：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40457\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40461\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40465\"\n                              >Python</a\n                            >\n                          </th>\n                        </tr>\n                      </thead>\n                      <tbody data-nodeid=\"40378\">\n                        <tr data-nodeid=\"40379\">\n                          <td data-nodeid=\"40380\">思考题</td>\n                          <td data-nodeid=\"40381\">\n                            <a\n                              href=\"https://leetcode-cn.com/problems/minimum-path-sum/description/?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40469\"\n                              >测试平台</a\n                            >\n                          </td>\n                          <td data-nodeid=\"40382\">\n                            代码：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40473\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40477\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"40481\"\n                              >Python</a\n                            >\n                          </td>\n                        </tr>\n                      </tbody>\n                    </table>\n            "}