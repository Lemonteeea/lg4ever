{"title":"35 | 案例：如何在微服务中集成 Zipkin 组件？","context":"\n                    <p data-nodeid=\"170290\">\n                      这一课时我们就来进行案例实战，选择当前流行的链路追踪组件\n                      Zipkin 作为示例，演示如何在 Go 微服务中集成\n                      Zipkin。对于很多使用了 Go\n                      微服务框架的用户来说，其框架本身就拥有 Trace 模块，如\n                      Go-kit。所以本课时我们就在 Go-kit 微服务的案例中集成\n                      Zipkin。\n                    </p>\n                    <p data-nodeid=\"170291\">\n                      Zipkin 社区提供了诸如\n                      zipkin-go、zipkin-go-opentracing、go-zipkin 等 Go\n                      客户端库，后面我们会介绍如何将其中的\n                      zipkin-go-opentracing（组件地址参见\n                      https://github.com/openzipkin-contrib/zipkin-go-opentracing）集成到微服务中并加以应用。\n                    </p>\n                    <p data-nodeid=\"170292\">\n                      Go-kit 微服务框架的 tracing 包为服务提供了 Dapper\n                      样式的请求追踪。Go-kit 支持 OpenTracing API，并使用\n                      opentracing-go\n                      包为其服务器和客户端提供追踪中间件。Zipkin、LightStep 和\n                      AppDash 是已支持的追踪组件，通过 OpenTracing API 与 Go-kit\n                      一起使用。\n                    </p>\n                    <h3 data-nodeid=\"170293\">应用架构图</h3>\n                    <p data-nodeid=\"172120\">\n                      本课时将会介绍如何在 Go-kit 中集成 Zipkin\n                      进行链路调用的追踪，包括<strong data-nodeid=\"172128\"\n                        >HTTP 和 gRPC 两种调用方式</strong\n                      >。在具体介绍这两种调用方式之前，我们先来看一下 Go-kit\n                      集成 Zipkin 的应用架构，如下图所示：\n                    </p>\n                    <p data-nodeid=\"172121\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/75/Ciqc1F-GvryAbSsGAABD2LP4yN8428.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"172131\"\n                      />\n                    </p>\n                    <div data-nodeid=\"172122\">\n                      <p style=\"text-align: center\">\n                        Go-kit 集成 Zipkin 的应用架构图\n                      </p>\n                    </div>\n\n                    <p data-nodeid=\"170297\">\n                      从架构图中可以看到：我们构建了一个服务网关，通过 API\n                      网关调用具体的微服务，所有的服务都注册到 Consul\n                      上；当客户端的请求到来之时，网关作为服务端的门户，会根据配置的规则，从\n                      Consul\n                      中获取对应服务的信息，并将请求反向代理到指定的服务实例。\n                    </p>\n                    <p data-nodeid=\"170298\">\n                      涉及的业务服务与组件包含以下 4 个：\n                    </p>\n                    <ul data-nodeid=\"170299\">\n                      <li data-nodeid=\"170300\">\n                        <p data-nodeid=\"170301\">Consul，本地安装并启动；</p>\n                      </li>\n                      <li data-nodeid=\"170302\">\n                        <p data-nodeid=\"170303\">Zipkin，本地安装并启动；</p>\n                      </li>\n                      <li data-nodeid=\"170304\">\n                        <p data-nodeid=\"170305\">API Gateway，微服务网关；</p>\n                      </li>\n                      <li data-nodeid=\"170306\">\n                        <p data-nodeid=\"170307\">\n                          String Service，字符串服务，是基于 Kit\n                          构建的，提供基本的字符串操作。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"170308\">HTTP 调用方式的链路追踪</h3>\n                    <p data-nodeid=\"170309\">\n                      关于 HTTP\n                      调用方式的链路追踪，下面我们将依次构建微服务网关、业务服务，并进行结果验证。\n                    </p>\n                    <h4 data-nodeid=\"172532\" class=\"\">1. API 网关构建</h4>\n\n                    <p data-nodeid=\"170313\">\n                      在网关（gateway）中增加链路追踪的采集逻辑，同时在反向代理中增加追踪（tracer）设置。\n                    </p>\n                    <p data-nodeid=\"170314\">\n                      Go-kit 在 tracing 包中默认添加了 Zipkin\n                      的支持，所以集成工作会比较轻松。在开始之前，需要下载以下依赖：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"># zipkin 官方库\n</div></li><li><div class=\"code-word\">go get github.com/openzipkin/zipkin-go\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"># 下面三个包都是依赖，按需下载\n</div></li><li><div class=\"code-word\">git clone https://github.com/googleapis/googleapis.git [your GOPATH]/ src/google.golang.org/genproto\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">git clone https://github.com/grpc/grpc-go.git [your GOPATH]/src/google. golang.org/grpc\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">git clone https://github.com/golang/text.git [your GOPATH]/src/golang. org/text\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"189686\" class=\"\">\n                      作为链路追踪的“第一站”和“最后一站”，网关会将客户端的请求转发给对应的业务服务，并将响应的结果返回给客户端。我们需要截获到达网关的所有请求，记录追踪信息。在下面这个示例中，网关是作为外部请求的服务端，同时作为字符串服务的客户端（反向代理内部实现），其代码实现如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 创建环境变量</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> (\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// consul 环境变量省略</span>\n</div></li><li><div class=\"code-word\">    zipkinURL  = flag.String(<span class=\"hljs-string\">\"zipkin.url\"</span>, <span class=\"hljs-string\">\"HTTP://localhost:9411/api/ v2/spans\"</span>, <span class=\"hljs-string\">\"Zipkin server url\"</span>)\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">flag.Parse()\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> zipkinTracer *zipkin.Tracer\n</div></li><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> (\n</div></li><li><div class=\"code-word\">        err           error\n</div></li><li><div class=\"code-word\">        hostPort      = <span class=\"hljs-string\">\"localhost:9090\"</span>\n</div></li><li><div class=\"code-word\">        serviceName   = <span class=\"hljs-string\">\"gateway-service\"</span>\n</div></li><li><div class=\"code-word\">        useNoopTracer = (*zipkinURL == <span class=\"hljs-string\">\"\"</span>)\n</div></li><li><div class=\"code-word\">        reporter      = zipkinHTTP.NewReporter(*zipkinURL)\n</div></li><li><div class=\"code-word\">    ) <span class=\"hljs-comment\">// zipkin 相关的配置变量</span>\n</div></li><li><div class=\"code-word\">    defer reporter.Close()\n</div></li><li><div class=\"code-word\">    zEP, <span class=\"hljs-attr\">_</span> := zipkin.NewEndpoint(serviceName, hostPort)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 构建 zipkinTracer</span>\n</div></li><li><div class=\"code-word\">    zipkinTracer, err = zipkin.NewTracer(\n</div></li><li><div class=\"code-word\">        reporter, zipkin.WithLocalEndpoint(zEP), zipkin.WithNoopTracer (useNoopTracer),\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> err != nil {\n</div></li><li><div class=\"code-word\">        logger.Log(<span class=\"hljs-string\">\"err\"</span>, err)\n</div></li><li><div class=\"code-word\">        os.Exit(<span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> !useNoopTracer {\n</div></li><li><div class=\"code-word\">        logger.Log(<span class=\"hljs-string\">\"tracer\"</span>, <span class=\"hljs-string\">\"Zipkin\"</span>, <span class=\"hljs-string\">\"type\"</span>, <span class=\"hljs-string\">\"Native\"</span>, <span class=\"hljs-string\">\"URL\"</span>, *zipkinURL)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"190656\">\n                      我们使用的传输方式为 HTTP，可以使用 zipkin-go 提供的\n                      middleware/HTTP 包，它采用装饰者模式把我们的 HTTP.Handler\n                      进行封装，然后启动 HTTP 监听，代码如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">//创建反向代理</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-attr\">proxy</span> := NewReverseProxy(consulClient, zipkinTracer, logger)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-attr\">tags</span> := map[string]string{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"component\"</span>: <span class=\"hljs-string\">\"gateway_server\"</span>,\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-attr\">handler</span> := zipkinHTTPsvr.NewServerMiddleware(\n</div></li><li><div class=\"code-word\">    zipkinTracer,\n</div></li><li><div class=\"code-word\">    zipkinHTTPsvr.SpanName(<span class=\"hljs-string\">\"gateway\"</span>),\n</div></li><li><div class=\"code-word\">    zipkinHTTPsvr.TagResponseSize(<span class=\"hljs-literal\">true</span>),\n</div></li><li><div class=\"code-word\">    zipkinHTTPsvr.ServerTags(tags),\n</div></li><li><div class=\"code-word\">)(proxy)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"193047\">\n                      网关接收请求后，会创建一个 Span，其中的 traceId\n                      将作为本次请求的唯一编号，网关必须把这个 traceID\n                      传递给字符串服务，字符串服务才能为该请求持续记录追踪信息。在\n                      ReverseProxy 中能够完成这一任务的就是\n                      Transport，我们可以使用 zipkin-go 的 middleware/HTTP\n                      包提供的 NewTransport 替换系统默认的\n                      HTTP.DefaultTransport。代码如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// NewReverseProxy 创建反向代理处理方法</span>\n</div></li><li><div class=\"code-word\">func NewReverseProxy(client *api.Client, zikkinTracer *zipkin.Tracer, logger log.Logger) *HTTPutil.ReverseProxy {\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">//创建 Director</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">director</span> := func(req *HTTP.Request) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//省略</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 为反向代理增加追踪逻辑，使用如下 RoundTrip 代替默认 Transport</span>\n</div></li><li><div class=\"code-word\">    roundTrip, <span class=\"hljs-attr\">_</span> := zipkinHTTPsvr.NewTransport(zikkinTracer, zipkinHTTPsvr.TransportTrace(<span class=\"hljs-literal\">true</span>))\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> &amp;HTTPutil.ReverseProxy{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">Director</span>:  director,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">Transport</span>: roundTrip,\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"195111\">\n                      至此，API 网关服务的搭建就完成了。\n                    </p>\n                    <h4 data-nodeid=\"195112\">2. 业务服务构建</h4>\n                    <p data-nodeid=\"195113\">\n                      创建追踪器与网关的处理方式一样，我们就不再描述。字符串服务对外提供了两个接口：字符串操作（/op/{type}/{a}/{b}）和健康检查（/health）。定义如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">endpoint := MakeStringEndpoint(svc)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//添加追踪，设置 span 的名称为 string-endpoint</span>\n</div></li><li><div class=\"code-word\">endpoint = Kitzipkin.TraceEndpoint(zipkinTracer, <span class=\"hljs-string\">\"string-endpoint\"</span>) (endpoint)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//创建健康检查的 Endpoint</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-attr\">healthEndpoint</span> := MakeHealthCheckEndpoint(svc)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//添加追踪，设置 span 的名称为 health-endpoint</span>\n</div></li><li><div class=\"code-word\">healthEndpoint = Kitzipkin.TraceEndpoint(zipkinTracer, <span class=\"hljs-string\">\"health-endpoint\"</span>) (healthEndpoint)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"198227\">\n                      Go-kit 提供了对 zipkin-go\n                      的封装，上面的实现中，直接调用中间件 TraceEndpoint\n                      对字符串服务的两个 Endpoint 进行设置。\n                    </p>\n                    <p data-nodeid=\"198228\">\n                      除了 Endpoint，还需要追踪 Transport。可以修改\n                      transports.go 的 MakeHTTPHandler 方法，增加参数\n                      zipkinTracer，然后在 ServerOption\n                      中设置追踪参数。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// MakeHTTPHandler make HTTP handler use mux</span>\n</div></li><li><div class=\"code-word\">func MakeHTTPHandler(ctx context.Context, endpoints ArithmeticEndpoints, zipkinTracer *gozipkin.Tracer, logger log.Logger) HTTP.Handler {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">r</span> := mux.NewRouter()\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">zipkinServer</span> := zipkin.HTTPServerTrace(zipkinTracer, zipkin.Name (<span class=\"hljs-string\">\"HTTP-transport\"</span>))\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">options</span> := []KitHTTP.ServerOption{\n</div></li><li><div class=\"code-word\">        KitHTTP.ServerErrorLogger(logger),\n</div></li><li><div class=\"code-word\">        KitHTTP.ServerErrorEncoder(KitHTTP.DefaultErrorEncoder),\n</div></li><li><div class=\"code-word\">        zipkinServer,\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> r\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"199549\">\n                      至此，所有的代码修改工作已经完成，下一步就是启动测试、对结果验证了。\n                    </p>\n                    <h4 data-nodeid=\"199550\">3. 结果验证</h4>\n                    <p data-nodeid=\"199551\">\n                      我们可以访问\n                      http://localhost:9090/string-service/op/Diff/abc/bcd，查看字符串服务的请求结果，如下图所示：\n                    </p>\n                    <p data-nodeid=\"199552\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/75/Ciqc1F-GvvSAdvD2AAJxdVYATAU644.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"199599\"\n                      />\n                    </p>\n                    <div data-nodeid=\"199553\">\n                      <p style=\"text-align: center\">结果验证截图</p>\n                    </div>\n                    <p data-nodeid=\"199554\">\n                      可以看到，通过网关，我们可以正常访问字符串服务提供的接口。下面我们通过\n                      Zipkin UI 来查看本次链路调用的信息，如下图所示：\n                    </p>\n                    <p data-nodeid=\"199555\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/80/CgqCHl-GvvqAccZPAAPASa8eLYA067.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"199603\"\n                      />\n                    </p>\n                    <div data-nodeid=\"199556\">\n                      <p style=\"text-align: center\">\n                        Zipkin UI 查看链路调用的信息截图\n                      </p>\n                    </div>\n                    <p data-nodeid=\"199557\">\n                      在浏览器请求之后，可以在 Zipkin UI\n                      中看到发送的请求记录（单击上方“Try Lens UI”切换成了 Lens\n                      UI，效果还不错），点击查看详细的链路调用情况，如下图所示：\n                    </p>\n                    <p data-nodeid=\"199558\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/75/Ciqc1F-GvwOAO5wJAANEaW1O3C4296.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"199607\"\n                      />\n                    </p>\n                    <div data-nodeid=\"199559\">\n                      <p style=\"text-align: center\">Lens UI 截图</p>\n                    </div>\n                    <p data-nodeid=\"199560\">\n                      从调用链中可以看到，本次请求涉及两个服务：gateway-service\n                      和 string-service。\n                    </p>\n                    <p data-nodeid=\"199561\">\n                      整个链路有 3 个 Span：gateway、HTTP-transport 和\n                      string-endpoint，确实如我们所定义的一样。这里我们主要看一下网关中的\n                      Gateway Span 详情，如下图所示：\n                    </p>\n                    <p data-nodeid=\"199562\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/80/CgqCHl-GvwuASVfGAAcZvmOB0Kc881.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"199612\"\n                      />\n                    </p>\n                    <div data-nodeid=\"199563\">\n                      <p style=\"text-align: center\">Gateway Span 详情截图</p>\n                    </div>\n                    <p data-nodeid=\"199564\">\n                      Gateway\n                      访问字符串服务的时候，其实是作为一个客户端建立连接并发起调用，然后等待\n                      Server\n                      写回响应结果，最后结束客户端的调用。通过上图的展开，我们清楚地了解这次调用（Span）打的标签（tag），包括\n                      method、path 等。\n                    </p>\n                    <h3 data-nodeid=\"199565\">gRPC 调用方式的链路追踪</h3>\n                    <p data-nodeid=\"199566\">\n                      上面我们分析了微服务中 HTTP 调用方式的链路追踪，Go-kit\n                      中的 transport 层可以方便地切换 RPC\n                      调用方式，所以下面我们就来介绍下基于 gRPC\n                      调用方式的链路追踪。本案例的实现是在前面HTTP\n                      调用的代码基础上进行修改，并增加测试的调用客户端。\n                    </p>\n                    <h4 data-nodeid=\"199567\">1. 定义 protobuf 文件</h4>\n                    <p data-nodeid=\"199568\">\n                      我们首先来定义 protobuf 文件及生成对应的 Go 文件。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">syntax = <span class=\"hljs-string\">\"proto3\"</span>;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">package pb;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">service StringService{\n</div></li><li><div class=\"code-word\">    rpc Diff(StringRequest) returns (StringResponse){}\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">message StringRequest {\n</div></li><li><div class=\"code-word\">    string request_type = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    string a = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">    string b = <span class=\"hljs-number\">3</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">message StringResponse {\n</div></li><li><div class=\"code-word\">    string result = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    string err = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"201404\">\n                      这里提供了字符串服务中的 Diff 方法，客户端通过 gRPC\n                      调用字符串服务。使用 proto 工具生成对应的 Go 语言文件：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">protoc string.proto --go_out=plugins=grpc:.\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"210043\">\n                      生成的 string.pb.go 可以参见<a\n                        href=\"https://github.com/longjoy/micro-go-course/blob/dev/section35/zipkin-kit/pb/string.pb.go\"\n                        data-nodeid=\"210066\"\n                        >源码</a\n                      >，此处不再展开。\n                    </p>\n                    <h4 data-nodeid=\"210044\">2. 定义 gRPC Server</h4>\n                    <p data-nodeid=\"210045\">\n                      在字符串服务中增加 gRPC server 的实现，并织入 gRPC\n                      链路追踪的相关代码。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">\t<span class=\"hljs-comment\">//grpc server</span>\n</div></li><li><div class=\"code-word\">\tgo func() {\n</div></li><li><div class=\"code-word\">\t\tfmt.Println(<span class=\"hljs-string\">\"grpc Server start at port\"</span> + *grpcAddr)\n</div></li><li><div class=\"code-word\">\t\tlistener, <span class=\"hljs-attr\">err</span> := net.Listen(<span class=\"hljs-string\">\"tcp\"</span>, *grpcAddr)\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">if</span> err != nil {\n</div></li><li><div class=\"code-word\">\t\t\terrChan &lt;- err\n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">\t\t}\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-attr\">serverTracer</span> := kitzipkin.GRPCServerTrace(zipkinTracer, kitzipkin.Name(<span class=\"hljs-string\">\"string-grpc-transport\"</span>))\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-attr\">handler</span> := NewGRPCServer(ctx, endpts, serverTracer)\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-attr\">gRPCServer</span> := grpc.NewServer()\n</div></li><li><div class=\"code-word\">\t\tpb.RegisterStringServiceServer(gRPCServer, handler)\n</div></li><li><div class=\"code-word\">\t\terrChan &lt;- gRPCServer.Serve(listener)\n</div></li><li><div class=\"code-word\">\t}()\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"212780\">\n                      要增加 Trace 的中间件，其实就是在 gRPC 的 ServerOption\n                      中追加 GRPCServerTrace。我们增加的通用 Span\n                      名为：string-grpc-transport。接下来就是在 endpoint\n                      中，增加暴露接口的 gRPC 实现，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">func (se StringEndpoints) Diff(ctx context.Context, a, b string) (string, error) {\n</div></li><li><div class=\"code-word\">\tresp, <span class=\"hljs-attr\">err</span> := se.StringEndpoint(ctx, StringRequest{\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-attr\">RequestType</span>: <span class=\"hljs-string\">\"Diff\"</span>,\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-attr\">A</span>:           a,\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-attr\">B</span>:           b,\n</div></li><li><div class=\"code-word\">\t})\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-attr\">response</span> := resp.(StringResponse)\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> response.Result, err\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"213935\">\n                      在构造 StringRequest 时，我们根据调用的 Diff\n                      方法，指定了请求参数为“Diff”，下面即可定义 RPC\n                      调用的客户端。\n                    </p>\n                    <h4 data-nodeid=\"213936\">3. 定义服务 gRPC 调用的客户端</h4>\n                    <p data-nodeid=\"213937\">\n                      字符串服务提供对外的客户端调用，定义方法名为\n                      StringDiff，返回 StringEndpoint，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> (\n</div></li><li><div class=\"code-word\">\tgrpctransport <span class=\"hljs-string\">\"github.com/go-kit/kit/transport/grpc\"</span>\n</div></li><li><div class=\"code-word\">\tkitgrpc <span class=\"hljs-string\">\"github.com/go-kit/kit/transport/grpc\"</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-string\">\"github.com/longjoy/micro-go-course/section35/zipkin-kit/pb\"</span>\n</div></li><li><div class=\"code-word\">\tendpts <span class=\"hljs-string\">\"github.com/longjoy/micro-go-course/section35/zipkin-kit/string-service/endpoint\"</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-string\">\"github.com/longjoy/micro-go-course/section35/zipkin-kit/string-service/service\"</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-string\">\"google.golang.org/grpc\"</span>\n</div></li><li><div class=\"code-word\">)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">func StringDiff(conn *grpc.ClientConn, clientTracer kitgrpc.ClientOption) service.Service {\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">var</span> ep = grpctransport.NewClient(conn,\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-string\">\"pb.StringService\"</span>,\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-string\">\"Diff\"</span>,\n</div></li><li><div class=\"code-word\">\t\tEncodeGRPCStringRequest, <span class=\"hljs-comment\">// 请求的编码</span>\n</div></li><li><div class=\"code-word\">\t\tDecodeGRPCStringResponse, <span class=\"hljs-comment\">// 响应的解码</span>\n</div></li><li><div class=\"code-word\">\t\tpb.StringResponse{}, <span class=\"hljs-comment\">//定义返回的对象</span>\n</div></li><li><div class=\"code-word\">\t\tclientTracer, <span class=\"hljs-comment\">//客户端的 GRPCClientTrace</span>\n</div></li><li><div class=\"code-word\">\t).Endpoint()\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-attr\">StringEp</span> := endpts.StringEndpoints{\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-attr\">StringEndpoint</span>: ep,\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> StringEp\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"215437\" class=\"\">\n                      从客户端调用的定义可以看到，传入的是 grpc 连接和客户端的\n                      trace 上下文。这里需要注意的是 GRPCClientTrace\n                      的初始化，测试 gRPC 调用的客户端时将会传入该参数。\n                    </p>\n                    <h4 data-nodeid=\"215438\">4. 测试 gRPC 调用的客户端</h4>\n                    <p data-nodeid=\"215627\">\n                      编写 client_test.go，调用我们在前面已经定义的\n                      client.StringDiff 方法，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">\t<span class=\"hljs-comment\">//... zipkinTracer 的构造省略</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-attr\">tr</span> := zipkinTracer\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 设定根 Span 的名称</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-attr\">parentSpan</span> := tr.StartSpan(<span class=\"hljs-string\">\"test\"</span>)\n</div></li><li><div class=\"code-word\">\tdefer parentSpan.Flush() <span class=\"hljs-comment\">// 写入上下文</span>\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-attr\">ctx</span> := zipkin.NewContext(context.Background(), parentSpan)\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">//初始化 GRPCClientTrace</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-attr\">clientTracer</span> := kitzipkin.GRPCClientTrace(tr) \n</div></li><li><div class=\"code-word\">\tconn, <span class=\"hljs-attr\">err</span> := grpc.Dial(*grpcAddr, grpc.WithInsecure(), grpc.WithTimeout (<span class=\"hljs-number\">1</span>*time.Second))\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">if</span> err != nil {\n</div></li><li><div class=\"code-word\">\t\tfmt.Println(<span class=\"hljs-string\">\"gRPC dial err:\"</span>, err)\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\tdefer conn.Close()\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 获取 rpc 调用的 endpoint，发起调用</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-attr\">svr</span> := client.StringDiff(conn, clientTracer)\n</div></li><li><div class=\"code-word\">\tresult, <span class=\"hljs-attr\">err</span> := svr.Diff(ctx, <span class=\"hljs-string\">\"Add\"</span>, <span class=\"hljs-string\">\"ppsdd\"</span>)\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">if</span> err != nil {\n</div></li><li><div class=\"code-word\">\t\tfmt.Println(<span class=\"hljs-string\">\"Diff error\"</span>, err.Error())\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\tfmt.Println(<span class=\"hljs-string\">\"result =\"</span>, result)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"216905\">\n                      客户端在调用之前，我们构建了要传入的\n                      GRPCClientTrace，作为获取 rpc 调用的 endpoint\n                      的参数，设定调用的父 Span 名称，这个上下文信息会传入\n                      Zipkin 服务端。调用输出的结果如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">ts=<span class=\"hljs-number\">2020</span><span class=\"hljs-number\">-9</span><span class=\"hljs-number\">-24</span>T15:<span class=\"hljs-number\">27</span>:<span class=\"hljs-number\">06.817056</span>Z caller=client_test.go:<span class=\"hljs-number\">51</span> tracer=Zipkin type=Native URL=http:<span class=\"hljs-comment\">//localhost:9411/api/v2/spans</span>\n</div></li><li><div class=\"code-word\">result = dd\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"220370\">\n                      测试用例的调用结果正确，我们来看一下 Zipkin\n                      中记录的调用链信息。点击查看详情，可以看到本次请求涉及两个服务：test-service\n                      和 string-service。如图所示：\n                    </p>\n                    <p data-nodeid=\"220371\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/81/CgqCHl-GvzeAWzGRAASmhMb8V3c466.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"220375\"\n                      />\n                    </p>\n            "}