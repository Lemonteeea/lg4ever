{"title":"30 | 实现高可用：使用 Puppeteer 生成性能最优的海报系统","context":"\n                    <p data-nodeid=\"853\" class=\"\">\n                      在前面<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=584#/detail/pc?id=5957&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"942\"\n                        >第 28 讲“设计性能守卫系统：完善 CI/CD 流程”</a\n                      >中我们提到了 Puppeteer。事实上，以 Puppeteer 为代表的\n                      Headless 浏览器在 Node.js\n                      中的应用极为广泛，这一讲，就让我们对 Puppeteer\n                      进行深入分析和应用。\n                    </p>\n                    <h3 data-nodeid=\"854\">Puppeteer 介绍和原理</h3>\n                    <p data-nodeid=\"855\">\n                      我们先对 Puppeteer 进行一个基本介绍。（<a\n                        href=\"https://github.com/puppeteer?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"948\"\n                        >Puppeteer 官方地址</a\n                      >）\n                    </p>\n                    <blockquote data-nodeid=\"856\">\n                      <p data-nodeid=\"857\">\n                        Puppeteer 是一个 Node 库，它提供了一整套高级 API，通过\n                        DevTools 协议控制 Chromium 或\n                        Chrome。正如其翻译为“操纵木偶的人”一样，你可以通过\n                        Puppeteer 提供的 API 直接控制\n                        Chrome，模拟大部分用户操作，进行 UI\n                        测试或者作为爬虫访问页面来收集数据。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"858\">\n                      整个定义非常好理解，这里需要开发者注意的是，Puppeteer 在\n                      1.7.0 版本之后，会同时给开发者提供：\n                    </p>\n                    <ul data-nodeid=\"859\">\n                      <li data-nodeid=\"860\">\n                        <p data-nodeid=\"861\">Puppeteer</p>\n                      </li>\n                      <li data-nodeid=\"862\">\n                        <p data-nodeid=\"863\">Puppeteer-core</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"864\">\n                      两个版本。它们的区别在于载入安装 Puppeteer 时，是否会下载\n                      Chromium。Puppeteer-core 默认不下载\n                      Chromium，同时会忽略所有 puppeteer_*\n                      环境变量。对于开发者来说，使用 Puppeteer-core\n                      无疑更加轻便，但是<strong data-nodeid=\"966\"\n                        >需要提前保证环境中已经具有可执行的 Chromium</strong\n                      >（具体说明可见<a\n                        href=\"https://github.com/puppeteer/puppeteer/blob/main/docs/api.md#puppeteer-vs-puppeteer-core?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"964\"\n                        >puppeteer vs puppeteer-core</a\n                      >）。\n                    </p>\n                    <p data-nodeid=\"865\">具体 Puppeteer 的应用场景有：</p>\n                    <ul data-nodeid=\"866\">\n                      <li data-nodeid=\"867\">\n                        <p data-nodeid=\"868\">\n                          为网页生成页面 PDF 或者截取图片；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"869\">\n                        <p data-nodeid=\"870\">\n                          抓取 SPA（单页应用）并生成预渲染内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"871\">\n                        <p data-nodeid=\"872\">\n                          自动提交表单，进行 UI 测试、键盘输入等；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"873\">\n                        <p data-nodeid=\"874\">\n                          创建一个随时更新的自动化测试环境，使用最新的\n                          JavaScript 和浏览器功能直接在最新版本的 Chrome\n                          中执行测试；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"875\">\n                        <p data-nodeid=\"876\">\n                          捕获网站的<a\n                            href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference?fileGuid=xxQTRXtVcqtHK6j8\"\n                            data-nodeid=\"975\"\n                            >timeline trace</a\n                          >，用来帮助分析性能问题；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"877\">\n                        <p data-nodeid=\"878\">测试浏览器扩展。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"879\">\n                      下面我们就梳理一些 Puppeteer\n                      应用的重点场景，并详细介绍如何使用 Puppeteer\n                      实现一个高性能的海报 Node.js 服务。\n                    </p>\n                    <h3 data-nodeid=\"880\">Puppeteer 在 SSR 中的应用</h3>\n                    <p data-nodeid=\"881\">\n                      区别于第 27 讲介绍的<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=584#/detail/pc?id=5956&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"983\"\n                        >“同构渲染架构：实现一个 SSR 应用”</a\n                      >，使用 Puppeteer\n                      实现服务端预渲染出发点完全不同。这种方案最大的好处是不需要对项目代码进行任何调整，却能获取到\n                      SSR 应用的收益。当然，相比同构渲染，基于 Puppeteer 技术的\n                      SSR 在灵活性和扩展性上都有所局限。甚至在 Node.js\n                      端渲染的性能成本也较高，不过该技术也逐渐落地，并在很多场景发挥了重要价值。\n                    </p>\n                    <p data-nodeid=\"882\">比如对于这样的一个页面，代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;html&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">&lt;!-- Populated by the JS below. --&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 JavaScript 脚本，进行 CSR 渲染</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">renderPosts</span>(<span class=\"hljs-params\">posts, container</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> html = posts.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">html, post</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\\`<span class=\"hljs-subst\">${html}</span>\n</span></div></li><li><div class=\"code-word\">      &lt;li class=\"post\"&gt;\n</div></li><li><div class=\"code-word\">        &lt;h2&gt;<span class=\"hljs-subst\">${post.title}</span>&lt;/h2&gt;\n</div></li><li><div class=\"code-word\">        &lt;div class=\"summary\"&gt;<span class=\"hljs-subst\">${post.summary}</span>&lt;/div&gt;\n</div></li><li><div class=\"code-word\">        &lt;p&gt;<span class=\"hljs-subst\">${post.content}</span>&lt;/p&gt;\n</div></li><li><div class=\"code-word\">      &lt;/li&gt;\\`;\n</div></li><li><div class=\"code-word\">  }, <span class=\"hljs-string\">''</span>);\n</div></li><li><div class=\"code-word\">  container.innerHTML = <span class=\"hljs-string\">\\`&lt;ul id=\"posts\"&gt;<span class=\"hljs-subst\">${html}</span>&lt;/ul&gt;\\`</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">(<span class=\"hljs-keyword\">async</span>() =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'#container'</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 发送数据请求</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> posts = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">'/posts'</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">resp</span> =&gt;</span> resp.json());\n</div></li><li><div class=\"code-word\">  renderPosts(posts, container);\n</div></li><li><div class=\"code-word\">})();\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li><li><div class=\"code-word\">&lt;/html&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"884\">\n                      该页面是一个典型的 CSR 页面，依靠\n                      Ajax，实现了页面动态化渲染。\n                    </p>\n                    <p data-nodeid=\"885\">\n                      当在 Node.js 端使用 Puppeteer 渲染时，我们可以实现<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"988\"\n                        >ssr.mjs</code\n                      >，完成渲染任务，如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> puppeteer from <span class=\"hljs-string\">'puppeteer'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 将已经渲染过的页面，缓存在内存中</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> RENDER_CACHE = <span class=\"hljs-keyword\">new</span> Map();\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">async function <span class=\"hljs-title\">ssr</span><span class=\"hljs-params\">(url)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 命中缓存</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (RENDER_CACHE.has(url)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {html: RENDER_CACHE.get(url), ttRenderMs: <span class=\"hljs-number\">0</span>};\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> start = Date.now();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 使用 Puppeteer launch 一个无头浏览器</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> browser = await puppeteer.launch();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> page = await browser.newPage();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 访问页面地址直到页面网络状态为 idle</span>\n</div></li><li><div class=\"code-word\">    await page.goto(url, {waitUntil: <span class=\"hljs-string\">'networkidle0'</span>});\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 确保 #posts 节点已经存在</span>\n</div></li><li><div class=\"code-word\">    await page.waitForSelector(<span class=\"hljs-string\">'#posts'</span>);\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">catch</span> (err) {\n</div></li><li><div class=\"code-word\">    console.error(err);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(<span class=\"hljs-string\">'page.goto/waitForSelector timed out.'</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 获取 html 内容</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> html = await page.content(); \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 关闭无头浏览器</span>\n</div></li><li><div class=\"code-word\">  await browser.close();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> ttRenderMs = Date.now() - start;\n</div></li><li><div class=\"code-word\">  console.info(\\`Headless rendered page in: ${ttRenderMs}ms\\`);\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 进行缓存存储</span>\n</div></li><li><div class=\"code-word\">  RENDER_CACHE.set(url, html);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> {html, ttRenderMs};\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">export {ssr as <span class=\"hljs-keyword\">default</span>};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"887\">\n                      对应<code data-backticks=\"1\" data-nodeid=\"991\"\n                        >server.mjs</code\n                      >代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> express from <span class=\"hljs-string\">'express'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> ssr from <span class=\"hljs-string\">'./ssr.mjs'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> app = express();\n</div></li><li><div class=\"code-word\">app.get(<span class=\"hljs-string\">'/'</span>, async (req, res, next) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 调用 SSR 方法渲染页面</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> {html, ttRenderMs} = <span class=\"hljs-function\">await <span class=\"hljs-title\">ssr</span><span class=\"hljs-params\">(\\`xxx/index.html\\`)</span></span>;\n</div></li><li><div class=\"code-word\">  res.set(<span class=\"hljs-string\">'Server-Timing'</span>, \\`Prerender;dur=${ttRenderMs};desc=<span class=\"hljs-string\">\"Headless render time (ms)\"</span>\\`);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> res.status(<span class=\"hljs-number\">200</span>).send(html);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\">app.listen(<span class=\"hljs-number\">8080</span>, () =&gt; console.log(<span class=\"hljs-string\">'Server started. Press Ctrl+C to quit'</span>));\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"889\">\n                      当然上述实现比较简陋，只是进行原理说明。如果更进一步，我们可以从以下几个角度进行优化：\n                    </p>\n                    <ul data-nodeid=\"890\">\n                      <li data-nodeid=\"891\">\n                        <p data-nodeid=\"892\">\n                          改造浏览器端代码，防止重复请求接口；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"893\">\n                        <p data-nodeid=\"894\">\n                          在 Node.js 端，abort\n                          掉不必要的请求，以得到更快的服务端渲染响应速度；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"895\">\n                        <p data-nodeid=\"896\">将关键资源内连进 HTML；</p>\n                      </li>\n                      <li data-nodeid=\"897\">\n                        <p data-nodeid=\"898\">自动压缩静态资源；</p>\n                      </li>\n                      <li data-nodeid=\"899\">\n                        <p data-nodeid=\"900\">\n                          在 Node.js 端，渲染页面时，重复利用 Chrome 实例。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"901\">这里我们用简单代码进行说明：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> express from <span class=\"hljs-string\">'express'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> puppeteer from <span class=\"hljs-string\">'puppeteer'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> ssr from <span class=\"hljs-string\">'./ssr.mjs'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 重复使用 Chrome 实例</span>\n</div></li><li><div class=\"code-word\">  let browserWSEndpoint = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> app = express();\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  app.get(<span class=\"hljs-string\">'/'</span>, async (req, res, next) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!browserWSEndpoint) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 一下两行代码不必随着渲染重复执行</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> browser = await puppeteer.launch();\n</div></li><li><div class=\"code-word\">      browserWSEndpoint = await browser.wsEndpoint();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> url = \\`${req.protocol}:<span class=\"hljs-comment\">//${req.get('host')}/index.html\\`;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> {html} = <span class=\"hljs-function\">await <span class=\"hljs-title\">ssr</span><span class=\"hljs-params\">(url, browserWSEndpoint)</span></span>;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> res.status(<span class=\"hljs-number\">200</span>).send(html);\n</div></li><li><div class=\"code-word\">  });\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"903\">\n                      至此，我们从原理和代码层面分析了 Puppeteer 在 SSR\n                      中的应用。接下来我们来了解更多的 Puppeteer\n                      使用场景，请你继续阅读。\n                    </p>\n                    <h3 data-nodeid=\"904\">Puppeteer 在 UI 测试中的应用</h3>\n                    <p data-nodeid=\"905\">\n                      Puppeteer 在 UI\n                      测试（即端到端测试）中也可以大显身手，比如和 Jest\n                      结合，通过断言能力实现一个完备的端到端测试系统。\n                    </p>\n                    <p data-nodeid=\"906\">比如下面代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> puppeteer = require(<span class=\"hljs-string\">'puppeteer'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 测试页面 title 符合预期</span>\n</div></li><li><div class=\"code-word\">test(<span class=\"hljs-string\">'baidu title is correct'</span>, async () =&gt; {\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 启动一个无头浏览器</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> browser = await puppeteer.launch()\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 通过无头浏览器访问页面</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> page = await browser.newPage()\n</div></li><li><div class=\"code-word\">  await page.goto(<span class=\"hljs-string\">'https://xxxxx'</span>)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取页面 title</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> title = await page.title()\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 使用 Jest 的 test 和 expect 两个全局函数进行断言</span>\n</div></li><li><div class=\"code-word\">  expect(title).toBe(<span class=\"hljs-string\">'xxxx'</span>)\n</div></li><li><div class=\"code-word\">  await browser.close()\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"908\">\n                      上面代码简单清晰地勾勒出了 Puppeteer 结合 Jest\n                      实现端到端测试的场景。实际上，现在流行的主流端到端测试框架，比如\n                      Cypress 原理都如上代码所示。\n                    </p>\n                    <p data-nodeid=\"909\">\n                      接下来，我们来分析 Puppeteer 结合 Lighthouse 应用场景。\n                    </p>\n                    <h3 data-nodeid=\"910\">\n                      Puppeteer 结合 Lighthouse 应用场景\n                    </h3>\n                    <p data-nodeid=\"911\">\n                      在<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=584#/detail/pc?id=5957&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"1010\"\n                        >第 28 讲“设计性能守卫系统：完善 CI/CD 流程”</a\n                      >中我们也提到了 Lighthouse，既然 Puppeteer 可以和 Jest\n                      结合实现一个端到端测试框架，当然也可以和 Lighthouse\n                      结合——这就是一个简单的性能守卫系统的雏形。\n                    </p>\n                    <p data-nodeid=\"912\">我们再通过代码来说明，如下代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> chromeLauncher = require(<span class=\"hljs-string\">'chrome-launcher'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> puppeteer = require(<span class=\"hljs-string\">'puppeteer'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> lighthouse = require(<span class=\"hljs-string\">'lighthouse'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> config = require(<span class=\"hljs-string\">'lighthouse/lighthouse-core/config/lr-desktop-config.js'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> reportGenerator = require(<span class=\"hljs-string\">'lighthouse/lighthouse-core/report/report-generator'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> request = require(<span class=\"hljs-string\">'request'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> util = require(<span class=\"hljs-string\">'util'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> fs = require(<span class=\"hljs-string\">'fs'</span>);\n</div></li><li><div class=\"code-word\">(async() =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 默认配置 </span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> opts = {\n</div></li><li><div class=\"code-word\">        logLevel: <span class=\"hljs-string\">'info'</span>,\n</div></li><li><div class=\"code-word\">        output: <span class=\"hljs-string\">'json'</span>,\n</div></li><li><div class=\"code-word\">        disableDeviceEmulation: <span class=\"hljs-keyword\">true</span>,\n</div></li><li><div class=\"code-word\">        defaultViewport: {\n</div></li><li><div class=\"code-word\">            width: <span class=\"hljs-number\">1200</span>,\n</div></li><li><div class=\"code-word\">            height: <span class=\"hljs-number\">900</span>\n</div></li><li><div class=\"code-word\">        },\n</div></li><li><div class=\"code-word\">        chromeFlags: [<span class=\"hljs-string\">'--disable-mobile-emulation'</span>]\n</div></li><li><div class=\"code-word\">    };\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-comment\">// 使用 chromeLauncher 启动一个 chrome 实例</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> chrome = await chromeLauncher.launch(opts);\n</div></li><li><div class=\"code-word\">    opts.port = chrome.port;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 puppeteer.connect 连接 chrome 实例</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> resp = await util.promisify(request)(\\`http:<span class=\"hljs-comment\">//localhost:${opts.port}/json/version\\`);</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> {webSocketDebuggerUrl} = JSON.parse(resp.body);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> browser = await puppeteer.connect({browserWSEndpoint: webSocketDebuggerUrl});\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// Puppeteer 访问逻辑</span>\n</div></li><li><div class=\"code-word\">    page = (await browser.pages())[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">    await page.setViewport({ width: <span class=\"hljs-number\">1200</span>, height: <span class=\"hljs-number\">900</span>});\n</div></li><li><div class=\"code-word\">    console.log(page.url());\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 lighthouse 产出报告</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> report = <span class=\"hljs-function\">await <span class=\"hljs-title\">lighthouse</span><span class=\"hljs-params\">(page.url()</span>, opts, config).<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(results =&gt; {\n</span></span></div></li><li><div class=\"code-word\">        return results;\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> html = reportGenerator.generateReport(report.lhr, <span class=\"hljs-string\">'html'</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> json = reportGenerator.generateReport(report.lhr, <span class=\"hljs-string\">'json'</span>);\n</div></li><li><div class=\"code-word\">    await browser.disconnect();\n</div></li><li><div class=\"code-word\">    await chrome.kill();\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 将报告写入文件系统</span>\n</div></li><li><div class=\"code-word\">    fs.writeFile(<span class=\"hljs-string\">'report.html'</span>, html, (err) =&gt; {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (err) {\n</div></li><li><div class=\"code-word\">            console.error(err);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    fs.writeFile(<span class=\"hljs-string\">'report.json'</span>, json, (err) =&gt; {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (err) {\n</div></li><li><div class=\"code-word\">            console.error(err);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">})();\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"914\">\n                      整体流程非常清晰，是一个典型的 Puppeteer 与 Lighthouse\n                      结合的案例。事实上，我们看到 Puppeteer 或 Headless\n                      浏览器可以和多个领域能力相结合，在 Node.js\n                      服务上实现平台化能力。接下来，我们再看最后一个案例，请读者继续阅读。\n                    </p>\n                    <h3 data-nodeid=\"915\">Puppeteer 实现海报 Node.js 服务</h3>\n                    <p data-nodeid=\"916\">\n                      社区上我们常见生成海报的技术分享。应用场景很多，比如文稿中划线，进行“金句分享”，如下图所示：\n                    </p>\n                    <p data-nodeid=\"917\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/5C/CioPOWBURyGAdWWfAAVd4uI0v5k453.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"1018\"\n                      />\n                    </p>\n                    <p data-nodeid=\"918\">\n                      一般来说，生成海报可以使用<a\n                        href=\"https://github.com/niklasvh/html2canvas?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"1022\"\n                        >html2canvas</a\n                      >这样的类库完成，这里面的技术难点主要有跨域处理、分页处理、页面截图时机处理等。整体来说，并不难实现，但是稳定性一般。另一种生成海报的方式就是使用\n                      Puppeteer，构建一个 Node.js 服务来做页面截图。\n                    </p>\n                    <p data-nodeid=\"2155\">\n                      下面我们来实现一个名叫 posterMan\n                      的海报服务，整体技术链路如下图：\n                    </p>\n                    <p data-nodeid=\"2156\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/25/41/Cgp9HWBZg66ADjAJAAJBHVTqmKw043.png\"\n                        alt=\"图片4.png\"\n                        data-nodeid=\"2160\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"2792\">\n                      核心技术无外乎使用\n                      Puppeteer，访问页面并截图，这与前面几个场景是一样的，如下图所示：\n                    </p>\n                    <p data-nodeid=\"2793\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/25/3D/CioPOWBZg8GAX2qJAALAFyJ2lc8362.png\"\n                        alt=\"图片5.png\"\n                        data-nodeid=\"2797\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"923\">\n                      这里需要特别强调的是，为了实现最好的性能，我们<strong\n                        data-nodeid=\"1037\"\n                        >设计了一个链接池来存储 Puppeteer 实例</strong\n                      >，以备所需，如下图所示：\n                    </p>\n                    <p data-nodeid=\"924\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/5F/Cgp9HWBUR3WAUmueAAEA26Dx-54108.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1040\"\n                      />\n                    </p>\n                    <p data-nodeid=\"925\">\n                      在实现上，我们依赖<a\n                        href=\"https://www.npmjs.com/package/generic-pool?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"1044\"\n                        >generic-pool</a\n                      >库，这个库提供了 Promise\n                      风格的通用池，可以用来对一些高消耗、高成本资源的调用实现<strong\n                        data-nodeid=\"1050\"\n                        >防抖或拒绝服务</strong\n                      >能力，一个典型场景是对数据库的连接。这里我们把它用于\n                      Puppeteer 实例的创建，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> puppeteer = require(<span class=\"hljs-string\">'puppeteer'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> genericPool = require(<span class=\"hljs-string\">'generic-pool'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> createPuppeteerPool = ({\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// pool 的最大容量</span>\n</div></li><li><div class=\"code-word\">  max = <span class=\"hljs-number\">10</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// pool 的最小容量</span>\n</div></li><li><div class=\"code-word\">  min = <span class=\"hljs-number\">2</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 连接在池中保持空闲而不被回收的最小时间值</span>\n</div></li><li><div class=\"code-word\">  idleTimeoutMillis = <span class=\"hljs-number\">30000</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 最大使用数</span>\n</div></li><li><div class=\"code-word\">  maxUses = <span class=\"hljs-number\">50</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 在连接池交付实例前是否先经过 factory.validate 测试</span>\n</div></li><li><div class=\"code-word\">  testOnBorrow = <span class=\"hljs-keyword\">true</span>,\n</div></li><li><div class=\"code-word\">  puppeteerArgs = {},\n</div></li><li><div class=\"code-word\">  validator = () =&gt; Promise.resolve(<span class=\"hljs-keyword\">true</span>),\n</div></li><li><div class=\"code-word\">  ...otherConfig\n</div></li><li><div class=\"code-word\">} = {}) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> factory = {\n</div></li><li><div class=\"code-word\">  \t<span class=\"hljs-comment\">// 创建实例</span>\n</div></li><li><div class=\"code-word\">    create: () =&gt;\n</div></li><li><div class=\"code-word\">      puppeteer.launch(puppeteerArgs).then(instance =&gt; {\n</div></li><li><div class=\"code-word\">        instance.useCount = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> instance\n</div></li><li><div class=\"code-word\">      }),\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 销毁实例</span>\n</div></li><li><div class=\"code-word\">    destroy: instance =&gt; {\n</div></li><li><div class=\"code-word\">      instance.close()\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 验证实例可用性</span>\n</div></li><li><div class=\"code-word\">    validate: instance =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> validator(instance).then(valid =&gt;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// maxUses 小于 0 或者 instance 使用计数小于 maxUses 时可用</span>\n</div></li><li><div class=\"code-word\">        Promise.resolve(valid &amp;&amp; (maxUses &lt;= <span class=\"hljs-number\">0</span> || instance.useCount &lt; maxUses))\n</div></li><li><div class=\"code-word\">      )\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> config = {\n</div></li><li><div class=\"code-word\">    max,\n</div></li><li><div class=\"code-word\">    min,\n</div></li><li><div class=\"code-word\">    idleTimeoutMillis,\n</div></li><li><div class=\"code-word\">    testOnBorrow,\n</div></li><li><div class=\"code-word\">    ...otherConfig\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建连接池</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> pool = genericPool.createPool(factory, config)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> genericAcquire = pool.acquire.bind(pool)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 池中资源连接时进行的操作</span>\n</div></li><li><div class=\"code-word\">  pool.acquire = () =&gt;\n</div></li><li><div class=\"code-word\">    genericAcquire().then(instance =&gt; {\n</div></li><li><div class=\"code-word\">      instance.useCount += <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> instance\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  pool.use = fn =&gt; {\n</div></li><li><div class=\"code-word\">    let resource\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> pool\n</div></li><li><div class=\"code-word\">      .acquire()\n</div></li><li><div class=\"code-word\">      .then(r =&gt; {\n</div></li><li><div class=\"code-word\">        resource = r\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> r\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">      .then(fn)\n</div></li><li><div class=\"code-word\">      .then(\n</div></li><li><div class=\"code-word\">        result =&gt; {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 释放资源</span>\n</div></li><li><div class=\"code-word\">          pool.release(resource)\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> result\n</div></li><li><div class=\"code-word\">        },\n</div></li><li><div class=\"code-word\">        err =&gt; {\n</div></li><li><div class=\"code-word\">          pool.release(resource)\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">throw</span> err\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      )\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> pool\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = createPuppeteerPool\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"927\">\n                      使用连接池的方式也很简单，如下代码，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1052\"\n                        >./pool.js</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> pool = createPuppeteerPool({\n</div></li><li><div class=\"code-word\">  puppeteerArgs: {\n</div></li><li><div class=\"code-word\">    args: config.browserArgs\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">})\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = pool\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"929\">\n                      有了“武器弹药”，我们来看看渲染一个页面为海报的具体逻辑。如下代码所示<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1055\"\n                        >render</code\n                      >方法，该方法支持接受一个 URL 也支持接受具体的 HTML\n                      字符串去生成相应海报：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取连接池</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> pool = require(<span class=\"hljs-string\">'./pool'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> config = require(<span class=\"hljs-string\">'./config'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> render = (ctx, handleFetchPicoImageError) =&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 使用连接池资源</span>\n</div></li><li><div class=\"code-word\">  pool.use(async browser =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> { body, query } = ctx.request\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 打开新的页面</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> page = await browser.newPage()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 服务支持直接传递 HTML 字符串内容</span>\n</div></li><li><div class=\"code-word\">    let html = body\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-comment\">// 从请求服务的 query 获取默认参数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">      width = <span class=\"hljs-number\">300</span>,\n</div></li><li><div class=\"code-word\">      height = <span class=\"hljs-number\">480</span>,\n</div></li><li><div class=\"code-word\">      ratio: deviceScaleFactor = <span class=\"hljs-number\">2</span>,\n</div></li><li><div class=\"code-word\">      type = <span class=\"hljs-string\">'png'</span>,\n</div></li><li><div class=\"code-word\">      filename = <span class=\"hljs-string\">'poster'</span>,\n</div></li><li><div class=\"code-word\">      waitUntil = <span class=\"hljs-string\">'domcontentloaded'</span>,\n</div></li><li><div class=\"code-word\">      quality = <span class=\"hljs-number\">100</span>,\n</div></li><li><div class=\"code-word\">      omitBackground,\n</div></li><li><div class=\"code-word\">      fullPage,\n</div></li><li><div class=\"code-word\">      url,\n</div></li><li><div class=\"code-word\">      useCache = <span class=\"hljs-string\">'true'</span>,\n</div></li><li><div class=\"code-word\">      usePicoAutoJPG = <span class=\"hljs-string\">'true'</span>\n</div></li><li><div class=\"code-word\">    } = query\n</div></li><li><div class=\"code-word\">    let image\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    \t<span class=\"hljs-comment\">// 设置浏览器视口</span>\n</div></li><li><div class=\"code-word\">      await page.setViewport({\n</div></li><li><div class=\"code-word\">        width: Number(width),\n</div></li><li><div class=\"code-word\">        height: Number(height),\n</div></li><li><div class=\"code-word\">        deviceScaleFactor: Number(deviceScaleFactor)\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (html.length &gt; <span class=\"hljs-number\">1.25e6</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(<span class=\"hljs-string\">'image size out of limits, at most 1 MB'</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-comment\">// 访问 URL 页面</span>\n</div></li><li><div class=\"code-word\">      await page.goto(url || \\`data:text/html,${html}\\`, {\n</div></li><li><div class=\"code-word\">        waitUntil: waitUntil.split(<span class=\"hljs-string\">','</span>)\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-comment\">// 进行截图</span>\n</div></li><li><div class=\"code-word\">      image = await page.screenshot({\n</div></li><li><div class=\"code-word\">        type: type === <span class=\"hljs-string\">'jpg'</span> ? <span class=\"hljs-string\">'jpeg'</span> : type,\n</div></li><li><div class=\"code-word\">        quality: type === <span class=\"hljs-string\">'png'</span> ? undefined : Number(quality),\n</div></li><li><div class=\"code-word\">        omitBackground: omitBackground === <span class=\"hljs-string\">'true'</span>,\n</div></li><li><div class=\"code-word\">        fullPage: fullPage === <span class=\"hljs-string\">'true'</span>\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">catch</span> (error) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">throw</span> error\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    ctx.set(<span class=\"hljs-string\">'Content-Type'</span>, \\`image/${type}\\`)\n</div></li><li><div class=\"code-word\">    ctx.set(<span class=\"hljs-string\">'Content-Disposition'</span>, \\`inline; filename=${filename}.${type}\\`)\n</div></li><li><div class=\"code-word\">    await page.close()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> image\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = render\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"931\">\n                      至此，基于 Puppeteer\n                      的海报系统就已经开发完成了。它是一个对外的 Node.js 服务。\n                    </p>\n                    <p data-nodeid=\"932\">\n                      我们也可以生成各种语言的 SDK\n                      客户端，调用该海报服务。比如一个简单的 Python 版 SDK\n                      客户端实现如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">import</span> requests\n</span></div></li><li><div class=\"code-word\">class <span class=\"hljs-title\">PosterGenerator</span><span class=\"hljs-params\">(object)</span>:\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">    def <span class=\"hljs-title\">generate</span><span class=\"hljs-params\">(self, **kwargs)</span>:\n</div></li><li><div class=\"code-word\">        \"\"\"\n</div></li><li><div class=\"code-word\">        生成海报图片，返回二进制海报数据\n</div></li><li><div class=\"code-word\">        :param kwargs: 渲染时需要传递的参数字典\n</div></li><li><div class=\"code-word\">        :return: 二进制图片数据\n</div></li><li><div class=\"code-word\">        \"\"\"\n</div></li><li><div class=\"code-word\">        html_content = render(self._syntax, self._template_content, **kwargs)\n</div></li><li><div class=\"code-word\">        url = POSTER_MAN_HA_PROXIES[self._api_env.value]\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span>:\n</div></li><li><div class=\"code-word\">        \t\t<span class=\"hljs-comment\">// post 请求海报服务</span>\n</div></li><li><div class=\"code-word\">            resp = requests.post(\n</div></li><li><div class=\"code-word\">                url,\n</div></li><li><div class=\"code-word\">                data=html_content.encode(<span class=\"hljs-string\">'utf8'</span>),\n</div></li><li><div class=\"code-word\">                headers={\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'text/plain'</span>\n</div></li><li><div class=\"code-word\">                },\n</div></li><li><div class=\"code-word\">                timeout=<span class=\"hljs-number\">60</span>,\n</div></li><li><div class=\"code-word\">                params=self.config\n</div></li><li><div class=\"code-word\">            )\n</div></li><li><div class=\"code-word\">        except RequestException as err:\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-function\">raise <span class=\"hljs-title\">GenerateFailed</span><span class=\"hljs-params\">(err.message)</span>\n</span></div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> not resp:\n</div></li><li><div class=\"code-word\">                raise <span class=\"hljs-title\">GenerateFailed</span><span class=\"hljs-params\">(u<span class=\"hljs-string\">\"Failed to generate poster, got NOTHING from poster-man\"</span>)</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">try</span>:\n</div></li><li><div class=\"code-word\">                resp.<span class=\"hljs-title\">raise_for_status</span><span class=\"hljs-params\">()</span>\n</div></li><li><div class=\"code-word\">            except requests.HTTPError as err:\n</div></li><li><div class=\"code-word\">                raise <span class=\"hljs-title\">GenerateFailed</span><span class=\"hljs-params\">(err.message)</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">                return resp.content\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"934\">总结</h3>\n                    <p data-nodeid=\"935\" class=\"\">\n                      这一讲我们介绍了 Puppeteer\n                      的各种应用场景，并重点介绍了一个基于 Puppeteer\n                      设计实现的海报服务系统。\n                    </p>\n                    <p data-nodeid=\"936\">本讲内容总结如下：</p>\n                    <p data-nodeid=\"937\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/60/Cgp9HWBUR8mAUFYXAALdEMP1LzI390.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"1064\"\n                      />\n                    </p>\n                    <p data-nodeid=\"938\" class=\"\">\n                      通过这几讲的学习，希望你能够从实践出发，对 Node.js\n                      落地应用有一个更全面的认知。这里我也给大家留一个思考题，你平时开发中使用过\n                      Puppeteer 吗？你还能基于 Puppeteer\n                      想到哪些使用场景呢？欢迎在留言区和我分享你的经验。\n                    </p>\n            "}