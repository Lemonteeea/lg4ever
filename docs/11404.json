{"title":"03 | 优先级队列：堆与优先级队列，筛选最优元素","context":"\n                    <p data-nodeid=\"339093\" class=\"\">\n                      在电影院，相信你也看到有人持有 VIP\n                      卡，可以直接越过队列进场去看电影。对于这种情况，我们的程序也可以用<strong\n                        data-nodeid=\"339103\"\n                        >优先级队列</strong\n                      >（<strong data-nodeid=\"339104\">Priority Queue</strong\n                      >）来模拟这个场景。\n                    </p>\n\n                    <p data-nodeid=\"349606\" class=\"te-preview-highlight\">\n                      通常而言，<strong data-nodeid=\"349620\"\n                        >优先级队列都是基于堆</strong\n                      >（<strong data-nodeid=\"349621\">Heap</strong>）<strong\n                        data-nodeid=\"349622\"\n                        >这种数据结构来实现的</strong\n                      >。因此，我们在正式开始学习优先级队列之前，还需要深入浅出地介绍一下堆及其相关的四种操作。\n                    </p>\n\n                    <p data-nodeid=\"326938\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB95iADDnqAACK2SKwkGM125.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"327259\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"326939\">堆</h3>\n                    <p data-nodeid=\"326940\">\n                      FIFO 队列能够解决广度遍历、分层遍历类似的题目，FIFO\n                      队列在遍历的时候，有一个有趣的特点：<strong\n                        data-nodeid=\"327266\"\n                        >每一层结点的先后顺序，遍历时就确定下来了</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"326941\">\n                      如果把这种先后顺序当成优先级，那么这些结点之间的优先级就由遍历时的顺序决定。但是有时候我们遇到的问题，结点之间需要按照<strong\n                        data-nodeid=\"327280\"\n                        >大小进行排序之后</strong\n                      >，<strong data-nodeid=\"327281\">再决定优先级</strong\n                      >。在这种情况下，FIFO\n                      队列不再适用，就需要用一种新的数据结构——<strong\n                        data-nodeid=\"327282\"\n                        >优先级队列</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"326942\">\n                      <strong data-nodeid=\"327287\"\n                        >优先级队列底层依赖的数据结构一般是堆，而堆是面试中经常遇到的考点之一</strong\n                      >。因此，在这里我会先介绍堆的实现与要点，再介绍优先级队列的特点以及具体如何运用。\n                    </p>\n                    <h4 data-nodeid=\"326943\">堆的分类：大堆与小堆</h4>\n                    <p data-nodeid=\"326944\">\n                      通常堆的结构都是表现为一棵树，如果<strong\n                        data-nodeid=\"327298\"\n                        >根比左右子结点都大</strong\n                      >，那么称为<strong data-nodeid=\"327299\">大堆</strong\n                      >。如下图所示：\n                    </p>\n                    <p data-nodeid=\"326945\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB96aAYBPuAADIgr8zVTQ525.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"327302\"\n                      />\n                    </p>\n                    <p data-nodeid=\"326946\">\n                      如果<strong data-nodeid=\"327314\"\n                        >根比左右子结点都要小</strong\n                      >，那么称为**小堆，**如下图所示：\n                    </p>\n                    <p data-nodeid=\"326947\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB966AG3lGAADMrGaqmms247.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"327317\"\n                      />\n                    </p>\n                    <p data-nodeid=\"326948\">\n                      通过堆的定义，可以发现<strong data-nodeid=\"327323\"\n                        >堆的特点：大堆的根是最大值，小堆的根是最小值</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"326949\">\n                      更有趣的是，每次有元素 push 或者 pop\n                      的时候，调整堆的时间复杂度为\n                      O(lgn)，速度也非常快。因此，<strong data-nodeid=\"327329\"\n                        >堆经常被用于优先级队列</strong\n                      >。接下来，我将以大堆为例，详细介绍堆的表示方式、添加元素、移除元素。\n                    </p>\n                    <p data-nodeid=\"326950\">\n                      <em data-nodeid=\"327333\"\n                        >注：后面的堆操作都是基于大堆。</em\n                      >\n                    </p>\n                    <h4 data-nodeid=\"326951\">堆的表示</h4>\n                    <p data-nodeid=\"326952\">\n                      大部分时候都是<strong data-nodeid=\"327340\"\n                        >使用数组</strong\n                      >表示一个堆，而不是使用二叉树。这是因为:\n                    </p>\n                    <ul data-nodeid=\"326953\">\n                      <li data-nodeid=\"326954\">\n                        <p data-nodeid=\"326955\">\n                          数组的内存具有连续性，访问速度更快；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"326956\">\n                        <p data-nodeid=\"326957\">\n                          堆结构是一棵<strong data-nodeid=\"327347\"\n                            >完全二叉树</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"326958\">如下图所示，堆的规律有如下几点：</p>\n                    <ul data-nodeid=\"326959\">\n                      <li data-nodeid=\"326960\">\n                        <p data-nodeid=\"326961\">i 结点的父结点 par = (i-1)/2</p>\n                      </li>\n                      <li data-nodeid=\"326962\">\n                        <p data-nodeid=\"326963\">i 结点的左子结点 2 * i + 1</p>\n                      </li>\n                      <li data-nodeid=\"326964\">\n                        <p data-nodeid=\"326965\">i 结点的右子结点 2 * i + 2</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"326966\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB97mANuA0AAEuXuRD7OM444.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"327358\"\n                      />\n                    </p>\n                    <p data-nodeid=\"326967\">\n                      <em data-nodeid=\"327362\"\n                        >注意：这里的下标是从 0 开始的。</em\n                      >\n                    </p>\n                    <p data-nodeid=\"326968\">\n                      接下来，我们将通过具体的题目将堆的操作代码<strong\n                        data-nodeid=\"327368\"\n                        >模板化</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"326969\">堆的操作</h4>\n                    <p data-nodeid=\"326970\">\n                      堆的操作实际上只有两种：<strong data-nodeid=\"327375\"\n                        >下沉和上浮</strong\n                      >，如下图所示：\n                    </p>\n                    <p data-nodeid=\"326971\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB98KAGCi1AACNPdvPhX0284.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"327378\"\n                      />\n                    </p>\n                    <p data-nodeid=\"326972\">\n                      通过下沉和上浮，又可以分别得到 pop 和 push\n                      操作，接下来我们一起讨论这四种操作的特点。\n                    </p>\n                    <p data-nodeid=\"326973\">\n                      假设我们已经申请了数组 a[] 和元素 n\n                      表示当前堆中元素的个数，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">100</span>]; <span class=\"hljs-comment\">// 表示堆的数组空间, 100作示例大小</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 堆中元素个数</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"326975\">\n                      <em data-nodeid=\"327387\"\n                        >注：这个数组的大小仅作为示例讲解，你可以根据实际情况调整，我们的重点是把算法讲清楚。</em\n                      >\n                    </p>\n                    <p data-nodeid=\"326976\">\n                      <strong data-nodeid=\"327393\">1. 下沉</strong>\n                    </p>\n                    <p data-nodeid=\"326977\">\n                      引起下沉操作的原因：假设 a[i] 比它的子结点要小，那么除\n                      a[i]\n                      以外，其他子树都满足堆的性质。这个时候，就可以通过下沉操作，帮助\n                      a[i] 找到正确的位置。\n                    </p>\n                    <p data-nodeid=\"326978\">\n                      <em data-nodeid=\"327410\">注意，上述操作的是大堆。</em>\n                    </p>\n                    <p data-nodeid=\"326979\">\n                      为了方便你理解，我制作了下沉过程的动图演示，如下图所示：\n                    </p>\n                    <p data-nodeid=\"326980\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB99OAQTpJAAGapaZWoyM328.gif\"\n                        alt=\"1.gif\"\n                        data-nodeid=\"327414\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"326981\">\n                      <p data-nodeid=\"326982\">\n                        Step 1. 结点 3 需要下沉。<br />\n                        Step 2. 将要下沉的值存入变量 t 中，腾出空位。<br />\n                        Step 3. 在子结点 8 和 9 中选中较大的结点 9。<br />\n                        Step 4. 9 比 3 大，9 需要上移，腾出空位。<br />\n                        Step 5. 上移之后，再查看子结点 4 与 7，选中较大结点\n                        7。<br />\n                        Step 6. 由于 7 比 3 大，7 需要上移，腾出空位。<br />\n                        Step 7. 将 3 填入最终空出来的空位中。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"326983\">\n                      首先，写下沉代码时，需要记住一个<strong\n                        data-nodeid=\"327437\"\n                        >贪心原则</strong\n                      >：如果子结点大，那么子结点就要上移。实际上，如果我们将移动路径<strong\n                        data-nodeid=\"327438\"\n                        >一维化</strong\n                      >，那么这段下沉代码就会变成如下图所示的样子：\n                    </p>\n                    <p data-nodeid=\"326984\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB996AJuAmAACoyw2YoTY998.gif\"\n                        alt=\"2.gif\"\n                        data-nodeid=\"327441\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"326985\">\n                      <p data-nodeid=\"326986\">\n                        Step 1. 最大堆，结点 3 需要下沉。<br />\n                        Step 2. 用临时变量 t 保存值 3。<br />\n                        Step 3.子结点 9 比 t = 3 大，向前移动。<br />\n                        Step 4.接着子结点 7 比 t = 3 大，向前移动。<br />\n                        Step 5.最终给 3 找取最终的位置。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"326987\">\n                      可以发现，下沉与经典的<strong data-nodeid=\"327456\"\n                        >插入排序（递减）非常相似</strong\n                      >。只有一点略有不同：插入排序是一维的，只与后继的元素进行比较，而下沉是二维的，需要在两个后继元素中找到最大值与插入值进行比较。\n                    </p>\n                    <p data-nodeid=\"326988\">\n                      根据这个原则，可以写出<strong data-nodeid=\"327462\"\n                        >下沉</strong\n                      >的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sink</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span> t = a[i];\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 找到i结点的左子结点</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">while</span> ((j = (i &lt;&lt; <span class=\"hljs-number\">1</span>) + <span class=\"hljs-number\">1</span>) &lt; n) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 比插入排序多出来的一步：需要在两个后继中找个最大的出来</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// j &lt; n - 1判断是否有右子结点</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 如果有，并且右子结点更大，那么</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// j指向右子结点</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (j &lt; n - <span class=\"hljs-number\">1</span> &amp;&amp; a[j] &lt; a[j + <span class=\"hljs-number\">1</span>]) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; j++;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 如果子结点比t大</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 那么t的位置还需要往后排</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (a[j] &gt; t) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; a[i] = a[j];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; i = j;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 找到了t的位置</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 此时t是大于所有的子结点的</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 将t放在找到的位置那里</span>\n</div></li><li><div class=\"code-word\">&nbsp; a[i] = t;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"326990\">\n                      <strong data-nodeid=\"327467\">复杂度分析</strong\n                      >：由于堆是一个完全二叉树，所以在下沉的时候，下沉路径就是树的高度。如果堆中有\n                      N 个元素的话，所以时间复杂度为 O(lgN)。\n                    </p>\n                    <p data-nodeid=\"326991\">\n                      <strong data-nodeid=\"327473\">2. 上浮</strong>\n                    </p>\n                    <p data-nodeid=\"326992\">\n                      上浮操作的条件：假设 a[i] 比它的父结点要大，并且除 a[i]\n                      以外，其他子树都满足大堆的性质。\n                    </p>\n                    <p data-nodeid=\"326993\">\n                      <em data-nodeid=\"327486\">注意，上述操作的是大堆。</em>\n                    </p>\n                    <p data-nodeid=\"326994\">\n                      为了方便你理解，我同样制作了上浮过程的动图演示，如下图所示：\n                    </p>\n                    <p data-nodeid=\"326995\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB9-6AO_sXAAF4Rim8-h4328.gif\"\n                        alt=\"3.gif\"\n                        data-nodeid=\"327490\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"326996\">\n                      <p data-nodeid=\"326997\">\n                        Step 1.结点 10 太大，需要上浮。<br />\n                        Step 2.将要上浮的 10 放到临时变量 t 中，腾出空位。<br />\n                        Step 3.找到空位的父结点 8。<br />\n                        Step 4.由于 8 比 t = 10 小，所以 8 往下移，腾出空位。<br />\n                        Step 5.选中空位的父结点 9。<br />\n                        Step 6.由于 9 仍然比 10 小，腾出空位。<br />\n                        Step 7.再也不能找到父结点了，将 10 放到空位中。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"326998\">\n                      同样，在<strong data-nodeid=\"327521\">上浮</strong\n                      >的时候，可以发现<strong data-nodeid=\"327522\"\n                        >一个原则</strong\n                      >：如果父结点比“我”<strong data-nodeid=\"327523\">小</strong\n                      >，那么父结点就需要下移。我们将移动路径<strong\n                        data-nodeid=\"327524\"\n                        >一维化</strong\n                      >，这段插入代码就会变成如下图所示的样子：\n                    </p>\n                    <p data-nodeid=\"326999\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB9_yAMrYIAACvs1tCxn0334.gif\"\n                        alt=\"4.gif\"\n                        data-nodeid=\"327527\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"327000\">\n                      <p data-nodeid=\"327001\">\n                        Step 1.最大堆，结点 10 需要上浮。<br />\n                        Step 2.将需要上浮的 10 放到临时变量 t 中，腾出空位。<br />\n                        Step 3.8 比 t 小，移动 8，腾出空位。<br />\n                        Step 4.9 比 t 小，移动 9，腾出空位。<br />\n                        Step 5.不能再移动了，将 t 放到空位中。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327002\">\n                      可以发现，上浮与经典的<strong data-nodeid=\"327546\"\n                        >插入排序（递减的）非常相似</strong\n                      >。到这里，结点 a[i] 上浮的代码也比较容易搞定了。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 上浮</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swim</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span> t = a[i];\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span> par = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// 如果还存在父结点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 由于我们的下标是从0开始</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 0结点没有父结点</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">while</span> (i &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">    par = (i - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 如果父结点比t值小</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (a[par] &lt; t) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 那么向下移动父结点的值。</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; a[i] = a[par];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; i = par;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; a[i] = t;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"327004\">\n                      <strong data-nodeid=\"327551\">复杂度分析</strong\n                      >：由于堆是一个完全二叉树，所以在上浮的时候，上浮路径就是树的高度。如果堆中有\n                      N 个元素的话，所以时间复杂度为 O(lgN)。\n                    </p>\n                    <p data-nodeid=\"327005\">\n                      <strong data-nodeid=\"327558\">3. push 操作</strong\n                      >需要两步来完成：\n                    </p>\n                    <p data-nodeid=\"327006\">\n                      （1）往堆的尾巴 a[n] 上添加新来的元素\n                    </p>\n                    <p data-nodeid=\"327007\">\n                      （2）新来元素 a[n] 进行<strong data-nodeid=\"327573\"\n                        >上浮</strong\n                      >的操作\n                    </p>\n                    <p data-nodeid=\"327008\">\n                      至此，我们可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> v)</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span>\n</div></li><li><div class=\"code-word\">&nbsp; a[n++] = v;\n</div></li><li><div class=\"code-word\">&nbsp; swim(n - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"327010\">\n                      <strong data-nodeid=\"327579\">复杂度分析</strong\n                      >：主要是上浮操作，所以时间复杂度为 O(lgN)。\n                    </p>\n                    <p data-nodeid=\"327011\">\n                      <strong data-nodeid=\"327586\">4. pop 操作</strong>需要以下\n                      3 步：\n                    </p>\n                    <p data-nodeid=\"327012\">（1）取出 a[0] 的值作为返回值</p>\n                    <p data-nodeid=\"327013\">（2）然后将 a[n-1] 存放至 a[0]</p>\n                    <p data-nodeid=\"327014\">\n                      （3）将 a[0] 进行<strong data-nodeid=\"327609\">下沉</strong\n                      >操作\n                    </p>\n                    <p data-nodeid=\"327015\">\n                      有了 sink()\n                      函数，操作还是比较简单的，我们可以直接写出代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">int</span> ret = a[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">&nbsp; a[<span class=\"hljs-number\">0</span>] = a[--n];\n</div></li><li><div class=\"code-word\">&nbsp; sink(<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">return</span> ret;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"327017\">\n                      <strong data-nodeid=\"327615\">复杂度分析</strong\n                      >：主要是下沉操作，所以时间复杂度为 O(lgN)。\n                    </p>\n                    <p data-nodeid=\"327018\">\n                      堆的操作都梳理完成之后，这里我们给出完整的代码。虽然是一块比较基础的代码，但是我曾经在<strong\n                        data-nodeid=\"327621\"\n                        >商汤</strong\n                      >的面试中就遇到过这么“裸”的面试题：“实现堆的 push 和\n                      pop”。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Heap</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] a = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 下沉</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sink</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> t = a[i];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 找到i结点的左子结点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> ((j = (i &lt;&lt; <span class=\"hljs-number\">1</span>) + <span class=\"hljs-number\">1</span>) &lt; n) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// j &lt; n - 1判断是否有右子结点</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果有，并且右子结点更大，那么</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// j指向右子结点</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (j &lt; n - <span class=\"hljs-number\">1</span> &amp;&amp; a[j] &lt; a[j + <span class=\"hljs-number\">1</span>]) {\n</div></li><li><div class=\"code-word\">                j++;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果子结点比t大</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 那么t的位置还需要往后排</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (a[j] &gt; t) {\n</div></li><li><div class=\"code-word\">                a[i] = a[j];\n</div></li><li><div class=\"code-word\">                i = j;\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 找到了t的位置</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 此时t是大于所有的子结点的</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 将t放在找到的位置那里</span>\n</div></li><li><div class=\"code-word\">        a[i] = t;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 上浮</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swim</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> t = a[i];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> par = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果还存在父结点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; (par = (i - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>) != i) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果父结点比t值小</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (a[par] &lt; t) {\n</div></li><li><div class=\"code-word\">                a[i] = a[par];\n</div></li><li><div class=\"code-word\">                i = par;\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        a[i] = t;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> v)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span>\n</div></li><li><div class=\"code-word\">        a[n++] = v;\n</div></li><li><div class=\"code-word\">        swim(n - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> ret = a[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">        a[<span class=\"hljs-number\">0</span>] = a[--n];\n</div></li><li><div class=\"code-word\">        sink(<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ret;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> n;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"327020\">\n                      讲完了堆的四种操作，我们再来看一下如何把知识运用到题目求解和实际工作中。\n                    </p>\n                    <h4 data-nodeid=\"327021\">例 1：最小的 k 个数</h4>\n                    <p data-nodeid=\"327022\">\n                      【<strong data-nodeid=\"327632\">题目</strong>】给定一个数组\n                      a[]，返回这个数组中最小的 k 个数。\n                    </p>\n                    <p data-nodeid=\"327023\">输入：A = [3,2,1], k = 2</p>\n                    <p data-nodeid=\"327024\">输出：[2, 1]</p>\n                    <p data-nodeid=\"327025\">\n                      【<strong data-nodeid=\"327651\">分析</strong\n                      >】这是一道来自<strong data-nodeid=\"327652\">阿里</strong\n                      >的题目。首先来看，如果是先排序，然后再返回前面的 k\n                      个数。这样操作的复杂度是\n                      O(nlgn)，但面试官可能想要得到复杂度更低的一些算法。\n                    </p>\n                    <p data-nodeid=\"327026\">\n                      现在问题的特点是，只需要 k\n                      个最小的数就可以了。假设我们已经拿到了前面 [0 ~ i]\n                      个数中最小的 k 个数。那么当第 a[i+1]\n                      进来的时候，应该怎么办呢？\n                    </p>\n                    <p data-nodeid=\"327027\">\n                      接下来我们按照“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690\"\n                        data-nodeid=\"327667\"\n                        >第 01</a\n                      ><a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690\"\n                        data-nodeid=\"327670\"\n                        >讲</a\n                      >”介绍的“<strong data-nodeid=\"327676\">四步分析法”</strong>\n                      寻找解题突破口。\n                    </p>\n                    <p data-nodeid=\"327028\">\n                      <strong data-nodeid=\"327682\">1. 模拟</strong>\n                    </p>\n                    <p data-nodeid=\"327029\">可以采用“挤出去的办法”：</p>\n                    <ul data-nodeid=\"327030\">\n                      <li data-nodeid=\"327031\">\n                        <p data-nodeid=\"327032\">\n                          先把 a[i+1] 加入集合中，此时集合中已经有 k+1 个数了；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327033\">\n                        <p data-nodeid=\"327034\">\n                          再把集合 k+1 个数中的<strong data-nodeid=\"327694\"\n                            >最大的数</strong\n                          >扔出去。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"327035\">\n                      此时，存留下来的 k 个数，就是 [0 ~ i + 1] 里面最小的 k\n                      个数了，具体演示如下图所示：\n                    </p>\n                    <p data-nodeid=\"327036\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB-CCAHNSQAAiT0tDfClw811.gif\"\n                        alt=\"5.gif\"\n                        data-nodeid=\"327704\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"327037\">\n                      <p data-nodeid=\"327038\">\n                        Step 1.当 i 指向 8 时，如果我们已经得到了最小的 k = 2\n                        个数的集合。<br />\n                        Step 2.i+1 指向 1 时，需要把 1 加到最小集合中。<br />\n                        Step 3.扔掉最大的元素 3，得到 [0~i+1] 范围里面的最小的 k\n                        个数。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327039\">\n                      <strong data-nodeid=\"327721\">2. 规律</strong>\n                    </p>\n                    <p data-nodeid=\"327040\">由上述分析可以找出以下两个规律：</p>\n                    <p data-nodeid=\"327041\">\n                      （1）我们要的是一个集合，这个集合并<strong\n                        data-nodeid=\"327728\"\n                        >不需要有序</strong\n                      >，但需要支持 push 功能；\n                    </p>\n                    <p data-nodeid=\"327042\">\n                      （2）pop 的时候，总是把<strong data-nodeid=\"327734\"\n                        >最大的元素</strong\n                      >扔出去。\n                    </p>\n                    <p data-nodeid=\"327043\">\n                      <strong data-nodeid=\"327740\">3. 匹配</strong>\n                    </p>\n                    <p data-nodeid=\"327044\">\n                      基于我们发现的两个规律，可以得出，这个时候应该使用<strong\n                        data-nodeid=\"327746\"\n                        >大堆</strong\n                      >。因为堆满足：\n                    </p>\n                    <p data-nodeid=\"327045\">\n                      （1）内部并不是有序的，支持 push 功能；\n                    </p>\n                    <p data-nodeid=\"327046\">\n                      （2）pop 时，扔掉<strong data-nodeid=\"327753\"\n                        >堆里最大元素</strong\n                      >就可以了。\n                    </p>\n                    <p data-nodeid=\"327047\">\n                      <strong data-nodeid=\"327759\">4. 边界</strong>\n                    </p>\n                    <p data-nodeid=\"327048\">\n                      数据结构选定后，在面试时，你还需要思考一下问题的边界。给定数组和\n                      k 的情况，应该有以下 7 种：\n                    </p>\n                    <p data-nodeid=\"327049\">（1）数组为 null</p>\n                    <p data-nodeid=\"327050\">（2）数组中元素个数小于 k</p>\n                    <p data-nodeid=\"327051\">（3）数组中元素个数等于 k</p>\n                    <p data-nodeid=\"327052\">（4）数组中元素个数大于 k</p>\n                    <p data-nodeid=\"327053\">（5）k &lt; 0</p>\n                    <p data-nodeid=\"327054\">（6）k == 0</p>\n                    <p data-nodeid=\"327055\">（7）k &gt; 0</p>\n                    <p data-nodeid=\"327056\">\n                      【<strong data-nodeid=\"327775\">画图</strong\n                      >】分析到这里。我们可以利用大堆完成一次模拟了，动图演示如下：\n                    </p>\n                    <p data-nodeid=\"327057\">\n                      输入：[9, 3, 2, 8, 1, 7, 5, 6, 4], k = 4\n                    </p>\n                    <p data-nodeid=\"327058\">输出：[1,2,3,4]</p>\n                    <p data-nodeid=\"327059\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB-DmADf7pACpCmKnHs-c177.gif\"\n                        alt=\"6.gif\"\n                        data-nodeid=\"327787\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"327060\">\n                      <p data-nodeid=\"327061\">\n                        Step 1.push(9)。<br />\n                        Step 2.push(3)。<br />\n                        Step 3.push(2)。<br />\n                        Step 4.push(8)。<br />\n                        Step 5.push(1)，堆中元素个数 &gt; k，需要执行 pop。<br />\n                        Step 6.pop() 结束。<br />\n                        Step 7.push(7)，堆中元素个数 &gt; k，需要执行 pop。<br />\n                        Step 8.pop 操作结束。<br />\n                        Step 9.push(5)，堆中元素个数 &gt; k，需要执行 pop。<br />\n                        Step 10.pop 操作结束。<br />\n                        Step 11.push(6)，堆中元素个数 &gt; k，需要执行 pop。<br />\n                        Step 12.pop 结束。<br />\n                        Step 13.push(4)，堆中元素个数 &gt; k，需要执行 pop。<br />\n                        Step 14.pop 结束，最终得到最小的 k 个数 [1, 2, 3, 4]。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327062\">\n                      【<strong data-nodeid=\"327824\">代码</strong\n                      >】接下来，就可以开始写代码了，也是时候亮出你真正的实力了。代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] a = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// .. 这里省略了堆的四种操作的代码: 参考前面的实现</span>\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 返回堆中元素的个数</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> n;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] getLeastNumbers(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> k) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (k &lt;= <span class=\"hljs-number\">0</span> || arr == <span class=\"hljs-keyword\">null</span> || arr.length == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 初始化堆, 注意大小要为k + 1</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[k + <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; n = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x : arr) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 首先将元素压入堆中</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果堆中已经有k个元素</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 此时压入，会有k+1个元素，</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 所以初始化时，申请数组大小需要为k+1</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; push(x);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果堆中元素多于k个，那么扔掉最大的元素</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (size() &gt; k) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; pop();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 返回最小的k个数</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">int</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[k];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (size() &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; ans[i++] = pop();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"327064\">\n                      <p data-nodeid=\"327065\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.java\"\n                          data-nodeid=\"327828\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.cpp\"\n                          data-nodeid=\"327832\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.py\"\n                          data-nodeid=\"327836\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327066\">\n                      <strong data-nodeid=\"327841\">复杂度分析</strong\n                      >：时间复杂度，每个元素都需要入堆，而堆 push\n                      的时间复杂度为 O(lgk)。因为我们控制了堆的大小为\n                      k，所以总的时间复杂度为 O(Nlgk)。因为我们使用了 k\n                      个元素的堆，所以空间复杂度为 O(k)。\n                    </p>\n                    <p data-nodeid=\"327067\">\n                      【<strong data-nodeid=\"327847\">小结</strong\n                      >】在这个并不算难的题目里，我们为了深入讲解优先级队列的原理，采用了一种“最费劲”的方式（自己写堆）来操作。\n                    </p>\n                    <p data-nodeid=\"327068\">\n                      但实际上，<strong data-nodeid=\"327861\"\n                        >大部分语言都内置了堆的实现</strong\n                      >（<strong data-nodeid=\"327862\">优先级队列</strong\n                      >）。<strong data-nodeid=\"327863\"\n                        >当你面试的时候，如果面试官没有明确提出要求你自己写堆，赶紧麻溜地用内置的优先级队列啊</strong\n                      >！\n                    </p>\n                    <p data-nodeid=\"327069\">\n                      接下来，我们一起看看如何用语言内置的优先级队列来解决这个问题。代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>&nbsp;<span class=\"hljs-title\">Solution</span>&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">public</span>&nbsp;<span class=\"hljs-keyword\">int</span>[]&nbsp;getLeastNumbers(<span class=\"hljs-keyword\">int</span>[]&nbsp;arr,&nbsp;<span class=\"hljs-keyword\">int</span>&nbsp;k)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(k&nbsp;&lt;=&nbsp;<span class=\"hljs-number\">0</span>&nbsp;||&nbsp;arr&nbsp;==&nbsp;<span class=\"hljs-keyword\">null</span>&nbsp;||&nbsp;arr.length&nbsp;==&nbsp;<span class=\"hljs-number\">0</span>)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;<span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 注意大堆的声明</span>\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;Integer&gt;&nbsp;Q&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;PriorityQueue&lt;&gt;((v1,&nbsp;v2)&nbsp;-&gt;&nbsp;v2&nbsp;-&nbsp;v1);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">for</span>&nbsp;(<span class=\"hljs-keyword\">int</span>&nbsp;x:&nbsp;arr)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.offer(x);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 保持堆中元素小于等于k个</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 保证一直拿到的是k个最小的数</span>\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">while</span>&nbsp;(Q.size()&nbsp;&gt;&nbsp;k)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.poll();\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 生成返回结果</span>\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">int</span>[]&nbsp;ans&nbsp;=&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;<span class=\"hljs-keyword\">int</span>[k];\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">int</span>&nbsp;i&nbsp;=&nbsp;<span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">for</span>&nbsp;(<span class=\"hljs-keyword\">int</span>&nbsp;x:&nbsp;Q)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[i++]&nbsp;=&nbsp;x;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;ans;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"327071\">\n                      <p data-nodeid=\"327072\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.java\"\n                          data-nodeid=\"327868\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp\"\n                          data-nodeid=\"327872\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/JiYou/LaGouAlgo/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.py\"\n                          data-nodeid=\"327876\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327073\">\n                      <strong data-nodeid=\"327881\">复杂度分析：</strong>\n                      首先堆的大小为 k，那么每次 push/pop 的复杂度都是\n                      O(lgk)。一共有 n 个元素，所以复杂度为 O(nlgk)。\n                    </p>\n                    <p data-nodeid=\"327074\">\n                      此外，这道题还有不使用优先级队列，直接可以达到 O(N)\n                      复杂度的算法，你可以尝试思考一下。\n                    </p>\n                    <blockquote data-nodeid=\"327075\">\n                      <p data-nodeid=\"327076\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.java\"\n                          data-nodeid=\"327886\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.cpp\"\n                          data-nodeid=\"327890\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.py\"\n                          data-nodeid=\"327894\"\n                          >Python</a\n                        ><br />\n                        注：<strong data-nodeid=\"327901\"\n                          >如果看不懂也没有关系，我们在“第 08\n                          讲”介绍快排时还会进一步讲解</strong\n                        >。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327077\">\n                      关于解决这类题目的思路、重点以及分析方法，建议你先尝试自己梳理总结一下，再来看我给出的思维导图：\n                    </p>\n                    <p data-nodeid=\"327078\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-FeAA31IAADlOdvhaHc020.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"327905\"\n                      />\n                    </p>\n                    <p data-nodeid=\"327079\">\n                      例 1\n                      是一道非常经典的题目，如果你掌握了这道题的解题思想，可以举一反三解决更多的题目。这里我给出一些堆的练习题。\n                    </p>\n                    <p data-nodeid=\"327080\">\n                      <strong data-nodeid=\"327911\">练习题 1</strong\n                      >：给定一个数组，求这个数组的前 k\n                      个高频元素。如果有两个数出现次数一样，那么优先取较小的那个数。\n                    </p>\n                    <p data-nodeid=\"327081\">\n                      输入：A = [1,2,1,1,3,3,2,3] k = 2\n                    </p>\n                    <p data-nodeid=\"327082\">输出：[1, 3]</p>\n                    <p data-nodeid=\"327083\">\n                      <strong data-nodeid=\"327935\">解释</strong\n                      >：每个数字的出现频率从高到低排序&lt;1, 3次&gt;,\n                      &lt;3,3次&gt; &lt;2, 2次&gt;，取前 2 个高频数字。所以是\n                      [1, 3]。\n                    </p>\n                    <blockquote data-nodeid=\"327084\">\n                      <p data-nodeid=\"327085\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.java\"\n                          data-nodeid=\"327939\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.cpp\"\n                          data-nodeid=\"327943\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.py\"\n                          data-nodeid=\"327947\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327086\">\n                      <strong data-nodeid=\"327952\">练习题 2</strong\n                      >：在练习题1的基础上，给定的是一个单词数组，求这个数组前 k\n                      个高频单词。如果有两个单词出现频率是一样的。那么输出字典序较小的那个单词。\n                    </p>\n                    <p data-nodeid=\"327087\">\n                      输入：A = [\"AA\", \"BB\", \"AA\", \"BB\", \"CCC\", \"CCC\", \"CCC\",\n                      \"AA\"] k = 2\n                    </p>\n                    <p data-nodeid=\"327088\">输出：[\"AA\", \"CCC\"]</p>\n                    <p data-nodeid=\"327089\">\n                      <strong data-nodeid=\"328011\">解释</strong>：出现次数最多的\n                      2 个单词就是[\"AA\", \"CCC\"]\n                    </p>\n                    <blockquote data-nodeid=\"327090\">\n                      <p data-nodeid=\"327091\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.java\"\n                          data-nodeid=\"328015\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.cpp\"\n                          data-nodeid=\"328019\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.py\"\n                          data-nodeid=\"328023\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327092\">\n                      <strong data-nodeid=\"328031\">练习题 3</strong\n                      >：给定一个点集数组 A[]，求离原点最近的 k 个点。\n                    </p>\n                    <p data-nodeid=\"327093\">\n                      输入：A = [[0,1], [1,0], [100,1], [1,100]], k = 2\n                    </p>\n                    <p data-nodeid=\"327094\">输出：[[0,1], [1,0]]</p>\n                    <p data-nodeid=\"327095\">\n                      <strong data-nodeid=\"328074\">解释</strong\n                      >：离原点最近的两个点就是 [[0,1], [1,0]]\n                    </p>\n                    <blockquote data-nodeid=\"327096\">\n                      <p data-nodeid=\"327097\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.java\"\n                          data-nodeid=\"328078\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.cpp\"\n                          data-nodeid=\"328082\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.py\"\n                          data-nodeid=\"328086\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327098\">\n                      <strong data-nodeid=\"328091\">练习题 4</strong>：将 k\n                      个有序的链表，合并成一个有序的链表。\n                    </p>\n                    <blockquote data-nodeid=\"327099\">\n                      <p data-nodeid=\"327100\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.java\"\n                          data-nodeid=\"328095\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp\"\n                          data-nodeid=\"328099\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.py\"\n                          data-nodeid=\"328103\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327101\">\n                      <strong data-nodeid=\"328108\">练习题 5</strong\n                      >：给定两个有序数组，两个数组中各找一个数，凑成一对，找出相加之和最小的\n                      k 对。\n                    </p>\n                    <p data-nodeid=\"327102\">\n                      输入：A = [1, 1, 2], B = [1, 2, 3], k = 2\n                    </p>\n                    <p data-nodeid=\"327103\">输出：B = [[1, 1], [1, 1]]]</p>\n                    <p data-nodeid=\"327104\">\n                      <strong data-nodeid=\"328137\">解释</strong>：A,B\n                      数组中各取一个1出来凑成一对，其和 [1+1=2, 1+1=2]是最小的 2\n                      对。\n                    </p>\n                    <blockquote data-nodeid=\"327105\">\n                      <p data-nodeid=\"327106\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.java\"\n                          data-nodeid=\"328141\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.cpp\"\n                          data-nodeid=\"328145\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.py\"\n                          data-nodeid=\"328149\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"327107\">优先级队列</h3>\n                    <p data-nodeid=\"327108\">\n                      前面提到，优先级队列主要基于堆来实现，因此，堆具备的特性优先级队列也同样具备。比如：\n                    </p>\n                    <ul data-nodeid=\"327109\">\n                      <li data-nodeid=\"327110\">\n                        <p data-nodeid=\"327111\">\n                          可以 O(lgn) 的复杂度往优先级队列中<strong\n                            data-nodeid=\"328156\"\n                            >添加元素；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327112\">\n                        <p data-nodeid=\"327113\">\n                          可以 O(lgn) 的复杂度从优先级队列<strong\n                            data-nodeid=\"328162\"\n                            >弹出最大/最小元素</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"327114\">\n                      经过简化，我们可以得到优先级队列的特性，如下图所示：\n                    </p>\n                    <p data-nodeid=\"327115\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-GWAals1AACz-cwh5A0701.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"328166\"\n                      />\n                    </p>\n                    <p data-nodeid=\"327116\">\n                      不过，如果只是知道这两个特性，你还不能从容地应对面试。接下来，我们一起看一下优先级队列的深度运用。\n                    </p>\n                    <h4 data-nodeid=\"327117\">例 2：跳跃游戏</h4>\n                    <p data-nodeid=\"327118\">\n                      【<strong data-nodeid=\"328178\">题目</strong\n                      >】假设你正在玩跳跃游戏，从<strong data-nodeid=\"328179\"\n                        >低处往高处跳</strong\n                      >的时候，可以有两种方法。\n                    </p>\n                    <p data-nodeid=\"327119\">\n                      方法一：塞砖块，但是你拥有砖块数是有限制的。为了简单起见，高度差就是你需要砖块数。\n                    </p>\n                    <p data-nodeid=\"327120\">\n                      方法二：用梯子，梯子可以无视高度差（你可以认为再高也能爬上去），但是梯子的个数是有限的(一个只能用一次)。\n                    </p>\n                    <p data-nodeid=\"327121\">\n                      其他无论是<strong data-nodeid=\"328191\">平着跳</strong\n                      >，还是<strong data-nodeid=\"328192\">从高处往低处跳</strong\n                      >，不需要借助什么就可以完成（在这道题中我们默认无论从多高跳下来，也摔不死）。\n                    </p>\n                    <p data-nodeid=\"327122\">\n                      给你一个数组，用来表示不同的高度。假设你总是站在 index = 0\n                      的高度开始。那么请问，你最远能跳到哪里?\n                    </p>\n                    <p data-nodeid=\"327123\">\n                      输入：[3, 1, 6, 20, 10, 20], bricks = 5, landers = 1\n                    </p>\n                    <p data-nodeid=\"327124\">输出：4</p>\n                    <p data-nodeid=\"327125\">\n                      <strong data-nodeid=\"328203\">解释：</strong>\n                    </p>\n                    <ul data-nodeid=\"327126\">\n                      <li data-nodeid=\"327127\">\n                        <p data-nodeid=\"327128\">\n                          Step 1. 从 3 跳到 1\n                          时，因为是从高往低处跳，直接跳就可以了\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327129\">\n                        <p data-nodeid=\"327130\">\n                          Step 2. 从 1 到 6 时，用掉 5 个砖块\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327131\">\n                        <p data-nodeid=\"327132\">\n                          Step 3. 从 6 到 20 时，用掉梯子\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327133\">\n                        <p data-nodeid=\"327134\">\n                          Step 4. 从 20 到 10 可以直接跳\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327135\">\n                        <p data-nodeid=\"327136\">\n                          Step 5.到 10 这里就停住了，没有东西可以帮助你跳到 20\n                          了，所以只能跳到下标 index = 4 这里。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"327137\">\n                      【<strong data-nodeid=\"328226\">分析</strong\n                      >】这是一道来自<strong data-nodeid=\"328227\">拼多多</strong\n                      >的面试题。首先我们想一想<strong data-nodeid=\"328228\"\n                        >在什么情况下使用梯子</strong\n                      >？因为梯子最好用，可以无视高度直接使用。但是这里有一个限制条件，只能在<strong\n                        data-nodeid=\"328229\"\n                        >大高度差</strong\n                      >的时候使用梯子。如果是在小高度差的时候使用，那么最终就走不远，比如对于上面给定的例子：\n                    </p>\n                    <ul data-nodeid=\"327138\">\n                      <li data-nodeid=\"327139\">\n                        <p data-nodeid=\"327140\">\n                          Step 1. 从 3 跳到 1 时，直接跳就可以了；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327141\">\n                        <p data-nodeid=\"327142\">\n                          Step 2. 从 1 到 6 时，用掉梯子；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327143\">\n                        <p data-nodeid=\"327144\">\n                          Step 3. 从 6 到 20 时，手里的 5\n                          个砖头就不够用了！所以最远只能到下标 index = 2。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"327145\">\n                      因此，我们选择使用<strong data-nodeid=\"328238\"\n                        >梯子的时候，一定要使用得当</strong\n                      >！那么应该如何判断在什么情况下使用梯子呢？\n                    </p>\n                    <p data-nodeid=\"327146\">\n                      下面可以尝试换种思路，从低往高跳跃的时候，本来是要使用砖块的。但是可以想象成我随身带着一个本子，在上面<strong\n                        data-nodeid=\"328244\"\n                        >记录落差(落差定义为：低往高处跳时的高度差)</strong\n                      >。比如从高度 1 跳到高度 6，就在小本子上写\n                      5。而高处往低处跳的时候，不需要记录，因为这不是落差（题目说了高往低处跳可以直接跳，没有必要记录）。\n                    </p>\n                    <p data-nodeid=\"327147\">\n                      在跳跃的时候，一定要保证小本子上的<strong\n                        data-nodeid=\"328250\"\n                        >落差之和要小于等于砖块数目</strong\n                      >。可是当落差大于砖块之和时怎么办呢？\n                    </p>\n                    <p data-nodeid=\"327148\">\n                      别忘了，我们还有梯子呢。梯子可是万能的（可以把梯子想象成一次性橡皮擦\n                      ）！如果还有梯子，我们只需要从小本子上挑出最大的落差，用“一次性<strong\n                        data-nodeid=\"328256\"\n                        >橡皮擦</strong\n                      >”将它从小本上擦掉即可。\n                    </p>\n                    <p data-nodeid=\"327149\">\n                      <strong data-nodeid=\"328262\">1. 模拟</strong>\n                    </p>\n                    <p data-nodeid=\"327150\">\n                      有了思路之后，我们来执行一次模拟。具体演示如下图所示：\n                    </p>\n                    <p data-nodeid=\"327151\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-IeAcgVAABQeZUJ0g7s661.gif\"\n                        alt=\"7.gif\"\n                        data-nodeid=\"328266\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"327152\">\n                      <p data-nodeid=\"327153\">\n                        Step 1. 首先从高度 3 出发，此时小本子为空 {}。<br />\n                        Step 2. 从高度 3 跳到高度\n                        1（高往低跳，无压力），此时小本子仍然为空 {}。<br />\n                        Step 3. 从 1 跳到高度 6，小本子记录落差 {5} &lt;= 砖头数\n                        5。<br />\n                        Step 4. 从 6 跳到 20, 小本子记录{5, 14}，总和 &gt;\n                        砖头数 5。<br />\n                        Step 5.需要从小本子{5, 14}中选出最大数\n                        14，然后梯子替换掉。<br />\n                        Step 6. 从 20 跳到 10，高到低跳。<br />\n                        Step 7. 要从 10 跳到 20，需要把落差 10 记录到本子上 {5,\n                        10} 。<br />\n                        Step 8. 小本子 {5, 10} 总和 = 15，大于砖头数\n                        5，又没有梯子可以用了。因此只能停在 4 这个位置。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327154\">\n                      <strong data-nodeid=\"328290\">2. 规律</strong\n                      >：在这里，我们发现小本子有两个有趣的地方：\n                    </p>\n                    <p data-nodeid=\"327155\">（1）需要在小本子上记录落差；</p>\n                    <p data-nodeid=\"327156\">\n                      （2）需要用梯子来替换最大的落差。\n                    </p>\n                    <p data-nodeid=\"327157\">\n                      在我们学过的数据结构里面，满足这个 push/pop\n                      特点的，应该就是<strong data-nodeid=\"328298\"\n                        >优先级队列</strong\n                      >啦。\n                    </p>\n                    <p data-nodeid=\"327158\">\n                      <strong data-nodeid=\"328305\">3. 边界</strong\n                      >：注意考虑给定数组为空的情况。\n                    </p>\n                    <p data-nodeid=\"327159\">\n                      【<strong data-nodeid=\"328311\">代码</strong\n                      >】到这里，可以开始写出代码了。具体代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">furthestBuilding</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] heights, <span class=\"hljs-keyword\">int</span> bricks, <span class=\"hljs-keyword\">int</span> ladders)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 注意处理非法输入</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (heights == <span class=\"hljs-keyword\">null</span> || heights.length == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 记录落并的小本子: 最大堆</span>\n</div></li><li><div class=\"code-word\">        Queue&lt;Integer&gt; Q = <span class=\"hljs-keyword\">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> qSum = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> lastPos = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> preHeight = heights[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; heights.length; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> curHeight = heights[i];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果是从高处往低处跳</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (preHeight &gt;= curHeight) {\n</div></li><li><div class=\"code-word\">                lastPos = i;\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 如果是低处往高处跳</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> delta = curHeight - preHeight;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 拿到高度的落差</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 写到小本子上</span>\n</div></li><li><div class=\"code-word\">                Q.offer(delta);\n</div></li><li><div class=\"code-word\">                qSum += delta;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 如果小本子上的总和比砖块多了</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 并且还有梯子</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">while</span> (qSum &gt; bricks &amp;&amp; ladders &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 需要用梯子把最大的落差给抵消掉</span>\n</div></li><li><div class=\"code-word\">                    qSum -= Q.peek();\n</div></li><li><div class=\"code-word\">                    Q.poll();\n</div></li><li><div class=\"code-word\">                    ladders--;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 看看经过一番处理之后，还能不能跳到i这个位置</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (qSum &lt;= bricks) {\n</div></li><li><div class=\"code-word\">                    lastPos = i;\n</div></li><li><div class=\"code-word\">                } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 如果经过一番处理之后，还是不能跳</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 看来不能跳到i了</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 跳出循环!</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 更新位置的高度</span>\n</div></li><li><div class=\"code-word\">            preHeight = curHeight;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> lastPos;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"327161\">\n                      <p data-nodeid=\"327162\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.java\"\n                          data-nodeid=\"328315\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.cpp\"\n                          data-nodeid=\"328319\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.py\"\n                          data-nodeid=\"328323\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327163\">\n                      <strong data-nodeid=\"328328\">复杂度分析</strong\n                      >：在跳跃的过程中，最差的情况下，我们需要把所有的高度差记录下来。在这种情况下，每个高度差都需要执行\n                      push 操作。那么时间复杂度为 O(NlgN)，空间复杂度为O(N)。\n                    </p>\n                    <p data-nodeid=\"327164\">\n                      【<strong data-nodeid=\"328334\">小结</strong\n                      >】首先我们仔细总结一下这道题目的特点：\n                    </p>\n                    <ul data-nodeid=\"327165\">\n                      <li data-nodeid=\"327166\">\n                        <p data-nodeid=\"327167\">\n                          需要将<strong data-nodeid=\"328340\"\n                            >消耗的过程，转换为存储的过程</strong\n                          >（记录在小本子上），对应堆的 push；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327168\">\n                        <p data-nodeid=\"327169\">\n                          需要优先消除一些元素，对应堆的 pop。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"327170\">\n                      与例 1 关于堆的题目相比，例 2\n                      的求解过程不再那么直白，需要我们深入挖掘题目的特点，才能找到正确的解答方法——使用push\n                      和 pop。\n                    </p>\n                    <p data-nodeid=\"327171\">\n                      此外，我们还能挖出一些不同的东西来——关于堆中元素需要弹出时的处理方式。在\n                      Top K 问题里，当堆中元素个数超出 k 个时，就要执行 pop\n                      操作。而这道题，将弹出元素的条件变成了堆中的总和不能超出砖块的数目。\n                    </p>\n                    <p data-nodeid=\"327172\">\n                      <strong data-nodeid=\"328360\">练习题 6</strong\n                      >：一只蚂蚁在树下吃果子，第 i 天会掉 落A[i]\n                      个果子，这些果子会在接下来的 B[i] 天（即第 i+B[i]\n                      天）立马坏掉不能吃。给定 A，B\n                      两个数组，蚂蚁一天只能吃一个果子。吃不完了它可以存放起来。请问最多蚂蚁可以吃多少个果子。\n                    </p>\n                    <p data-nodeid=\"327173\">输入：A = [3, 1], B = [3, 1]</p>\n                    <p data-nodeid=\"327174\">输出：3</p>\n                    <p data-nodeid=\"327175\">\n                      <strong data-nodeid=\"328374\">解释</strong>：我们假设下标从\n                      1 开始：\n                    </p>\n                    <p data-nodeid=\"327176\">第 1 天你吃 1 个第 1 天的果子</p>\n                    <p data-nodeid=\"327177\">\n                      第 2 天吃 1 个第 1 天的果子，同时把第 2 天的果子存起来。\n                    </p>\n                    <p data-nodeid=\"327178\">\n                      第 3 天吃 1 个第 1 天的果子，第 2 天的果子只能放 1 天，第\n                      2 天的果子第 3 天坏了。\n                    </p>\n                    <p data-nodeid=\"327179\">第 4 天没有果子吃了。</p>\n                    <blockquote data-nodeid=\"327180\">\n                      <p data-nodeid=\"327181\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.java\"\n                          data-nodeid=\"328382\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.cpp\"\n                          data-nodeid=\"328386\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.py\"\n                          data-nodeid=\"328390\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327182\">\n                      你可以自己尝试总结一下解决这类题目的思路和重点，然后再来参考我给出的思维导图：\n                    </p>\n                    <p data-nodeid=\"327183\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-LyAd-I8AACuBAvv24c185.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"328394\"\n                      />\n                    </p>\n                    <h4 data-nodeid=\"327184\">例 3：汽车加油次数</h4>\n                    <p data-nodeid=\"327185\">\n                      【<strong data-nodeid=\"328417\">题目</strong>】一辆汽车携带\n                      startFuel 升汽油从位置 0 出发前往位置\n                      target，按顺序有一系列加油站 stations。第 i 个加油站位于\n                      stations[i][0]，可以加 stations[i][1]\n                      升油（一个加油站只能加一次）。如果想要到达\n                      target，输出最少加油次数。如果不能到达 target，那么返回\n                      -1。\n                    </p>\n                    <p data-nodeid=\"327186\">\n                      <strong data-nodeid=\"328422\">两个条件</strong>：\n                    </p>\n                    <ol data-nodeid=\"327187\">\n                      <li data-nodeid=\"327188\">\n                        <p data-nodeid=\"327189\">假设汽车油箱总是很大；</p>\n                      </li>\n                      <li data-nodeid=\"327190\">\n                        <p data-nodeid=\"327191\">\n                          假设行走一单位距离，消耗一升汽油。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"327192\">\n                      <strong data-nodeid=\"328429\">示例</strong>：\n                    </p>\n                    <p data-nodeid=\"327193\">\n                      输入：target = 100, startFuel = 10, stations = [[10, 60],\n                      [20, 30], [30, 30], [60, 40]]\n                    </p>\n                    <p data-nodeid=\"327194\">输出：2</p>\n                    <p data-nodeid=\"327195\">\n                      【<strong data-nodeid=\"328454\">分析</strong>】首先带着 10\n                      升汽油，可以顺利开到 pos = 10 的加油站，加上 60\n                      升汽油。然后直接开车到 pos = 60 的加油站，加上 40\n                      升汽油就可以顺利到达 target = 100 处。所以最少需要加 2\n                      次油。\n                    </p>\n                    <p data-nodeid=\"327196\">\n                      在<strong data-nodeid=\"328466\">微软和头条</strong\n                      >都有同学遇到过这道题目。仔细读题之后，可以发现，需要加油的情况只有一种：汽<strong\n                        data-nodeid=\"328467\"\n                        >车当前位置 + 车里剩余汽油 &lt;\n                        要到达的下一个目标地点</strong\n                      >。这里的下一个目标地点，有可能是\n                      target，也有可能是加油站。\n                    </p>\n                    <p data-nodeid=\"327197\">\n                      那么问题是，当我们发现汽油不够的时候，应该如何加油呢？题目最终目的是产生尽量少的加油次数，所以每次加油加得越多越好！这就找到了一个解题方向：应该<strong\n                        data-nodeid=\"328473\"\n                        >挑油量最大的加油站</strong\n                      >进行加油。\n                    </p>\n                    <p data-nodeid=\"327198\">\n                      假设有一个巨大无比的副油箱，每次经过加油站的时候，都可以把加油站里面的油放到副油箱里面<strong\n                        data-nodeid=\"328479\"\n                        >存起来</strong\n                      >。缺油的时候，就从副油箱里把最大量的汽油加到车里（这里才算加一次油）。\n                    </p>\n                    <p data-nodeid=\"327199\">\n                      <strong data-nodeid=\"328485\">1. 模拟</strong>\n                    </p>\n                    <p data-nodeid=\"327200\">\n                      接下来我们就利用这个副油箱进行一下模拟，具体演示如下图所示（注意：副油箱里面的汽油不能算在已经加到车的汽油里，你可以认为它还放在后面座位上呢）：\n                    </p>\n                    <p data-nodeid=\"327201\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-NWATbp5ABcZWJEFfns318.gif\"\n                        alt=\"8.gif\"\n                        data-nodeid=\"328489\"\n                      />\n                    </p>\n                    <blockquote data-nodeid=\"327202\">\n                      <p data-nodeid=\"327203\">\n                        Step 1. 从 0 位置出发，下一站位于 pos =\n                        10，当前汽油可以达到。<br />\n                        Step 2. 开到了pos = 10，将 60\n                        升汽油放到副油箱，此时余下汽油量为 0。<br />\n                        Step 3. 汽油里面的汽油不足开到 pos = 20\n                        加油站，从副油箱中取出最多汽油 60 加上。<strong\n                          data-nodeid=\"328509\"\n                          >第 1 次</strong\n                        >加油之后，余下油量变成 60。<br />\n                        Step 4. 开到 pos = 20 处，余下汽油 50, 并且将加油站的 30\n                        升汽油放到副油箱。<br />\n                        Step 5. 开到 pos = 30 处，余下 40 升汽油，并且将加油站的\n                        30 升汽油放到副油箱。<br />\n                        Step 6. 开到加油站 60 处，余下 10 升汽油，并且将加油站的\n                        40 升汽油放到副油箱。<br />\n                        Step 7. 发现无法开到位置 100 处，那么将最多的汽油 40\n                        升加到汽车里，此时余下汽油 50。<br />\n                        最后，成功开到了终点。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327204\">\n                      <strong data-nodeid=\"328515\">2. 规律</strong>\n                    </p>\n                    <p data-nodeid=\"327205\">\n                      通过观察副油箱的操作，我们发现它的行为具有两个特点：\n                    </p>\n                    <p data-nodeid=\"327206\">\n                      （1）每次经过加油站会把汽油<strong data-nodeid=\"328522\"\n                        >加到</strong\n                      >副油箱\n                    </p>\n                    <p data-nodeid=\"327207\">\n                      （2）缺油的时候，总是把<strong data-nodeid=\"328528\"\n                        >最大升</strong\n                      >的汽油拿出来加上\n                    </p>\n                    <p data-nodeid=\"327208\">\n                      这两个行为让我们联想到本讲学过的 push/pop 操作。并且每次\n                      pop\n                      的时候，都要弹出最大的元素，这又让我们想起了今天学过的堆（不过这里不再写堆的四种操作了），就用优先级队列吧。因为总是<strong\n                        data-nodeid=\"328534\"\n                        >最大升的汽油优先</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"327209\">\n                      <strong data-nodeid=\"328540\">3. 边界</strong>\n                    </p>\n                    <p data-nodeid=\"327210\">\n                      在正式写代码前，你还是要考虑到以下 3 种情况：\n                    </p>\n                    <p data-nodeid=\"327211\">（1）加油站的位置都小于 target</p>\n                    <p data-nodeid=\"327212\">（2）某些加油站的位置等于 target</p>\n                    <p data-nodeid=\"327213\">（3）有些加油站的位置大于 target</p>\n                    <p data-nodeid=\"327214\">\n                      在处理的时候，<strong data-nodeid=\"328550\"\n                        >可以将 target\n                        也当成一个站。只不过这个站，并不提供汽油</strong\n                      >。这样处理起来更容易一些。\n                    </p>\n                    <p data-nodeid=\"327215\">\n                      【<strong data-nodeid=\"328556\">代码</strong\n                      >】通过了前面的分析，此时我们应该撸起袖子开始写代码了，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minRefuelStops</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> target, <span class=\"hljs-keyword\">int</span> startFuel, <span class=\"hljs-keyword\">int</span>[][] stations)</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = stations.length;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 当前汽车的状态{位置, 还余下多少汽油}</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> curPos = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> fuelLeft = startFuel;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 副油箱</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; Queue&lt;Integer&gt; Q = <span class=\"hljs-keyword\">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 从副油箱里面往汽车加油的次数</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> addFuelTimes = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (curPos + fuelLeft &lt; target) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 默认期望的下一站，站点设置为target</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 此时能加的汽油为0</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> pos = target;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> fuel = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果有位于target之前的站点, 那么更新</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 加油站的位置，以及能加到副油箱的油量</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (i &lt; N &amp;&amp; stations[i][<span class=\"hljs-number\">0</span>] &lt;= target) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; pos = stations[i][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; fuel = stations[i][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果当前汽车的状态，不能到达期望的下一站</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (curPos + fuelLeft &lt; pos) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 拿出副油箱啊</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 惨了，副油箱没有油了，</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (Q.isEmpty()) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 从副油箱里面拿出最大的汽油加上去</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> curMaxFuel = Q.peek();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; Q.poll();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; fuelLeft += curMaxFuel;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 加油次数++</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; addFuelTimes++;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 好了，现在可以到达期望的下一站了</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 不过需要把消耗的汽油扣掉</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> fuelCost = pos - curPos;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 更新当前汽车的状态</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; fuelLeft -= fuelCost;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; curPos = pos;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 这个汽油站里面的汽油加到副油箱</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (fuel &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; Q.offer(fuel);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 这个站就过去了</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; i++;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-comment\">// 能到达target吗？如果能，返回加油次数，不能返回-1</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> curPos + fuelLeft &gt;= target ? addFuelTimes : -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"327217\">\n                      <p data-nodeid=\"327218\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.java\"\n                          data-nodeid=\"328560\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.cpp\"\n                          data-nodeid=\"328564\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.py\"\n                          data-nodeid=\"328568\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327219\">\n                      <strong data-nodeid=\"328573\">复杂度分析</strong\n                      >：最差情况下，需要把所有的油都收集起来，此时所有的油都需要有\n                      push 操作，所以时间复杂度为O(NlgN)，而空间复杂度为O(N)。\n                    </p>\n                    <p data-nodeid=\"327220\">\n                      【<strong data-nodeid=\"328583\">小结</strong\n                      >】首先，当你发现这道题属于“<strong data-nodeid=\"328584\"\n                        >消耗物品</strong\n                      >”类题目，并且优先消耗较大的油箱时，脑海中应该联想前面我们讲过的关于堆的总结：\n                    </p>\n                    <ul data-nodeid=\"327221\">\n                      <li data-nodeid=\"327222\">\n                        <p data-nodeid=\"327223\">\n                          将消耗的过程转换为存储的过程，对应堆的 push 操作；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"327224\">\n                        <p data-nodeid=\"327225\">\n                          将优先选择大油桶的过程看成堆的 pop 操作。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"327226\">\n                      经过一番分析，我们挖出了这道题背后的考点，以及优先级队列可能存在变化地方：\n                    </p>\n                    <ul data-nodeid=\"327227\">\n                      <li data-nodeid=\"327228\">\n                        <p data-nodeid=\"327229\">什么时候执行 push 操作？</p>\n                      </li>\n                      <li data-nodeid=\"327230\">\n                        <p data-nodeid=\"327231\">什么时候执行 pop 操作？</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"327232\">\n                      <strong data-nodeid=\"328600\">练习题 7</strong\n                      >：在一个网络中有 N 台计算机，编号从\n                      1~N，现在给定一些<strong data-nodeid=\"328601\">有向</strong\n                      >边，表示计算机之间网络传输使用的时间（ms），请问，从节点编号为k的计算机发出一个信号，需要多久才能让所有的计算机接收到信号。如果不能让所有人接收到信号，请输出\n                      -1。\n                    </p>\n                    <p data-nodeid=\"327233\">\n                      输入：N = 2, times = [1, 2, 100], k = 1\n                    </p>\n                    <p data-nodeid=\"327234\">输出：100</p>\n                    <p data-nodeid=\"327235\">\n                      <strong data-nodeid=\"328612\">解释</strong>：只有两个计算机\n                      1，和计算机 2。从计算机 1 发送信息到计算机 2 需要\n                      100ms。所以输出 100。\n                    </p>\n                    <blockquote data-nodeid=\"327236\">\n                      <p data-nodeid=\"327237\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java\"\n                          data-nodeid=\"328616\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp\"\n                          data-nodeid=\"328620\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py\"\n                          data-nodeid=\"328624\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"327238\">总结与延伸</h3>\n                    <p data-nodeid=\"327239\">\n                      至此，我们已经学习了堆的特性与实现。在了解了 push/pop\n                      元素的复杂度为 logn\n                      后，我们还需要知道考点可能出现在以下两个地方：\n                    </p>\n                    <ol data-nodeid=\"327240\">\n                      <li data-nodeid=\"327241\">\n                        <p data-nodeid=\"327242\">什么时候 push 元素</p>\n                      </li>\n                      <li data-nodeid=\"327243\">\n                        <p data-nodeid=\"327244\">什么时候 pop 元素</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"327245\">\n                      这里我做了一个简单的归纳，并且列举了例题中的条件，你能在实战中补充一些其他有趣的条件吗？\n                    </p>\n                    <p data-nodeid=\"327246\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/4A/Cgp9HWBB-QCAcvk-AADd5wNIZG0008.png\"\n                        alt=\"Drawing 16.png\"\n                        data-nodeid=\"328632\"\n                      />\n                    </p>\n                    <p data-nodeid=\"327247\">\n                      优先级队列非常有趣，也非常有用，在后面的<strong\n                        data-nodeid=\"328638\"\n                        >广度优先搜索中，还会重拾这个知识，</strong\n                      >\n                      帮助你解决更多的疑难问题。\n                    </p>\n                    <h3 data-nodeid=\"327248\">思考题</h3>\n                    <p data-nodeid=\"327249\">\n                      最后我再给你留一道<strong data-nodeid=\"328645\"\n                        >思考题</strong\n                      >：\n                    </p>\n                    <p data-nodeid=\"327250\">\n                      来自\n                      <strong data-nodeid=\"328651\">Google</strong>\n                      的面试题。一个机器每隔一秒钟就会输出一个整数，请你写一个查询接口，输出所有已经得到的整数的中位数。中位数就是排序之后位于中间的数。如果数目为偶数，则是中间两个数的平均值。\n                    </p>\n                    <blockquote data-nodeid=\"327251\">\n                      <p data-nodeid=\"327252\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.java\"\n                          data-nodeid=\"328655\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp\"\n                          data-nodeid=\"328659\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.py\"\n                          data-nodeid=\"328663\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"327253\">\n                      你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。后会有期，优先级队列！\n                    </p>\n                    <p data-nodeid=\"327254\" class=\"\">\n                      下一讲将介绍 04 |\n                      链表：如何利用“假头，新链表，双指针”解决链表题？（上）记得按时来探险。\n                    </p>\n            "}