{"title":"08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？","context":"\n                    <p data-nodeid=\"2616\" class=\"\">\n                      在前边课程中，我们介绍了基础类型、字面量类型、函数类型及接口类型等内容，它们都是单一、原子的类型元素。其实，如前边课程中一些稍微复杂、实际编程场景的示例所示，我们还需要通过组合/结合单一、原子类型构造更复杂的类型，以此描述更复杂的数据和结构。这就是这一讲中将介绍的内容——联合和交叉类型（Unions\n                      and Intersection Types）。\n                    </p>\n                    <blockquote data-nodeid=\"2617\">\n                      <p data-nodeid=\"2618\">\n                        <strong data-nodeid=\"2711\">学习建议</strong>：请使用 VS\n                        Code 新建一个 08.ts 文件，并尝试这一讲中涉及的所有示例。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"2619\">联合类型</h3>\n                    <p data-nodeid=\"2620\">\n                      联合类型（Unions）用来表示变量、参数的类型不是单一原子类型，而可能是多种不同的类型的组合。\n                    </p>\n                    <p data-nodeid=\"2621\">\n                      我们主要通过“|”操作符分隔类型的语法来表示联合类型。这里，我们可以把“|”类比为\n                      JavaScript 中的逻辑或 “||”，只不过前者表示可能的类型。\n                    </p>\n                    <p data-nodeid=\"2622\">\n                      举个例子，我们封装了一个将 string 或者 number\n                      类型的输入值转换成 '数字 + \"px\" 格式的函数，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatPX</span>(<span class=\"hljs-params\">size: unknown</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> size === <span class=\"hljs-string\">'number'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\\`<span class=\"hljs-subst\">${size}</span>px\\`</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> size === <span class=\"hljs-string\">'string'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\\`<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">parseInt</span>(size) || <span class=\"hljs-number\">0</span>}</span>px\\`</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\\` 仅支持 number 或者 string\\`</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">formatPX(<span class=\"hljs-number\">13</span>);\n</div></li><li><div class=\"code-word\">formatPX(<span class=\"hljs-string\">'13px'</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2624\">\n                      <strong data-nodeid=\"2732\"\n                        >说明：在学习联合类型之前，我们可能免不了使用 any 或\n                        unknown\n                        类型来表示参数的类型（为了让大家养成好习惯，推荐使用\n                        unknown）。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"2625\">\n                      通过这样的方式带来的问题是，在调用 formatPX\n                      时，我们可以传递任意的值，并且可以通过静态类型检测（使用\n                      any 亦如是），但是运行时还是会抛出一个错误，例如：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">formatPX(<span class=\"hljs-literal\">true</span>);\n</div></li><li><div class=\"code-word\">formatPX(<span class=\"hljs-literal\">null</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2627\">\n                      这显然不符合我们的预期，因为 size\n                      应该是更明确的，即可能也只可能是 number 或 string\n                      这两种可选类型的类型。\n                    </p>\n                    <p data-nodeid=\"2628\">\n                      所幸有联合类型，我们可以使用一个更明确表示<strong\n                        data-nodeid=\"2740\"\n                        >可能是 number 或 string 的联合类型</strong\n                      >来注解 size 参数，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatPX</span>(<span class=\"hljs-params\">size: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">formatPX(<span class=\"hljs-number\">13</span>); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">formatPX(<span class=\"hljs-string\">'13px'</span>); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">formatPX(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// ts(2345) 'true' 类型不能赋予 'number | string' 类型</span>\n</div></li><li><div class=\"code-word\">formatPX(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// ts(2345) 'null' 类型不能赋予 'number | string' 类型</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2630\">\n                      在第 1 行，我们定义了函数 formatPX 的参数 size 既可以是\n                      number 类型也可以是 string 类型，所以第 5 行和第 6\n                      行传入数字 13 和字符串 '13px' 都正确，但在第 8 行和第 9\n                      行传入布尔类型的 true 或者 null 类型都会提示一个 ts(2345)\n                      错误。\n                    </p>\n                    <p data-nodeid=\"2631\">\n                      当然，我们可以组合任意个、任意类型来构造更满足我们诉求的类型。比如，我们希望给前边的示例再加一个\n                      unit\n                      参数表示可能单位，这个时候就可以声明一个字符串字面类型组成的联合类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatUnit</span>(<span class=\"hljs-params\">size: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>, unit: 'px' | 'em' | 'rem' | '%' = 'px'</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">formatUnit(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'em'</span>); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">formatUnit(<span class=\"hljs-string\">'1px'</span>, <span class=\"hljs-string\">'rem'</span>); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">formatUnit(<span class=\"hljs-string\">'1px'</span>, <span class=\"hljs-string\">'bem'</span>); <span class=\"hljs-comment\">// ts(2345)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2633\">\n                      我们定义了 formatPX 函数的第二个参数 unit，它的类型是由\n                      'px'、'em'、'rem'、'%'\n                      字符串字面类型组成的类型集合。因此，我们可以在第 5 行和第\n                      6 行传入字符串字面量 'em' 和 'rem'\n                      作为第二个实参。如果在第 8\n                      行我们传入一个不在类型集合中的字符串字面量 'bem'\n                      ，就会提示一个 ts(2345) 错误。\n                    </p>\n                    <p data-nodeid=\"2634\">\n                      我们也可以使用类型别名抽离上边的联合类型，然后再将其进一步地联合，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">type</span> ModernUnit = <span class=\"hljs-string\">'vh'</span> | <span class=\"hljs-string\">'vw'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">type</span> Unit = <span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">type</span> MessedUp = ModernUnit | Unit; <span class=\"hljs-comment\">// 类型是 'vh' | 'vw' | 'px' | 'em' | 'rem'</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2636\">\n                      这里我们定义了 ModernUnit 别名表示 'vh' 和 'vw'\n                      这两个字面量类型的组合，且定义了 Unit 别名表示 'px' 和\n                      'em' 和 'rem' 字面量类型组合，同时又定义了 MessedUp\n                      别名表示 ModernUnit 和 Unit 两个类型别名的组合。\n                    </p>\n                    <blockquote data-nodeid=\"2637\">\n                      <p data-nodeid=\"2638\">\n                        <strong data-nodeid=\"2802\">这里埋一个伏笔：</strong>\n                        如果将 string 原始类型和“string\n                        字面量类型”组合成一个联合类型会是什么效果？你可以自己尝试一下，答案将在这一讲的最后揭晓。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"2639\">\n                      我们也可以把接口类型联合起来表示更复杂的结构，如下所示示例（援引官方示例，顺带复习一下类型断言\n                      as）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">interface</span> Bird {\n</div></li><li><div class=\"code-word\">  fly(): <span class=\"hljs-built_in\">void</span>;\n</div></li><li><div class=\"code-word\">  layEggs(): <span class=\"hljs-built_in\">void</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">interface</span> Fish {\n</div></li><li><div class=\"code-word\">  swim(): <span class=\"hljs-built_in\">void</span>;\n</div></li><li><div class=\"code-word\">  layEggs(): <span class=\"hljs-built_in\">void</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> getPet: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> Bird | Fish = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">as</span> Bird | Fish;\n</div></li><li><div class=\"code-word\">};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Pet = getPet();\n</div></li><li><div class=\"code-word\">Pet.layEggs(); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">Pet.fly(); <span class=\"hljs-comment\">// ts(2339) 'Fish' 没有 'fly' 属性; 'Bird | Fish' 没有 'fly' 属性</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2641\">\n                      从上边的示例可以看到，在联合类型中，我们可以直接访问各个接口成员都拥有的属性、方法，且不会提示类型错误。但是，如果是个别成员特有的属性、方法，我们就需要区分对待了，此时又要引入类型守卫（详见\n                      11 讲）来区分不同的成员类型。\n                    </p>\n                    <p data-nodeid=\"2642\">\n                      只不过，在这种情况下，我们还需要使用基于 in\n                      操作符判断的类型守卫，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> Pet.fly === <span class=\"hljs-string\">'function'</span>) { <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">  Pet.fly(); <span class=\"hljs-comment\">// ts(2339)</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'fly'</span> <span class=\"hljs-keyword\">in</span> Pet) {\n</div></li><li><div class=\"code-word\">  Pet.fly(); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2644\">\n                      因为 Pet 的类型既可能是 Bird 也可能是 Fish，这就意味着在第\n                      1 行可能会通过 Fish 类型获取 fly 属性，但 Fish 类型没有\n                      fly 属性定义，所以会提示一个 ts(2339) 错误。\n                    </p>\n                    <h3 data-nodeid=\"2645\">交叉类型</h3>\n                    <p data-nodeid=\"2646\">\n                      前边我们使用了逻辑或“||”\n                      类比联合类型，那是不是还有一个逻辑与“&amp;&amp;”可以类比类型？\n                    </p>\n                    <p data-nodeid=\"2647\">\n                      在 TypeScript\n                      中，确实还存在一种类似逻辑与行为的类型——交叉类型（Intersection\n                      Type），它可以把多个类型合并成一个类型，合并后的类型将拥有所有成员类型的特性。\n                    </p>\n                    <p data-nodeid=\"2648\">\n                      在 TypeScript\n                      中，我们可以使用“&amp;”操作符来声明交叉类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> Useless = <span class=\"hljs-built_in\">string</span> &amp; <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2650\">\n                      很显然，如果我们仅仅把原始类型、字面量类型、函数类型等原子类型合并成交叉类型，是没有任何用处的，因为任何类型都不能满足同时属于多种原子类型，比如既是\n                      string 类型又是 number\n                      类型。因此，在上述的代码中，类型别名 Useless 的类型就是个\n                      never。\n                    </p>\n                    <h4 data-nodeid=\"2651\">合并接口类型</h4>\n                    <p data-nodeid=\"2652\">\n                      联合类型真正的用武之地就是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> IntersectionType = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; } \n</div></li><li><div class=\"code-word\">    &amp; { age: <span class=\"hljs-built_in\">number</span> };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> mixed: IntersectionType = {\n</div></li><li><div class=\"code-word\">    id: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\">    name: <span class=\"hljs-string\">'name'</span>,\n</div></li><li><div class=\"code-word\">    age: <span class=\"hljs-number\">18</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2654\">\n                      在上述示例中，我们通过交叉类型，使得 IntersectionType\n                      同时拥有了 id、name、age\n                      所有属性，这里我们可以试着将合并接口类型理解为求并集。\n                    </p>\n                    <blockquote data-nodeid=\"2655\">\n                      <p data-nodeid=\"2656\">\n                        这里，我们来发散思考一下：如果合并的多个接口类型存在同名属性会是什么效果呢？\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"2657\">\n                      此时，我们可以根据同名属性的类型是否兼容（详见 12\n                      讲）将这个问题分开来看。\n                    </p>\n                    <p data-nodeid=\"2658\">\n                      如果同名属性的类型不兼容，比如上面示例中两个接口类型同名的\n                      name 属性类型一个是 number，另一个是 string，合并后，name\n                      属性的类型就是 number 和 string 两个原子类型的交叉类型，即\n                      never，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> IntersectionTypeConfict = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">string</span>; } \n</div></li><li><div class=\"code-word\">    &amp; { age: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">number</span>; };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> mixedConflict: IntersectionTypeConfict = {\n</div></li><li><div class=\"code-word\">    id: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\">    name: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// ts(2322) 错误，'number' 类型不能赋给 'never' 类型</span>\n</div></li><li><div class=\"code-word\">    age: <span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">  };\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2660\">\n                      此时，我们赋予 mixedConflict 任意类型的 name\n                      属性值都会提示类型错误。而如果我们不设置 name\n                      属性，又会提示一个缺少必选的 name\n                      属性的错误。在这种情况下，就意味着上述代码中交叉出来的\n                      IntersectionTypeConfict 类型是一个无用类型。\n                    </p>\n                    <p data-nodeid=\"2661\">\n                      如果同名属性的类型兼容，比如一个是 number，另一个是 number\n                      的子类型、数字字面量类型，合并后 name\n                      属性的类型就是两者中的子类型。\n                    </p>\n                    <p data-nodeid=\"2662\">\n                      如下所示示例中 name 属性的类型就是数字字面量类型\n                      2，因此，我们不能把任何非 2 之外的值赋予 name 属性。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> IntersectionTypeConfict = { id: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-number\">2</span>; } \n</div></li><li><div class=\"code-word\">  &amp; { age: <span class=\"hljs-built_in\">number</span>; name: <span class=\"hljs-built_in\">number</span>; };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">let</span> mixedConflict: IntersectionTypeConfict = {\n</div></li><li><div class=\"code-word\">    id: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\">    name: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">    age: <span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  mixedConflict = {\n</div></li><li><div class=\"code-word\">    id: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\">    name: <span class=\"hljs-number\">22</span>, <span class=\"hljs-comment\">// '22' 类型不能赋给 '2' 类型</span>\n</div></li><li><div class=\"code-word\">    age: <span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">  };\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"2664\">合并联合类型</h4>\n                    <p data-nodeid=\"2665\">\n                      另外，我们可以合并联合类型为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是提取了所有联合类型的相同类型成员。这里，我们也可以将合并联合类型理解为求交集。\n                    </p>\n                    <p data-nodeid=\"2666\">\n                      在如下示例中，两个联合类型交叉出来的类型 IntersectionUnion\n                      其实等价于 'em' | 'rem'，所以我们只能把 'em' 或者 'rem'\n                      字符串赋值给 IntersectionUnion 类型的变量。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionA = <span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'%'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionB = <span class=\"hljs-string\">'vh'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'pt'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> IntersectionUnion = UnionA &amp; UnionB;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> intersectionA: IntersectionUnion = <span class=\"hljs-string\">'em'</span>; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> intersectionB: IntersectionUnion = <span class=\"hljs-string\">'rem'</span>; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> intersectionC: IntersectionUnion = <span class=\"hljs-string\">'px'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> intersectionD: IntersectionUnion = <span class=\"hljs-string\">'pt'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2668\">\n                      既然是求交集，如果多个联合类型中没有相同的类型成员，交叉出来的类型自然就是\n                      never 了，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionC = <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionD = <span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'pt'</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> IntersectionUnionE = UnionC &amp; UnionD;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> intersectionE: IntersectionUnionE = <span class=\"hljs-string\">'any'</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-comment\">// ts(2322) 不能赋予 'never' 类型</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2670\">\n                      在上述示例中，因为 UnionC 和 UnionD\n                      没有交集，交叉出来的类型 IntersectionUnionE 就是\n                      never，所以我们不能把任何类型的值赋予 IntersectionUnionE\n                      类型的变量。\n                    </p>\n                    <h3 data-nodeid=\"2671\">联合、交叉组合</h3>\n                    <p data-nodeid=\"2672\">\n                      在前面的示例中，我们把一些联合、交叉类型抽离成了类型别名，再把它作为原子类型进行进一步的联合、交叉。其实，联合、交叉类型本身就可以直接组合使用，这就涉及\n                      |、&amp;\n                      操作符的优先级问题。实际上，联合、交叉运算符不仅在行为上表现一致，还在运算的优先级和\n                      JavaScript 的逻辑或 ||、逻辑与 &amp;&amp; 运算符上表现一致\n                      。\n                    </p>\n                    <p data-nodeid=\"2673\">\n                      联合操作符 | 的优先级低于交叉操作符\n                      &amp;，同样，我们可以通过使用小括弧 ()\n                      来调整操作符的优先级。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionIntersectionA = { id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; } | { id: <span class=\"hljs-built_in\">string</span>; } &amp; { name: <span class=\"hljs-built_in\">number</span>; }; <span class=\"hljs-comment\">// 交叉操作符优先级高于联合操作符</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionIntersectionB = (<span class=\"hljs-string\">'px'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'%'</span>) | (<span class=\"hljs-string\">'vh'</span> | <span class=\"hljs-string\">'em'</span> | <span class=\"hljs-string\">'rem'</span> | <span class=\"hljs-string\">'pt'</span>); <span class=\"hljs-comment\">// 调整优先级</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2675\">\n                      进而，我们也可以把分配率、交换律等基本规则引入类型组合中，然后优化出更简洁、清晰的类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionIntersectionC = ({ id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; } | { id: <span class=\"hljs-built_in\">string</span>; }) &amp; { name: <span class=\"hljs-built_in\">number</span>; };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionIntersectionD = { id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; } &amp; { name: <span class=\"hljs-built_in\">number</span>; } | { id: <span class=\"hljs-built_in\">string</span>; } &amp; { name: <span class=\"hljs-built_in\">number</span>; }; <span class=\"hljs-comment\">// 满足分配率</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionIntersectionE = ({ id: <span class=\"hljs-built_in\">string</span>; } | { id: <span class=\"hljs-built_in\">number</span>; } &amp; { name: <span class=\"hljs-built_in\">string</span>; }) &amp; { name: <span class=\"hljs-built_in\">number</span>; }; <span class=\"hljs-comment\">// 满足交换律</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2677\">\n                      在上述代码中，第 2 行是在第 1 行的基础上进行展开，说明\n                      &amp; 满足分配率；第 3 行则是在第 1\n                      行的基础上调整了成员的顺序，说明 | 操作满足交换律。\n                    </p>\n                    <h3 data-nodeid=\"2678\">类型缩减</h3>\n                    <p data-nodeid=\"2679\">\n                      这里呼应一下在介绍联合类型时埋下的伏笔：如果将 string\n                      原始类型和“string字面量类型”组合成联合类型会是什么效果？效果就是类型缩减成\n                      string 了。\n                    </p>\n                    <p data-nodeid=\"2680\">\n                      同样，对于 number、boolean（其实还有枚举类型，详见第 9\n                      讲）也是一样的缩减逻辑，如下所示示例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> URStr = <span class=\"hljs-string\">'string'</span> | <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// 类型是 string</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> URNum = <span class=\"hljs-number\">2</span> | <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 类型是 number</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> URBoolen = <span class=\"hljs-literal\">true</span> | <span class=\"hljs-built_in\">boolean</span>; <span class=\"hljs-comment\">// 类型是 boolean</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">enum</span> EnumUR {\n</div></li><li><div class=\"code-word\">    ONE,\n</div></li><li><div class=\"code-word\">    TWO\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> URE = EnumUR.ONE | EnumUR; <span class=\"hljs-comment\">// 类型是 EnumUR</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2682\">\n                      TypeScript\n                      对这样的场景做了缩减，它把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的“优化”。\n                    </p>\n                    <p data-nodeid=\"2683\">\n                      可是这个缩减，却极大地削弱了 IDE\n                      自动提示的能力，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> BorderColor = <span class=\"hljs-string\">'black'</span> | <span class=\"hljs-string\">'red'</span> | <span class=\"hljs-string\">'green'</span> | <span class=\"hljs-string\">'yellow'</span> | <span class=\"hljs-string\">'blue'</span> | <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// 类型缩减成 string</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2685\">\n                      在上述代码中，我们希望 IDE\n                      能自动提示显示注解的字符串字面量，但是因为类型被缩减成\n                      string，所有的字符串字面量 black、red\n                      等都无法自动提示出来了。<br />\n                      不要慌，TypeScript\n                      官方其实还提供了一个黑魔法，它可以让类型缩减被控制。如下代码所示，我们只需要给父类型添加“&amp;\n                      {}”即可。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> BorderColor = <span class=\"hljs-string\">'black'</span> | <span class=\"hljs-string\">'red'</span> | <span class=\"hljs-string\">'green'</span> | <span class=\"hljs-string\">'yellow'</span> | <span class=\"hljs-string\">'blue'</span> | <span class=\"hljs-built_in\">string</span> &amp; {}; <span class=\"hljs-comment\">// 字面类型都被保留</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4268\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/41/AB/Cgp9HWCtuN2AaTQhAAIsKJ6nHYA767.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"4272\"\n                      />\n                    </p>\n                    <div data-nodeid=\"4269\">\n                      <p style=\"text-align: center\">VS Code 自动提示效果图</p>\n                    </div>\n\n                    <p data-nodeid=\"2689\">\n                      此时，其他字面量类型就不会被缩减掉了，在 IDE\n                      中字符串字面量 black、red 等也就自然地可以自动提示出来了。\n                    </p>\n                    <p data-nodeid=\"2690\">\n                      此外，当联合类型的成员是接口类型，如果满足其中一个接口的属性是另外一个接口属性的子集，这个属性也会类型缩减，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionInterce =\n</div></li><li><div class=\"code-word\">  | {\n</div></li><li><div class=\"code-word\">      age: <span class=\"hljs-string\">'1'</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  | ({\n</div></li><li><div class=\"code-word\">      age: <span class=\"hljs-string\">'1'</span> | <span class=\"hljs-string\">'2'</span>;\n</div></li><li><div class=\"code-word\">      [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">    });\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2692\">\n                      这里因为 '1' 是 '1' | '2' 的子集，所以 age 的属性变成 '1'\n                      | '2'：\n                    </p>\n                    <p data-nodeid=\"2693\">\n                      利用这个特性，我们来实现 07\n                      讲中埋下的那个伏笔，如何定义如下所示 age\n                      属性是数字类型，而其他不确定的属性是字符串类型的数据结构的对象？\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 数字类型</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-attr\">anyProperty</span>: <span class=\"hljs-string\">'str'</span>, <span class=\"hljs-comment\">// 其他不确定的属性都是字符串类型</span>\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2695\">\n                      在这里提到这个伏笔，想必你应该明白了，我们肯定要用到两个接口的联合类型及类型缩减，这个问题的核心在于找到一个既是\n                      number 的子类型，这样 age 类型缩减之后的类型就是\n                      number；同时也是 string 的子类型，这样才能满足属性和\n                      string 索引类型的约束关系。\n                    </p>\n                    <p data-nodeid=\"2696\">\n                      哪个类型满足这个条件呢？我们一起回忆一下 02\n                      讲中介绍的特殊类型 never。\n                    </p>\n                    <p data-nodeid=\"2697\">\n                      never 有一个特性是它是所有类型的子类型，自然也是 number 和\n                      string 的子类型，所以答案如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">type</span> UnionInterce =\n</div></li><li><div class=\"code-word\">  | {\n</div></li><li><div class=\"code-word\">      age: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  | ({\n</div></li><li><div class=\"code-word\">      age: never;\n</div></li><li><div class=\"code-word\">      [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> O: UnionInterce = {\n</div></li><li><div class=\"code-word\">    age: <span class=\"hljs-number\">2</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">string</span>: <span class=\"hljs-string\">'string'</span>\n</div></li><li><div class=\"code-word\">  };\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2699\">\n                      在上述代码中，我们在第 3 行定义了 number 类型的 age\n                      属性，第 6 行定义了 never 类型的 age 属性，等价于 age\n                      属性的类型是由 number 和 never\n                      类型组成的联合类型，所以我们可以把 number\n                      类型的值（比如说数字字面量 1）赋予 age\n                      属性；但是不能把其他任何类型的值（比如说字符串字面量\n                      'string' ）赋予 age。\n                    </p>\n                    <p data-nodeid=\"2700\">\n                      同时，我们在第 5 行~第 8 行定义的接口类型中，还额外定义了\n                      string 类型的字符串索引签名。因为 never 同时又是 string\n                      类型的子类型，所以 age\n                      属性的类型和字符串索引签名类型不冲突。如第 9 行~第 12\n                      行所示，我们可以把一个 age 属性是 2、string 属性是\n                      'string' 的对象字面量赋值给 UnionInterce 类型的变量 O。\n                    </p>\n                    <h3 data-nodeid=\"2701\">小结与预告</h3>\n                    <p data-nodeid=\"2702\">\n                      这一讲中介绍的联合和交叉类型赋予了 TypeScript\n                      类型最基本的“编程”（运算）能力，学习和掌握联合和交叉类型后，可以培养我们抽离、复用公共类型的意识和能力。\n                    </p>\n                    <p data-nodeid=\"2703\">\n                      插播一个思考题：在联合类型中，类型缩减的规则是什么？欢迎你在留言区与我进行交流、互动。\n                    </p>\n                    <p data-nodeid=\"2704\">\n                      09 讲我们将介绍如何定义常量集合的方法——枚举类型，敬请期待~\n                    </p>\n                    <p data-nodeid=\"2705\" class=\"\">\n                      另外，如果你觉得本专栏有价值，欢迎分享给更多好友。\n                    </p>\n            "}