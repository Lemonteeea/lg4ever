{"title":"18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？","context":"\n                    <p data-nodeid=\"117342\" class=\"\">\n                      今天，我们继续尝试从不同的角度（方法）来求解一个题目，通过“一题多解”的训练，拓展我们的思维。“<strong\n                        data-nodeid=\"117595\"\n                        >搜索类型</strong\n                      >”的题目一直是面试考察的重点，其变形非常广，不过万变不离其宗，大部分解题方法仍然逃不开\n                      BFS/DFS 这两个框架。\n                    </p>\n                    <p data-nodeid=\"117343\">\n                      所以在本讲，我们将以一道经典的搜索题目为引，串联和使用前面学习过的各种知识点，比如：\n                    </p>\n                    <ul data-nodeid=\"117344\">\n                      <li data-nodeid=\"117345\">\n                        <p data-nodeid=\"117346\">BFS/双向 BFS</p>\n                      </li>\n                      <li data-nodeid=\"117347\">\n                        <p data-nodeid=\"117348\">DFS</p>\n                      </li>\n                      <li data-nodeid=\"117349\">\n                        <p data-nodeid=\"117350\">Dijkstra</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117351\">\n                      具体介绍这类题目的分析和处理技巧，让你的面试得心应手。让我们马上开始。\n                    </p>\n                    <h3 data-nodeid=\"117352\">题目</h3>\n                    <p data-nodeid=\"117353\">\n                      字典 wordList 中单词 beginWord 和 endWord\n                      的转换序列是一个按下述规则形成的序列：\n                    </p>\n                    <ul data-nodeid=\"117354\">\n                      <li data-nodeid=\"117355\">\n                        <p data-nodeid=\"117356\">\n                          序列中第一个单词是 beginWord ；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117357\">\n                        <p data-nodeid=\"117358\">\n                          序列中最后一个单词是 endWord，endWord 需要在 wordList\n                          中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117359\">\n                        <p data-nodeid=\"117360\">每次转换只能改变一个字母；</p>\n                      </li>\n                      <li data-nodeid=\"117361\">\n                        <p data-nodeid=\"117362\">\n                          转换过程中的中间单词必须是字典 wordList 中的单词。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117363\">\n                      给你两个单词 beginWord 和 endWord 和一个字典 wordList\n                      ，找到从 beginWord 到 endWord 的最短转换序列中的单词数目\n                      。如果不存在这样的转换序列，返回 0。\n                    </p>\n                    <p data-nodeid=\"117364\">\n                      输入：beginWord = \"hit\", endWord = \"cog\", wordList =\n                      [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n                    </p>\n                    <p data-nodeid=\"117365\">输出：5</p>\n                    <p data-nodeid=\"117366\">\n                      解释：一个最短转换序列是 \"hit\" → \"hot\" → \"dot\" → \"dog\" →\n                      \"cog\"，返回它的长度 5。\n                    </p>\n                    <p data-nodeid=\"117367\">首先，这里需要重点说一下条件：</p>\n                    <ul data-nodeid=\"117368\">\n                      <li data-nodeid=\"117369\">\n                        <p data-nodeid=\"117370\">beginWord != endWord；</p>\n                      </li>\n                      <li data-nodeid=\"117371\">\n                        <p data-nodeid=\"117372\">\n                          beginWord 可以不在 wordList 中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117373\">\n                        <p data-nodeid=\"117374\">\n                          endWord 必须要在 wordList 中，如果不在 wordList\n                          中，那么需要返回 0；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117375\">\n                        <p data-nodeid=\"117376\">所有的单词长度都一样。</p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"117377\">预处理</h3>\n                    <p data-nodeid=\"117378\">\n                      拿到题目，我们要做的第一件事，应该是去<strong\n                        data-nodeid=\"117677\"\n                        >挖掘题目中的隐含条件</strong\n                      >。我们看到题目中有如下条件：\n                    </p>\n                    <ul data-nodeid=\"117379\">\n                      <li data-nodeid=\"117380\">\n                        <p data-nodeid=\"117381\">每次转换只能改变一个字母；</p>\n                      </li>\n                      <li data-nodeid=\"117382\">\n                        <p data-nodeid=\"117383\">\n                          转换过程中的中间单词必须是 wordList 里面的单词。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117384\">\n                      如果将每一次的转换，看成是图中两个点的连接，题目的最终问题就是希望我们找到图中给定两个点的<strong\n                        data-nodeid=\"117685\"\n                        >最短距离</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"117385\">\n                      如果把单词看成图的点，那么对应图的边又是什么呢？\n                    </p>\n                    <blockquote data-nodeid=\"117386\">\n                      <p data-nodeid=\"117387\">\n                        注意：这里提到的图，都是指算法中的图 Graph，而不是图画\n                        Picture。\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"117388\">边的由来</h4>\n                    <p data-nodeid=\"117389\">\n                      当我们有 word = \"hit\"，如果改变其中一个字母，就可以生成\n                      \"hat\"。但是，我们立马发现 wordList =\n                      [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] 并不存在单词 \"hat\"。\n                    </p>\n                    <p data-nodeid=\"117390\">\n                      如果从图的角度来看，可以认为 &lt;\"hit\", \"hat\"&gt;\n                      这条边不存在。那么接下来，我们再看一下成功的情况。\n                    </p>\n                    <p data-nodeid=\"117391\">\n                      当我们有 word = \"hit\"，如果改变一个字母，生成 \"hot\"，由于\n                      wordList[0] == \"hot\"，因此，这种转换 \"hit\" ←→ \"hot\"\n                      是合法的，那么，可以认为边 &lt;\"hit\", \"hot\"&gt; 是存在的。\n                    </p>\n                    <h4 data-nodeid=\"117392\">边的无向性</h4>\n                    <p data-nodeid=\"117393\">\n                      对于单词转换来说，当 word=\"hit\" 可以转换成 \"hot\"\n                      的时候，那么反过来 \"hot\" 也可以转换为\n                      \"hit\"。因此，当我们得到一条边的时候，这条边就是一条无向边。\n                    </p>\n                    <p data-nodeid=\"117394\">\n                      接下来我们再分析一下这类题的考点。\n                    </p>\n                    <h4 data-nodeid=\"117395\">考点</h4>\n                    <p data-nodeid=\"117396\">\n                      在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"117795\"\n                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a\n                      >”中，我们学习的大部分关于“<strong data-nodeid=\"117801\"\n                        >图</strong\n                      >”的题目，都是明确地知道图的边，或者题目中给出了图的边。\n                    </p>\n                    <p data-nodeid=\"117397\">\n                      但是，在这个题中，并没有明确地给出图的边。所有的边都需要依赖一定的条件动态生成。我们可以利用伪代码，表示边的生成，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> word in Graph:\n</div></li><li><div class=\"code-word\">    startPoint = word <span class=\"hljs-comment\">// 图中边起始点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> c in word:\n</div></li><li><div class=\"code-word\">        oldChar = c\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> toChar in <span class=\"hljs-string\">'a'</span>~<span class=\"hljs-string\">'z'</span>:\n</div></li><li><div class=\"code-word\">             c = toChar\n</div></li><li><div class=\"code-word\">             endPoint = word\n</div></li><li><div class=\"code-word\">             <span class=\"hljs-keyword\">if</span> endPoint in wordList:\n</div></li><li><div class=\"code-word\">                 <span class=\"hljs-comment\">// 于是得到一条无向边 &lt;startPoint, endPoint&gt;</span>\n</div></li><li><div class=\"code-word\">        c = oldChar\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"117399\">\n                      有了图的重建，再给定输入，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">beginWord = <span class=\"hljs-string\">\"hit\"</span>\n</div></li><li><div class=\"code-word\">endWord = <span class=\"hljs-string\">\"cog\"</span>\n</div></li><li><div class=\"code-word\">wordList = [<span class=\"hljs-string\">\"hot\"</span>,<span class=\"hljs-string\">\"dot\"</span>,<span class=\"hljs-string\">\"dog\"</span>,<span class=\"hljs-string\">\"lot\"</span>,<span class=\"hljs-string\">\"log\"</span>,<span class=\"hljs-string\">\"cog\"</span>]\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"117401\">\n                      经过上述操作，就可以得到题目中图的表示：\n                    </p>\n                    <p data-nodeid=\"127862\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/FB/Cgp9HWCHz-KAVAogAADx9Asf9G0216.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"127865\"\n                      />\n                    </p>\n\n                    <h4 data-nodeid=\"117404\">转换</h4>\n                    <p data-nodeid=\"117405\">\n                      如何利用字符串表示图中的点，就需要两个字符串来表示一条边。为了压缩这部分信息，我们采用整数来表示字符串。优点有以下几个方面。\n                    </p>\n                    <ul data-nodeid=\"117406\">\n                      <li data-nodeid=\"117407\">\n                        <p data-nodeid=\"117408\">\n                          字符串的处理不方便，必须使用哈希表。如果是整数表示图中的点，那么我们可以使用数组记录点的信息。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117409\">\n                        <p data-nodeid=\"117410\">字符串的运算速度没有整数快。</p>\n                      </li>\n                      <li data-nodeid=\"117411\">\n                        <p data-nodeid=\"117412\">\n                          我们在学习图算法的时候，大部分时候都是使用整数来表示图中的点，相对来说，对代码更加熟悉。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117413\">\n                      基于以上三个原因，我们决定将 String\n                      表示一个点，转换为用整数表示一个点。转换的思想也比较简单：<strong\n                        data-nodeid=\"117818\"\n                        >利用哈希表将不同的字符串映射到不同的整数上即可</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"117414\">\n                      这里我们直接给出“建图”+“转换”的代码，如下所示（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> Map&lt;String, Integer&gt; wordID = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> List&lt;Integer&gt; Graph[] = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">buildGraph</span><span class=\"hljs-params\">(String beginWord,\n</span></span></div></li><li><div class=\"code-word\">                       String endWord,\n</div></li><li><div class=\"code-word\">                       List&lt;String&gt; wordList) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 首先如果单词一样：题目中给出了条件，这两个单词必须不一样</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (beginWord.compareTo(endWord) == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 需要记录每个单词的ID</span>\n</div></li><li><div class=\"code-word\">        wordID = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> id = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (String word: wordList) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (!wordID.containsKey(word)) {\n</div></li><li><div class=\"code-word\">                wordID.put(word, id++);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 根据题意：如果我们在wordList中找不到endWord必须要</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 返回0</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!wordID.containsKey(endWord)) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果wordID中没有beginWord</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 那么把beginWord添加到wordID &amp; wordList中</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!wordID.containsKey(beginWord)) {\n</div></li><li><div class=\"code-word\">            wordID.put(beginWord, id++);\n</div></li><li><div class=\"code-word\">            wordList.add(beginWord);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 构建图</span>\n</div></li><li><div class=\"code-word\">        Graph = <span class=\"hljs-keyword\">new</span> ArrayList[wordID.size()];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; wordID.size(); i++) {\n</div></li><li><div class=\"code-word\">            Graph[i] = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (String word: wordList) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 边的起始点 from</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> from = wordID.get(word);\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 看一下from能转变成什么</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">byte</span>[] wordBytes = word.getBytes();\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; wordBytes.length; i++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">byte</span> old = wordBytes[i];\n</div></li><li><div class=\"code-word\">                \n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 改变成其他byte</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">byte</span> toByte = <span class=\"hljs-string\">'a'</span>; toByte &lt;= <span class=\"hljs-string\">'z'</span>; toByte++) {\n</div></li><li><div class=\"code-word\">                    wordBytes[i] = toByte;\n</div></li><li><div class=\"code-word\">                    String toWord = <span class=\"hljs-keyword\">new</span> String(wordBytes);\n</div></li><li><div class=\"code-word\">                    \n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">if</span> (wordID.containsKey(toWord)) {\n</div></li><li><div class=\"code-word\">                        <span class=\"hljs-comment\">// 边的终点to</span>\n</div></li><li><div class=\"code-word\">                        <span class=\"hljs-keyword\">int</span> to = wordID.get(toWord);\n</div></li><li><div class=\"code-word\">                        <span class=\"hljs-comment\">// 把这条边加到Graph中</span>\n</div></li><li><div class=\"code-word\">                        Graph[from].add(to);\n</div></li><li><div class=\"code-word\">                    }\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                \n</div></li><li><div class=\"code-word\">                wordBytes[i] = old;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ladderLength</span><span class=\"hljs-params\">(String beginWord,\n</span></span></div></li><li><div class=\"code-word\">                            String endWord,\n</div></li><li><div class=\"code-word\">                            List&lt;String&gt; wordList) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 我们要写的核心代码在这里。</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果建图失败，说明无法找到有效解，依照题意，无解的时候</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 我们需要返回0</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!buildGraph(beginWord, endWord, wordList)) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 接下来我们要讨论的重点代码，还没有写!</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"117416\">\n                      <p data-nodeid=\"117417\">\n                        注意：在后文的代码中，我不再罗列 buildGraph\n                        函数的详细代码，所有引用到 buildGraph\n                        代码的地方，都是指这里的 buildGraph() 函数。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117418\">当我们建好图之后，问题就变成：</p>\n                    <ul data-nodeid=\"117419\">\n                      <li data-nodeid=\"117420\">\n                        <p data-nodeid=\"117421\">给定一个无向图；</p>\n                      </li>\n                      <li data-nodeid=\"117422\">\n                        <p data-nodeid=\"117423\">如何求图中两个点的最短距离。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117424\">\n                      不过，根据题意，还需要注意题目要求输出的是“最短转换序列”：\n                    </p>\n                    <blockquote data-nodeid=\"117425\">\n                      <p data-nodeid=\"117426\">\n                        一个最短转换序列是 \"hit\" → \"hot\" → \"dot\" → \"dog\" →\n                        \"cog\"，返回它的长度 5。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117427\">\n                      因此，最短序列等价于<strong data-nodeid=\"117856\"\n                        >最短路径上的点的个数。<strong data-nodeid=\"117855\"\n                          >而我们平时求的最短路径实际上是最短路径上</strong\n                        >边的数目</strong\n                      >。因此：\n                    </p>\n                    <blockquote data-nodeid=\"117428\">\n                      <p data-nodeid=\"117429\">\n                        最短转换序列长度 = 最短路径长度 + 1\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117430\">\n                      那么，到这里，我们已经将陌生的题目成功转变成非常熟悉的问题：<strong\n                        data-nodeid=\"117863\"\n                        >求图中两个点的最短距离</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"117431\">\n                      接下来，我们看一下具体如何破解“最短路径”问题，其实我们在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"117867\"\n                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a\n                      >”的“例 2 和例\n                      4”都学习过，你可以返回去再复习一下，以便加深对这个经典问题的理解。\n                    </p>\n                    <h3 data-nodeid=\"117432\">BFS 算法</h3>\n                    <p data-nodeid=\"117433\">\n                      求两个点的最短路径的时候，我们可以直接用 BFS。为什么呢？\n                    </p>\n                    <p data-nodeid=\"117434\">\n                      你应该还记得，我们在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"117874\"\n                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a\n                      >”中提到过 BFS 的特点：\n                    </p>\n                    <blockquote data-nodeid=\"117435\">\n                      <p data-nodeid=\"117436\">\n                        在搜索的时候，若想知道一些关于“最近/最快/最少”之类问题的答案，往往采用\n                        BFS 更加适合。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117437\">\n                      因此，在这里，我们直接使用 BFS 算法。如果从 beginWord\n                      开始搜索，那么 BFS\n                      的搜索过程可以表达成一个“雷达波搜索”的样子——每一轮搜索都会往外扩散一圈。\n                    </p>\n                    <p data-nodeid=\"133148\">\n                      你可以结合下图展示的BFS 的搜索过程示意图进一步思考，我们从\n                      beginWord = \"hit\" 开始搜索，直接到找到 endWord = \"cog\"\n                      时停止。\n                    </p>\n                    <p data-nodeid=\"133149\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/FB/Cgp9HWCHz_6AAxR5AAE6U53LZ3U453.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"133161\"\n                      />\n                    </p>\n\n                    <blockquote data-nodeid=\"117440\">\n                      <p data-nodeid=\"117441\">\n                        注：这里第 1 圈就是 hit 自身，蓝色圈表示 1 次搜索。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117442\">\n                      那么在写代码的时候，我们可以使用类似的技巧进行\n                      BFS。在每一层，我们都使用一个 ArrayList\n                      来表示。那么，可以写出基于 BFS\n                      的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// buildGraph的代码 ... 略...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ladderLength</span><span class=\"hljs-params\">(String beginWord,\n</span></span></div></li><li><div class=\"code-word\">                          String endWord,\n</div></li><li><div class=\"code-word\">                          List&lt;String&gt; wordList) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果建图失败，那么返回0</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!buildGraph(beginWord, endWord, wordList)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 接下来，我们就是在一个图中找到两个点的最近距离</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里采用BFS的方法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> src = wordID.get(beginWord);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> dst = wordID.get(endWord);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里我们采用“两段击”的BFS的方式进行处理</span>\n</div></li><li><div class=\"code-word\">    List&lt;Integer&gt; cur = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">    cur.add(src);\n</div></li><li><div class=\"code-word\">    List&lt;Integer&gt; next = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录哪些点被访问过了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">boolean</span>[] vis = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">boolean</span>[wordID.size()];\n</div></li><li><div class=\"code-word\">    vis[src] = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 初始步数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> step = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (!cur.isEmpty()) {\n</div></li><li><div class=\"code-word\">      next.clear();\n</div></li><li><div class=\"code-word\">      step++;\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 遍历当前层的点，然后放到next中</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (Integer curNode : cur) {\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果走到终点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (curNode == dst) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> step;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (Integer nextNode : Graph[curNode]) {\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 遍历边curNode -&gt; nextNode</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 如果这个点还没有被访问过</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (!vis[nextNode]) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 那么放到next中</span>\n</div></li><li><div class=\"code-word\">            next.add(nextNode);\n</div></li><li><div class=\"code-word\">            vis[nextNode] = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// swap the 2 list</span>\n</div></li><li><div class=\"code-word\">      List&lt;Integer&gt; tmp = cur;\n</div></li><li><div class=\"code-word\">      cur = next;\n</div></li><li><div class=\"code-word\">      next = tmp;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"117444\">\n                      <p data-nodeid=\"117445\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"117895\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"117899\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"117903\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117446\">\n                      <strong data-nodeid=\"117908\">复杂度分析</strong\n                      >：（假设我们有 N 个单词，每个单词的长度为\n                      M。每个单词需要更改每个位置的字母来生成新的单词）这里时间复杂度需要分为两步。\n                    </p>\n                    <p data-nodeid=\"117447\">\n                      <strong data-nodeid=\"117912\">第一步：预处理建图</strong>\n                    </p>\n                    <h4 data-nodeid=\"137370\" class=\"\">1. 时间复杂度</h4>\n\n                    <p data-nodeid=\"117451\">\n                      1）一共需要处理 N * M 个字母，每个字母要替换 26\n                      次。替换之后生成的长度为 M\n                      的新单词需要去哈希表中检验，每次去哈希表中检查一个单词需要的时间复杂度为\n                      O(M)。\n                    </p>\n                    <p data-nodeid=\"117452\">\n                      2）建图<strong data-nodeid=\"117932\">时间复杂度</strong>为\n                      O(N * M * M * 26)，我们可以把常数 26\n                      去掉，因此时间复杂度为 O(N * M * M)。\n                    </p>\n                    <h4 data-nodeid=\"139468\" class=\"\">2. 空间复杂度</h4>\n\n                    <p data-nodeid=\"117456\">\n                      1）建图时需要建立一个有 N 个 Item，并且每个 Item 长度为 M\n                      的哈希表。因此，哈希表空间复杂度为 O(N * M)。\n                    </p>\n                    <p data-nodeid=\"117457\">\n                      2）Graph 需要占用 O(N * N) 的空间。\n                    </p>\n                    <p data-nodeid=\"117458\">\n                      <strong data-nodeid=\"117943\">第二步：BFS</strong>\n                    </p>\n                    <h4 data-nodeid=\"141562\" class=\"\">1. 时间复杂度</h4>\n\n                    <p data-nodeid=\"117462\">\n                      在后面 BFS 搜索的过程中，由于<strong data-nodeid=\"117950\"\n                        >不会访问</strong\n                      >已访问过的点，相当于所有的点被遍历一遍，所以时间复杂度为\n                      O(N)。\n                    </p>\n                    <h4 data-nodeid=\"143652\" class=\"\">2. 空间复杂度</h4>\n\n                    <p data-nodeid=\"117466\">\n                      最差情况下，需要把所有的点都放到 Array\n                      中，此时空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"117467\">\n                      综上，整个问题的时间复杂度为 O(N * M * M)，空间复杂度为\n                      O(max(N<sup>2</sup>, N * M))。\n                    </p>\n                    <h3 data-nodeid=\"117468\">双向 BFS</h3>\n                    <p data-nodeid=\"117469\">\n                      如果说前面的 BFS\n                      是“一个人”苦苦地用雷达搜索（后文中称为单向\n                      BFS），那么会不会存在从两个方向进行搜索的情况呢？我们尝试分析一下。如果要找的目标也用雷达开启搜索，那么当两者有交互的时候，就可以认为找到了最短路径。\n                    </p>\n                    <p data-nodeid=\"117470\">\n                      这种方法我们称为<strong data-nodeid=\"117971\"\n                        >双向 BFS</strong\n                      >。两者的搜索过程如下图所示：\n                    </p>\n                    <p data-nodeid=\"145738\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/03/CioPOWCHz_iAeJHUAAE70Bz7hFs200.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"145741\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"117472\">\n                      实际上，我们在写双向 BFS\n                      的时候，两边不会同时开启搜索。而是<strong\n                        data-nodeid=\"117980\"\n                        >采用一种策略：优先搜索范围更小的</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"117473\">主要原因在于：</p>\n                    <ul data-nodeid=\"117474\">\n                      <li data-nodeid=\"117475\">\n                        <p data-nodeid=\"117476\">\n                          我们写算法的时候，往往不需要多线程；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117477\">\n                        <p data-nodeid=\"117478\">\n                          优先搜索范围更小的，可以节省更多的内存，因为要存放的信息变少了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117479\">\n                      基于这种双向 BFS\n                      的想法，可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 省略 buildGraph的代码 ... </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ladderLength</span><span class=\"hljs-params\">(String beginWord,\n</span></span></div></li><li><div class=\"code-word\">                          String endWord,\n</div></li><li><div class=\"code-word\">                          List&lt;String&gt; wordList){\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果建图失败，那么返回0</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!buildGraph(beginWord, endWord, wordList)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 接下来，我们就是在一个图中找到两个点的最近距离</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里采用BFS的方法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> srcNode = wordID.get(beginWord);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> dstNode = wordID.get(endWord);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里我们采用“两段击”的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 双向BFS的方式来进行处理</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里正向出发</span>\n</div></li><li><div class=\"code-word\">    Set&lt;Integer&gt; src = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\n</div></li><li><div class=\"code-word\">    src.add(srcNode);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里逆向出发</span>\n</div></li><li><div class=\"code-word\">    Set&lt;Integer&gt; dst = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\n</div></li><li><div class=\"code-word\">    dst.add(dstNode);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> srcVisTag = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> dstVisTag = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录哪些点被访问过了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] vis = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[wordID.size()];\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 通过不同的标号来标记点是被前序遍历过</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 还是被后序遍历过</span>\n</div></li><li><div class=\"code-word\">    vis[srcNode] = srcVisTag;\n</div></li><li><div class=\"code-word\">    vis[dstNode] = dstVisTag;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 初始步数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> step = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (!src.isEmpty() &amp;&amp; !dst.isEmpty()) {\n</div></li><li><div class=\"code-word\">      step++;\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 查看src与set是否相遇</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (Integer node : dst) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (src.contains(node)) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> step;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 哪边点更少，就更新哪一边</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> visTag = src.size() &lt; dst.size() ?\n</div></li><li><div class=\"code-word\">            srcVisTag : dstVisTag;\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">      Set&lt;Integer&gt; tmp = src.size() &lt; dst.size() ? src : dst;\n</div></li><li><div class=\"code-word\">      Set&lt;Integer&gt; next = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> startNode : tmp) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> nextNode : Graph[startNode]) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (vis[nextNode] != visTag) {\n</div></li><li><div class=\"code-word\">            vis[nextNode] = visTag;\n</div></li><li><div class=\"code-word\">            next.add(nextNode);\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (src.size() &lt; dst.size()) {\n</div></li><li><div class=\"code-word\">        src = next;\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        dst = next;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"117481\">\n                      <p data-nodeid=\"117482\">\n                        代码<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"117988\"\n                          >：Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"117992\"\n                          >C+</a\n                        ><a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"117995\"\n                          >+/Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"147826\">\n                      这里，我们将双向 BFS 与单向 BFS 进行一个比较，如下表所示：\n                    </p>\n                    <p data-nodeid=\"147827\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/03/CioPOWCH0CuAddFeAABSuMkK5zs509.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"147831\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"117485\">那么，双向 BFS 主要的优化在于：</p>\n                    <ul data-nodeid=\"117486\">\n                      <li data-nodeid=\"117487\">\n                        <p data-nodeid=\"117488\">\n                          搜索时需要存放的信息更小了（因为搜索范围更小的优先），因此更加<strong\n                            data-nodeid=\"118006\"\n                            >节省内存</strong\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117489\">\n                        <p data-nodeid=\"117490\">\n                          由于要处理的信息变少了，那么查找起来也会<strong\n                            data-nodeid=\"118012\"\n                            >更快</strong\n                          >一些。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117491\">\n                      不过双向 BFS 还是在单向 BFS\n                      上做常数上的优化。最差情况下，时间复杂度与空间复杂度仍然是在一个数量级的。\n                    </p>\n                    <h3 data-nodeid=\"117492\">Dijkstra 算法</h3>\n                    <p data-nodeid=\"117493\">一般而言，最短路径问题，有三种：</p>\n                    <ul data-nodeid=\"117494\">\n                      <li data-nodeid=\"117495\">\n                        <p data-nodeid=\"117496\">\n                          两点之间的最短路径（BFS 算法/Dijkstra 算法/BF\n                          算法，即Bellman-Ford 算法）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117497\">\n                        <p data-nodeid=\"117498\">\n                          一个点到其他所有点的最短路径（Dijkstra 算法/BF\n                          算法）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117499\">\n                        <p data-nodeid=\"117500\">\n                          <strong data-nodeid=\"118022\">每两点</strong\n                          >之间的最短路径（Floyd 算法）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117501\">\n                      现在，我们先讨论一下，在计算两点间的最短路径的时候，什么时候应该使用\n                      BFS 算法，什么时候应该使用 Dijkstra 算法？\n                    </p>\n                    <ul data-nodeid=\"117502\">\n                      <li data-nodeid=\"117503\">\n                        <p data-nodeid=\"117504\">\n                          当图中边的权重都是 1 的时候，最好的办法是使用 BFS\n                          算法。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117505\">\n                        <p data-nodeid=\"117506\">\n                          当图中边的权重非负的时候，最好的办法是使用 Dijkstra\n                          算法。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117507\">\n                        <p data-nodeid=\"117508\">\n                          当图中的边的权重存在负值的时候，最好的办法是采用 BF\n                          算法。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117509\">\n                      实际上，我们可以将权重为 1\n                      的时候，看成权重不同的特例。那么，这里我们应该也可以使用\n                      Dijkstra 算法。根据 Dijkstra 算法的思路（“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"118030\"\n                        >03 | 优先级队列：堆与优先级队列，筛选最优元素</a\n                      >”的“练习题 7”用到了 Dijkstra，以及“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"118034\"\n                        >13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a\n                      >”的“例 5”），我们可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// .. 省略 buildGraph函数代码 ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ladderLength</span><span class=\"hljs-params\">(String beginWord,\n</span></span></div></li><li><div class=\"code-word\">                          String endWord,\n</div></li><li><div class=\"code-word\">                          List&lt;String&gt; wordList) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果建图失败，那么返回0</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!buildGraph(beginWord, endWord, wordList)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 接下来，我们就是在一个图中找到两个点的最近距离</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里采用BFS的方法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> src = wordID.get(beginWord);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> target = wordID.get(endWord);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录从src到各个点的距离</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] dist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[wordID.size()];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; dist.length; i++) {\n</div></li><li><div class=\"code-word\">      dist[i] = wordID.size() * wordID.size() + <span class=\"hljs-number\">100</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    dist[src] = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// java小堆</span>\n</div></li><li><div class=\"code-word\">    Queue&lt;Integer&gt; Q = <span class=\"hljs-keyword\">new</span> PriorityQueue&lt;&gt;(\n</div></li><li><div class=\"code-word\">            (v1, v2) -&gt; dist[v1] - dist[v2]);\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">    Q.add(src);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (!Q.isEmpty()) {\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> startNode = Q.poll();\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> startDist = dist[startNode];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> nextNode : Graph[startNode]) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nextDist = startDist + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (dist[nextNode] &gt; nextDist) {\n</div></li><li><div class=\"code-word\">          dist[nextNode] = nextDist;\n</div></li><li><div class=\"code-word\">          Q.add(nextNode);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">   \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> dist[target] &gt; wordID.size() ?\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-number\">0</span> : dist[target] + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"117511\">\n                      <p data-nodeid=\"117512\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118039\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118043\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118047\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117513\">\n                      <strong data-nodeid=\"118052\">复杂度分析</strong\n                      >：时间复杂度，由于 Dijkstra 算法的时间复杂度在有 N\n                      个点的情况下，复杂度为\n                      O(NlgN)。但是，整个题目的时间复杂度与空间复杂度仍然由\n                      buildGraph 函数主导。与 BFS 的时间复杂度相同。\n                    </p>\n                    <p data-nodeid=\"117514\">\n                      我们再对 Dijkstra 算法做个小小的总结，在使用 Dijkstra\n                      算法的时候，有以下特点：\n                    </p>\n                    <ul data-nodeid=\"117515\">\n                      <li data-nodeid=\"117516\">\n                        <p data-nodeid=\"117517\">\n                          并没有使用 vis 数组来进行标记；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117518\">\n                        <p data-nodeid=\"117519\">\n                          而是当发现一个点的最小距离变得更小的时候，就需要放到优先级队列中，然后重新展开搜索。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117520\">\n                      本讲中，我们提到了 BF 算法。不过 BF 算法在有 N 个点，E\n                      条边的情况下，时间复杂度会达到 O(N x\n                      E)。在本题中，当单词长度为 M\n                      时，最差情况下，一个单词可以有 M x 26\n                      条边。一个图中的边可以达到 N x M x\n                      26。此时，时间复杂度达到 O(N x N x M x\n                      26)，会出现超时的情况。关于这种情况，你可以自己求解一下下面这道练习题，本讲不再详细讨论。\n                    </p>\n                    <p data-nodeid=\"117521\">\n                      <strong data-nodeid=\"118065\">练习题 1</strong>：有 N\n                      个网络结点，标记为 1 到 N。给定一个列表\n                      times，表示信号经过有向边的传递时间。 times[i] = (u, v,\n                      w)，其中 u 是源结点，v 是目标结点，w\n                      是一个信号从源结点传递到目标结点的时间。\n                    </p>\n                    <p data-nodeid=\"117522\">\n                      现在，我们从某个结点 K\n                      发出一个信号。需要多久才能使所有结点都收到信号？如果不能使所有结点收到信号，则返回\n                      -1。\n                    </p>\n                    <blockquote data-nodeid=\"117523\">\n                      <p data-nodeid=\"117524\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118070\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118074\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118078\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"117525\">DFS 算法</h3>\n                    <p data-nodeid=\"117526\">\n                      不知道你有没有从 Dijkstra 的算法中找到灵感？<strong\n                        data-nodeid=\"118085\"\n                        >在遍历的时候，我们不再使用 vis\n                        数组来记录一个点是否被访问，而是利用最小距离是否被更新作为条件</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"117527\">\n                      那么在 DFS 的时候，是不是也可以这样操作？比如：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(List&lt;Integer&gt; G[], <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span>[] dist)</span>\n</span></div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> nextNode : G[start]) { <span class=\"hljs-comment\">// 边：&lt;startNode-&gt;nextNode&gt;</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nextDist = dist[start] + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (nextDist &lt; dist[nextNode]) { <span class=\"hljs-comment\">// 如果发现距离被更新了</span>\n</div></li><li><div class=\"code-word\">        dist[nextNode] = nextDist;\n</div></li><li><div class=\"code-word\">        dfs(G, nextNode, dist);        <span class=\"hljs-comment\">// 那么就从nextNode重新展开搜索</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"117529\">\n                      那么，基于这种距离更新，就重新展开 DFS\n                      的搜索方法，我们也可以写出新的 DFS\n                      算法来解决这道题，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(List&lt;Integer&gt; G[], <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span>[] dist)</span>\n</span></div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> nextNode : G[start]) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nextDist = dist[start] + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (nextDist &lt; dist[nextNode]) {\n</div></li><li><div class=\"code-word\">        dist[nextNode] = nextDist;\n</div></li><li><div class=\"code-word\">        dfs(G, nextNode, dist);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// .. 省略 buildGraph函数的代码 ...</span>\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ladderLength</span><span class=\"hljs-params\">(String beginWord,\n</span></span></div></li><li><div class=\"code-word\">                          String endWord,\n</div></li><li><div class=\"code-word\">                          List&lt;String&gt; wordList) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里构图</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!buildGraph(beginWord, endWord, wordList)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 分别设置好源点，终点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> src = wordID.get(beginWord);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> dst = wordID.get(endWord);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 数组记录src点出发到其他点的最短距离</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] dist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[wordID.size()];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 设置一个最大距离，表示无解</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> maxPathLength = wordID.size() + <span class=\"hljs-number\">1024</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 初始化dist数组</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; dist.length; i++) {\n</div></li><li><div class=\"code-word\">      dist[i] = maxPathLength;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    dist[src] = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// dfs搜索最优解</span>\n</div></li><li><div class=\"code-word\">    dfs(Graph, src, dist);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> dist[dst] &gt;= maxPathLength ? <span class=\"hljs-number\">0</span> : dist[dst] + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"117531\">\n                      <p data-nodeid=\"117532\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118091\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118095\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118099\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117533\">\n                      <strong data-nodeid=\"118118\">复杂度分析</strong\n                      >：假设一共有 N\n                      个点，那么最差情况下，每个点会被其他点最多更新 N\n                      次。因此，最差时间复杂度为\n                      O(N<sup>2</sup>)。但是就整个题目而言，时间复杂度由构建图\n                      buildGraph 的部分主导。综上，时间复杂度为 O(N * M *\n                      M)，空间复杂度为 O(max(N<sup>2</sup>N * M))。\n                    </p>\n                    <p data-nodeid=\"117534\">\n                      那么，接下来，我们考虑一下，Dijkstra 算法与 DFS\n                      算法不同的地方。\n                    </p>\n                    <p data-nodeid=\"117535\">\n                      虽然 Dijkstra 与 DFS 都不会再用到 vis 数组，并且都在点\n                      nextNode\n                      的距离被更新，然后重新展开搜索。但是依然存在不同的地方。\n                    </p>\n                    <ul data-nodeid=\"117536\">\n                      <li data-nodeid=\"117537\">\n                        <p data-nodeid=\"117538\">\n                          Dijkstra 算法是从<strong data-nodeid=\"118126\"\n                            >优先级队列中拿出最优的点重新</strong\n                          >展开搜索。而且Dijkstra\n                          算法在用一个点更新的时候，会把这个点相邻的所有点更新之后，再重新展开搜索。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117539\">\n                        <p data-nodeid=\"117540\">\n                          而 DFS 算法却是立马从点 nextNode 重新展开搜索。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"117541\">\n                      那么，有没有可能将 DFS\n                      也改成Dijkstra这样呢？我们是不是发明了 DFS 也可以实现\n                      Dijkstra 算法呢？基于这种思路，对 DFS\n                      算法进行一下改写，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// .... 省略了 buildGraph() 函数的代码 ...</span>\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] dist = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 优先级队列</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> Queue&lt;Integer&gt; Q = \n</div></li><li><div class=\"code-word\">       <span class=\"hljs-keyword\">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; dist[v1] - dist[v2]);\n</div></li><li><div class=\"code-word\">       \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// DFS + priorityQueue</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (Q.isEmpty()) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> startNode = Q.poll();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> nextNode : Graph[startNode]) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nextDist = dist[startNode] + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (nextDist &lt; dist[nextNode]) {\n</div></li><li><div class=\"code-word\">        dist[nextNode] = nextDist;\n</div></li><li><div class=\"code-word\">        Q.add(nextNode);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    dfs();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意：我们要用startNode把所有的点都更新完之后</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 再重新展开DFS</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">ladderLength</span><span class=\"hljs-params\">(String beginWord,\n</span></span></div></li><li><div class=\"code-word\">                          String endWord,\n</div></li><li><div class=\"code-word\">                          List&lt;String&gt; wordList) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!buildGraph(beginWord, endWord, wordList)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> src = wordID.get(beginWord);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> dst = wordID.get(endWord);\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 初始化距离数组</span>\n</div></li><li><div class=\"code-word\">    dist = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[wordID.size()];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> maxPathLength = wordID.size() + <span class=\"hljs-number\">1024</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; dist.length; i++) {\n</div></li><li><div class=\"code-word\">      dist[i] = maxPathLength;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    dist[src] = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 优先级队列中放入src</span>\n</div></li><li><div class=\"code-word\">    Q.add(src);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 进行dfs</span>\n</div></li><li><div class=\"code-word\">    dfs();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> dist[dst] &gt;= maxPathLength ? <span class=\"hljs-number\">0</span> : dist[dst] + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"117543\">\n                      <p data-nodeid=\"117544\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118132\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118136\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118140\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117545\">\n                      我们发现，经过上述处理的 DFS，本质上与 Dijkstra\n                      算法是一样的。在这里，我们将不同的算法的特点加以迁移（从原本是\n                      Dijkstra 的特点，迁移到 DFS\n                      算法），让不同的算法可以取得同样的效果。\n                    </p>\n                    <h3 data-nodeid=\"117546\">总结</h3>\n                    <p data-nodeid=\"117547\">\n                      这一讲中，我们再次通过一个题目，挖掘了题目的信息+考点。\n                    </p>\n                    <ul data-nodeid=\"117548\">\n                      <li data-nodeid=\"117549\">\n                        <p data-nodeid=\"117550\">\n                          信息：需要通过一定的条件生成边。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"117551\">\n                        <p data-nodeid=\"117552\">考点：两点的最短路径。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"149916\">\n                      当拿到这两部分信息之后，我们首先进行<strong\n                        data-nodeid=\"149927\"\n                        >题目的预处理：建图</strong\n                      >。通过建图，让题目回到了一个我们非常熟悉的知识点：两点最短路径。接来下就是<strong\n                        data-nodeid=\"149928\"\n                        >匹配到了已经学过的各种知识点</strong\n                      >，轮番上阵，也就展开了不同的破题方法。最后，我把这个题目中用到的知识点整理在下面这张思维导图中，你可以参考下图梳理一遍今天学到的重点知识。\n                    </p>\n                    <p data-nodeid=\"149917\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/FB/Cgp9HWCH0ESATdYbAAH54J1eIGc572.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"149931\"\n                      />\n                    </p>\n\n                    <h3 data-nodeid=\"158271\" class=\"\">思考题</h3>\n\n                    <p data-nodeid=\"117556\">\n                      我再给你留一道思考题：在本讲介绍的题目基础上，我们找到<strong\n                        data-nodeid=\"118173\"\n                        >最短的转换序列的长度</strong\n                      >之后。如果要输出<strong data-nodeid=\"118174\">所有</strong\n                      >的最短转换序列，应该怎么办呢？\n                    </p>\n                    <p data-nodeid=\"117557\">\n                      输入：beginWord = \"hit\", endWord = \"cog\", wordList =\n                      [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n                    </p>\n                    <p data-nodeid=\"117558\">\n                      输出：[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\n                    </p>\n                    <p data-nodeid=\"117559\">解释：存在 2 种最短的转换序列：</p>\n                    <p data-nodeid=\"117560\">\n                      \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\"\n                    </p>\n                    <p data-nodeid=\"117561\">\n                      \"hit\" -&gt; \"hot\" -&gt; \"lot\" -&gt; \"log\" -&gt; \"cog\"\n                    </p>\n                    <blockquote data-nodeid=\"117562\">\n                      <p data-nodeid=\"117563\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118297\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118301\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"118305\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"117564\">\n                      你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于单词转换的题目就介绍到这里。接下来，下一讲介绍“19\n                      |\n                      最小体力消耗路径：如何突破经典题型，掌握解题模板”，让我们继续前进。\n                    </p>\n                    <h3 data-nodeid=\"117565\">附录：题目出处和代码汇总</h3>\n                    <table data-nodeid=\"160352\">\n                      <thead data-nodeid=\"160353\">\n                        <tr data-nodeid=\"160354\">\n                          <th align=\"center\" data-nodeid=\"160356\">题目</th>\n                          <th data-nodeid=\"160357\">\n                            <a\n                              href=\"https://leetcode-cn.com/problems/word-ladder/?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160374\"\n                              >测试链接</a\n                            >\n                          </th>\n                          <th align=\"center\" data-nodeid=\"160358\">\n                            BFS代码：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160378\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160382\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160386\"\n                              >Python</a\n                            ><br />双向 BFS代码<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160391\"\n                              >：Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160395\"\n                              >C+</a\n                            ><a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160398\"\n                              >+/Python</a\n                            ><br />Dijkstra代码：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160403\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160407\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160411\"\n                              >Python</a\n                            ><br />DFS + Q代码：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160416\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160420\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160424\"\n                              >Python</a\n                            >\n                          </th>\n                        </tr>\n                      </thead>\n                      <tbody data-nodeid=\"160362\">\n                        <tr data-nodeid=\"160363\">\n                          <td align=\"center\" data-nodeid=\"160364\">练习题 1</td>\n                          <td data-nodeid=\"160365\">\n                            <a\n                              href=\"https://leetcode-cn.com/problems/network-delay-time/?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160428\"\n                              >测试链接</a\n                            >\n                          </td>\n                          <td align=\"center\" data-nodeid=\"160366\">\n                            代码：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160432\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160436\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160440\"\n                              >Python</a\n                            >\n                          </td>\n                        </tr>\n                        <tr data-nodeid=\"160367\">\n                          <td align=\"center\" data-nodeid=\"160368\">思考题</td>\n                          <td data-nodeid=\"160369\">\n                            <a\n                              href=\"https://leetcode-cn.com/problems/word-ladder-ii/?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160444\"\n                              >测试链接</a\n                            >\n                          </td>\n                          <td align=\"center\" data-nodeid=\"160370\">\n                            代码：<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160448\"\n                              >Java</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160452\"\n                              >C++</a\n                            >/<a\n                              href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                              data-nodeid=\"160456\"\n                              >Python</a\n                            >\n                          </td>\n                        </tr>\n                      </tbody>\n                    </table>\n            "}