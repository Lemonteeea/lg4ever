{"title":"05 | Vite 实现：从源码分析出发，构建 bundleless 开发工程","context":"\n                    <p data-nodeid=\"39436\" class=\"\">\n                      通过上一讲的内容，相信你已经了解了现代化构建流程和处理内容。这一讲，我将结合\n                      Webpack\n                      为主的成熟方案现阶段的“不足”，从源码实现角度带你分析 Vite\n                      的设计哲学，同时为“解析 Webpack\n                      源码，实现自己的构建工具”一讲内容打下基础，循序渐进，最终你将能够开发一个自己的构建工具。\n                    </p>\n                    <h3 data-nodeid=\"39437\">Vite 的“横空出世”</h3>\n                    <p data-nodeid=\"39438\">\n                      Vite 是由 Vue 作者尤雨溪开发的 Web\n                      开发工具，尤雨溪在微博上推广时对 Vite 做了简短介绍：\n                    </p>\n                    <blockquote data-nodeid=\"39439\">\n                      <p data-nodeid=\"39440\">\n                        Vite，一个基于浏览器原生 ES imports\n                        的开发服务器。利用浏览器去解析\n                        imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有\n                        Vue\n                        文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用\n                        Rollup\n                        打包。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"39441\">\n                      从这段话中我们能够提炼一些关键点：\n                    </p>\n                    <ul data-nodeid=\"39442\">\n                      <li data-nodeid=\"39443\">\n                        <p data-nodeid=\"39444\">\n                          Vite 基于\n                          ESM，因此实现了快速启动和即时模块热更新能力；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39445\">\n                        <p data-nodeid=\"39446\">Vite 在服务端实现了按需编译。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"39447\">\n                      经验丰富的开发者通过上述介绍，似乎就能给出 Vite\n                      的基本流程，甚至可以说得更直白一些：<strong\n                        data-nodeid=\"39585\"\n                        >Vite 在开发环境下并没有打包和构建过程</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"39448\">\n                      开发者在代码中写到的 ESM\n                      导入语法会直接发送给服务器，而服务器也直接将 ESM\n                      模块内容运行处理后，下发给浏览器。接着，现代浏览器通过解析\n                      script module，对每一个 import 到的模块进行 HTTP\n                      请求，服务器继续对这些 HTTP 请求进行处理并响应。\n                    </p>\n                    <h3 data-nodeid=\"39449\">Vite 实现原理解读</h3>\n                    <p data-nodeid=\"39450\">\n                      Vite\n                      思想比较容易理解，实现起来也并不复杂。接下来，我们就对\n                      Vite\n                      源码进行分析，帮助你更好地体会它的设计哲学和实现技巧。\n                    </p>\n                    <p data-nodeid=\"39451\">\n                      首先，我们打造一个学习环境，创建一个基于 Vite\n                      的应用，并启动：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">npm init vite-app vite-app\n</div></li><li><div class=\"code-word\">cd vite-app\n</div></li><li><div class=\"code-word\">npm install\n</div></li><li><div class=\"code-word\">npm run dev\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39453\">得到以下目录结构和页面内容：</p>\n                    <p data-nodeid=\"39454\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/18/Ciqc1F_ltOCAMzS3AAHqGo5sIeo562.png\"\n                        alt=\"Lark20201225-174521.png\"\n                        data-nodeid=\"39593\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39455\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/03/A7/Cip5yF_gX_iAUku7AAK-5yeYi0A500.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"39596\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39456\">\n                      其中浏览器请求：<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"39598\"\n                        >http://localhost:3000/</code\n                      >，得到的内容即是我们应用项目中的 index.html 内容。\n                    </p>\n                    <p data-nodeid=\"39457\">\n                      在项目 packaga.json 中，我们看到：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"dev\"</span>: <span class=\"hljs-string\">\"vite\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\"> },\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39459\">\n                      找到 Vite 源码中，<a\n                        href=\"https://github.com/vitejs/vite/blob/master/src/node/cli.ts#L66\"\n                        data-nodeid=\"39604\"\n                        >命令行实现部分：</a\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (!options.command || options.command === <span class=\"hljs-string\">'serve'</span>) {\n</div></li><li><div class=\"code-word\">\trunServe(options)\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (options.command === <span class=\"hljs-string\">'build'</span>) {\n</div></li><li><div class=\"code-word\">\trunBuild(options)\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (options.command === <span class=\"hljs-string\">'optimize'</span>) {\n</div></li><li><div class=\"code-word\">\trunOptimize(options)\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">\tconsole.error(chalk.red(\\`unknown command: ${options.command}\\`))\n</div></li><li><div class=\"code-word\">\tprocess.exit(<span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39461\">\n                      上面代码，根据不同的命令行命令，执行不同的入口函数。\n                    </p>\n                    <p data-nodeid=\"39462\">\n                      在开发模式下，Vite 通过 runServe 方法，启动了一个\n                      koaServer，来实现对浏览器请求的响应，<a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/cli.ts#L131\"\n                        data-nodeid=\"39609\"\n                        >runServer 实现</a\n                      >如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> server = require(<span class=\"hljs-string\">'./server'</span>).createServer(options)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39464\">\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/server/index.ts#L50\"\n                        data-nodeid=\"39613\"\n                        >createServer 方法实现</a\n                      >，我们可以精简为以下内容：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">createServer</span><span class=\"hljs-params\">(config: ServerConfig)</span>: Server </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">    root = process.cwd(),\n</div></li><li><div class=\"code-word\">    configureServer = [],\n</div></li><li><div class=\"code-word\">    resolvers = [],\n</div></li><li><div class=\"code-word\">    alias = {},\n</div></li><li><div class=\"code-word\">    transforms = [],\n</div></li><li><div class=\"code-word\">    vueCustomBlockTransforms = {},\n</div></li><li><div class=\"code-word\">    optimizeDeps = {},\n</div></li><li><div class=\"code-word\">    enableEsbuild = <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">  } = config\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//&nbsp;创建 Koa 实例</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa&lt;State, Context&gt;()\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> server = resolveServer(config, app.callback())\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> resolver = createResolver(root, resolvers, alias)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 相关上下文信息&nbsp;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> context: ServerPluginContext = {\n</div></li><li><div class=\"code-word\">    root,\n</div></li><li><div class=\"code-word\">    app,\n</div></li><li><div class=\"code-word\">    server,\n</div></li><li><div class=\"code-word\">    resolver,\n</div></li><li><div class=\"code-word\">    config,\n</div></li><li><div class=\"code-word\">    port: config.port || <span class=\"hljs-number\">3000</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 一个简单中间件，扩充 context 上下文内容</span>\n</div></li><li><div class=\"code-word\">  app.use((ctx, next) =&gt; {\n</div></li><li><div class=\"code-word\">    Object.assign(ctx, context)\n</div></li><li><div class=\"code-word\">    ctx.read = cachedRead.bind(<span class=\"hljs-keyword\">null</span>, ctx)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> next()\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> resolvedPlugins = [\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  ]\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  resolvedPlugins.forEach((m) =&gt; m &amp;&amp; m(context))\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> listen = server.listen.bind(server)\n</div></li><li><div class=\"code-word\">  server.listen = (async (port: number, ...args: any[]) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (optimizeDeps.auto !== <span class=\"hljs-keyword\">false</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\">await <span class=\"hljs-title\">require</span><span class=\"hljs-params\">(<span class=\"hljs-string\">'../optimizer'</span>)</span>.<span class=\"hljs-title\">optimizeDeps</span><span class=\"hljs-params\">(config)</span>\n</span></div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> listener = listen(port, ...args)\n</div></li><li><div class=\"code-word\">    context.port = server.address().port\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> listener\n</div></li><li><div class=\"code-word\">  }) as any\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> server\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39466\">\n                      浏览器在访问<code data-backticks=\"1\" data-nodeid=\"39616\"\n                        >http://localhost:3000/</code\n                      >后，得到了主体为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;body&gt;\n</div></li><li><div class=\"code-word\">  &lt;di v id=\"app\"&gt;&lt;/div&gt;\n</div></li><li><div class=\"code-word\">  &lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">&lt;/body&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39468\">的内容。</p>\n                    <p data-nodeid=\"39469\">\n                      依据 ESM 规范在浏览器 script 标签中的实现，对于<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"39620\"\n                        >&lt;script type=\"module\"\n                        src=\"./bar.js\"&gt;&lt;/script&gt;</code\n                      >内容：<strong data-nodeid=\"39626\"\n                        >当出现 script 标签 type 属性为 module\n                        时，浏览器将会请求模块相应内容</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"39470\">\n                      另一种 ESM 规范在浏览器 script 标签中的实现为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;script type=\"module\"&gt;\n</div></li><li><div class=\"code-word\">  import { bar } from './bar.js‘\n</div></li><li><div class=\"code-word\">&lt;/script&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39472\">\n                      浏览器会发起 HTTP 请求，请求 HTTP Server 托管的 bar.js。\n                    </p>\n                    <p data-nodeid=\"39473\">\n                      我们可以看到，经过 Vite Server 处理\n                      http://localhost:3000/src/main.js 请求后，最终返回了：\n                    </p>\n                    <p data-nodeid=\"39474\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/18/Ciqc1F_ltQGAaQZkAAXD68sxUe4161.png\"\n                        alt=\"Lark20201225-174524.png\"\n                        data-nodeid=\"39632\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39475\">\n                      返回内容和我们项目中的 ./src/main.js 略有差别：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { createApp } from <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> App from <span class=\"hljs-string\">'./App.vue'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'./index.css'</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39477\">现在变为：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { createApp } from <span class=\"hljs-string\">'/@modules/vue.js'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> App from <span class=\"hljs-string\">'/src/App.vue'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'/src/index.css?import'</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39479\">这里我们拆成两部分来看。</p>\n                    <p data-nodeid=\"39480\">\n                      其中<code data-backticks=\"1\" data-nodeid=\"39637\"\n                        >import { createApp } from 'vue'</code\n                      >改为<code data-backticks=\"1\" data-nodeid=\"39639\"\n                        >import { createApp } from '/@modules/vue.js'</code\n                      >，原因很明显：<strong data-nodeid=\"39656\"\n                        >import 对应的路径只支持 \"/\"\"./\"或者 \"../\"\n                        开头的内容，直接使用模块名 import，会立即报错</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"39481\">\n                      所以在 Vite Server 处理请求时，通过\n                      serverPluginModuleRewrite 这个中间件来给 import from 'A'\n                      的 A 添加 /@module/ 前缀为 from '/@modules/A'，<a\n                        href=\"https://github.com/vitejs/vite/blob/master/src/node/server/index.ts#L97\"\n                        data-nodeid=\"39668\"\n                        >源码部分对应</a\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> resolvedPlugins = [\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  moduleRewritePlugin,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">]\n</div></li><li><div class=\"code-word\">resolvedPlugins.forEach((m) =&gt; m &amp;&amp; m(context))\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39483\">\n                      而 moduleRewritePlugin 插件的<a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/server/serverPluginModuleRewrite.ts#L48\"\n                        data-nodeid=\"39673\"\n                        >实现</a\n                      >也并不困难，主要通过\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/server/serverPluginModuleRewrite.ts#L120\"\n                        data-nodeid=\"39677\"\n                        >rewriteImports 方法</a\n                      >，来执行\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/server/serverPluginModuleRewrite.ts#L259\"\n                        data-nodeid=\"39681\"\n                        >resolveImport 方法</a\n                      >，并进行改写。这里已经添加了相关源码链接，我们不再一一展开，你可以在课后进一步学习。\n                    </p>\n                    <p data-nodeid=\"39484\">\n                      整个过程和调用链路较长，我对 Vite 处理 import\n                      方法做一个简单总结：\n                    </p>\n                    <ul data-nodeid=\"39485\">\n                      <li data-nodeid=\"39486\">\n                        <p data-nodeid=\"39487\">\n                          在 koa 中间件里获取请求 path 对应的 body 内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39488\">\n                        <p data-nodeid=\"39489\">\n                          通过\n                          <a\n                            href=\"https://github.com/guybedford/es-module-lexer\"\n                            data-nodeid=\"39688\"\n                            >es-module-lexer</a\n                          >\n                          解析资源 AST，并拿到 import 的内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39490\">\n                        <p data-nodeid=\"39491\">\n                          如果判断 import 的资源是绝对路径，即可认为该资源为 npm\n                          模块，并返回处理后的资源路径。比如上述代码中，vue →\n                          /@modules/vue。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"39492\">\n                      对于形如：<code data-backticks=\"1\" data-nodeid=\"39692\"\n                        >import App from './App.vue'</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"39694\"\n                        >import './index.css'</code\n                      >的处理，与上述情况类似：\n                    </p>\n                    <ul data-nodeid=\"39493\">\n                      <li data-nodeid=\"39494\">\n                        <p data-nodeid=\"39495\">\n                          在 koa 中间件里获取请求 path 对应的 body 内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39496\">\n                        <p data-nodeid=\"39497\">\n                          通过\n                          <a\n                            href=\"https://github.com/guybedford/es-module-lexer\"\n                            data-nodeid=\"39700\"\n                            >es-module-lexer</a\n                          >\n                          解析资源 AST，并拿到 import 的内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39498\">\n                        <p data-nodeid=\"39499\">\n                          如果判断 import\n                          的资源是相对路径，即可认为该资源为项目应用中资源，并返回处理后的资源路径。比如上述代码中，./App.vue\n                          → /src/App.vue。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"39500\">\n                      接下来浏览器根据 main.js 的内容，分别请求：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">/<span class=\"hljs-meta\">@modules</span>/vue.js\n</div></li><li><div class=\"code-word\">/src/App.vue\n</div></li><li><div class=\"code-word\">/src/index.css?<span class=\"hljs-keyword\">import</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39502\">\n                      对于 /@module/ 类请求较为容易，我们只需要完成下面三步：\n                    </p>\n                    <ul data-nodeid=\"39503\">\n                      <li data-nodeid=\"39504\">\n                        <p data-nodeid=\"39505\">\n                          在 koa 中间件里获取请求 path 对应的 body 内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39506\">\n                        <p data-nodeid=\"39507\">\n                          判断路径是否以 /@module/\n                          开头，如果是，取出包名（这里为 vue.js）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39508\">\n                        <p data-nodeid=\"39509\">\n                          去 node_modules 文件中找到对应的 npm 库，并返回内容。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"39510\">\n                      上述步骤在 Vite 中使用 serverPluginModuleResolve\n                      中间件实现，点击这里可以访问<a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/server/serverPluginModuleResolve.ts#L22\"\n                        data-nodeid=\"39713\"\n                        >对应源码</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"39511\">\n                      接着，就是对 /src/App.vue 类请求进行处理，这就涉及 Vite\n                      服务器的编译能力了。\n                    </p>\n                    <p data-nodeid=\"39512\">\n                      我们先看结果，对比项目中的\n                      App.vue，浏览器请求得到的结果显然出现了大变样：\n                    </p>\n                    <p data-nodeid=\"39513\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8B/C6/Ciqc1F_gYEGAL6S2AASUUhepUGQ785.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"39719\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39514\">\n                      实际上，App.vue 这样的单文件组件对应 script、style 和\n                      template，在经过 Vite Server 处理时，服务端对\n                      script、style 和 template 三部分分别处理，对应中间件为\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/server/serverPluginVue.ts\"\n                        data-nodeid=\"39723\"\n                        >serverPluginVue</a\n                      >。这个中间件的实现很简单，即<strong data-nodeid=\"39733\"\n                        >对 .vue 文件请求进行处理，通过 parseSFC\n                        方法解析单文件组件，并通过 compileSFCMain\n                        方法将单文件组件拆分</strong\n                      >为形如上图内容，对应中间件关键内容可在源码 vuePlugin\n                      中找到。源码中，涉及\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/node/server/serverPluginVue.ts#L377\"\n                        data-nodeid=\"39731\"\n                        >parseSFC</a\n                      >\n                      具体所做的事情，是调用 @vue/compiler-sfc\n                      进行单文件组件解析。精简为我自己的逻辑，帮助你理解：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (!query.type) {\n</div></li><li><div class=\"code-word\">  ctx.body = \\`\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> __script = ${descriptor.script.content.replace(<span class=\"hljs-string\">'export default '</span>, <span class=\"hljs-string\">''</span>)}\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 单文件组件中，对于 style 部分的编译，编译为对应 style 样式的 import 请求</span>\n</div></li><li><div class=\"code-word\">    ${descriptor.styles.length ? \\`<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"${url}?type=style\"</span>\\` : <span class=\"hljs-string\">''</span>}\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 单文件组件中，对于 template 部分的编译，编译为对应 template 样式的 import 请求</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">import</span> { render as __render } from <span class=\"hljs-string\">\"${url}?type=template\"</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 渲染 template 的内容</span>\n</div></li><li><div class=\"code-word\">    __script.render = __render;\n</div></li><li><div class=\"code-word\">    export <span class=\"hljs-keyword\">default</span> __script;\n</div></li><li><div class=\"code-word\">  \\`;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39516\">\n                      总而言之，每一个 .vue\n                      单文件组件都被拆分成多个请求。比如对应上面场景，浏览器接收到\n                      App.vue 对应的实际内容后，发出 HelloWorld.vue 以及\n                      App.vue?type=template 的请求（通过 type 这个 query\n                      来表示是 template 还是 style）。koa server\n                      进行分别处理并返回，这些请求依然分别被上面提到的\n                      serverPluginVue 中间件处理：对于 template 的请求，服务使用\n                      @vue/compiler-dom 进行编译 template 并返回内容。\n                    </p>\n                    <p data-nodeid=\"39517\">精简为我自己的逻辑，帮助你理解：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (query.type === <span class=\"hljs-string\">'template'</span>) {\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">const</span> template = descriptor.template;\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">const</span> render = require(<span class=\"hljs-string\">'@vue/compiler-dom'</span>).compile(template.content, {\n</div></li><li><div class=\"code-word\">\t  mode: <span class=\"hljs-string\">'module'</span>,\n</div></li><li><div class=\"code-word\">\t}).code;\n</div></li><li><div class=\"code-word\">\tctx.type = <span class=\"hljs-string\">'application/javascript'</span>;\n</div></li><li><div class=\"code-word\">\tctx.body = render;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39519\">\n                      对于上面提到的 http://localhost:3000/src/index.css?import\n                      请求稍微特殊，需通过 serverPluginVue 来实现解析：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">//&nbsp;style 类型请求</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (query.type === <span class=\"hljs-string\">'style'</span>) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> index = Number(query.index)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> styleBlock = descriptor.styles[index]\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (styleBlock.src) {\n</div></li><li><div class=\"code-word\">    filePath = <span class=\"hljs-function\">await <span class=\"hljs-title\">resolveSrcImport</span><span class=\"hljs-params\">(root, styleBlock, ctx, resolver)</span>\n</span></div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> id = hash_sum(publicPath)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//&nbsp;调用 compileSFCStyle 方法编译当文件组件样式部分</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-function\">await <span class=\"hljs-title\">compileSFCStyle</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">    root,\n</div></li><li><div class=\"code-word\">    styleBlock,\n</div></li><li><div class=\"code-word\">    index,\n</div></li><li><div class=\"code-word\">    filePath,\n</div></li><li><div class=\"code-word\">    publicPath,\n</div></li><li><div class=\"code-word\">    config\n</div></li><li><div class=\"code-word\">  )\n</div></li><li><div class=\"code-word\">  ctx.type = <span class=\"hljs-string\">'js'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//&nbsp;返回样式内容</span>\n</div></li><li><div class=\"code-word\">  ctx.body = codegenCss(\\`${id}-${index}\\`, result.code, result.modules)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> etagCacheCheck(ctx)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39521\">\n                      调用\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/38f811c5b077f437ffff072276531e8f75953e94/src/node/server/serverPluginCss.ts\"\n                        data-nodeid=\"39740\"\n                        >serverPluginCss</a\n                      >\n                      中间件的 codegenCss 方法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">codegenCss</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">  id: string,\n</div></li><li><div class=\"code-word\">  css: string,\n</div></li><li><div class=\"code-word\">  modules?: Record&lt;string, string&gt;\n</div></li><li><div class=\"code-word\">): string {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 样式代码模板</span>\n</div></li><li><div class=\"code-word\">  let code =\n</div></li><li><div class=\"code-word\">    \\`<span class=\"hljs-keyword\">import</span> { updateStyle } from <span class=\"hljs-string\">\"${clientPublicPath}\"</span>\\n\\` +\n</div></li><li><div class=\"code-word\">    \\`<span class=\"hljs-keyword\">const</span> css = ${JSON.stringify(css)}\\n\\` +\n</div></li><li><div class=\"code-word\">    \\`updateStyle(${JSON.stringify(id)}, css)\\n\\`\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (modules) {\n</div></li><li><div class=\"code-word\">    code += dataToEsm(modules, { namedExports: <span class=\"hljs-keyword\">true</span> })\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    code += \\`export <span class=\"hljs-keyword\">default</span> css\\`\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> code\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39523\">\n                      该方法会在浏览器中执行 updateStyle 方法，<a\n                        href=\"https://github.com/vitejs/vite/blob/c3ef4f64ec09c6916f4e6b9764362a23843b98b6/src/client/client.ts#L170\"\n                        data-nodeid=\"39745\"\n                        >源码</a\n                      >如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> supportsConstructedSheet = (() =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生成 CSSStyleSheet 实例，试探是否支持 ConstructedSheet</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">new</span> CSSStyleSheet()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">catch</span> (e) {}\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">})()\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">updateStyle</span><span class=\"hljs-params\">(id: string, content: string)</span> </span>{\n</div></li><li><div class=\"code-word\">  let style = sheetsMap.get(id)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (supportsConstructedSheet &amp;&amp; !content.includes(<span class=\"hljs-string\">'@import'</span>)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (style &amp;&amp; !(style <span class=\"hljs-keyword\">instanceof</span> CSSStyleSheet)) {\n</div></li><li><div class=\"code-word\">      removeStyle(id)\n</div></li><li><div class=\"code-word\">      style = undefined\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!style) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 生成 CSSStyleSheet 实例</span>\n</div></li><li><div class=\"code-word\">      style = <span class=\"hljs-keyword\">new</span> CSSStyleSheet()\n</div></li><li><div class=\"code-word\">      style.replaceSync(content)\n</div></li><li><div class=\"code-word\">      document.adoptedStyleSheets = [...document.adoptedStyleSheets, style]\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      style.replaceSync(content)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (style &amp;&amp; !(style <span class=\"hljs-keyword\">instanceof</span> HTMLStyleElement)) {\n</div></li><li><div class=\"code-word\">      removeStyle(id)\n</div></li><li><div class=\"code-word\">      style = undefined\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!style) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 生成新的 style 标签并插入到 document 挡住</span>\n</div></li><li><div class=\"code-word\">      style = document.createElement(<span class=\"hljs-string\">'style'</span>)\n</div></li><li><div class=\"code-word\">      style.setAttribute(<span class=\"hljs-string\">'type'</span>, <span class=\"hljs-string\">'text/css'</span>)\n</div></li><li><div class=\"code-word\">      style.innerHTML = content\n</div></li><li><div class=\"code-word\">      document.head.appendChild(style)\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      style.innerHTML = content\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  sheetsMap.set(id, style)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39525\">最终完成在浏览器中插入样式。</p>\n                    <p data-nodeid=\"39526\">\n                      至此，我们解析并列举了较多源码内容。以上内容需要你跟着思路，一步步梳理，我也强烈建议你打开\n                      Vite\n                      源码自己动手剖析。如果看到这里你仍然也有些“云里雾里”，不要心急，结合我下面这个图示，再次进行阅读，相信会更有收获。\n                    </p>\n                    <p data-nodeid=\"39527\">\n                      Vite 这种 bundleless 方案的运行原理图：\n                    </p>\n                    <p data-nodeid=\"39528\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/03/FB/Cip5yF_ltUqAV2zLAADo9NOnOvk745.png\"\n                        alt=\"Lark20201225-174527.png\"\n                        data-nodeid=\"39752\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39529\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/18/Ciqc1F_ltVCAEgT6AAERxP80SRw964.png\"\n                        alt=\"Lark20201225-174517.png\"\n                        data-nodeid=\"39755\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39530\">接下来我们再做一些更细节的总结。</p>\n                    <ul data-nodeid=\"39531\">\n                      <li data-nodeid=\"39532\">\n                        <p data-nodeid=\"39533\">\n                          Vite 利用浏览器原生支持 ESM\n                          这一特性，省略了对模块的打包，也就不需要生成\n                          bundle，因此初次启动更快，HMR 特性友好。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39534\">\n                        <p data-nodeid=\"39535\">\n                          Vite 开发模式下，通过启动 koa\n                          服务器，在服务端完成模块的改写（比如单文件的解析编译等）和请求处理，实现真正的按需编译。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39536\">\n                        <p data-nodeid=\"39537\">\n                          Vite Server\n                          所有逻辑基本都依赖中间件实现。这些中间件，拦截请求之后，完成了如下内容：\n                        </p>\n                        <ul data-nodeid=\"39538\">\n                          <li data-nodeid=\"39539\">\n                            <p data-nodeid=\"39540\">\n                              处理 ESM 语法，比如将业务代码中的 import\n                              第三方依赖路径转为浏览器可识别的依赖路径；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"39541\">\n                            <p data-nodeid=\"39542\">\n                              对 .ts、.vue 等文件进行即时编译；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"39543\">\n                            <p data-nodeid=\"39544\">\n                              对 Sass/Less 的需要预编译的模块进行编译；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"39545\">\n                            <p data-nodeid=\"39546\">\n                              和浏览器端建立 socket 连接，实现 HMR。\n                            </p>\n                          </li>\n                        </ul>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"39547\">Vite HMR 实现原理</h4>\n                    <p data-nodeid=\"39548\">\n                      Vite 的打包命令使用了 Rollup\n                      进行，这里并没有什么特别之处，我们不再展开讲解。而 Vite 的\n                      HMR 特性，主要是围绕着：\n                    </p>\n                    <ul data-nodeid=\"39549\">\n                      <li data-nodeid=\"39550\">\n                        <p data-nodeid=\"39551\">通过 watcher 监听文件改动</p>\n                      </li>\n                      <li data-nodeid=\"39552\">\n                        <p data-nodeid=\"39553\">\n                          通过 server 端编译资源，并推送新模块内容给浏览器\n                        </p>\n                      </li>\n                      <li data-nodeid=\"39554\">\n                        <p data-nodeid=\"39555\">\n                          浏览器收到新的模块内容，执行框架层面的 rerender/reload\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"39556\">三步进行。</p>\n                    <p data-nodeid=\"39557\">\n                      当浏览器请求 HTML 页面时，服务端通过\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/master/src/node/server/serverPluginHtml.ts\"\n                        data-nodeid=\"39773\"\n                        >serverPluginHtml</a\n                      >\n                      插件向 HTML 内容注入一段脚本。如下图所示，我们可以看到，\n                      index.html 中就有一段引入 /vite/client 代码，进行\n                      WebSocket 的注册和监听。\n                    </p>\n                    <p data-nodeid=\"39558\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8B/C7/Ciqc1F_gZk-AeTAnAAK2AAgChPQ413.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"39777\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39559\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8B/D2/CgqCHl_gZlWAHmvqAAgRairyZ98357.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"39780\"\n                      />\n                    </p>\n                    <p data-nodeid=\"39560\">\n                      对于 /vite/client 请求的处理，服务端由\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/a47429dabea12e8aa5f4a21209846aaf857d5be0/src/node/server/serverPluginClient.ts\"\n                        data-nodeid=\"39784\"\n                        >serverPluginClient</a\n                      >\n                      插件进行处理：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-keyword\">const</span> clientPlugin: ServerPlugin = ({ app, config }) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> clientCode = fs\n</div></li><li><div class=\"code-word\">    .readFileSync(clientFilePath, <span class=\"hljs-string\">'utf-8'</span>)\n</div></li><li><div class=\"code-word\">    .replace(\\`__MODE__\\`, JSON.stringify(config.mode || <span class=\"hljs-string\">'development'</span>))\n</div></li><li><div class=\"code-word\">    .replace(\n</div></li><li><div class=\"code-word\">      \\`__DEFINES__\\`,\n</div></li><li><div class=\"code-word\">      JSON.stringify({\n</div></li><li><div class=\"code-word\">        ...defaultDefines,\n</div></li><li><div class=\"code-word\">        ...config.define\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 相应中间件处理</span>\n</div></li><li><div class=\"code-word\">  app.use(async (ctx, next) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (ctx.path === clientPublicPath) {\n</div></li><li><div class=\"code-word\">      ctx.type = <span class=\"hljs-string\">'js'</span>\n</div></li><li><div class=\"code-word\">      ctx.status = <span class=\"hljs-number\">200</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 返回具体内容</span>\n</div></li><li><div class=\"code-word\">      ctx.body = clientCode.replace(\\`__PORT__\\`, ctx.port.toString())\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 兼容历史逻辑，并进行错误提示</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (ctx.path === legacyPublicPath) {\n</div></li><li><div class=\"code-word\">        console.error(\n</div></li><li><div class=\"code-word\">          chalk.red(\n</div></li><li><div class=\"code-word\">            \\`[vite] client <span class=\"hljs-keyword\">import</span> path has changed from <span class=\"hljs-string\">\"/vite/hmr\"</span> to <span class=\"hljs-string\">\"/vite/client\"</span>. \\` +\n</div></li><li><div class=\"code-word\">              \\`please update your code accordingly.\\`\n</div></li><li><div class=\"code-word\">          )\n</div></li><li><div class=\"code-word\">        )\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> next()\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39562\">\n                      返回的 /vite/src/client/client.js 代码在浏览器端主要通过\n                      WebSocket 监听了一些更新的类型（vue 组件更新/vue template\n                      更新/vue style 更新/css 更新/css 移除/js 更新/页面\n                      roload），分别进行处理。\n                    </p>\n                    <p data-nodeid=\"39563\">\n                      在服务端，通过\n                      <a\n                        href=\"https://www.npmjs.com/package/chokidar\"\n                        data-nodeid=\"39790\"\n                        >chokidar</a\n                      >\n                      创建了一个监听文件改动的 watcher 来监听文件改动：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> watcher = chokidar.watch(root, {\n</div></li><li><div class=\"code-word\">\tignored: [/node_modules/, /\\.git/],\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// #610</span>\n</div></li><li><div class=\"code-word\">\tawaitWriteFinish: {\n</div></li><li><div class=\"code-word\">\t  stabilityThreshold: <span class=\"hljs-number\">100</span>,\n</div></li><li><div class=\"code-word\">\t  pollInterval: <span class=\"hljs-number\">10</span>\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">}) as HMRWatcher\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"39565\">\n                      并通过\n                      <a\n                        href=\"https://github.com/vitejs/vite/blob/master/src/node/server/serverPluginHmr.ts\"\n                        data-nodeid=\"39795\"\n                        >serverPluginHmr</a\n                      >\n                      发布变动，通知浏览器。\n                    </p>\n                    <p data-nodeid=\"39566\">\n                      更多源码不再一一贴出。这里我总结了一张流程图供你参考：\n                    </p>\n                    <p data-nodeid=\"39809\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/03/FD/CgpVE1_ltm6AN8nCAAMSQ8AjILg631.png\"\n                        alt=\"Lark20201225-175233.png\"\n                        data-nodeid=\"39813\"\n                      />\n                    </p>\n                    <div data-nodeid=\"39810\">\n                      <p style=\"text-align: center\">Vite 实现 HMR 流程图</p>\n                    </div>\n\n                    <h3 data-nodeid=\"39569\">总结</h3>\n                    <p data-nodeid=\"39570\">\n                      这一讲我们聚焦 Vite 实现，分析了如何利用 ESM，构建一个\n                      bundleless\n                      风格的现代化开发工程方案。源码内容较多，也涉及一定工程化架构设计内容，但\n                      Vite 实现流程清晰，易读性高，是源码阅读类很好的资源。\n                    </p>\n                    <p data-nodeid=\"39571\">\n                      事实上，Vite 依赖优化的灵感来自\n                      <a href=\"https://www.snowpack.dev/\" data-nodeid=\"39806\"\n                        >Snowpack</a\n                      >，这类 bundleless\n                      工具也代表着一种新趋势、新方向。我认为，技术功底是很重要的一方面，而技术敏感度的培养也非常关键。希望与你共勉！\n                    </p>\n                    <p data-nodeid=\"39572\" class=\"\">\n                      到此，新编译工具理念——Vite\n                      我们就介绍到这里。接下来我们将进入代码降级编译环节的学习，我们下一讲再见。\n                    </p>\n            "}