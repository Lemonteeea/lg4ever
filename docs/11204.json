{"title":"02 | Yarn 的安装理念及如何破解依赖管理困境","context":"\n                    <p data-nodeid=\"1645\" class=\"\">\n                      01 讲我们讲了 npm\n                      的技巧和原理，但其实在前端工程化这个主题上除了\n                      npm，还有不可忽视的 Yarn。\n                    </p>\n                    <p data-nodeid=\"1646\">\n                      Yarn 是一个由 Facebook、Google、Exponent 和 Tilde\n                      构建的新的 JavaScript 包管理器。它的出现是为了解决历史上\n                      npm 的某些不足（比如 npm\n                      对于依赖的完整性和一致性保障，以及 npm\n                      安装速度过慢的问题等），虽然 npm 目前经过版本迭代汲取了\n                      Yarn\n                      一些优势特点（比如一致性安装校验算法等），但我们依然有必要关注\n                      Yarn 的思想和理念。\n                    </p>\n                    <p data-nodeid=\"1647\">\n                      Yarn 和 npm 的关系，有点像当年的 Io.js 和\n                      Node.js，殊途同归，都是为了进一步解放和优化生产力。这里需要说明的是，<strong\n                        data-nodeid=\"1782\"\n                        >不管是哪种工具，你应该做的就是全面了解其思想，优劣胸中有数，这样才能驾驭它，为自己的项目架构服务</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1648\">\n                      当 npm 还处在 v3 时期时，一个叫作 Yarn\n                      的包管理方案横空出世。2016 年，npm 还没有\n                      package-lock.json 文件，安装速度很慢，稳定性也较差，而\n                      Yarn 的理念很好地解决了以下问题。\n                    </p>\n                    <ul data-nodeid=\"1649\">\n                      <li data-nodeid=\"1650\">\n                        <p data-nodeid=\"1651\">\n                          <strong data-nodeid=\"1792\">确定性</strong>：通过\n                          yarn.lock\n                          等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。（在\n                          npm v5 之前，没有 package-lock.json\n                          机制，只有默认并不会使用的<a\n                            href=\"https://docs.npmjs.com/cli/shrinkwrap\"\n                            data-nodeid=\"1790\"\n                            >npm-shrinkwrap.json</a\n                          >。）\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1652\">\n                        <p data-nodeid=\"1653\">\n                          <strong data-nodeid=\"1797\"\n                            >采用模块扁平安装模式</strong\n                          >：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（npm\n                          目前也有相同的优化）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1654\">\n                        <p data-nodeid=\"1655\">\n                          <strong data-nodeid=\"1802\">网络性能更好</strong>：Yarn\n                          采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1656\">\n                        <p data-nodeid=\"1657\">\n                          <strong data-nodeid=\"1807\"\n                            >采用缓存机制，实现了离线模式</strong\n                          >（npm 目前也有类似实现）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1658\">我们先来看看 yarn.lock 结构：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-string\">\"@babel/cli@^7.1.6\"</span>, <span class=\"hljs-string\">\"@babel/cli@^7.5.5\"</span>:\n</div></li><li><div class=\"code-word\">  version <span class=\"hljs-string\">\"7.8.4\"</span>\n</div></li><li><div class=\"code-word\">  resolved <span class=\"hljs-string\">\"http://npm.in.zhihu.com/@babel%2fcli/-/cli-7.8.4.tgz#505fb053721a98777b2b175323ea4f090b7d3c1c\"</span>\n</div></li><li><div class=\"code-word\">  integrity sha1-UF+wU3IamHd7KxdTI+pPCQt9PBw=\n</div></li><li><div class=\"code-word\">  dependencies:\n</div></li><li><div class=\"code-word\">    commander <span class=\"hljs-string\">\"^4.0.1\"</span>\n</div></li><li><div class=\"code-word\">    convert-source-map <span class=\"hljs-string\">\"^1.1.0\"</span>\n</div></li><li><div class=\"code-word\">    fs-readdir-recursive <span class=\"hljs-string\">\"^1.1.0\"</span>\n</div></li><li><div class=\"code-word\">    glob <span class=\"hljs-string\">\"^7.0.0\"</span>\n</div></li><li><div class=\"code-word\">    lodash <span class=\"hljs-string\">\"^4.17.13\"</span>\n</div></li><li><div class=\"code-word\">    make-dir <span class=\"hljs-string\">\"^2.1.0\"</span>\n</div></li><li><div class=\"code-word\">    slash <span class=\"hljs-string\">\"^2.0.0\"</span>\n</div></li><li><div class=\"code-word\">    source-map <span class=\"hljs-string\">\"^0.5.0\"</span>\n</div></li><li><div class=\"code-word\">  optionalDependencies:\n</div></li><li><div class=\"code-word\">    chokidar <span class=\"hljs-string\">\"^2.1.8\"</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1660\">\n                      该结构整体和 package-lock.json 结构类似，只不过 yarn.lock\n                      并没有使用 JSON\n                      格式，而是采用了一种自定义的标记格式，新的格式仍然保持了较高的可读性。\n                    </p>\n                    <p data-nodeid=\"1661\">\n                      <strong data-nodeid=\"1816\"\n                        >相比 npm，Yarn 另外一个显著区别是 yarn.lock\n                        中子依赖的版本号不是固定版本</strong\n                      >。这就说明单独一个 yarn.lock 确定不了 node_modules\n                      目录结构，还需要和 package.json 文件进行配合。\n                    </p>\n                    <p data-nodeid=\"1662\">\n                      其实，不管是 npm 还是\n                      Yarn，说到底它们都是一个包管理工具，在项目中如果想进行\n                      npm/Yarn 切换，并不是一件麻烦的事情。<strong\n                        data-nodeid=\"1826\"\n                        >甚至还有一个专门的\n                        <a\n                          href=\"https://github.com/imsnif/synp\"\n                          data-nodeid=\"1822\"\n                          >synp</a\n                        >\n                        工具，它可以将 yarn.lock 转换为\n                        package-lock.json</strong\n                      >，反之亦然。\n                    </p>\n                    <p data-nodeid=\"1663\">\n                      关于 Yarn\n                      缓存，我们可以通过这个命令查看缓存目录，并通过目录查看缓存内容：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">yarn cache dir\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1665\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/84/9F/CgqCHl_TbhOAEFfxAAFJ2o762gM476.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"1830\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1666\">\n                      值得一提的是，Yarn 默认使用 prefer-online\n                      模式，即优先使用网络数据。如果网络数据请求失败，再去请求缓存数据。\n                    </p>\n                    <p data-nodeid=\"1667\">\n                      最后，我们来看一看一些区别于 npm，Yarn 所独有的命令：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">yarn <span class=\"hljs-keyword\">import</span>\n</div></li><li><div class=\"code-word\">yarn licenses\n</div></li><li><div class=\"code-word\">yarn pack\n</div></li><li><div class=\"code-word\">yarn why\n</div></li><li><div class=\"code-word\">yarn autoclean\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1669\">\n                      npm 独有的命令是：<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1834\"\n                        >npm rebuild</code\n                      >。\n                    </p>\n                    <p data-nodeid=\"1670\">\n                      现在，你已经对 Yarn 有了一个初步了解，接下来我们来分析一下\n                      Yarn 的安装机制和思想。\n                    </p>\n                    <h3 data-nodeid=\"1671\">Yarn 安装机制和背后思想</h3>\n                    <p data-nodeid=\"1672\">\n                      上一讲我们已经介绍过了 npm 安装机制，这里我们再来看一下\n                      Yarn 的安装理念。简单来说，Yarn 的安装过程主要有以下 5\n                      大步骤：\n                    </p>\n                    <p data-nodeid=\"1673\">\n                      检测（checking）→ 解析包（Resolving Packages） →\n                      获取包（Fetching Packages）→ 链接包（Linking Packages）→\n                      构建包（Building Packages）\n                    </p>\n                    <p data-nodeid=\"1674\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8A/17/CgqCHl_ZflCANVu8AAJJZZYzwhs026.png\"\n                        alt=\"图片14.png\"\n                        data-nodeid=\"1842\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1675\">\n                      <p style=\"text-align: center\">Yarn 安装流程图</p>\n                    </div>\n                    <p data-nodeid=\"1676\">\n                      <strong data-nodeid=\"1846\">检测包（checking）</strong>\n                    </p>\n                    <p data-nodeid=\"1677\">\n                      这一步主要是<strong data-nodeid=\"1856\"\n                        >检测项目中是否存在一些 npm 相关文件</strong\n                      >，比如 package-lock.json\n                      等。如果有，会提示用户注意：这些文件的存在可能会导致冲突。在这一步骤中，<strong\n                        data-nodeid=\"1857\"\n                        >也会检查系统 OS、CPU 等信息</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1678\">\n                      <strong data-nodeid=\"1861\"\n                        >解析包（Resolving Packages）</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1679\">\n                      这一步会解析依赖树中每一个包的版本信息。\n                    </p>\n                    <p data-nodeid=\"1680\">\n                      首先获取当前项目中 package.json 定义的\n                      dependencies、devDependencies、optionalDependencies\n                      的内容，这属于首层依赖。\n                    </p>\n                    <p data-nodeid=\"1681\">\n                      接着<strong data-nodeid=\"1869\"\n                        >采用遍历首层依赖的方式获取依赖包的版本信息</strong\n                      >，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个\n                      Set\n                      数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析。\n                    </p>\n                    <ul data-nodeid=\"1682\">\n                      <li data-nodeid=\"1683\">\n                        <p data-nodeid=\"1684\">\n                          对于没有解析过的包 A，首次尝试从 yarn.lock\n                          中获取到版本信息，并标记为已解析；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1685\">\n                        <p data-nodeid=\"1686\">\n                          如果在 yarn.lock 中没有找到包 A，则向 Registry\n                          发起请求获取满足版本范围的已知最高版本的包信息，获取后将当前包标记为已解析。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1687\">\n                      总之，在经过解析包这一步之后，我们就确定了所有依赖的具体版本信息以及下载地址。\n                    </p>\n                    <p data-nodeid=\"1688\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/84/9F/CgqCHl_TbimACnDOAAFMC14gP8I289.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"1875\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1689\">\n                      <p style=\"text-align: center\">解析包获取流程图</p>\n                    </div>\n                    <p data-nodeid=\"1690\">\n                      <strong data-nodeid=\"1879\"\n                        >获取包（Fetching Packages）</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1691\">\n                      这一步我们首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录。说起来简单，但是还是有些问题值得思考。\n                    </p>\n                    <p data-nodeid=\"1692\">\n                      比如：如何判断缓存中是否存在当前的依赖包？<strong\n                        data-nodeid=\"1888\"\n                        >其实 Yarn 会根据 cacheFolder+slug+node_modules+pkg.name\n                        生成一个 path，判断系统中是否存在该\n                        path，如果存在证明已经有缓存，不用重新下载。这个 path\n                        也就是依赖包缓存的具体路径</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1693\">\n                      对于没有命中缓存的包，Yarn 会维护一个 fetch\n                      队列，按照规则进行网络请求。如果下载包地址是一个 file\n                      协议，或者是相对路径，就说明其指向一个本地目录，此时调用\n                      Fetch From Local 从离线缓存中获取包；否则调用 Fetch From\n                      External 获取包。最终获取结果使用 fs.createWriteStream\n                      写入到缓存目录下。\n                    </p>\n                    <p data-nodeid=\"1694\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/84/94/Ciqc1F_TbjKAThkOAAEsp0sOHUc622.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1892\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1695\">\n                      <p style=\"text-align: center\">获取包流程图</p>\n                    </div>\n                    <p data-nodeid=\"1696\">\n                      <strong data-nodeid=\"1896\"\n                        >链接包（Linking Packages）</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1697\">\n                      上一步是将依赖下载到缓存目录，这一步是将项目中的依赖复制到项目\n                      node_modules 下，同时遵循扁平化原则。在复制依赖前，Yarn\n                      会先解析 peerDependencies，如果找不到符合 peerDependencies\n                      的包，则进行 warning 提示，并最终拷贝依赖到项目中。\n                    </p>\n                    <p data-nodeid=\"1698\">\n                      这里提到的扁平化原则是核心原则，我也会在后面内容进行详细的讲解。\n                    </p>\n                    <p data-nodeid=\"1699\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/84/94/Ciqc1F_Tbj2AWiPOAADyaZB-wGw502.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"1903\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1700\">\n                      <p style=\"text-align: center\">链接包解析流程图</p>\n                    </div>\n                    <p data-nodeid=\"1701\">\n                      <strong data-nodeid=\"1907\"\n                        >构建包（Building Packages）</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1702\">\n                      如果依赖包中存在二进制包需要进行编译，会在这一步进行。\n                    </p>\n                    <p data-nodeid=\"1703\">\n                      了解了 npm 和 Yarn\n                      的安装原理还不是“终点”，因为一个应用项目的依赖错综复杂。接下来我将从“依赖地狱”说起，帮助你加深对依赖机制相关内容的理解，以便在开发生产中灵活运用。\n                    </p>\n                    <h3 data-nodeid=\"1704\">破解依赖管理困境</h3>\n                    <p data-nodeid=\"1705\">\n                      早期 npm（npm\n                      v2）的设计非常简单，在安装依赖时将依赖放到项目的\n                      node_modules 文件中；同时如果某个直接依赖 A 还依赖其他模块\n                      B，作为间接依赖，模块 B 将会被下载到 A 的 node_modules\n                      文件夹中，依此递归执行，最终形成了一颗巨大的依赖模块树。\n                    </p>\n                    <p data-nodeid=\"1706\">\n                      这样的 node_modules\n                      结构，的确简单明了、符合预期，但对大型项目在某些方面却不友好，比如可能有很多重复的依赖包，而且会形成“嵌套地狱”。\n                    </p>\n                    <p data-nodeid=\"1707\">那么如何理解“嵌套地狱”呢？</p>\n                    <ul data-nodeid=\"1708\">\n                      <li data-nodeid=\"1709\">\n                        <p data-nodeid=\"1710\">\n                          项目依赖树的层级非常深，不利于调试和排查问题；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1711\">\n                        <p data-nodeid=\"1712\">\n                          依赖树的不同分支里，可能存在同样版本的相同依赖。比如直接依赖\n                          A 和 B，但 A 和 B 都依赖相同版本的模块 C，那么 C\n                          会重复出现在 A 和 B 依赖的 node_modules 中。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"2044\" class=\"\">\n                      这种重复问题使得<strong data-nodeid=\"2052\"\n                        >安装结果浪费了较大的空间资源，也使得安装过程过慢，甚至会因为目录层级太深导致文件路径太长，最终在\n                        Windows 系统下删除 node_modules\n                        文件夹出现失败情况</strong\n                      >。\n                    </p>\n\n                    <p data-nodeid=\"1714\">\n                      因此 npm v3 之后，node_modules\n                      的结构改成了扁平结构，按照上面的例子（项目直接依赖模块\n                      A，A 还依赖其他模块 B），我们得到下面的图示：\n                    </p>\n                    <p data-nodeid=\"1715\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8A/0C/Ciqc1F_ZfoKACluCAADJ2SvodGg411.png\"\n                        alt=\"图片10.png\"\n                        data-nodeid=\"1937\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1716\">\n                      <p style=\"text-align: center\">\n                        npm 不同版本的安装结构图 ①\n                      </p>\n                    </div>\n                    <p data-nodeid=\"1717\" class=\"\">\n                      当项目新添加了 C 依赖，而它依赖另一个版本的 B\n                      v2.0。这时候版本要求不一致导致冲突，B v2.0\n                      没办法放在项目平铺目录下的 node_moduls 文件当中，npm v3\n                      会把 C 依赖的 B v2.0 安装在 C 的 node_modules 下：\n                    </p>\n                    <p data-nodeid=\"1718\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8A/0D/Ciqc1F_Zf1eAWVhcAADO_4H0sjA082.png\"\n                        alt=\"图片9.png\"\n                        data-nodeid=\"1945\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1719\">\n                      <p style=\"text-align: center\">\n                        npm 不同版本的安装结构图 ②\n                      </p>\n                    </div>\n                    <p data-nodeid=\"1720\">\n                      接下来，在 npm v3 中，假如我们的 App 现在还需要依赖一个\n                      D，而 D 也依赖 B v2.0 ，我们会得到如下结构：\n                    </p>\n                    <p data-nodeid=\"1721\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/EB/Cip5yF_Zf2mABSwEAAC-YH5jkcQ965.png\"\n                        alt=\"图片17.png\"\n                        data-nodeid=\"1949\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1722\">\n                      <p style=\"text-align: center\">npm 安装结构图 ①</p>\n                    </div>\n                    <p data-nodeid=\"9323\" class=\"te-preview-highlight\">\n                      这里我想请你思考一个问题：<strong data-nodeid=\"9333\"\n                        >为什么 B v1.0 出现在项目顶层 node_modules，而不是 B\n                        v2.0 出现在 node_modules 顶层呢</strong\n                      >？\n                    </p>\n\n                    <p data-nodeid=\"1724\">\n                      其实这取决于模块 A 和 C 的安装顺序。因为 A 先安装，所以 A\n                      的依赖 B v1.0 率先被安装在顶层 node_modules 中，接着 C 和\n                      D 依次被安装，C 和 D 的依赖 B v2.0 就不得不安装在 C 和 D\n                      的 node_modules 当中了。因此，<strong data-nodeid=\"1971\"\n                        >模块的安装顺序可能影响 node_modules\n                        内的文件结构</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1725\">\n                      我们继续依赖工程化之旅。假设这时候项目又添加了一个依赖 E\n                      ，E 依赖了 B v1.0 ，安装 E 之后，我们会得到这样一个结构：\n                    </p>\n                    <p data-nodeid=\"1726\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/EC/CgpVE1_Zf4aADdDJAADNnUsWnlc423.png\"\n                        alt=\"图片6.png\"\n                        data-nodeid=\"1975\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1727\">\n                      <p style=\"text-align: center\">npm 安装结构图 ②</p>\n                    </div>\n                    <p data-nodeid=\"1728\">\n                      此时对应的 package.json 中，依赖包的顺序如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">    A: <span class=\"hljs-string\">\"1.0\"</span>,\n</div></li><li><div class=\"code-word\">    C: <span class=\"hljs-string\">\"1.0\"</span>,\n</div></li><li><div class=\"code-word\">    D: <span class=\"hljs-string\">\"1.0\"</span>,\n</div></li><li><div class=\"code-word\">    E: <span class=\"hljs-string\">\"1.0\"</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1730\">\n                      如果我们想更新模块 A 为 v2.0，而模块 A v2.0 依赖了 B\n                      v2.0，npm v3 会怎么处理呢？\n                    </p>\n                    <p data-nodeid=\"1731\">整个过程是这样的：</p>\n                    <ul data-nodeid=\"1732\">\n                      <li data-nodeid=\"1733\">\n                        <p data-nodeid=\"1734\">删除 A v1.0；</p>\n                      </li>\n                      <li data-nodeid=\"1735\">\n                        <p data-nodeid=\"1736\">安装 A v2.0；</p>\n                      </li>\n                      <li data-nodeid=\"1737\">\n                        <p data-nodeid=\"1738\">\n                          留下 B v1.0 ，因为 E v1.0 还在依赖；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1739\">\n                        <p data-nodeid=\"1740\">\n                          把 B v2.0 安装在 A v2.0 下，因为顶层已经有了一个 B\n                          v1.0。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1741\">它的结构如下：</p>\n                    <p data-nodeid=\"1742\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/EB/Cip5yF_Zf6iAClRIAADSW-XFvzA495.png\"\n                        alt=\"图片5.png\"\n                        data-nodeid=\"1986\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1743\">\n                      <p style=\"text-align: center\">npm 安装结构图 ③</p>\n                    </div>\n                    <p data-nodeid=\"1744\">\n                      这时模块 B v2.0 分别出现在了 A、C、D 模块下——重复存在了。\n                    </p>\n                    <p data-nodeid=\"1745\">\n                      通过这一系列操作我们可以看到：<strong data-nodeid=\"1995\"\n                        >npm\n                        包的安装顺序对于依赖树的影响很大。模块安装顺序可能影响\n                        node_modules 内的文件数量</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1746\">这里一个更理想的依赖结构理应是：</p>\n                    <p data-nodeid=\"1747\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/EC/CgpVE1_Zf76ADk3NAADVWLHAHTo908.png\"\n                        alt=\"图片4.png\"\n                        data-nodeid=\"1999\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1748\">\n                      <p style=\"text-align: center\">npm 安装结构图 ④</p>\n                    </div>\n                    <p data-nodeid=\"1749\">\n                      过了一段时间，模块 E v2.0 发布了，并且 E v2.0 也依赖了模块\n                      B v2.0 ，npm v3 更新 E 时会怎么做呢？\n                    </p>\n                    <ul data-nodeid=\"1750\">\n                      <li data-nodeid=\"1751\">\n                        <p data-nodeid=\"1752\">删除 E v1.0；</p>\n                      </li>\n                      <li data-nodeid=\"1753\">\n                        <p data-nodeid=\"1754\">安装 E v2.0；</p>\n                      </li>\n                      <li data-nodeid=\"1755\">\n                        <p data-nodeid=\"1756\">删除 B v1.0；</p>\n                      </li>\n                      <li data-nodeid=\"1757\">\n                        <p data-nodeid=\"1758\">\n                          安装 B v2.0 在顶层 node_modules\n                          中，因为现在顶层没有任何版本的 B 了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1759\">此时得到图：</p>\n                    <p data-nodeid=\"1760\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8A/0D/Ciqc1F_Zf82Abr7LAADYStAX7VU318.png\"\n                        alt=\"图片3.png\"\n                        data-nodeid=\"2010\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1761\">\n                      <p style=\"text-align: center\">npm 安装结构图 ⑤</p>\n                    </div>\n                    <p data-nodeid=\"1762\">\n                      这时候，你可以明显看到出现了较多重复的依赖模块 B\n                      v2.0。我们可以删除 node_modules，重新安装，利用 npm\n                      的依赖分析能力，得到一个更清爽的结构。\n                    </p>\n                    <p data-nodeid=\"1763\">\n                      实际上，更优雅的方式是使用 npm dedupe 命令，得到：\n                    </p>\n                    <p data-nodeid=\"1764\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8A/19/CgqCHl_Zf-WAb-BnAADAe1GD0YY021.png\"\n                        alt=\"图片2.png\"\n                        data-nodeid=\"2017\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1765\">\n                      <p style=\"text-align: center\">npm 安装结构图 ⑥</p>\n                    </div>\n                    <p data-nodeid=\"1766\">\n                      实际上，Yarn 在安装依赖时会自动执行 dedupe 命令。<strong\n                        data-nodeid=\"2023\"\n                        >整个优化的安装过程，就是上一讲提到的扁平化安装模式，也是需要你掌握的关键内容</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"1767\">结语</h3>\n                    <p data-nodeid=\"1768\">这一讲我们解析了 Yarn 安装原理。</p>\n                    <p data-nodeid=\"1769\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8A/19/CgqCHl_ZgAuAIfWbAAc_D0oluIE175.png\"\n                        alt=\"前端基建 金句.png\"\n                        data-nodeid=\"2028\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1770\">\n                      通过本讲内容，你可以发现包安装并不只是从远程下载文件那么简单，这其中涉及缓存、系统文件路径，更重要的是还涉及了安装依赖树的解析、安装结构算法等。\n                    </p>\n                    <p data-nodeid=\"1771\">\n                      最后，给大家布置一个思考题，<a\n                        href=\"https://github.blog/2020-10-13-presenting-v7-0-0-of-the-npm-cli/\"\n                        data-nodeid=\"2033\"\n                        >npm v7</a\n                      >\n                      在 2020 年 10\n                      月刚刚发布，请你总结一下它的新特性，并思考一下为什么要引入这些新的特性？这些新特性背后是如何实现的？欢迎在留言区分享你的观点。\n                    </p>\n                    <hr data-nodeid=\"1772\" />\n                    <p data-nodeid=\"1773\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"2039\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image2/M01/00/66/CgpVE1_W_x2AaW0rAAdqMM6w3z0145.png\"\n                          alt=\"大前端引流.png\"\n                          data-nodeid=\"2038\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"1774\" class=\"\">\n                      对标阿里P7技术需求 + 每月大厂内推，6 个月助你斩获名企高薪\n                      Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"2043\"\n                        >点此链接，快来领取！</a\n                      >\n                    </p>\n            "}