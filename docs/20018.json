{"title":"17 | 进阶练习（下）：如何实现符合 Promise/A+ 规范的 Promise？","context":"\n                    <p data-nodeid=\"38688\">\n                      我在上一讲带你实现了一个浏览器端的\n                      EventEmitter，那么这一讲还是继续进阶，我们来实现一个符合\n                      Promise/A+ 规范的 Promise。\n                    </p>\n                    <p data-nodeid=\"38689\">\n                      其实在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6187\"\n                        data-nodeid=\"38787\"\n                        >14 | 异步编程（中）：如何深入理解异步编程的核心\n                        Promise</a\n                      >”中，我已经专门介绍了 Promise 的基本原理和使用情况。由于\n                      Promise\n                      在异步编程中的重要性不言而喻，因此在很多互联网大厂面试中，现场实现\n                      Promise 相关方法的题目经常会出现，比如 all、race 或者 any\n                      等。\n                    </p>\n                    <p data-nodeid=\"38690\">\n                      因此这一讲，我将要带你一步步实现一个符合标准的\n                      Promise，希望你在遇到相关题目时能够游刃有余。\n                    </p>\n                    <p data-nodeid=\"38691\">在课程开始前请你先思考一下：</p>\n                    <ol data-nodeid=\"38692\">\n                      <li data-nodeid=\"38693\">\n                        <p data-nodeid=\"38694\">Promise/A+ 约定了哪些规范？</p>\n                      </li>\n                      <li data-nodeid=\"38695\">\n                        <p data-nodeid=\"38696\">\n                          在手动实现 Promise 的过程中都遇到过哪些问题？\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"38697\">\n                      在开始手动实现 Promise 之前，你有必要先了解 Promise/A+\n                      的规范。\n                    </p>\n                    <h3 data-nodeid=\"38698\">Promise/A+ 规范</h3>\n                    <p data-nodeid=\"38699\">\n                      只有对规范进行解读并且形成明确的认知，才能更好地实现\n                      Promise。官方的地址为：<a\n                        href=\"https://promisesaplus.com/\"\n                        data-nodeid=\"38798\"\n                        >https://promisesaplus.com/</a\n                      >，这是一个英文的版本，我把其中比较关键的部分挑了出来。\n                    </p>\n                    <h4 data-nodeid=\"38700\">术语</h4>\n                    <p data-nodeid=\"38701\">\n                      先来看看 Promise/A+ 规范的基本术语，如下所示。\n                    </p>\n                    <blockquote data-nodeid=\"38702\">\n                      <p data-nodeid=\"38703\">\n                        “promise” is an object or function with\n                        a&nbsp;then&nbsp;method whose behavior conforms to this\n                        specification.<br />\n                        “thenable” is an object or function that defines\n                        a&nbsp;then&nbsp;method.<br />\n                        “value” is any legal JavaScript value\n                        (including&nbsp;undefined, a thenable, or a promise).<br />\n                        “exception” is a value that is thrown using\n                        the&nbsp;throw&nbsp;statement.<br />\n                        “reason” is a value that indicates why a promise was\n                        rejected.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"38704\">\n                      翻译过来，它所描述的就是以下五点。\n                    </p>\n                    <ol data-nodeid=\"38705\">\n                      <li data-nodeid=\"38706\">\n                        <p data-nodeid=\"38707\">\n                          “promise”：是一个具有 then\n                          方法的对象或者函数，它的行为符合该规范。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"38708\">\n                        <p data-nodeid=\"38709\">\n                          “thenable”：是一个定义了 then 方法的对象或者函数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"38710\">\n                        <p data-nodeid=\"38711\">\n                          “value”：可以是任何一个合法的 JavaScript 的值（包括\n                          undefined、thenable 或 promise）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"38712\">\n                        <p data-nodeid=\"38713\">\n                          “exception”：是一个异常，是在 Promise 里面可以用 throw\n                          语句抛出来的值。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"38714\">\n                        <p data-nodeid=\"38715\">\n                          “reason”：是一个 Promise 里 reject\n                          之后返回的拒绝原因。\n                        </p>\n                      </li>\n                    </ol>\n                    <h4 data-nodeid=\"38716\">状态描述</h4>\n                    <p data-nodeid=\"38717\">\n                      看完了术语部分，我们再看下Promise/A+ 规范中，对 Promise\n                      的内部状态的描述，如下所示。\n                    </p>\n                    <blockquote data-nodeid=\"38718\">\n                      <p data-nodeid=\"38719\">\n                        A promise must be in one of three states: pending,\n                        fulfilled, or rejected.<br />\n                        When pending, a promise:<br />\n                        may transition to either the fulfilled or rejected\n                        state.<br />\n                        When fulfilled, a promise:<br />\n                        must not transition to any other state.<br />\n                        must have a value, which must not change.<br />\n                        When rejected, a promise:<br />\n                        must not transition to any other state.<br />\n                        must have a reason, which must not change.<br />\n                        Here, “must not change” means immutable identity\n                        (i.e.&nbsp;===), but does not imply deep immutability.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"38720\">\n                      将上述描述总结起来，大致有以下几点。\n                    </p>\n                    <ol data-nodeid=\"38721\">\n                      <li data-nodeid=\"38722\">\n                        <p data-nodeid=\"38723\">\n                          一个 Promise 有三种状态：pending、fulfilled 和\n                          rejected。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"38724\">\n                        <p data-nodeid=\"38725\">\n                          当状态为 pending 状态时，即可以转换为 fulfilled 或者\n                          rejected 其中之一。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"38726\">\n                        <p data-nodeid=\"38727\">\n                          当状态为 fulfilled\n                          状态时，就不能转换为其他状态了，必须返回一个不能再改变的值。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"38728\">\n                        <p data-nodeid=\"38729\">\n                          当状态为 rejected\n                          状态时，同样也不能转换为其他状态，必须有一个原因的值也不能改变。\n                        </p>\n                      </li>\n                    </ol>\n                    <h4 data-nodeid=\"38730\">then 方法</h4>\n                    <p data-nodeid=\"38731\">\n                      关于 then 方法的英文解读和翻译，我直接总结了出来：一个\n                      Promise 必须拥有一个 then 方法来访问它的值或者拒绝原因。\n                    </p>\n                    <p data-nodeid=\"38732\">then 方法有两个参数：</p>\n                    <blockquote data-nodeid=\"38733\">\n                      <p data-nodeid=\"38734\">\n                        promise.then(onFulfilled, onRejected)\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"38735\">\n                      onFulfilled&nbsp;和&nbsp;onRejected&nbsp;都是可选参数。\n                    </p>\n                    <p data-nodeid=\"38736\">\n                      <strong data-nodeid=\"38851\"\n                        >onFulfilled 和 onRejected&nbsp;特性</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"38737\">\n                      如果&nbsp;onFulfilled&nbsp;是函数，则当 Promise\n                      执行结束之后必须被调用，最终返回值为\n                      value，其调用次数不可超过一次。而 onRejected\n                      除了最后返回的是 reason 外，其他方面和 onFulfilled\n                      在规范上的表述基本一样。\n                    </p>\n                    <p data-nodeid=\"38738\">\n                      <strong data-nodeid=\"38856\">多次调用</strong>\n                    </p>\n                    <p data-nodeid=\"38739\">\n                      then 方法其实可以被一个 Promise 调用多次，且必须返回一个\n                      Promise 对象。then 的写法如下所示，其中 Promise1 执行了\n                      then 的方法之后，返回的依旧是个 Promise2，然后我们拿着\n                      Promise2 又可以执行 then 方法，而 Promise2 是一个新的\n                      Promise 对象，又可以继续进行 then 方法调用。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">promise2 = promise1.then(onFulfilled, onRejected);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38741\">\n                      规范里面还有很大一部分讲解的是 Promise\n                      的解决过程。其实只看规范的话，整体感觉很空洞，方才我已经将规范的主要部分为你讲解了，这些内容基本可以指导我们自己实现一个\n                      Promise 了。\n                    </p>\n                    <p data-nodeid=\"38742\">\n                      那么下面我们就理论结合实践，动手实现一个 Promise 吧。\n                    </p>\n                    <h3 data-nodeid=\"38743\">一步步实现 Promise</h3>\n                    <p data-nodeid=\"38744\">\n                      按照 Promise/A+ 的规范，第一步就是构造函数。\n                    </p>\n                    <h4 data-nodeid=\"38745\">构造函数</h4>\n                    <p data-nodeid=\"38746\">\n                      这一步的思路是：Promise 构造函数接受一个 executor\n                      函数，executor\n                      函数执行完同步或者异步操作后，调用它的两个参数 resolve 和\n                      reject。请看下面的代码，大致的构造函数框架就是这样的。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Promise</span>(<span class=\"hljs-params\">executor</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  self.status = <span class=\"hljs-string\">'pending'</span>   <span class=\"hljs-comment\">// Promise当前的状态</span>\n</div></li><li><div class=\"code-word\">  self.data = <span class=\"hljs-literal\">undefined</span>     <span class=\"hljs-comment\">// Promise的值</span>\n</div></li><li><div class=\"code-word\">  self.onResolvedCallback = [] <span class=\"hljs-comment\">// Promise resolve时的回调函数集</span>\n</div></li><li><div class=\"code-word\">  self.onRejectedCallback = [] <span class=\"hljs-comment\">// Promise reject时的回调函数集</span>\n</div></li><li><div class=\"code-word\">  executor(resolve, reject) <span class=\"hljs-comment\">// 执行executor并传入相应的参数</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38748\">\n                      从上面的代码中可以看出，我们先定义了一个 Promise\n                      的初始状态 pending，以及参数执行函数\n                      executor，并且按照规范设计了一个 resolve 回调函数集合数组\n                      onResolvedCallback 以及 一个 reject\n                      回调函数集合数组，那么构造函数的初始化就基本完成了。\n                    </p>\n                    <p data-nodeid=\"38749\">\n                      接下来我们看看还需要添加什么东西呢？那就是需要在构造函数中完善\n                      resolve 和 reject 两个函数，完善之后的代码如下。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Promise</span>(<span class=\"hljs-params\">executor</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  self.status = <span class=\"hljs-string\">'pending'</span>   <span class=\"hljs-comment\">// Promise当前的状态</span>\n</div></li><li><div class=\"code-word\">  self.data = <span class=\"hljs-literal\">undefined</span>    <span class=\"hljs-comment\">// Promise的值</span>\n</div></li><li><div class=\"code-word\">  self.onResolvedCallback = [] <span class=\"hljs-comment\">// Promise resolve时的回调函数集</span>\n</div></li><li><div class=\"code-word\">  self.onRejectedCallback = [] <span class=\"hljs-comment\">// Promise reject时的回调函数集</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// TODO</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// TODO</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> { <span class=\"hljs-comment\">// 考虑到执行过程中有可能出错，所以我们用try/catch块给包起</span>\n</div></li><li><div class=\"code-word\">    executor(resolve, reject) <span class=\"hljs-comment\">// 执行executor</span>\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">catch</span>(e) {\n</div></li><li><div class=\"code-word\">    reject(e)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38751\">\n                      resolve 和 reject\n                      内部应该怎么实现呢？我们根据规范知道这两个方法主要做的事情就是返回对应状态的值\n                      value 或者 reason，并把 Promise 内部的 status 从 pending\n                      变成对应的状态，并且这个状态在改变了之后是不可以逆转的。\n                    </p>\n                    <p data-nodeid=\"38752\">\n                      那么这两个函数应该怎么写呢？可以看下面的这段代码。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Promise</span>(<span class=\"hljs-params\">executor</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...上面的省略</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'pending'</span>) {\n</div></li><li><div class=\"code-word\">      self.status = <span class=\"hljs-string\">'resolved'</span>\n</div></li><li><div class=\"code-word\">      self.data = value\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; self.onResolvedCallback.length; i++) {\n</div></li><li><div class=\"code-word\">        self.onResolvedCallback[i](value)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'pending'</span>) {\n</div></li><li><div class=\"code-word\">      self.status = <span class=\"hljs-string\">'rejected'</span>\n</div></li><li><div class=\"code-word\">      self.data = reason\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; self.onRejectedCallback.length; i++) {\n</div></li><li><div class=\"code-word\">        self.onRejectedCallback[i](reason)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 下面的省略</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38754\">\n                      上述代码所展示的，基本就是在判断状态为 pending\n                      之后，把状态改为相应的值，并把对应的 value 和 reason\n                      存在内部的 data\n                      属性上面，之后执行相应的回调函数。逻辑比较简单，无非是由于\n                      onResolveCallback 和 onRejectedCallback\n                      这两个是数组，需要通过循环来执行，这里就不多解释了，你应该会知道。\n                    </p>\n                    <p data-nodeid=\"38755\">\n                      好了，构造函数基本就实现了，那么我们再看看如何实现 then\n                      方法，从而保证可以实现链式调用。\n                    </p>\n                    <h4 data-nodeid=\"38756\">实现 then 方法</h4>\n                    <p data-nodeid=\"38757\">根据标准，我们要考虑几个问题。</p>\n                    <p data-nodeid=\"38758\">\n                      then 方法是 Promise 执行完之后可以拿到 value 或者 reason\n                      的方法，并且还要保持 then 执行之后，返回的依旧是一个\n                      Promise 方法，还要支持多次调用（上面标准中提到过）。\n                    </p>\n                    <p data-nodeid=\"38759\">\n                      因此 then 方法实现的思路也有了，请看下面的一段代码。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// then方法接收两个参数onResolved和onRejected，分别为Promise成功或失败后的回调</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onResolved, onRejected</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> promise2\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 根据标准，如果then的参数不是function，则需要忽略它</span>\n</div></li><li><div class=\"code-word\">  onResolved = <span class=\"hljs-keyword\">typeof</span> onResolved === <span class=\"hljs-string\">'function'</span> ? onResolved : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) </span>{}\n</div></li><li><div class=\"code-word\">  onRejected = <span class=\"hljs-keyword\">typeof</span> onRejected === <span class=\"hljs-string\">'function'</span> ? onRejected : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">r</span>) </span>{}\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'resolved'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'rejected'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'pending'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38761\">\n                      从上面的代码中可以看到，我们在 then 方法内部先初始化了\n                      Promise2 的对象，用来存放执行之后返回的\n                      Promise，并且还需要判断 then\n                      方法传参进来的两个参数必须为函数，这样才可以继续执行。\n                    </p>\n                    <p data-nodeid=\"38762\">\n                      上面我只是搭建了 then\n                      方法框架的整体思路，但是不同状态的返回细节处理也需要完善，通过仔细阅读标准，完善之后的\n                      then 的代码如下。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onResolved, onRejected</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> promise2\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 根据标准，如果then的参数不是function，则需要忽略它</span>\n</div></li><li><div class=\"code-word\">  onResolved = <span class=\"hljs-keyword\">typeof</span> onResolved === <span class=\"hljs-string\">'function'</span> ? onResolved : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{}\n</div></li><li><div class=\"code-word\">  onRejected = <span class=\"hljs-keyword\">typeof</span> onRejected === <span class=\"hljs-string\">'function'</span> ? onRejected : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>) </span>{}\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'resolved'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果promise1的状态已经确定并且是resolved，我们调用onResolved，考虑到有可能throw，所以还需要将其包在try/catch块里</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> x = onResolved(self.data)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (x <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Promise</span>) {\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 如果onResolved的返回值是一个Promise对象，直接取它的结果作为promise2的结果</span>\n</div></li><li><div class=\"code-word\">          x.then(resolve, reject)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        resolve(x) <span class=\"hljs-comment\">// 否则，以它的返回值作为promise2的结果</span>\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">        reject(e) <span class=\"hljs-comment\">// 如果出错，以捕获到的错误作为promise2的结果</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'rejected'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> x = onRejected(self.data)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (x <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Promise</span>) {\n</div></li><li><div class=\"code-word\">          x.then(resolve, reject)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">        reject(e)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'pending'</span>) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，只能等到Promise的状态确定后，才能确定如何处理</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">      self.onResolvedCallback.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">var</span> x = onResolved(self.data)\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (x <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Promise</span>) {\n</div></li><li><div class=\"code-word\">            x.then(resolve, reject)\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">          reject(e)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">      self.onRejectedCallback.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>) </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">var</span> x = onRejected(self.data)\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (x <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Promise</span>) {\n</div></li><li><div class=\"code-word\">            x.then(resolve, reject)\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">          reject(e)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38764\">\n                      根据上面的代码可以看出，我们基本实现了一个符合标准的 then\n                      方法。但是标准里提到了，还要支持不同的 Promise\n                      进行交互，关于不同的 Promise 交互其实<a\n                        href=\"https://promisesaplus.com/#point-46\"\n                        data-nodeid=\"38879\"\n                        >Promise 标准说明</a\n                      >中有提到。其中详细指定了如何通过 then\n                      的实参返回的值来决定 Promise2 的状态。\n                    </p>\n                    <p data-nodeid=\"38765\">\n                      关于为何需要不同的 Promise 实现交互，原因应该是 Promise\n                      并不是 JS\n                      一开始存在的标准，如果你使用的某一个库中封装了一个 Promise\n                      的实现，想象一下如果它不能跟你自己使用的 Promise\n                      实现交互的情况，其实还是会有问题的，因此我们还需要调整一下\n                      then 方法中执行 Promise 的方法。\n                    </p>\n                    <p data-nodeid=\"38766\">\n                      另外还有一个需要注意的是，在 Promise/A+ 规范中，onResolved\n                      和 onRejected\n                      这两项函数需要异步调用，关于这一点，标准里面是这么说的：\n                    </p>\n                    <blockquote data-nodeid=\"38767\">\n                      <p data-nodeid=\"38768\">\n                        In practice, this requirement ensures that onFulfilled\n                        and onRejected execute asynchronously, after the event\n                        loop turn in which then is called, and with a fresh\n                        stack.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"38769\">\n                      所以我们需要对代码做一点变动，即在处理 Promise 进行\n                      resolve 或者 reject 的时候，加上 setTimeout(fn, 0)。\n                    </p>\n                    <p data-nodeid=\"38770\">\n                      下面我就结合上面两点调整，给出完整版的代码，你可以根据注释关注一下我所做的调整。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-built_in\">Promise</span>\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">catch</span> (e) {}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Promise</span>(<span class=\"hljs-params\">executor</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  self.status = <span class=\"hljs-string\">'pending'</span>\n</div></li><li><div class=\"code-word\">  self.onResolvedCallback = []\n</div></li><li><div class=\"code-word\">  self.onRejectedCallback = []\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (value <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Promise</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> value.then(resolve, reject)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">// 异步执行所有的回调函数</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'pending'</span>) {\n</div></li><li><div class=\"code-word\">        self.status = <span class=\"hljs-string\">'resolved'</span>\n</div></li><li><div class=\"code-word\">        self.data = value\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; self.onResolvedCallback.length; i++) {\n</div></li><li><div class=\"code-word\">          self.onResolvedCallback[i](value)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>) </span>{\n</div></li><li><div class=\"code-word\">    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">// 异步执行所有的回调函数</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'pending'</span>) {\n</div></li><li><div class=\"code-word\">        self.status = <span class=\"hljs-string\">'rejected'</span>\n</div></li><li><div class=\"code-word\">        self.data = reason\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; self.onRejectedCallback.length; i++) {\n</div></li><li><div class=\"code-word\">          self.onRejectedCallback[i](reason)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    executor(resolve, reject)\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">catch</span> (reason) {\n</div></li><li><div class=\"code-word\">    reject(reason)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolvePromise</span>(<span class=\"hljs-params\">promise2, x, resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> then\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> thenCalledOrThrow = <span class=\"hljs-literal\">false</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (promise2 === x) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Chaining cycle detected for promise!'</span>))\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (x <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Promise</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (x.status === <span class=\"hljs-string\">'pending'</span>) { \n</div></li><li><div class=\"code-word\">      x.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) </span>{\n</div></li><li><div class=\"code-word\">        resolvePromise(promise2, v, resolve, reject)\n</div></li><li><div class=\"code-word\">      }, reject)\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      x.then(resolve, reject)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> ((x !== <span class=\"hljs-literal\">null</span>) &amp;&amp; ((<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'object'</span>) || (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'function'</span>))) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">      then = x.then\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> then === <span class=\"hljs-string\">'function'</span>) {\n</div></li><li><div class=\"code-word\">        then.call(x, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rs</span>(<span class=\"hljs-params\">y</span>) </span>{\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (thenCalledOrThrow) <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">          thenCalledOrThrow = <span class=\"hljs-literal\">true</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> resolvePromise(promise2, y, resolve, reject)\n</div></li><li><div class=\"code-word\">        }, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rj</span>(<span class=\"hljs-params\">r</span>) </span>{\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (thenCalledOrThrow) <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">          thenCalledOrThrow = <span class=\"hljs-literal\">true</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> reject(r)\n</div></li><li><div class=\"code-word\">        })\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        resolve(x)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (thenCalledOrThrow) <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">      thenCalledOrThrow = <span class=\"hljs-literal\">true</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> reject(e)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    resolve(x)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onResolved, onRejected</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> promise2\n</div></li><li><div class=\"code-word\">  onResolved = <span class=\"hljs-keyword\">typeof</span> onResolved === <span class=\"hljs-string\">'function'</span> ? onResolved : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> v\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  onRejected = <span class=\"hljs-keyword\">typeof</span> onRejected === <span class=\"hljs-string\">'function'</span> ? onRejected : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">r</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">throw</span> r\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'resolved'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">      setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">// 异步执行onResolved</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">var</span> x = onResolved(self.data)\n</div></li><li><div class=\"code-word\">          resolvePromise(promise2, x, resolve, reject)\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span> (reason) {\n</div></li><li><div class=\"code-word\">          reject(reason)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'rejected'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">      setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">// 异步执行onRejected</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">var</span> x = onRejected(self.data)\n</div></li><li><div class=\"code-word\">          resolvePromise(promise2, x, resolve, reject)\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span> (reason) {\n</div></li><li><div class=\"code-word\">          reject(reason)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (self.status === <span class=\"hljs-string\">'pending'</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">      self.onResolvedCallback.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">var</span> x = onResolved(value)\n</div></li><li><div class=\"code-word\">          resolvePromise(promise2, x, resolve, reject)\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span> (r) {\n</div></li><li><div class=\"code-word\">          reject(r)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">      self.onRejectedCallback.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>) </span>{\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">var</span> x = onRejected(reason)\n</div></li><li><div class=\"code-word\">            resolvePromise(promise2, x, resolve, reject)\n</div></li><li><div class=\"code-word\">          } <span class=\"hljs-keyword\">catch</span> (r) {\n</div></li><li><div class=\"code-word\">            reject(r)\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        })\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.prototype.catch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onRejected</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.then(<span class=\"hljs-literal\">null</span>, onRejected)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 最后这个是测试用的，后面会说</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.deferred = <span class=\"hljs-built_in\">Promise</span>.defer = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> dfd = {}\n</div></li><li><div class=\"code-word\">  dfd.promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">    dfd.resolve = resolve\n</div></li><li><div class=\"code-word\">    dfd.reject = reject\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> dfd\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38772\">\n                      上面这段代码就是通过一步步优化调整出来的最终版，其中细节也是比较多的，介于篇幅问题，暂时能讲的点就先说这么多。如果你还有哪里不清楚的，最好还是动手实践去理解。\n                    </p>\n                    <p data-nodeid=\"38773\">\n                      最终版的 Promise 的实现还是需要经过规范的测试（Promise /A+\n                      规范测试的工具地址为：<a\n                        href=\"https://github.com/promises-aplus/promises-tests\"\n                        data-nodeid=\"38890\"\n                        >https://github.com/promises-aplus/promises-tests</a\n                      >），需要暴露一个 deferred 方法（即 exports.deferred\n                      方法），上面提供的代码中我已经将其加了进去。\n                    </p>\n                    <p data-nodeid=\"38774\">\n                      最后，执行如下代码 npm 安装之后，即可执行测试。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">npm i -g promises-aplus-tests\n</div></li><li><div class=\"code-word\">promises-aplus-tests Promise.js\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"38776\">总结</h3>\n                    <p data-nodeid=\"39758\" class=\"te-preview-highlight\">\n                      讲到这里，你可以再思考一下 Promise /A+\n                      规范中的一些细节，以及实现过程中需要注意的问题，如果你能够在面试中实现一个这样的\n                      Promise，就基本可以满足岗位的需求了。\n                    </p>\n\n                    <p data-nodeid=\"38778\">\n                      通过这一讲的学习，你应该能理解 Promise\n                      底层的实现逻辑了，虽然并不一定有场景适合落地业务，但是整个手动实现的过程对于你\n                      JS 编码能力的提升会很有帮助。\n                    </p>\n                    <p data-nodeid=\"38779\">\n                      关于 Promise 还有很多 API 的方法，在已经实现的 Promise\n                      的版本之上，你可以再尝试实现 all、race 以及 any\n                      等方法，学会举一反三，才能在工作中游刃有余。\n                    </p>\n                    <p data-nodeid=\"38780\">\n                      下一讲开始，我们就要进入一个新的模块——JS\n                      引擎篇，我要带你了解 JS\n                      引擎中的垃圾回收机制、事件轮询等，这对于写出高性能的\n                      JavaScript 代码有着很好的帮助。\n                    </p>\n                    <p data-nodeid=\"38781\">我们到时见。</p>\n            "}