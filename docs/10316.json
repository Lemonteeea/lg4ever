{"title":"15 | ReactDOM.render 是如何串联渲染链路的？（下）","context":"\n                    <p data-nodeid=\"1653\" class=\"\">\n                      在上一讲我们从 beginWork 切入，摸索出了 Fiber\n                      节点的创建链路与 Fiber 树的构建链路。本讲我们将以\n                      completeWork 为线索，去寻觅 Fiber 树和 DOM\n                      树之间的关联，将整个 render 阶段讲透。在此基础上，结合\n                      commit 阶段工作流，你将会对 ReactDOM.render\n                      所触发的渲染链路有一个完整、通透的理解。\n                    </p>\n                    <p data-nodeid=\"1654\">\n                      本讲的实验 Demo 与前两讲保持一致，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React from \"react\";\n</div></li><li><div class=\"code-word\">import ReactDOM from \"react-dom\";\n</div></li><li><div class=\"code-word\">function App() {\n</div></li><li><div class=\"code-word\">  return (\n</div></li><li><div class=\"code-word\">    &lt;div className=\"App\"&gt;\n</div></li><li><div class=\"code-word\">      &lt;div className=\"container\"&gt;\n</div></li><li><div class=\"code-word\">        &lt;h1&gt;我是标题&lt;/h1&gt;\n</div></li><li><div class=\"code-word\">        &lt;p&gt;我是第一段话&lt;/p&gt;\n</div></li><li><div class=\"code-word\">        &lt;p&gt;我是第二段话&lt;/p&gt;\n</div></li><li><div class=\"code-word\">      &lt;/div&gt;\n</div></li><li><div class=\"code-word\">    &lt;/div&gt;\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">const rootElement = document.getElementById(\"root\");\n</div></li><li><div class=\"code-word\">ReactDOM.render(&lt;App /&gt;, rootElement);\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"1656\">\n                      completeWork——将 Fiber 节点映射为 DOM 节点\n                    </h3>\n                    <h4 data-nodeid=\"1657\">completeWork 的调用时机</h4>\n                    <p data-nodeid=\"1658\">\n                      首先，我们先在调用栈中定位一下 completeWork。Demo\n                      所对应的调用栈中，第一个 completeWork\n                      出现在下图红框选中的位置：\n                    </p>\n                    <p data-nodeid=\"1659\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/1B/CgqCHl_AsdSAQuGuAAC09U5X0K0556.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"1787\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1660\">\n                      从图上我们需要把握住的一个信息是，从 performUnitOfWork 到\n                      completeWork，中间会经过一个这样的调用链路：\n                    </p>\n                    <p data-nodeid=\"1661\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2PuADu50AABVUspw4O0014.png\"\n                        alt=\"图片10.png\"\n                        data-nodeid=\"1791\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1662\">\n                      其中 completeUnitOfWork 的工作也非常关键，但眼下我们先拿\n                      completeWork 开刀，你可以暂时将 completeUnitOfWork\n                      简单理解为一个用于发起 completeWork\n                      调用的“工具人”。completeUnitOfWork 是在 performUnitOfWork\n                      中被调用的，那么 performUnitOfWork\n                      是如何把握其调用时机的呢？我们直接来看相关源码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">performUnitOfWork</span><span class=\"hljs-params\">(unitOfWork)</span> </span>{\n</div></li><li><div class=\"code-word\">  ......\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取入参节点对应的 current 节点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> current = unitOfWork.alternate;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> next;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (xxx) {\n</div></li><li><div class=\"code-word\">    ...\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 创建当前节点的子节点</span>\n</div></li><li><div class=\"code-word\">    next = beginWork$<span class=\"hljs-number\">1</span>(current, unitOfWork, subtreeRenderLanes);\n</div></li><li><div class=\"code-word\">    ...\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 创建当前节点的子节点</span>\n</div></li><li><div class=\"code-word\">    next = beginWork$<span class=\"hljs-number\">1</span>(current, unitOfWork, subtreeRenderLanes);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  ......\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (next === <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 调用 completeUnitOfWork</span>\n</div></li><li><div class=\"code-word\">    completeUnitOfWork(unitOfWork);\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将当前节点更新为新创建出的 Fiber 节点</span>\n</div></li><li><div class=\"code-word\">    workInProgress = next;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  ......\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1664\">\n                      这段源码中你需要提取出的信息是：performUnitOfWork\n                      每次会尝试调用 beginWork\n                      来创建当前节点的子节点，若创建出的子节点为空（也就意味着当前节点不存在子\n                      Fiber 节点），则说明当前节点是一个叶子节点。<strong\n                        data-nodeid=\"1798\"\n                        >按照深度优先遍历的原则，当遍历到叶子节点时，“递”阶段就结束了，随之而来的是“归”的过程</strong\n                      >。因此这种情况下，就会调用\n                      completeUnitOfWork，执行当前节点对应的 completeWork 逻辑。\n                    </p>\n                    <p data-nodeid=\"1665\">\n                      接下来我们在 Demo 代码的 completeWork\n                      处打上断点，看看第一个走到 completeWork\n                      的节点是哪个，结果如下图所示：\n                    </p>\n                    <p data-nodeid=\"1666\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_AseOADKNDAALdERWik0M525.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"1802\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1667\">\n                      显然，第一个进入 completeWork 的节点是\n                      h1，这也符合我们上一讲所构建出来的 Fiber\n                      树中的节点关系，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1668\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/1B/CgqCHl_AsgSAJoM0AAEYVWI-PXg056.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1806\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1669\">\n                      由图可知，按照深度优先遍历的原则，h1\n                      确实将是第一个被遍历到的叶子节点。接下来我们就以 h1\n                      为例，一起看看 completeWork 都围绕它做了哪些事情。\n                    </p>\n                    <h4 data-nodeid=\"1670\">completeWork 的工作原理</h4>\n                    <p data-nodeid=\"1671\">\n                      这里仍然为你提取一下 completeWork\n                      的源码结构和主体逻辑，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">completeWork</span><span class=\"hljs-params\">(current, workInProgress, renderLanes)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 取出 Fiber 节点的属性值，存储在 newProps 里</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> newProps = workInProgress.pendingProps;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 根据 workInProgress 节点的 tag 属性的不同，决定要进入哪段逻辑</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">switch</span> (workInProgress.tag) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> ......:\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> ClassComponent:\n</div></li><li><div class=\"code-word\">      {\n</div></li><li><div class=\"code-word\">        .....\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> HostRoot:\n</div></li><li><div class=\"code-word\">      {\n</div></li><li><div class=\"code-word\">        ......\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// h1 节点的类型属于 HostComponent，因此这里为你讲解的是这段逻辑</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> HostComponent:\n</div></li><li><div class=\"code-word\">      {\n</div></li><li><div class=\"code-word\">        popHostContext(workInProgress);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> rootContainerInstance = getRootHostContainer();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> type = workInProgress.type;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 判断 current 节点是否存在，因为目前是挂载阶段，因此 current 节点是不存在的</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (current !== <span class=\"hljs-keyword\">null</span> &amp;&amp; workInProgress.stateNode != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">          updateHostComponent$<span class=\"hljs-number\">1</span>(current, workInProgress, type, newProps, rootContainerInstance);\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (current.ref !== workInProgress.ref) {\n</div></li><li><div class=\"code-word\">            markRef$<span class=\"hljs-number\">1</span>(workInProgress);\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 这里首先是针对异常情况进行 return 处理</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (!newProps) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (!(workInProgress.stateNode !== <span class=\"hljs-keyword\">null</span>)) {\n</div></li><li><div class=\"code-word\">              {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">throw</span> Error(<span class=\"hljs-string\">\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\"</span>);\n</div></li><li><div class=\"code-word\">              }\n</div></li><li><div class=\"code-word\">            } \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 接下来就为 DOM 节点的创建做准备了</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">var</span> currentHostContext = getHostContext();\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// _wasHydrated 是一个与服务端渲染有关的值，这里不用关注</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">var</span> _wasHydrated = popHydrationState(workInProgress);\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 判断是否是服务端渲染</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (_wasHydrated) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 这里不用关注，请你关注 else 里面的逻辑</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n</div></li><li><div class=\"code-word\">              markUpdate(workInProgress);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">          } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 这一步很关键， createInstance 的作用是创建 DOM 节点</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">var</span> instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// appendAllChildren 会尝试把上一步创建好的 DOM 节点挂载到 DOM 树上去</span>\n</div></li><li><div class=\"code-word\">            appendAllChildren(instance, workInProgress, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">false</span>);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// stateNode 用于存储当前 Fiber 节点对应的 DOM 节点</span>\n</div></li><li><div class=\"code-word\">            workInProgress.stateNode = instance; \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// finalizeInitialChildren 用来为 DOM 节点设置属性</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {\n</div></li><li><div class=\"code-word\">              markUpdate(workInProgress);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">          ......\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> HostText:\n</div></li><li><div class=\"code-word\">      {\n</div></li><li><div class=\"code-word\">        ......\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> SuspenseComponent:\n</div></li><li><div class=\"code-word\">      {\n</div></li><li><div class=\"code-word\">        ......\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> HostPortal:\n</div></li><li><div class=\"code-word\">      ......\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">case</span> ContextProvider:\n</div></li><li><div class=\"code-word\">      ......\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    ......\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">throw</span> Error(<span class=\"hljs-string\">\"Unknown unit of work tag (\"</span> + workInProgress.tag + <span class=\"hljs-string\">\"). This error is likely caused by a bug in React. Please file an issue.\"</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1673\">\n                      试图捋顺这段 completeWork 逻辑，你需要掌握以下几个要点。\n                    </p>\n                    <ol data-nodeid=\"1674\">\n                      <li data-nodeid=\"1675\">\n                        <p data-nodeid=\"1676\">\n                          completeWork 的核心逻辑是一段体量巨大的 switch\n                          语句，在这段 switch 语句中，<strong data-nodeid=\"1816\"\n                            >completeWork 将根据 workInProgress 节点的 tag\n                            属性的不同，进入不同的 DOM\n                            节点的创建、处理逻辑</strong\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1677\">\n                        <p data-nodeid=\"1678\">\n                          在 Demo 示例中，h1 节点的 tag 属性对应的类型应该是\n                          HostComponent，也就是“原生 DOM 元素类型”。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1679\">\n                        <p data-nodeid=\"1680\">\n                          completeWork 中的 current、 workInProgress\n                          分别对应的是下图中左右两棵 Fiber 树上的节点：\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1681\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2R-AWalhAAD-42SivEU001.png\"\n                        alt=\"图片12.png\"\n                        data-nodeid=\"1821\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1682\">\n                      其中 workInProgress 树代表的是“当前正在 render 中的树”，而\n                      current 树则代表“已经存在的树”。\n                    </p>\n                    <p data-nodeid=\"1683\">\n                      workInProgress 节点和 current 节点之间用 alternate\n                      属性相互连接。在组件的挂载阶段，current 树只有一个\n                      rootFiber 节点，并没有其他内容。因此 h1 这个\n                      workInProgress 节点对应的 current 节点是 null。\n                    </p>\n                    <p data-nodeid=\"1684\">\n                      带着上面这些前提，再去结合注释读一遍上面提炼出来的源码，思路是不是就清晰多了？\n                    </p>\n                    <p data-nodeid=\"1685\">\n                      捋顺思路后，我们直接来提取知识点。关于\n                      completeWork，你需要明白以下几件事。\n                    </p>\n                    <p data-nodeid=\"1686\">\n                      （1）用一句话来总结 completeWork 的工作内容：<strong\n                        data-nodeid=\"1831\"\n                        >负责处理 Fiber 节点到 DOM 节点的映射逻辑</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1687\">\n                      （2）completeWork 内部有 3 个关键动作：\n                    </p>\n                    <ul data-nodeid=\"1688\">\n                      <li data-nodeid=\"1689\">\n                        <p data-nodeid=\"1690\">\n                          <strong data-nodeid=\"1837\">创建</strong>DOM\n                          节点（CreateInstance）\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1691\">\n                        <p data-nodeid=\"1692\">\n                          将 DOM 节点<strong data-nodeid=\"1843\">插入</strong>到\n                          DOM 树中（AppendAllChildren）\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1693\">\n                        <p data-nodeid=\"1694\">\n                          为 DOM 节点<strong data-nodeid=\"1849\">设置属性</strong\n                          >（FinalizeInitialChildren）\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1695\">\n                      （3）<strong data-nodeid=\"1855\"\n                        >创建好的 DOM 节点会被赋值给 workInProgress 节点的\n                        stateNode 属性</strong\n                      >。也就是说当我们想要定位一个 Fiber 对应的 DOM\n                      节点时，访问它的 stateNode\n                      属性就可以了。这里我们可以尝试访问运行时的 h1 节点的\n                      stateNode 属性，结果如下图所示：\n                    </p>\n                    <p data-nodeid=\"1696\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_Ash-AW32XAABIXg8drFo176.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"1858\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1697\">\n                      （4）将 DOM 节点插入到 DOM 树的操作是通过\n                      appendAllChildren 函数来完成的。\n                    </p>\n                    <p data-nodeid=\"1698\">\n                      说是将 DOM 节点插入到 DOM 树里去，实际上是将<strong\n                        data-nodeid=\"1869\"\n                        >子 Fiber 节点所对应的 DOM 节点</strong\n                      >挂载到其<strong data-nodeid=\"1870\"\n                        >父 Fiber 节点所对应的 DOM 节点里去</strong\n                      >。比如说在本讲 Demo 所构建出的 Fiber 树中，h1\n                      节点的父结点是 div，那么 h1 对应的 DOM 节点就理应被挂载到\n                      div 对应的 DOM 节点里去。\n                    </p>\n                    <p data-nodeid=\"1699\">\n                      那么如果执行 appendAllChildren 时，父级的 DOM\n                      节点还不存在怎么办？\n                    </p>\n                    <p data-nodeid=\"1700\">\n                      比如 h1 节点作为第一个进入 completeWork 的节点，它的父节点\n                      div 对应的 DOM 就尚不存在。其实不存在也没关系，反正 h1 DOM\n                      节点被创建后，会作为 h1 Fiber 节点的 stateNode\n                      属性存在，丢不掉的。当父节点 div 进入 appendAllChildren\n                      逻辑后，会逐个向下查找并添加自己的后代节点，这时候，h1\n                      就会被它的父级 DOM 节点“收入囊中”啦~\n                    </p>\n                    <h3 data-nodeid=\"1701\">\n                      completeUnitOfWork —— 开启收集 EffectList 的“大循环”\n                    </h3>\n                    <p data-nodeid=\"1702\">\n                      completeUnitOfWork\n                      的作用是开启一个大循环，在这个大循环中，将会重复地做下面三件事：\n                    </p>\n                    <ol data-nodeid=\"1703\">\n                      <li data-nodeid=\"1704\">\n                        <p data-nodeid=\"1705\">\n                          <strong data-nodeid=\"1880\"\n                            >针对传入的当前节点，调用 completeWork</strong\n                          >，completeWork\n                          的工作内容前面已经讲过，这一步应该是没有异议的；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1706\">\n                        <p data-nodeid=\"1707\">\n                          将<strong data-nodeid=\"1890\"\n                            >当前节点的副作用链</strong\n                          >（EffectList）插入到其<strong data-nodeid=\"1891\"\n                            >父节点对应的副作用链</strong\n                          >（EffectList）中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1708\">\n                        <p data-nodeid=\"1709\">\n                          以当前节点为起点，循环遍历其兄弟节点及其父节点。当遍历到兄弟节点时，将\n                          return 掉当前调用，触发兄弟节点对应的\n                          performUnitOfWork\n                          逻辑；而遍历到父节点时，则会直接进入下一轮循环，也就是重复\n                          1、2 的逻辑。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1710\">\n                      步骤 1 无须多言，接下来我将为你解读步骤 2 和步骤 3\n                      的含义。\n                    </p>\n                    <h4 data-nodeid=\"1711\">\n                      completeUnitOfWork 开启下一轮循环的原则\n                    </h4>\n                    <p data-nodeid=\"1712\">\n                      在理解副作用链之前，首先要理解 completeUnitOfWork\n                      开启下一轮循环的原则，也就是步骤 3。步骤 3\n                      相关的源码如下所示（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">do</span> {\n</div></li><li><div class=\"code-word\">  ......\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里省略步骤 1 和步骤 2 的逻辑 </span>\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取当前节点的兄弟节点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> siblingFiber = completedWork.sibling;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 若兄弟节点存在</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (siblingFiber !== <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将 workInProgress 赋值为当前节点的兄弟节点</span>\n</div></li><li><div class=\"code-word\">    workInProgress = siblingFiber;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将正在进行的 completeUnitOfWork 逻辑 return 掉</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 若兄弟节点不存在，completeWork 会被赋值为 returnFiber，也就是当前节点的父节点</span>\n</div></li><li><div class=\"code-word\">  completedWork = returnFiber; \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这一步与上一步是相辅相成的，上下文中要求 workInProgress 与 completedWork 保持一致</span>\n</div></li><li><div class=\"code-word\">  workInProgress = completedWork;\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">while</span> (completedWork !== <span class=\"hljs-keyword\">null</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1714\">\n                      步骤 3\n                      是整个循环体的收尾工作，它会在当前节点相关的各种工作都做完之后执行。\n                    </p>\n                    <p data-nodeid=\"1715\">\n                      当前节点处理完了，自然是去寻找下一个可以处理的节点。我们知道，当前的\n                      Fiber 节点之所以会进入\n                      completeWork，是因为“递无可递”了，才会进入“归”的逻辑，这就意味着当前\n                      Fiber 要么没有 child 节点、要么 child 节点的 completeWork\n                      早就执行过了。因此 child\n                      节点不会是下次循环需要考虑的对象，下次循环只需要考虑兄弟节点（siblingFiber）和父节点（returnFiber）。\n                    </p>\n                    <p data-nodeid=\"1716\">\n                      那么为什么在源码中，遇到兄弟节点会\n                      return，遇到父节点才会进入下次循环呢？这里我以 h1\n                      节点的节点关系为例进行说明。请看下图：\n                    </p>\n                    <p data-nodeid=\"1717\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2UCAeC8WAAByZUWVwpM770.png\"\n                        alt=\"图片8.png\"\n                        data-nodeid=\"1901\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1718\">\n                      结合前面的分析和图示可知，<strong data-nodeid=\"1907\"\n                        >h1\n                        节点是递归过程中所触及的第一个叶子节点，也是其兄弟节点中被遍历到的第一个节点</strong\n                      >；而剩下的两个 p 节点，此时都还没有被遍历到，也就是说连\n                      beginWork 都没有执行过。\n                    </p>\n                    <p data-nodeid=\"1719\">\n                      <strong data-nodeid=\"1912\"\n                        >因此对于 h1 节点的兄弟节点来说，当下的第一要务是回去从\n                        beginWork 开始走起，直到 beginWork\n                        “递无可递”时，才能够执行 completeWork 的逻辑</strong\n                      >。beginWork 的调用是在 performUnitOfWork 里发生的，因此\n                      completeUnitOfWork\n                      一旦识别到当前节点的兄弟节点不为空，就会终止后续的逻辑，退回到上一层的\n                      performUnitOfWork 里去。\n                    </p>\n                    <p data-nodeid=\"1720\">\n                      接下来我们再来看 h1 的父节点 div：在向下递归到 h1\n                      的过程中，div 必定已经被遍历过了，也就是说 div\n                      的“递”阶段（ beginWork）\n                      已经执行完毕，只剩下“归”阶段的工作要处理了。因此，对于父节点，completeUnitOfWork\n                      会毫不犹豫地把它推到下一次循环里去，让它进入 completeWork\n                      的逻辑。\n                    </p>\n                    <p data-nodeid=\"1721\">\n                      值得注意的是，completeUnitOfWork\n                      中处理兄弟节点和父节点的顺序是：先检查兄弟节点是否存在，若存在则优先处理兄弟节点；确认没有待处理的兄弟节点后，才转而处理父节点。这也就意味着，<strong\n                        data-nodeid=\"1919\"\n                        >completeWork 的执行是严格自底向上的</strong\n                      >，子节点的 completeWork 总会先于父节点执行。\n                    </p>\n                    <h4 data-nodeid=\"1722\">\n                      副作用链（effectList）的设计与实现\n                    </h4>\n                    <p data-nodeid=\"1723\">\n                      无论是 beginWork 还是 completeWork，它们的应用对象都是\n                      workInProgress 树上的节点。我们说 render\n                      阶段是一个递归的过程，“递归”的对象，正是这棵\n                      workInProgress 树（见下图右侧高亮部分）：\n                    </p>\n                    <p data-nodeid=\"1724\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2VCAHbHdAAEBwCIJFE4253.png\"\n                        alt=\"图片13.png\"\n                        data-nodeid=\"1924\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1725\">\n                      那么我们递归的目的是什么呢？或者说，render\n                      阶段的工作目标是什么呢？\n                    </p>\n                    <p data-nodeid=\"1726\">\n                      <strong data-nodeid=\"1930\"\n                        >render 阶段的工作目标是找出界面中需要处理的更新</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1727\">\n                      在实际的操作中，并不是所有的节点上都会产生需要处理的更新。比如在挂载阶段，对图中的整棵\n                      workInProgress 递归完毕后，React 会发现实际只需要对 App\n                      节点执行一个挂载操作就可以了；而在更新阶段，这种现象更为明显。\n                    </p>\n                    <p data-nodeid=\"1728\">\n                      更新阶段与挂载阶段的主要区别在于更新阶段的 current\n                      树不为空，比如说情况可以是下图这样子的：\n                    </p>\n                    <p data-nodeid=\"1729\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2VyAUxeJAAIrypFDLh4388.png\"\n                        alt=\"图片14.png\"\n                        data-nodeid=\"1935\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1730\">\n                      假如说我的某一次操作，仅仅对 p\n                      节点产生了影响，那么对于渲染器来说，它理应只关注 p\n                      节点这一处的更新。这时候问题就来了：<strong\n                        data-nodeid=\"1941\"\n                        >怎样做才能让渲染器又快又好地定位到那些真正需要更新的节点呢</strong\n                      >？\n                    </p>\n                    <p data-nodeid=\"7897\" class=\"\">\n                      在 render 阶段，我们通过艰难的递归过程来明确“p\n                      节点这里有一处更新”这件事情。按照 React 的设计思路，render\n                      阶段结束后，“找不同”这件事情其实也就告一段落了。<strong\n                        data-nodeid=\"7911\"\n                        >commit 只负责实现更新，而不负责寻找更新</strong\n                      >，这就意味着我们必须找到一个办法能让 commit\n                      阶段“坐享其成”，能直接拿到 render\n                      阶段的工作成果。而这，正是<strong data-nodeid=\"7912\"\n                        >副作用链</strong\n                      >（<strong data-nodeid=\"7913\">effectList</strong\n                      >）的价值所在。\n                    </p>\n\n                    <p data-nodeid=\"1732\" class=\"te-preview-highlight\">\n                      <strong data-nodeid=\"1958\">副作用链（effectList）</strong>\n                      可以理解为 render 阶段“工作成果”的一个集合：每个 Fiber\n                      节点都维护着一个属于它自己的 effectList，effectList\n                      在数据结构上以链表的形式存在，链表内的每一个元素都是一个\n                      Fiber 节点。这些 Fiber 节点需要满足两个共性：\n                    </p>\n                    <ol data-nodeid=\"1733\">\n                      <li data-nodeid=\"1734\">\n                        <p data-nodeid=\"1735\">都是当前 Fiber 节点的后代节点</p>\n                      </li>\n                      <li data-nodeid=\"1736\">\n                        <p data-nodeid=\"1737\">都有待处理的副作用</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1738\">\n                      没错，Fiber 节点的 effectList\n                      里记录的并非它自身的更新，而是其<strong data-nodeid=\"1966\"\n                        >需要更新的后代节点</strong\n                      >。带着这个结论，我们再来品品小节开头 completeUnitOfWork\n                      中的“步骤 2”：\n                    </p>\n                    <blockquote data-nodeid=\"1739\">\n                      <p data-nodeid=\"1740\">\n                        将<strong data-nodeid=\"1976\">当前节点的副作用链</strong\n                        >（effectList）插入到其<strong data-nodeid=\"1977\"\n                          >父节点对应的副作用链</strong\n                        >（effectList）中。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1741\">\n                      咱们前面已经分析过，“<strong data-nodeid=\"1987\"\n                        >completeWork 是自底向上执行的</strong\n                      >”，也就是说，子节点的 completeWork\n                      总是比父节点先执行。试想，若每次处理到一个节点，都将当前节点的\n                      effectList 插入到其父节点的 effectList\n                      中。那么当所有节点的 completeWork\n                      都执行完毕时，我是不是就可以从“终极父节点”，也就是\n                      rootFiber 上，拿到一个<strong data-nodeid=\"1988\"\n                        >存储了当前 Fiber 树所有 effect Fiber</strong\n                      >的“终极版”的 effectList 了？\n                    </p>\n                    <p data-nodeid=\"1742\">\n                      <strong data-nodeid=\"1993\"\n                        >把所有需要更新的 Fiber\n                        节点单独串成一串链表，方便后续有针对性地对它们进行更新，这就是所谓的“收集副作用”的过程</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1743\">\n                      这里我以挂载过程为例，带你分析一下这个过程是如何实现的。\n                    </p>\n                    <p data-nodeid=\"1744\">\n                      首先我们要知道的是，这个 effectList 链表在 Fiber\n                      节点中是通过 firstEffect 和 lastEffect\n                      来维护的，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1745\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/1C/CgqCHl_AspmALRFDAADaKY8wTqc180.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"1998\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1746\">\n                      其中 firstEffect 表示 effectList 的第一个节点，而\n                      lastEffect 则记录最后一个节点。\n                    </p>\n                    <p data-nodeid=\"1747\">\n                      对于挂载过程来说，我们唯一要做的就是把 App\n                      组件挂载到界面上去，因此 App 后代节点们的\n                      effectList&nbsp;其实都是不存在的。effectList 只有在 App\n                      的父节点（rootFiber）这才不为空。\n                    </p>\n                    <p data-nodeid=\"1748\">\n                      那么 effectList\n                      的创建逻辑又是怎样的呢？其实非常简单，只需要为 firstEffect\n                      和 lastEffect 各赋值一个引用即可。以下是从\n                      completeUnitOfWork\n                      源码中提取出的相关逻辑（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 若副作用类型的值大于“PerformedWork”，则说明这里存在一个需要记录的副作用</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (flags &gt; PerformedWork) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// returnFiber 是当前节点的父节点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (returnFiber.lastEffect !== <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 若父节点的 effectList 不为空，则将当前节点追加到 effectList 的末尾去</span>\n</div></li><li><div class=\"code-word\">    returnFiber.lastEffect.nextEffect = completedWork;\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 若父节点的 effectList 为空，则当前节点就是 effectList 的 firstEffect</span>\n</div></li><li><div class=\"code-word\">    returnFiber.firstEffect = completedWork;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 将 effectList 的 lastEffect 指针后移一位</span>\n</div></li><li><div class=\"code-word\">  returnFiber.lastEffect = completedWork;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1750\">\n                      代码中的 flags\n                      咱们已经反复强调过了，它旧时的名字叫“effectTag”，是用来标识副作用类型的；而“completedWork”这个变量，在当前上下文中存储的就是“正在被执行\n                      completeWork\n                      相关逻辑”的节点；至于“PerformedWork”，它是一个值为 1\n                      的常量，React 规定若 flags（又名 effectTag）的值小于等于\n                      1，则不必提交到 commit 阶段。因此 completeUnitOfWork\n                      只会对 flags 大于 PerformedWork 的 effect fiber 进行收集。\n                    </p>\n                    <p data-nodeid=\"1751\">\n                      结合这些信息，再去读一遍源码片段，相信你的理解过程就会很流畅了。这里我以\n                      App 节点为例，带你走一遍 effectList 的创建过程：\n                    </p>\n                    <ol data-nodeid=\"1752\">\n                      <li data-nodeid=\"1753\">\n                        <p data-nodeid=\"1754\">\n                          App FiberNode 的 flags 属性为 3，大于\n                          PerformedWork，因此会进入 effectList 的创建逻辑；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1755\">\n                        <p data-nodeid=\"1756\">\n                          创建 effectList 时，并不是为当前 Fiber\n                          节点创建，而是为它的父节点创建，App 节点的父节点是\n                          rootFiber，rootFiber 的 effectList 此时为空；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1757\">\n                        <p data-nodeid=\"1758\">\n                          rootFiber 的 firstEffect 和 lastEffect 指针都会指向\n                          App 节点，App 节点由此成为 effectList 中的唯一一个\n                          FiberNode，如下图所示。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1759\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/1E/Ciqc1F_A2W-AVmmRAABDdji0MoI238.png\"\n                        alt=\"图片15.png\"\n                        data-nodeid=\"2009\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1760\">\n                      OK，读到这里，相信你已经对 effectList\n                      的创建过程知根知底了。\n                    </p>\n                    <p data-nodeid=\"1761\">\n                      现在，即便你对部分源码细节的消化可能没有那么快，也请你不要因为这些细节去中断自己串联整个渲染链路的思路。你只需要把握住“根节点（rootFiber）上的\n                      effectList 信息，是 commit\n                      阶段的更新线索”这个结论，就足以将 render 阶段和 commit\n                      阶段串联起来。\n                    </p>\n                    <h3 data-nodeid=\"1762\">commit 阶段工作流简析</h3>\n                    <p data-nodeid=\"1763\">\n                      在整个 ReactDOM.render 的渲染链路中，render 阶段是 Fiber\n                      架构的核心体现，也是我们讲解的重点。对于 render\n                      阶段，我对你的期望是“熟悉”，为了达成这个目标，我们对\n                      render 阶段的学习还会再持续一个课时；而对于 commit\n                      阶段，我只要求你做到“了解”。因此这里我会快速地带你过一遍\n                      commit 阶段的重点知识，不占用你太多时间。\n                    </p>\n                    <p data-nodeid=\"1764\">\n                      commit 会在 performSyncWorkOnRoot 中被调用，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1765\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_AsqiAENXWAAF6r2_37Lc521.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"2017\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1766\">\n                      这里的入参 root 并不是 rootFiber，而是\n                      fiberRoot（FiberRootNode）实例。fiberRoot 的 current\n                      节点指向 rootFiber，因此拿到 effectList 对后续的 commit\n                      流程来说不是什么难事。\n                    </p>\n                    <p data-nodeid=\"1767\">\n                      从流程上来说，commit 共分为 3 个阶段：<strong\n                        data-nodeid=\"2023\"\n                        >before mutation、mutation、layout。</strong\n                      >\n                    </p>\n                    <ul data-nodeid=\"1768\">\n                      <li data-nodeid=\"1769\">\n                        <p data-nodeid=\"1770\">\n                          before mutation 阶段，<strong data-nodeid=\"2029\"\n                            >这个阶段 DOM 节点还没有被渲染到界面上去</strong\n                          >，过程中会触发 getSnapshotBeforeUpdate，也会处理\n                          useEffect 钩子相关的调度逻辑。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1771\">\n                        <p data-nodeid=\"1772\">\n                          mutation，<strong data-nodeid=\"2035\"\n                            >这个阶段负责 DOM 节点的渲染</strong\n                          >。在渲染过程中，会遍历 effectList，根据\n                          flags（effectTag）的不同，执行不同的 DOM 操作。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1773\">\n                        <p data-nodeid=\"1774\">\n                          layout，<strong data-nodeid=\"2045\"\n                            >这个阶段处理 DOM 渲染完毕之后的收尾逻辑</strong\n                          >。比如调用 componentDidMount/componentDidUpdate，调用\n                          useLayoutEffect\n                          钩子函数的回调等。除了这些之外，它还会<strong\n                            data-nodeid=\"2046\"\n                            >把 fiberRoot 的 current 指针指向 workInProgress\n                            Fiber 树</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1775\">\n                      关于 commit 阶段的实现细节，感兴趣的同学课下可以参阅\n                      <a\n                        href=\"https://github.com/facebook/react/blob/a81c02ac150233bdb5f31380d4135397fb8f4660/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\"\n                        data-nodeid=\"2050\"\n                        >commit 相关源码</a\n                      >，这里不再展开讨论。对于\n                      commit，如果你只能记住一个知识点，我希望你记住<strong\n                        data-nodeid=\"2056\"\n                        >它是一个绝对同步的过程</strong\n                      >。render 阶段可以同步也可以异步，但 commit 一定是同步的。\n                    </p>\n                    <h3 data-nodeid=\"1776\" class=\"\">总结</h3>\n                    <p data-nodeid=\"1777\">\n                      这一讲我们完成了对 ReactDOM.render\n                      调用栈的分析。表面上剖析的是首次渲染的渲染链路，实际上将包括同步模式下的挂载、更新链路（与挂载链路的调用栈非常相似）都串联了一遍。\n                    </p>\n                    <p data-nodeid=\"1778\">\n                      虽然还没有正式介入更新链路、包括异步更新模式的讲解，但你此时其实已经具备了理解这些知识的基础：Concurrent\n                      模式（异步渲染）与 Legacy\n                      模式（同步渲染）在数据结构设计、核心 API\n                      调用等方面都是一致的。<strong data-nodeid=\"2064\"\n                        >这也就意味着我们这三讲所讲解的知识，都是可以在后续的学习中复用的</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1779\" class=\"\">\n                      接下来，我们就将进入更新过程的学习，揭开 Concurrent 模式及\n                      Scheduler\n                      的神秘面纱。同时，针对上一讲遗留下来的“为什么需要两棵树”的问题，我也会在下一讲中为你解答。\n                    </p>\n            "}