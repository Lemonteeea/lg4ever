{"title":"加餐 | 课后练习题详解","context":"\n                    <p data-nodeid=\"57879\" class=\"\">\n                      专栏虽已结束，但学习不应停止。我看到很多同学依然还在这里学习，一部分同学积极地在留言区和大家分享学习总结和练习题答案。\n                    </p>\n                    <p data-nodeid=\"57880\">\n                      我几乎在每个课时的结尾都留下了一道练习题，目的是帮助你检测和巩固本课时的重点内容，抑或是引出后续课时中的内容。在我处理留言的过程中，发现很多同学想要练习题详细解答过程以及答案，所以就有了今天的这一篇加餐内容，希望对你有所帮助。\n                    </p>\n                    <p data-nodeid=\"57881\">\n                      接下来我会给出每个课时练习题的解题思路和答案，如果你没有找到对应的练习题答案，那么请你在正课中查找。\n                    </p>\n                    <h4 data-nodeid=\"58786\" class=\"\">\n                      01 | 复杂度：如何衡量程序运行的效率？\n                    </h4>\n\n                    <p data-nodeid=\"57883\">\n                      <strong data-nodeid=\"57967\">【问题】</strong>\n                      评估一下，如下的代码片段，时间复杂度是多少？\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) { \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; n; j++) { \n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; n; k++) { \n</div></li><li><div class=\"code-word\">\t\t} \n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">for</span> (m = <span class=\"hljs-number\">0</span>; m &lt; n; m++) { \n</div></li><li><div class=\"code-word\">\t\t} \n</div></li><li><div class=\"code-word\">\t} \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"57885\">\n                      <strong data-nodeid=\"57972\">【解析】</strong>\n                      在上面的代码中：\n                    </p>\n                    <ul data-nodeid=\"57886\">\n                      <li data-nodeid=\"57887\">\n                        <p data-nodeid=\"57888\">\n                          第 3～5 行和 6～8 行，显然是一个 O(n)\n                          复杂度的循环。这两个循环是顺序结构，因此合在一起的复杂度是\n                          O(n) + O(n) = O(2n) = O(n)。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"57889\">\n                        <p data-nodeid=\"57890\">\n                          第 2～9 行是一个 for 循环，它的时间复杂度是 O(n)。这个\n                          for 循环内部嵌套了 O(n) 复杂度的代码，因此合在一起就是\n                          O(n ² ) 的时间复杂度。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"57891\">\n                        <p data-nodeid=\"57892\">\n                          在代码的最外部，第 1～10 行又是一个 O(n)\n                          复杂度的循环，内部嵌套了 O(n ² )\n                          的时间复杂度的代码。因此合在一起就是 O(n ³ )\n                          的时间复杂度。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"59392\" class=\"\">\n                      02 |\n                      数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度\n                    </h4>\n\n                    <p data-nodeid=\"57894\">\n                      <strong data-nodeid=\"57983\">【问题】</strong>\n                      在下面这段代码中，如果要降低代码的执行时间，第 4\n                      行代码需要做哪些改动呢？如果做出改动后，是否降低了时间复杂度呢？\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">s2_2</span><span class=\"hljs-params\">()</span> </span>{ \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>; \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= (<span class=\"hljs-number\">100</span> / <span class=\"hljs-number\">7</span>); i++) { \n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt;= (<span class=\"hljs-number\">100</span> / <span class=\"hljs-number\">3</span>); j++) { \n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-number\">100</span>-i*<span class=\"hljs-number\">7</span>-j*<span class=\"hljs-number\">3</span> &gt;= <span class=\"hljs-number\">0</span>)&amp;&amp;((<span class=\"hljs-number\">100</span>-i*<span class=\"hljs-number\">7</span>-j*<span class=\"hljs-number\">3</span>) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)) { \n</div></li><li><div class=\"code-word\">\t\t\t\tcount += <span class=\"hljs-number\">1</span>; \n</div></li><li><div class=\"code-word\">\t\t\t} \n</div></li><li><div class=\"code-word\">\t\t} \n</div></li><li><div class=\"code-word\">\t} \n</div></li><li><div class=\"code-word\">\tSystem.out.println(count); \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"57896\">\n                      <strong data-nodeid=\"57988\">【解析】</strong> 代码的第 4\n                      行可以改为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt;= (<span class=\"hljs-number\">100</span>-<span class=\"hljs-number\">7</span>*i) / <span class=\"hljs-number\">3</span>; j++) {\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"57898\">\n                      代码改造完成后，时间复杂度并没有变小。但由于减少了一些不必要的计算量，程序的执行时间变少了。\n                    </p>\n                    <h4 data-nodeid=\"59998\" class=\"\">\n                      03 | 增删查：掌握数据处理的基本操作，以不变应万变\n                    </h4>\n\n                    <p data-nodeid=\"57900\">\n                      <strong data-nodeid=\"57997\">【问题】</strong> 对于一个包含\n                      5\n                      个元素的数组，如果要把这个数组元素的顺序翻转过来。你可以试着分析该过程需要对数据进行哪些操作？\n                    </p>\n                    <p data-nodeid=\"57901\">\n                      <strong data-nodeid=\"58002\">【解析】</strong> 假设原数组 a\n                      = {1,2,3,4,5}，现在要更改为 a =\n                      {5,4,3,2,1}。要想得到新的数组，就要找到 “1” 和\n                      “5”，再分别把它们赋值给对方。因此，这里主要会产生大量的基于索引位置的查找动作。\n                    </p>\n                    <h4 data-nodeid=\"60604\" class=\"\">\n                      04 | 如何完成线性表结构下的增删查？\n                    </h4>\n\n                    <p data-nodeid=\"57903\">\n                      <strong data-nodeid=\"58010\">【问题】</strong> 给定一个包含\n                      n 个元素的链表，现在要求每 k\n                      个节点一组进行翻转，打印翻转后的链表结果。例如，链表为 1\n                      -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6，k = 3，则打印\n                      321654。\n                    </p>\n                    <p data-nodeid=\"57904\">\n                      <strong data-nodeid=\"58015\">【解析】</strong>\n                      我们给出一些提示。利用链表翻转的算法，这个问题应该很简单。利用\n                      3 个指针，prev、curr、next，执行链表翻转，每次得到了 k\n                      个翻转的结点就执行打印。\n                    </p>\n                    <h4 data-nodeid=\"61210\" class=\"\">\n                      05 | 栈：后进先出的线性表，如何实现增删查？\n                    </h4>\n\n                    <p data-nodeid=\"57906\">\n                      <strong data-nodeid=\"58023\">【问题】</strong> 给定一个包含\n                      n 个元素的链表，现在要求每 k\n                      个节点一组进行翻转，打印翻转后的链表结果。例如，链表为 1\n                      -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6，k = 3，则打印\n                      321654。要求用栈来实现。\n                    </p>\n                    <p data-nodeid=\"57907\">\n                      <strong data-nodeid=\"58032\">【解析】</strong>\n                      我们用栈来实现它，就很简单了。你可以牢牢记住，<strong\n                        data-nodeid=\"58033\"\n                        >只要涉及翻转动作的题目，都是使用栈来解决的强烈信号</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"57908\">\n                      具体的操作如下，设置一个栈，不断将队列数据入栈，并且实时记录栈的大小。当栈的大小达到\n                      k 的时候，全部出栈。我们给出核心代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> (tmp != <span class=\"hljs-keyword\">null</span> &amp;&amp; count &lt; k) { \n</div></li><li><div class=\"code-word\">    stack.push(tmp.value); \n</div></li><li><div class=\"code-word\">    tmp = tmp.next; \n</div></li><li><div class=\"code-word\">    count++; \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> (!stack.isEmpty()) { \n</div></li><li><div class=\"code-word\">    System.out.print(stack.pop()); \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"61816\" class=\"\">\n                      07 | 数组：如何实现基于索引的查找？\n                    </h4>\n\n                    <p data-nodeid=\"57911\">\n                      <strong data-nodeid=\"58042\"\n                        >详细分析和答案，请翻阅 18 课时例题 1</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"62422\" class=\"\">\n                      08 | 字符串：如何正确回答面试中高频考察的字符串匹配算法？\n                    </h4>\n\n                    <p data-nodeid=\"57913\">\n                      <strong data-nodeid=\"58049\"\n                        >详细分析和解题步骤，请参考 17 课时例题 1。</strong\n                      >\n                    </p>\n                    <h4 data-nodeid=\"62727\" class=\"\">\n                      10 | 哈希表：如何利用好高效率查找的“利器”？\n                    </h4>\n\n                    <p data-nodeid=\"57915\">\n                      <strong data-nodeid=\"58057\"\n                        >详细分析和答案，请翻阅 15 课时例题 1</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"63333\" class=\"\">\n                      11 | 递归：如何利用递归求解汉诺塔问题？\n                    </h4>\n\n                    <p data-nodeid=\"57917\">\n                      <strong data-nodeid=\"58065\"\n                        >详细分析和答案，请翻阅 16 课时例题 1</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"63939\" class=\"\">\n                      12 | 分治：如何利用分治法完成数据查找？\n                    </h4>\n\n                    <p data-nodeid=\"57919\">\n                      <strong data-nodeid=\"58073\">【问题】</strong>\n                      在一个有序数组中，查找出第一个大于 9\n                      的数字，假设一定存在。例如，arr = { -1, 3, 3, 7, 10, 14,\n                      14 }；则返回 10。\n                    </p>\n                    <p data-nodeid=\"57920\">\n                      <strong data-nodeid=\"58078\">【解析】</strong>\n                      在这里提醒一下，带查找的目标数字具备这样的性质：\n                    </p>\n                    <ul data-nodeid=\"57921\">\n                      <li data-nodeid=\"57922\">\n                        <p data-nodeid=\"57923\">第一，它比 9 大；</p>\n                      </li>\n                      <li data-nodeid=\"57924\">\n                        <p data-nodeid=\"57925\">\n                          第二，它前面的数字（除非它是第一个数字），比 9 小。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"57926\">\n                      因此，当我们作出向左走或向右走的决策时，必须满足这两个条件。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{ \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span> targetNumb = <span class=\"hljs-number\">9</span>; \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 目标有序数组 </span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span>[] arr = { -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">14</span> }; \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span> middle = <span class=\"hljs-number\">0</span>; \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span> low = <span class=\"hljs-number\">0</span>; \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span> high = arr.length - <span class=\"hljs-number\">1</span>; \n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">while</span> (low &lt;= high) { \n</div></li><li><div class=\"code-word\">\t\tmiddle = (high + low) / <span class=\"hljs-number\">2</span>; \n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">if</span> (arr[middle] &gt; targetNumb &amp;&amp; (middle == <span class=\"hljs-number\">0</span> || arr[middle - <span class=\"hljs-number\">1</span>] &lt;= targetNumb)) { \n</div></li><li><div class=\"code-word\">\t\t\tSystem.out.println(<span class=\"hljs-string\">\"第一个比 \"</span> + targetNumb + <span class=\"hljs-string\">\" 大的数字是 \"</span> + arr[middle]); \n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-keyword\">break</span>; \n</div></li><li><div class=\"code-word\">\t\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[middle] &gt; targetNumb) { \n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-comment\">// 说明该数在low~middle之间 </span>\n</div></li><li><div class=\"code-word\">\t\t\thigh = middle - <span class=\"hljs-number\">1</span>; \n</div></li><li><div class=\"code-word\">\t\t} <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-comment\">// 说明该数在middle~high之间 </span>\n</div></li><li><div class=\"code-word\">\t\t\tlow = middle + <span class=\"hljs-number\">1</span>; \n</div></li><li><div class=\"code-word\">\t\t} \n</div></li><li><div class=\"code-word\">\t}\t \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"64545\" class=\"\">\n                      14 | 动态规划：如何通过最优子结构，完成复杂问题求解？\n                    </h4>\n\n                    <p data-nodeid=\"57929\">\n                      <strong data-nodeid=\"58089\"\n                        >详细分析和答案，请翻阅 16 课时例题 3</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"65151\" class=\"\">\n                      15 |\n                      定位问题才能更好地解决问题：开发前的复杂度分析与技术选型\n                    </h4>\n\n                    <p data-nodeid=\"57931\">\n                      <strong data-nodeid=\"58097\">【问题】</strong>\n                      下面的代码采用了两个 for 循环去实现 two\n                      sums。那么，能否只使用一个 for 循环完成呢？\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] twoSum(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> target) { \n</div></li><li><div class=\"code-word\">    Map&lt;Integer, Integer&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;(); \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) { \n</div></li><li><div class=\"code-word\">        map.put(arr[i], i); \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> complement = target - arr[i]; \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { map.get(complement), i }; \n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>; \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"57933\">\n                      <strong data-nodeid=\"58102\">【解析】</strong> 原代码中，第\n                      3 和第 6 行的 for 循环合并后，就需要把 map\n                      的新增、查找合在一起执行。则代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span>[] twoSum(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> target) { \n</div></li><li><div class=\"code-word\">    Map&lt;Integer, Integer&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;(); \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> complement = target - arr[i]; \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] { map.get(complement), i }; \n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span>{ \n</div></li><li><div class=\"code-word\">            map.put(arr[i], i); \n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>; \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"65757\" class=\"\">\n                      16 | 真题案例（一）：算法思维训练\n                    </h4>\n\n                    <p data-nodeid=\"57936\">\n                      <strong data-nodeid=\"58110\">【问题】</strong>\n                      如果现在是个线上实时交互的系统。客户端输入\n                      x，服务端返回斐波那契数列中的第 x\n                      位。那么，这个问题使用上面的解法是否可行。\n                    </p>\n                    <p data-nodeid=\"57937\">\n                      <strong data-nodeid=\"58115\">【解析】</strong>\n                      这里给你一个小提示，既然我这么问，答案显然是不可行的。如果不可行，原因是什么呢？我们又该如何解决？\n                    </p>\n                    <p data-nodeid=\"57938\">\n                      注意，题目中给出的是一个实时系统。当用户提交了\n                      x，如果在几秒内没有得到系统响应，用户就会卸载 App 啦。\n                    </p>\n                    <p data-nodeid=\"57939\">\n                      一个实时系统，必须想方设法在 O(1)\n                      时间复杂度内返回结果。因此，一个可行的方式是，在系统上线之前，把输入\n                      x 在 1～100 的结果预先就计算完，并且保存在数组里。当收到\n                      1～100 范围内输入时，O(1)\n                      时间内就可以返回。如果不在这个范围，则需要计算。计算之后的结果返回给用户，并在数组中进行保存。以方便后续同样输入时，能在\n                      O(1) 时间内可以返回。\n                    </p>\n                    <h4 data-nodeid=\"66363\" class=\"\">\n                      17 | 真题案例（二）：数据结构训练\n                    </h4>\n\n                    <p data-nodeid=\"57941\">\n                      <strong data-nodeid=\"58125\">【问题】</strong>\n                      对于树的层次遍历，我们再拓展一下。如果要打印的不是层次，而是蛇形遍历，又该如何实现呢？蛇形遍历就是\n                      s 形遍历，即奇数层从左到右，偶数层从右到左。\n                    </p>\n                    <p data-nodeid=\"57942\">\n                      <strong data-nodeid=\"58130\">【解析】</strong>\n                      这里要对数据的顺序进行逆序处理，直观上，你需要立马想到栈。毕竟只有栈是后进先出的结构，是能快速实现逆序的。具体而言，需要建立两个栈\n                      s1 和 s2。进栈的顺序是，s1 先右后左，s2\n                      先左后右。两个栈交替出栈的结果就是 s 形遍历，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNodes pRoot) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 先右后左 </span>\n</div></li><li><div class=\"code-word\">    Stack&lt;TreeNodes&gt; s1 = <span class=\"hljs-keyword\">new</span> Stack&lt;TreeNodes&gt;(); \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 先左后右 </span>\n</div></li><li><div class=\"code-word\">    Stack&lt;TreeNodes&gt; s2 = <span class=\"hljs-keyword\">new</span> Stack&lt;TreeNodes&gt;(); \n</div></li><li><div class=\"code-word\">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); \n</div></li><li><div class=\"code-word\">    list.add(pRoot.val); \n</div></li><li><div class=\"code-word\">    s1.push(pRoot); \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (s1.isEmpty() || s2.isEmpty()) { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (s1.isEmpty() &amp;&amp; s2.isEmpty()) { \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">break</span>; \n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (s2.isEmpty()) { \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">while</span> (!s1.isEmpty()) { \n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (s1.peek().right != <span class=\"hljs-keyword\">null</span>) { \n</div></li><li><div class=\"code-word\">                    list.add(s1.peek().right.val); \n</div></li><li><div class=\"code-word\">                    s2.push(s1.peek().right); \n</div></li><li><div class=\"code-word\">                } \n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (s1.peek().left != <span class=\"hljs-keyword\">null</span>) { \n</div></li><li><div class=\"code-word\">                    list.add(s1.peek().left.val); \n</div></li><li><div class=\"code-word\">                    s2.push(s1.peek().left); \n</div></li><li><div class=\"code-word\">                } \n</div></li><li><div class=\"code-word\">                s1.pop(); \n</div></li><li><div class=\"code-word\">            } \n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">while</span> (!s2.isEmpty()) { \n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (s2.peek().left != <span class=\"hljs-keyword\">null</span>) { \n</div></li><li><div class=\"code-word\">                    list.add(s2.peek().left.val); \n</div></li><li><div class=\"code-word\">                    s1.push(s2.peek().left); \n</div></li><li><div class=\"code-word\">                } \n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (s2.peek().right != <span class=\"hljs-keyword\">null</span>) { \n</div></li><li><div class=\"code-word\">                    list.add(s2.peek().right.val); \n</div></li><li><div class=\"code-word\">                    s1.push(s2.peek().right); \n</div></li><li><div class=\"code-word\">                } \n</div></li><li><div class=\"code-word\">                s2.pop(); \n</div></li><li><div class=\"code-word\">            } \n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> list; \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"66969\" class=\"\">\n                      18 | 真题案例（三）： 力扣真题训练\n                    </h4>\n\n                    <p data-nodeid=\"57945\">\n                      <strong data-nodeid=\"58138\">【问题】</strong>\n                      给定一个链表，删除链表的倒数第 n\n                      个节点。例如，给定一个链表: 1 -&gt; 2 -&gt; 3 -&gt; 4\n                      -&gt; 5, 和 n = 2。当删除了倒数第二个节点后，链表变为 1\n                      -&gt; 2 -&gt; 3 -&gt; 5。你可以假设，给定的 n\n                      是有效的。额外要求就是，要在一趟扫描中实现，即时间复杂度是\n                      O(n)。这里给你一个提示，可以采用快慢指针的方法。\n                    </p>\n                    <p data-nodeid=\"57946\">\n                      <strong data-nodeid=\"58143\">【解析】</strong>\n                      定义快慢指针，slow 和 fast 并同时指向 header。然后，让\n                      fast 指针先走 n\n                      步。接着，让二者保持同样的速度，一起往前走。最后，fast\n                      指针先到达终点，并指向了 null。此时，slow\n                      指针的结果就是倒数第 n\n                      个结点。比较简单，我们就不给代码了。\n                    </p>\n                    <h4 data-nodeid=\"67575\" class=\"\">\n                      19 | 真题案例（四）：大厂真题实战演练\n                    </h4>\n\n                    <p data-nodeid=\"57948\">\n                      <strong data-nodeid=\"58155\">【问题】</strong>\n                      小明从小就喜欢数学，喜欢在笔记里记录很多表达式。他觉得现在的表达式写法很麻烦，为了提高运算符优先级，不得不添加很多括号。如果不小心漏了一个右括号的话，就差之毫厘，谬之千里了。因此他改用前缀表达式，例如把\n                      <code data-backticks=\"1\" data-nodeid=\"58151\"\n                        >(2 + 3) * 4</code\n                      >写成<code data-backticks=\"1\" data-nodeid=\"58153\"\n                        >* + 2 3 4</code\n                      >，这样就能避免使用括号了。这样的表达式虽然书写简单，但计算却不够直观。请你写一个程序帮他计算这些前缀表达式。\n                    </p>\n                    <p data-nodeid=\"57949\">\n                      <strong data-nodeid=\"58164\">【解析】</strong>\n                      在这个题目中，输入就是前缀表达式，输出就是计算的结果。你可以假设除法为整除，即\n                      “5/3 = 1”。例如，输入字符串为 +&nbsp;2&nbsp;3，输出\n                      5；输入字符串为 *&nbsp;+&nbsp;2&nbsp;2&nbsp;3，输出为\n                      12；输入字符串为 *&nbsp;2&nbsp;+&nbsp;2&nbsp;3，输出为\n                      10。\n                    </p>\n                    <p data-nodeid=\"57950\">\n                      假设输入字符串为 *&nbsp;2&nbsp;+&nbsp;2&nbsp;3，即\n                      2*(2+3)。第一个字符为运算符号\n                      *，它将对两个数字进行乘法。如果后面紧接着的字符不全是数字字符，那就需要暂存下来，先计算后面的算式。一旦后面的计算完成，就需要接着从后往前去继续计算。因为从后往前是一种逆序动作，我们能够很自然地想到可以用栈的数据结构进行存储。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{ \n</div></li><li><div class=\"code-word\">    Stack&lt;Object&gt; stack = <span class=\"hljs-keyword\">new</span> Stack&lt;Object&gt;(); \n</div></li><li><div class=\"code-word\">    String s = <span class=\"hljs-string\">\"* + 2 2 3\"</span>; \n</div></li><li><div class=\"code-word\">    String attr[] = s.split(<span class=\"hljs-string\">\" \"</span>); \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = attr.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!(attr[i].equals(<span class=\"hljs-string\">\"+\"</span>) || attr[i].equals(<span class=\"hljs-string\">\"-\"</span>) || attr[i].equals(<span class=\"hljs-string\">\"*\"</span>) || attr[i].equals(<span class=\"hljs-string\">\"/\"</span>))) { \n</div></li><li><div class=\"code-word\">            stack.push(Integer.parseInt(attr[i])); \n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> a = (<span class=\"hljs-keyword\">int</span>) stack.pop();<span class=\"hljs-comment\">// 出栈 </span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> b = (<span class=\"hljs-keyword\">int</span>) stack.pop();<span class=\"hljs-comment\">// 出栈 </span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> result = Cal(a, b, attr[i]); <span class=\"hljs-comment\">// 调用函数计算结果值 </span>\n</div></li><li><div class=\"code-word\">            stack.push(result); <span class=\"hljs-comment\">// 结果进栈 </span>\n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = (<span class=\"hljs-keyword\">int</span>) stack.pop(); \n</div></li><li><div class=\"code-word\">    System.out.print(ans); \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Cal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b, String s)</span> </span>{ \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">switch</span> (s) { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"+\"</span>: \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> a + b; \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"-\"</span>: \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> a - b; \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"*\"</span>: \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> a * b; \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"/\"</span>: \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> a / b; \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"57952\">\n                      以上这些练习题你做得怎么样呢？还能回忆起来每道题是源自哪个算法知识点或哪个课时吗？\n                    </p>\n                    <p data-nodeid=\"57953\">\n                      你可以把课后习题和课程中的案例都当作一个小项目，自己动手实践，即使有些题目你还不能写出完整的代码，那也可以尝试写出解题思路，从看不明白到能够理解，再到能联想到用什么数据结构和算法去解决什么样的问题，这是一个循序渐进的过程，切勿着急。\n                    </p>\n                    <p data-nodeid=\"57954\">\n                      通过留言可以看出，你们都在认真地学习这门课程，也正因如此，我才愿意付出更多的时间优化这个已经完结的专栏。所以，请你不要犹豫，尽管畅所欲言，在留言区留下你的思考，也欢迎你积极地提问，更欢迎你为专栏提出建议，这样我才能更直接地看到你们的想法和收获。也许你的一条留言，就是下一篇加餐的主题。\n                    </p>\n                    <p data-nodeid=\"57955\">\n                      最后呢，我还想邀请你为本专栏课程进行结课评价，因为你的每一个观点，都是我们最关注的点。<a\n                        href=\"https://wj.qq.com/s2/6946469/226f/\"\n                        data-nodeid=\"58178\"\n                        >点击链接，即可参与课程评价。</a\n                      >\n                    </p>\n                    <p data-nodeid=\"57956\" class=\"\">\n                      很高兴遇见你，我是公瑾，后会有期。\n                    </p>\n            "}