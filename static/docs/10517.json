{"title":"16 | 真题案例（一）：算法思维训练","context":"\n                    <p data-nodeid=\"32413\" class=\"\">\n                      你好，欢迎进入第 16\n                      课时的学习。在前面课时中，我们已经学习了解决代码问题的方法论。宏观上，它可以分为以下\n                      4 个步骤：\n                    </p>\n                    <ol data-nodeid=\"32414\">\n                      <li data-nodeid=\"32415\">\n                        <p data-nodeid=\"32416\">\n                          <strong data-nodeid=\"32568\">复杂度分析</strong\n                          >。估算问题中复杂度的上限和下限。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32417\">\n                        <p data-nodeid=\"32418\">\n                          <strong data-nodeid=\"32573\">定位问题</strong\n                          >。根据问题类型，确定采用何种算法思维。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32419\">\n                        <p data-nodeid=\"32420\">\n                          <strong data-nodeid=\"32578\">数据操作分析</strong\n                          >。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32421\">\n                        <p data-nodeid=\"32422\">\n                          <strong data-nodeid=\"32583\">编码实现</strong>。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"32423\">\n                      这套方法论的框架，是解决绝大多数代码问题的基本步骤。本课时，我们将在一些更开放的题目中进行演练，继续训练你的算法思维。\n                    </p>\n                    <h3 data-nodeid=\"32424\">算法思维训练题</h3>\n                    <h4 data-nodeid=\"32425\">例题 1：斐波那契数列</h4>\n                    <p data-nodeid=\"32426\">\n                      斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；也就是\n                      a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和\n                      1。<strong data-nodeid=\"32604\"\n                        >在这个数列中的数字，就被称为斐波那契数</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"32427\">\n                      <strong data-nodeid=\"32609\"\n                        >【题目】写一个函数，输入 x，输出斐波那契数列中第 x\n                        位的元素</strong\n                      >。例如，输入 4，输出 2；输入 9，输出\n                      21。要求：需要用递归的方式来实现。\n                    </p>\n                    <p data-nodeid=\"32428\">\n                      <strong data-nodeid=\"32614\">【解析】</strong>\n                      在本课时开头，我们复习了解决代码问题的方法论，下面我们按照解题步骤进行详细分析。\n                    </p>\n                    <ul data-nodeid=\"32429\">\n                      <li data-nodeid=\"32430\">\n                        <p data-nodeid=\"32431\">\n                          首先我们还是先做好复杂度的分析\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32432\">\n                      题目中要求要用递归的方式来实现，而递归的次数与 x\n                      的具体数值有非常强的关系。因此，此时的时间复杂度应该是关于输入变量\n                      x 的数值大小的函数。\n                    </p>\n                    <ul data-nodeid=\"32433\">\n                      <li data-nodeid=\"32434\">\n                        <p data-nodeid=\"32435\">至于问题定位</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32436\">\n                      因为题目中已经明确了要采用递归去解决。所以也不用再去做额外的分析和判断了。\n                    </p>\n                    <p data-nodeid=\"32437\">\n                      那么，如何使用递归呢？我们需要依赖斐波那契数列的重要性质“某个数等于它前面两个数的和”。也就是说，要求出某个位置\n                      x 的数字，需要先求出 x-1 的位置是多少和 x-2\n                      的位置是多少。递归同时还需要终止条件，对应于斐波那契数列的性质，就是起始两个元素，分别为\n                      0 和 1。\n                    </p>\n                    <ul data-nodeid=\"32438\">\n                      <li data-nodeid=\"32439\">\n                        <p data-nodeid=\"32440\">数据操作方面</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32441\">\n                      斐波那契数列需要对数字进行求和。而且所有的计算，都是依赖最原始的\n                      0 和 1\n                      进行。因此，这道题是不需要设计什么复杂的数据结构的。\n                    </p>\n                    <ul data-nodeid=\"32442\">\n                      <li data-nodeid=\"32443\">\n                        <p data-nodeid=\"32444\">最后，实现代码</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32445\">\n                      我们围绕递归的性质进行开发，去试着写出递归体和终止条件。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> x = <span class=\"hljs-number\">20</span>;\n</div></li><li><div class=\"code-word\">    System.out.println(fun(x));\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">2</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> fun(n - <span class=\"hljs-number\">1</span>) + fun(n - <span class=\"hljs-number\">2</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"32447\">\n                      <strong data-nodeid=\"32628\"\n                        >下面，我们来对代码进行解读</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"32448\">\n                      <strong data-nodeid=\"32633\">主函数中</strong>，第 1 行到第\n                      4 行，定义输入变量 x，并调用 fun(x) 去计算第 x\n                      位的斐波那契数列元素。\n                    </p>\n                    <p data-nodeid=\"32449\">\n                      <strong data-nodeid=\"32638\">在 fun() 函数内部</strong\n                      >，采用了递归去完成计算。递归分为递归体和终止条件：\n                    </p>\n                    <ul data-nodeid=\"32450\">\n                      <li data-nodeid=\"32451\">\n                        <p data-nodeid=\"32452\">\n                          递归体是第 13 行。即当输入变量 n 比 2\n                          大的时候，递归地调用 fun() 函数，并传入 n-1 和 n-2，即\n                          return fun(n - 1) + fun(n - 2)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32453\">\n                        <p data-nodeid=\"32454\">\n                          终止条件则是在第 7 行到第 12 行，分别定义了当 n 为 1\n                          或 2 的时候，直接返回 0 或 1。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"32455\">\n                      例题2：判断一个数组中是否存在某个数\n                    </h4>\n                    <p data-nodeid=\"32456\">\n                      <strong data-nodeid=\"32646\"\n                        >【题目】给定一个经过任意位数的旋转后的排序数组，判断某个数是否在里面</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"32457\">\n                      例如，对于一个给定数组 {4, 5, 6, 7, 0, 1,\n                      2}，它是将一个有序数组的前三位旋转地放在了数组末尾。假设输入的\n                      target 等于 0，则输出答案是 4，即 0 所在的位置下标是\n                      4。如果输入 3，则返回 -1。\n                    </p>\n                    <p data-nodeid=\"32458\">\n                      <strong data-nodeid=\"32652\">【解析】</strong>\n                      这道题目依旧是按照解决代码问题的方法论的步骤进行分析。\n                    </p>\n                    <ul data-nodeid=\"32459\">\n                      <li data-nodeid=\"32460\">\n                        <p data-nodeid=\"32461\">先做复杂度分析</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32462\">\n                      这个问题就是判断某个数字是否在数组中，因此，复杂度极限就是全部遍历地去查找，也就是\n                      O(n) 的复杂度。\n                    </p>\n                    <ul data-nodeid=\"32463\">\n                      <li data-nodeid=\"32464\">\n                        <p data-nodeid=\"32465\">接着，进入定位问题的环节中</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32466\">\n                      这个问题有很多关键字，因此能够让你立马锁定问题。例如，判断某个数是否在数组里面，这就是一个查找问题。\n                    </p>\n                    <ul data-nodeid=\"32467\">\n                      <li data-nodeid=\"32468\">\n                        <p data-nodeid=\"32469\">然后，我们来做数据操作分析</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32470\">\n                      原数组是经过某些处理的排序数组，也就是说原数组是有序的。有序和查找，你就会很快地想到，这个问题极有可能用二分查找的方式去解决，时间复杂度是\n                      O(logn)，相比上面 O(n) 的基线也是有显著的提高。\n                    </p>\n                    <p data-nodeid=\"32471\">\n                      在利用二分查找时，更多的是判断，基本没有数据的增删操作，因此不需要太多地定义复杂的数据结构。\n                    </p>\n                    <p data-nodeid=\"32472\">\n                      分析到这里，解决方案已经非常明朗了，就是采用二分查找的方法，在\n                      O(logn)\n                      的时间复杂度下去解决这个问题。二分查找可以通过递归来实现。<strong\n                        data-nodeid=\"32665\"\n                        >而每次递归的关键点在于，根据切分的点（最中间的那个数字），确定是向左走还是向右走。这也是这个例题中唯一的难点了</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"32473\">\n                      试想一下，在一个旋转后的有序数组中，利用中间元素作为切分点得到的两个子数组有什么样的性质。经过枚举不难发现，这两个子数组中，一定存在一个数组是有序的。也可能出现一个极端情况，二者都是有序的。如下图所示：\n                    </p>\n                    <p data-nodeid=\"32474\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/2E/C4/CgqCHl8Fi6eAVyX3AAAnk9vJF3c337.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"32669\"\n                      />\n                    </p>\n                    <p data-nodeid=\"32475\">\n                      对于有序的一边，我们是很容易判断目标值，是否在这个区间内的。如果在其中，也说明了目标值不在另一边的旋转有序组里；反之亦然。\n                    </p>\n                    <p data-nodeid=\"32476\">\n                      当我们知道了目标值在左右哪边之后，就可以递归地调用旋转有序的二分查找了。之所以可以递归调用，是因为，对于旋转有序组，这个问题和原始问题完全一致，可以调用。对于有序组，它是旋转有序的特殊情况（即旋转\n                      0\n                      位），也一定是可以通过递归的方法去实现查找的。直到不断二分后，搜索空间只有\n                      1 位数字，直接判断是否找到即可。\n                    </p>\n                    <ul data-nodeid=\"32477\">\n                      <li data-nodeid=\"32478\">\n                        <p data-nodeid=\"32479\">最后，实现代码</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32480\">\n                      我们给出这个例子的实现代码，如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> };\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> target = <span class=\"hljs-number\">7</span>;\n</div></li><li><div class=\"code-word\">    System.out.println(bs(arr, target, <span class=\"hljs-number\">0</span>, arr.length-<span class=\"hljs-number\">1</span>));\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> target, <span class=\"hljs-keyword\">int</span> begin, <span class=\"hljs-keyword\">int</span> end)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (begin == end) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (target == arr[begin]){\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> begin;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span>{\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> middle = (begin + end)/<span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (target == arr[middle]) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> middle;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (begin != middle &amp;&amp; arr[begin] &lt;= arr[middle-<span class=\"hljs-number\">1</span>]){\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (arr[begin] &lt;= target &amp;&amp; target &lt;= arr[middle-<span class=\"hljs-number\">1</span>]) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> bs(arr,target, begin,middle);\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> bs(arr,target, middle+<span class=\"hljs-number\">1</span>,end);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (arr[middle+<span class=\"hljs-number\">1</span>] &lt;= target &amp;&amp; target &lt;= arr[end]) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> bs(arr,target, middle+<span class=\"hljs-number\">1</span>,end);\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> bs(arr,target, begin,middle);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"32482\">\n                      <strong data-nodeid=\"32677\">我们对代码进行解读：</strong>\n                    </p>\n                    <p data-nodeid=\"32483\">\n                      <strong data-nodeid=\"32682\"\n                        >主函数中，第 2 到 4 行。定义数组和\n                        target，并且执行二分查找</strong\n                      >。二分查找包括两部分，其一是二分策略，其二是终止条件。\n                    </p>\n                    <p data-nodeid=\"32484\">\n                      <strong data-nodeid=\"32686\"\n                        >二分策略在代码的 16～33 行：</strong\n                      >\n                    </p>\n                    <ul data-nodeid=\"32485\">\n                      <li data-nodeid=\"32486\">\n                        <p data-nodeid=\"32487\">\n                          16 行计算分裂点的索引值。17 到 19\n                          行，进行目标值与分裂点的判断。\n                        </p>\n                        <ul data-nodeid=\"32488\">\n                          <li data-nodeid=\"32489\">\n                            <p data-nodeid=\"32490\">\n                              如果相等，则查找到结果并返回；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"32491\">\n                            <p data-nodeid=\"32492\">如果不等就要继续二分。</p>\n                          </li>\n                        </ul>\n                      </li>\n                      <li data-nodeid=\"32493\">\n                        <p data-nodeid=\"32494\">\n                          在二分的过程中，第 20\n                          行进行了左右子数组哪边是有序的判断。\n                        </p>\n                        <ul data-nodeid=\"32495\">\n                          <li data-nodeid=\"32496\">\n                            <p data-nodeid=\"32497\">\n                              如果左边有序，则进入到 21 到 25 行；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"32498\">\n                            <p data-nodeid=\"32499\">\n                              如果右边有序，则进入到 28 到 32 行。\n                            </p>\n                          </li>\n                        </ul>\n                      </li>\n                      <li data-nodeid=\"32500\">\n                        <p data-nodeid=\"32501\">\n                          假设左边有序，则还需要判断 target\n                          是否在有序区间内，这是在第 21 行。\n                        </p>\n                        <ul data-nodeid=\"32502\">\n                          <li data-nodeid=\"32503\">\n                            <p data-nodeid=\"32504\">\n                              如果在，则继续递归的调用 bs(arr,target,\n                              begin,middle-1)；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"32505\">\n                            <p data-nodeid=\"32506\">\n                              如果不在有序部分，则说明 target\n                              在另一边的旋转有序中，则调用 bs(arr,target,\n                              middle+1,end)。\n                            </p>\n                          </li>\n                        </ul>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32507\">下面的逻辑与此类似，不再赘述。</p>\n                    <p data-nodeid=\"32508\">\n                      <strong data-nodeid=\"32701\"\n                        >经过了层层二分，最终 begin 和 end\n                        变成了相等的两个变量，则进入到终止条件，即 8 到 15\n                        行</strong\n                      >。\n                    </p>\n                    <ul data-nodeid=\"32509\">\n                      <li data-nodeid=\"32510\">\n                        <p data-nodeid=\"32511\">\n                          在这里，需要判断最后剩下的 1 个元素是否与 target\n                          相等：\n                        </p>\n                        <ul data-nodeid=\"32512\">\n                          <li data-nodeid=\"32513\">\n                            <p data-nodeid=\"32514\">如果相等则返回索引值；</p>\n                          </li>\n                          <li data-nodeid=\"32515\">\n                            <p data-nodeid=\"32516\">如果不等则返回 -1。</p>\n                          </li>\n                        </ul>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"32517\">例题3：求解最大公共子串</h4>\n                    <p data-nodeid=\"32518\">\n                      <strong data-nodeid=\"32710\"\n                        >【题目】输入两个字符串，用动态规划的方法，求解出最大公共子串</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"32519\">\n                      例如，输入 a = \"13452439\"， b =\n                      \"123456\"。由于字符串\"345\"同时在 a 和 b\n                      中出现，且是同时出现在 a 和 b\n                      中的最长的子串。因此输出\"345\"。\n                    </p>\n                    <p data-nodeid=\"32520\">\n                      <strong data-nodeid=\"32732\"\n                        >【解析】这里已经定义了问题，就是寻找最大公共子串。同时也定义了方法，就是要用动态规划的方法</strong\n                      >。那么我们也不需要做太多的分析，只要依赖动态规划的步骤完成就可以了。\n                    </p>\n                    <p data-nodeid=\"32521\">\n                      首先，我们回顾一下先前学过的最短路径问题。在最短路径问题中，我们是定义了起点和终点后，再去寻找二者之间的最短路径。\n                    </p>\n                    <p data-nodeid=\"32522\">\n                      而现在的最大公共子串问题是，所有相邻的字符距离都是\n                      1，在不确定起点和终点时，我们需要去寻找起点和终点之间最远的距离。\n                    </p>\n                    <p data-nodeid=\"32523\">\n                      如果要基于已有的知识来探索陌生问题，那就需要根据每个可能的公共子串起点，去寻找与之对应的最远终点。这样就能得到全部的子串。随后再从中找到最大的那个子串。\n                    </p>\n                    <p data-nodeid=\"32524\">\n                      别忘了，<strong data-nodeid=\"32741\"\n                        >动态规划的基本方法是：分阶段、找状态、做决策、状态转移方程、定目标、寻找终止条件</strong\n                      >。下面我们来具体分析一下动态规划的步骤：\n                    </p>\n                    <ul data-nodeid=\"32525\">\n                      <li data-nodeid=\"32526\">\n                        <p data-nodeid=\"32527\">\n                          对于一个可能的起点，它后面的每个字符都是一个阶段。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32528\">\n                        <p data-nodeid=\"32529\">\n                          状态就是当前寻找到的相匹配的字符。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32530\">\n                        <p data-nodeid=\"32531\">\n                          决策就是当前找到的字符是否相等（相等则进入到公共子串中）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32532\">\n                        <p data-nodeid=\"32533\">\n                          状态转移方程可以写作 s<sub>k+1</sub> =\n                          u<sub>k</sub>(s<sub>k</sub>)。可以理解为，如果 s<sub\n                            >k</sub\n                          >\n                          = \"123\"是公共子串，且在 a 字符串和 b\n                          字符串中，\"123\"后面的字符相等，假设为\"4\"，则决策要进入到公共子串中，s<sub\n                            >k+1</sub\n                          >\n                          = \"1234\"。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32534\">\n                        <p data-nodeid=\"32535\">目标自然就是公共子串最长。</p>\n                      </li>\n                      <li data-nodeid=\"32536\">\n                        <p data-nodeid=\"32537\">\n                          终止条件就是决策到了不相等的结果。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"32538\">\n                      这段分析对于初学者来说会非常难懂，接下来我们给一个实现的流程来辅助你理解。\n                    </p>\n                    <p data-nodeid=\"32539\">\n                      <strong data-nodeid=\"32789\"\n                        >我们在最短路径问题中，曾重点提到的一个难点是，对于输入的图，采用什么样的数据结构予以保存。最终我们选择了二维数组</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"32540\">\n                      在这个例子中也可以采用二维数组。每一行或每一列就对应了输入字符串\n                      a 和 b 的每个字符，即 6 x 8 的二维数组（矩阵）为：\n                    </p>\n                    <p data-nodeid=\"32541\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/2E/C1/Ciqc1F8Fkz6APcxAAAAepje1Jv8882.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"32793\"\n                      />\n                    </p>\n                    <p data-nodeid=\"32542\">\n                      接着，每个可能的起点字符，都应该同时出现在字符串 a 和 b\n                      中，例如\"1\"就是一个可能的起点。如果以\"1\"作为起点，那么它后面的字符就是阶段，显然下个阶段就是\n                      a[1] = 3 和 b[1] = 2。而此时的状态就是当前的公共子串，即\n                      \"1\"。\n                    </p>\n                    <p data-nodeid=\"32543\">\n                      决策的结果是，下一个阶段是否进入到公共子串中。很显然 a[1]\n                      不等于\n                      b[1]，因此决策的结果是不进入。这也同时命中了终止条件。如果以\"3\"起点，则因为它之后的\n                      a[2] 等于 b[3]，则决策结果是进入到公共子串。\n                    </p>\n                    <p data-nodeid=\"32544\">\n                      因此状态转移方程 s<sub>k+1</sub> =\n                      u<sub>k</sub>(s<sub>k</sub>)，含义是在\"3\"的状态下决策\"4\"进入子串，结果得到\"34\"。我们的目标是寻找最大的公共子串，因此可以用从\n                      1 开始的数字定义距离（子串的长度）。具体步骤如下：\n                    </p>\n                    <p data-nodeid=\"32545\">\n                      对于每个可能的起点，距离都是 1 （不可能的起点置为\n                      0，图中忽略未写）。则有：\n                    </p>\n                    <p data-nodeid=\"32546\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/2E/CC/CgqCHl8Fk3OAO0i4AAAfVRzJAfw184.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"32864\"\n                      />\n                    </p>\n                    <p data-nodeid=\"32547\">\n                      接着利用状态转移方程，去寻找最优子结构。也就是，如果 b[i]\n                      = a[j]，则 m[i,j] = m[i-1,j-1] +\n                      1。含义为，如果决策结果是相等，则状态增加一个新的字符，进行更新。可以得到：\n                    </p>\n                    <p data-nodeid=\"32548\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/2E/CD/CgqCHl8Fk32AEA7dAAAgSbzrdRM560.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"32884\"\n                      />\n                    </p>\n                    <p data-nodeid=\"32549\">\n                      最终，检索这个矩阵，得到的最大数字就是最大公共子串的长度。根据其所在的位置，就能从\n                      a 或 b 中找到最大公共子串。\n                    </p>\n                    <p data-nodeid=\"32550\">代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">    String a = <span class=\"hljs-string\">\"13452439\"</span>;\n</div></li><li><div class=\"code-word\">    String b = <span class=\"hljs-string\">\"123456\"</span>;\n</div></li><li><div class=\"code-word\">    getCommenStr(a, b);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getCommenStr</span><span class=\"hljs-params\">(String a, String b)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">char</span>[] c1 = a.toCharArray();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">char</span>[] c2 = b.toCharArray();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[][] m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[c2.length+<span class=\"hljs-number\">1</span>][c1.length+<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= c2.length; i++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= c1.length; j++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (c2[i - <span class=\"hljs-number\">1</span>] == c1[j - <span class=\"hljs-number\">1</span>])\n</div></li><li><div class=\"code-word\">                m[i][j] = m[i - <span class=\"hljs-number\">1</span>][j - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> max = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> index = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= c2.length; i++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt;= c1.length; j++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (m[i][j] &gt; max) {\n</div></li><li><div class=\"code-word\">                max = m[i][j];\n</div></li><li><div class=\"code-word\">                index = i;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    String s = <span class=\"hljs-string\">\"\"</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = index - max; i &lt; index; i++)\n</div></li><li><div class=\"code-word\">        s += b.charAt(i);\n</div></li><li><div class=\"code-word\">    System.out.println(s);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"32552\">\n                      <strong data-nodeid=\"32890\"\n                        >下面我们对代码进行解读：</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"32553\">\n                      主函数中定义了字符串 a 和字符串 b，随后调用动态规划代码。\n                    </p>\n                    <p data-nodeid=\"32554\">\n                      进入 getCommenStr() 函数中之后，首先在第 10\n                      行定义了二维数组。此时二维数组的维数是 7 x 9\n                      的。这主要的原因是，后续会需要用到第一行和第一列的全零向量，作为起始条件。\n                    </p>\n                    <p data-nodeid=\"32555\">\n                      接着，在第 11～16\n                      行，利用双重循环去完成状态转移的计算。此时就得到了最关键的矩阵，如下所示：\n                    </p>\n                    <p data-nodeid=\"32556\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/2E/CD/CgqCHl8Fk32AEA7dAAAgSbzrdRM560.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"32896\"\n                      />\n                    </p>\n                    <p data-nodeid=\"32557\">\n                      随后的 17～26 行，我们从矩阵 m 中，找到了最大值为\n                      3，在字符串 b 中的索引值为 4（此时 index 为\n                      5，但别忘了我们之前额外定义了一行/一列的全零向量）。\n                    </p>\n                    <p data-nodeid=\"32558\">\n                      最后，27～30 行，我们根据终点字符串索引值 4\n                      和最大公共子串长度 3，就能找到最大公共子串在 b 中的 2～4\n                      的位置。即 \"345\"。\n                    </p>\n                    <h3 data-nodeid=\"32559\">总结</h3>\n                    <p data-nodeid=\"32560\">\n                      这一课时中，我们对例题做了详细的分析和讲解，重点其实是训练你的算法思维。为了检验你的学习成果，我们基于斐波那契数列的例题，再给出一个<strong\n                        data-nodeid=\"32909\"\n                        >思考题，题目如下</strong\n                      >：\n                    </p>\n                    <p data-nodeid=\"32561\">\n                      <strong data-nodeid=\"32914\"\n                        >如果现在是个线上实时交互的系统。客户端输入\n                        x，服务端返回斐波那契数列中的第 x\n                        位。那么，这个问题使用上面的解法是否可行</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"32562\" class=\"te-preview-highlight\">\n                      这里给你一个小提示，既然我这么问，答案显然是不可行的。如果不可行，原因是什么呢？我们又该如何解决？注意，题目中给出的是一个实时系统。当用户提交了\n                      x，如果在几秒内没有得到系统响应，用户就会卸载 App 啦。\n                    </p>\n            "}