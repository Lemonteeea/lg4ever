{"title":"11 | 内存检查：多种类型的内存泄漏分析方案","context":"\n                    <p data-nodeid=\"188830\" class=\"\">\n                      前面一讲我们主要介绍了进程的安全，而内存的泄漏异常是进程安全的其中一种场景，那么本讲我们就来详细介绍一下，什么是内存泄漏以及当出现内存异常时，我们应该如何去分析并定位具体的问题。其次在上一讲中，我们提到了需要优化\n                      router 这个中间件，我们将在本讲末说明下。\n                    </p>\n                    <h3 data-nodeid=\"188831\">内存泄漏</h3>\n                    <blockquote data-nodeid=\"188832\">\n                      <p data-nodeid=\"188833\">\n                        内存泄漏（Memory\n                        Leak）是指程序中已动态分配的堆内存，由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"188834\">\n                      这是来自百度百科的一段解释，下面我们先来看下 Node.js\n                      中的内存回收策略。\n                    </p>\n                    <h4 data-nodeid=\"188835\">Node.js GC 的策略</h4>\n                    <p data-nodeid=\"188836\">\n                      首先我们要理解在 Node.js 存储中分为堆和栈：\n                    </p>\n                    <ul data-nodeid=\"188837\">\n                      <li data-nodeid=\"188838\">\n                        <p data-nodeid=\"188839\">\n                          <strong data-nodeid=\"188961\"\n                            >栈中主要存储的是一些原始类型</strong\n                          >，比如\n                          Boolean、Null、Undefined、Number、BigInt、String 以及\n                          Symbol；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"188840\">\n                        <p data-nodeid=\"188841\">\n                          <strong data-nodeid=\"188966\"\n                            >堆中主要存储引用类型的数据</strong\n                          >，比如对象、全局变量等。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"188842\">\n                      <strong data-nodeid=\"188971\"\n                        >由于栈是系统存储的临时数据，因此系统会进行释放，不会引发内存泄漏问题；而堆中的数据是需要程序自己进行清理，因此存在内存泄漏风险，在\n                        JavaScript\n                        中进行垃圾回收的有引用计数和标记清除法</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"188843\">\n                      而<strong data-nodeid=\"188977\"\n                        >在 Node.js V8 引擎中使用了多种方法的融合</strong\n                      >：\n                    </p>\n                    <ul data-nodeid=\"188844\">\n                      <li data-nodeid=\"188845\">\n                        <p data-nodeid=\"188846\">\n                          对于存活较短的存储对象会使用<strong\n                            data-nodeid=\"188983\"\n                            >Scavenge 算法</strong\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"188847\">\n                        <p data-nodeid=\"188848\">\n                          而对于存活较长的对象或者说在 Scavenge\n                          算法中存储的对象数据超过一定比例时，则会使用<strong\n                            data-nodeid=\"188989\"\n                            >标记清除法与标记整理法相结合的方式</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"188849\">\n                      具体这三种算法的细节，你需要自行去了解下，本讲核心还是内存泄漏的类型以及分析方法，下面我们先来了解下内存泄漏的分类。\n                    </p>\n                    <h3 data-nodeid=\"188850\">内存泄漏分类</h3>\n                    <p data-nodeid=\"188851\">\n                      <strong data-nodeid=\"188996\"\n                        >内存泄漏可以分为 4\n                        种类型，分别是常发性、偶发性、一次性和隐性</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"188852\">1.常发性</h4>\n                    <p data-nodeid=\"188853\">\n                      <strong data-nodeid=\"189002\"\n                        >发生内存泄漏的代码会被多次执行，每次被执行的时候都会导致一块内存泄漏</strong\n                      >。这种是比较好理解的，比如说我们有一个全局变量，在每次调用该部分业务逻辑时，都会导致该变量的数据增加，这就是常发性。这种问题一般比较好定位，只要在开发或者测试阶段就可以快速定位到。\n                    </p>\n                    <h4 data-nodeid=\"188854\">2.偶发性</h4>\n                    <p data-nodeid=\"188855\">\n                      <strong data-nodeid=\"189012\"\n                        >发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生</strong\n                      >。<strong data-nodeid=\"189013\"\n                        >常发性和偶发性是相对的</strong\n                      >。对于特定的环境，偶发性也许就变成了常发性。比如虽然都是全局变量，A\n                      逻辑只要调用就会增加，而 B\n                      逻辑需要满足各种复杂条件后才会增加，那么 B 就是偶发性，而\n                      A 就是上面的常发性。\n                    </p>\n                    <h4 data-nodeid=\"188856\">3.一次性</h4>\n                    <p data-nodeid=\"188857\">\n                      <strong data-nodeid=\"189019\"\n                        >发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅一块内存发生泄漏</strong\n                      >。这种情况如果出现的次数不多，那么影响相对较小，比如说我们在启动\n                      Node.js 服务后，require\n                      并初始化了一个对象，但是并没有在程序中使用这个对象，我们知道在\n                      Node.js require\n                      的模块是会被缓存起来的，因此这也算是一种内存泄漏场景，只是这类场景影响非常有限。\n                    </p>\n                    <h4 data-nodeid=\"188858\">4.隐性</h4>\n                    <p data-nodeid=\"188859\">\n                      <strong data-nodeid=\"189025\"\n                        >在调用函数或者模块时，当参数或者输入没有达到界定值时，是不会发生泄漏，当参数或者输入值达到一定时，才会发现内存泄漏，我们称这种为隐性</strong\n                      >。举个简单的例子，比如我们要读取一个文件，当文件很小时，我们内存可以处理，但是当读取的文件非常大，则会导致内存异常问题，严格来说隐性的情况并不是内存泄漏，因为当程序调用结束后，还是会最终释放。\n                    </p>\n                    <h3 data-nodeid=\"188860\">Node.js 内存泄漏分析方法</h3>\n                    <p data-nodeid=\"188861\">\n                      一般情况下内存的增长是不会立即出现的，而是缓慢地增长，特别是偶发性和隐性的情况，因此<strong\n                        data-nodeid=\"189032\"\n                        >我们需要选择相应的时间来进行一些内存快照分析</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"188862\">\n                      <strong data-nodeid=\"189041\"\n                        >如果内存泄漏是常发性的，这就不需要到生产环境（现网环境）复现了，可以直接在开发或者测试环境进行内存快照即可</strong\n                      >。<strong data-nodeid=\"189042\"\n                        >而如果是偶发性的或者隐性的情况，你才需要在生产环境进行内存快照</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"188863\">\n                      接下来我们先来看看，这其中会应用到哪些工具。\n                    </p>\n                    <h4 data-nodeid=\"188864\">1.工具介绍</h4>\n                    <p data-nodeid=\"188865\">\n                      只需要 2 个工具就可以分析出内存泄漏的问题：\n                    </p>\n                    <ul data-nodeid=\"188866\">\n                      <li data-nodeid=\"188867\">\n                        <p data-nodeid=\"188868\">heapdump 内存快照的工具</p>\n                      </li>\n                      <li data-nodeid=\"188869\">\n                        <p data-nodeid=\"188870\">\n                          chrome dev tools 中的 Memory Profiles\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"188871\">\n                      <strong data-nodeid=\"189051\">heapdump</strong>\n                    </p>\n                    <p data-nodeid=\"188872\">\n                      该工具主要是生成一个内存快照文件，在我们框架项目中，你可以直接\n                      require lib 下的 heapdump 这个库即可，比如我们的 app.js\n                      这段代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'koa'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa();\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> routerMiddleware = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/router'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> logCenter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/logCenter'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> dumpFun = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/lib/heapdump'</span>); \n</div></li><li><div class=\"code-word\">app.use(logCenter());\n</div></li><li><div class=\"code-word\">app.use(routerMiddleware());\n</div></li><li><div class=\"code-word\">app.listen(<span class=\"hljs-number\">3000</span>, () =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`Example app listening on port 3000!\\`</span>));\n</div></li><li><div class=\"code-word\">dumpFun(<span class=\"hljs-string\">'nodejs-cloumn'</span>, <span class=\"hljs-string\">'10:53'</span>, <span class=\"hljs-number\">60</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188874\">\n                      在代码中的第 5 行引用了这个库，然后调用 dumpFun 从 10 点\n                      53 分开始，每隔 60\n                      秒打印一次内存快照。这个库如何实现的细节，你可以自己去\n                      <a\n                        href=\"https://github.com/love-flutter/nodejs-column?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"189056\"\n                        >GitHub 源码</a\n                      >中的 lib 目录下查看，主要是<strong data-nodeid=\"189062\"\n                        >做了一层封装，能够更好地适用我们的应用场景</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"188875\">\n                      <strong data-nodeid=\"189066\">chrome dev tools</strong>\n                    </p>\n                    <p data-nodeid=\"188876\">\n                      打开 Chrome 浏览器的控制台，在图 1 界面可以找到该工具。\n                    </p>\n                    <p data-nodeid=\"188877\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwqqAQM50AAD9oysXX_E217.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"189070\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188878\">\n                      <p style=\"text-align: center\">\n                        图 1 chrome dev tools 的 Memory 工具\n                      </p>\n                    </div>\n                    <p data-nodeid=\"188879\">\n                      把生成的内存快照文件，点击 Load 按钮加载进来。\n                    </p>\n                    <p data-nodeid=\"188880\">\n                      接下来我们做一些实践的例子分析，来介绍下具体的使用方法。\n                    </p>\n                    <h4 data-nodeid=\"188881\">2.实践分析</h4>\n                    <p data-nodeid=\"188882\">\n                      在介绍之前，我们先来看一个常发性的内存泄漏场景，假设我们有一个\n                      session\n                      处理的模块，每次用户请求时需要判断用户是否有登录态，因此需要将\n                      session\n                      保存在一个地方，这里我们保存在内存中。为了效果，我们在请求登录的接口时，进行一个比较大的循环处理，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Controller = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../core/controller'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MemLeak</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Controller</span> </span>{\n</div></li><li><div class=\"code-word\">    login() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">10000000</span>; i++){\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">this</span>.ctx.session.set(i);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.resApi(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-string\">'set success'</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">module</span>.exports = MemLeak;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188884\">\n                      这个文件在源码的 controller/memLeak.js\n                      中，上面代码就是在调用这个接口时，往 session 中 set 了一个\n                      10000000 的数据。\n                    </p>\n                    <p data-nodeid=\"188885\">\n                      接下来我们修改 app.js，在其中<strong data-nodeid=\"189085\"\n                        >增加 session 功能模块</strong\n                      >，<strong data-nodeid=\"189086\"\n                        >并且启动内存快照的打印时间节点</strong\n                      >，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'koa'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa();\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> routerMiddleware = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/router'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> logCenter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/logCenter'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> session = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/session'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> dumpFun = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/lib/heapdump'</span>); \n</div></li><li><div class=\"code-word\">app.use(logCenter());\n</div></li><li><div class=\"code-word\">app.use(session());\n</div></li><li><div class=\"code-word\">app.use(routerMiddleware());\n</div></li><li><div class=\"code-word\">app.listen(<span class=\"hljs-number\">3000</span>, () =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`Example app listening on port 3000!\\`</span>));\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 为了方便，可以打开如下代码自动获取</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> currentDate = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n</div></li><li><div class=\"code-word\">dumpFun(<span class=\"hljs-string\">'nodejs-cloumn'</span>, <span class=\"hljs-string\">\\`<span class=\"hljs-subst\">${currentDate.getHours()}</span>:<span class=\"hljs-subst\">${currentDate.getMinutes()+<span class=\"hljs-number\">1</span>}</span>\\`</span>, <span class=\"hljs-number\">60</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188887\">\n                      在上面代码中的第 5 行就是加载我们的 session\n                      中间件，并且在第 10\n                      行，也就是路由转发处理之前调用，这样就可以在 controller\n                      中处理 session。最后在代码 15\n                      行增加内存快照，这里的时间点，你需要根据自己的当前时间进行调整，最好大于当前时间\n                      1 分钟就行了，比如我现在的时间是 14 点 43\n                      分，因此可以设置成 14 点 44\n                      分，为了方便，我这里将上面的时间设置为了自动获取。\n                    </p>\n                    <p data-nodeid=\"188888\">\n                      session 这个中间件是比较简单的，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> loginUsers = {};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"> ctx, next </span>) </span>{\n</div></li><li><div class=\"code-word\">       ctx.session = session;\n</div></li><li><div class=\"code-word\">       <span class=\"hljs-keyword\">await</span> next();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> session = {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">username</span>) </span>{\n</div></li><li><div class=\"code-word\">        loginUsers[username] = <span class=\"hljs-literal\">true</span>;\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">check</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">username</span>)</span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> loginUsers[username] ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188890\">\n                      在上面代码中存在一个内存泄漏的点，就是<strong\n                        data-nodeid=\"189094\"\n                        >loginUsers 会随着用户请求越来越大，</strong\n                      >\n                      导致存储的空间占用越来越大，而这个 loginUsers\n                      在进程运行期间，又不会进行释放，从而导致内存泄漏的问题。\n                    </p>\n                    <p data-nodeid=\"188891\">\n                      接下来我们就启动服务，启动成功后会看到如下提示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">系统将在 <span class=\"hljs-number\">38</span> 秒后打印首次内存快照，请在首次快照后请求内存泄漏接口\n</div></li><li><div class=\"code-word\">Example app listening on port <span class=\"hljs-number\">3000</span>!\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188893\">等待 38 秒后，同样会提示：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">打印首次内存快照成功，请开始请求内存泄漏接口\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188895\">接下来我们打开内存异常的接口：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:3000/v1/mem-leak</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188897\">\n                      请求成功后，由于我们内存快照间隔 1 分钟，再耐心等待 1\n                      分钟，你会在项目的 log 目录下看到两个 heapsnapshot 文件。\n                    </p>\n                    <p data-nodeid=\"188898\">\n                      接下来我们打开 Chrome 浏览器 Memory 分析工具，分别 Load\n                      这两个问题，如图 2 所示，先选择较大内存的文件，然后再选择\n                      comparsion 对比最新的文件。\n                    </p>\n                    <p data-nodeid=\"188899\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/9B/Cgp9HWBmwryAJxI1AAKJIYG0_JU009.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"189102\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188900\">\n                      <p style=\"text-align: center\">图 2 内存快照对比图</p>\n                    </div>\n                    <p data-nodeid=\"188901\">\n                      在对比后，你可以选择右侧的单独每一列进行排序，其中右侧的每一项表示的是：\n                    </p>\n                    <ul data-nodeid=\"188902\">\n                      <li data-nodeid=\"188903\">\n                        <p data-nodeid=\"188904\">\n                          <strong data-nodeid=\"189107\"\n                            >New，对比文件新创建的对象；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"188905\">\n                        <p data-nodeid=\"188906\">\n                          <strong data-nodeid=\"189111\"\n                            >Deleted，对比文件删除的对象；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"188907\">\n                        <p data-nodeid=\"188908\">\n                          <strong data-nodeid=\"189115\"\n                            >Delta，对比文件净新增的对象；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"188909\">\n                        <p data-nodeid=\"188910\">\n                          <strong data-nodeid=\"189119\"\n                            >Alloc Size，已分配使用中的内存空间；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"188911\">\n                        <p data-nodeid=\"188912\">\n                          <strong data-nodeid=\"189123\"\n                            >Freed Size，对比文件释放的内存空间；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"188913\">\n                        <p data-nodeid=\"188914\">\n                          <strong data-nodeid=\"189128\"\n                            >Size Delta，对比文件净占用内存空间</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"188915\">\n                      以上我们主要对比净新增的 Delta 和 Size\n                      Delta，分别用两者排序，你会发现 Size Delta 中 (array)\n                      占用空间非常大，如图 3 所示。\n                    </p>\n                    <p data-nodeid=\"188916\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/9B/Cgp9HWBmwsSAd_jVAAKOBgdlSSQ463.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"189132\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188917\">\n                      <p style=\"text-align: center\">\n                        图 3 Size Delta 排序后的结果\n                      </p>\n                    </div>\n                    <p data-nodeid=\"188918\">\n                      你展开 (array) 这一列，然后在 (array) 的第一行，如图 4\n                      所示，会看到一个未描述的对象占用了非常大的空间，这个对象几乎占用了\n                      99% 的空间，在这个对象中有一个关键信息是 @108135\n                      这个值，你可以先对这个值有个印象。\n                    </p>\n                    <p data-nodeid=\"188919\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmws2ALJfrAAF6K_LTAvs088.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"189136\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188920\">\n                      <p style=\"text-align: center\">\n                        图 4 (array) 空间占比排序结果\n                      </p>\n                    </div>\n                    <p data-nodeid=\"188921\">\n                      我们右键这个数据，然后选择 Reveal in Summary\n                      view，你将会看到图 5 的结果：\n                    </p>\n                    <p data-nodeid=\"188922\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwtSARfZXAAELN9G896Q666.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"189140\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188923\">\n                      <p style=\"text-align: center\">\n                        图 5 Reveal in Summary view 结果\n                      </p>\n                    </div>\n                    <p data-nodeid=\"188924\">\n                      但是这里因为 (array)\n                      是一个引用对象，因此我们要看下整体的占用情况，我们把\n                      (array) 收缩起来，然后选择右侧的 Retained Size，可以看到图\n                      6 所示的结果。\n                    </p>\n                    <p data-nodeid=\"188925\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/9B/Cgp9HWBmwuCAAi-LAAFhD2HwhQo398.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"189144\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188926\">\n                      <p style=\"text-align: center\">\n                        图 6 Retained Size 排序后的结果\n                      </p>\n                    </div>\n                    <p data-nodeid=\"188927\">\n                      现在你可以看到了，占用最大的就是前 3 个，因此我们着重看这\n                      3 个，我们展开 Object 看看，你会发现一个如图 7\n                      所示的结果，注意 @108135 就是我们之前看到的 (array)\n                      中的数组对象。\n                    </p>\n                    <p data-nodeid=\"188928\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwuiAP3CDAAG2Cu236LA987.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"189148\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188929\">\n                      <p style=\"text-align: center\">\n                        图 7 展开 Object 后的结果\n                      </p>\n                    </div>\n                    <p data-nodeid=\"188930\">\n                      在图 7 中你发现很多以 0、1、10 、...\n                      这种为键的对象，里面存储了比较简单的值\n                      true，这里我们还没有找到具体的原因，但是至少发现了数据问题，那么接下来我们继续看\n                      system/Context，其实第一眼就能发现其是 Koa 框架中的\n                      ctx，我们展开就可以看到图 8 结果。\n                    </p>\n                    <p data-nodeid=\"188931\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/A4/CioPOWBmwvCAC9V1AAH1y5NvYrw937.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"189152\"\n                      />\n                    </p>\n                    <div data-nodeid=\"188932\">\n                      <p style=\"text-align: center\">\n                        图 8 展开 system/Context 结果\n                      </p>\n                    </div>\n                    <p data-nodeid=\"188933\">\n                      你从图 8 发现异常了吗，loginUsers 占用了 95%\n                      空间，好了这下真相大白了，我们再去 ctx 中寻找在哪里进行\n                      loginUsers\n                      的设置，经过代码检查，那肯定能找到泄漏的具体位置了。\n                    </p>\n                    <p data-nodeid=\"188934\">\n                      以上就是一个分析过程，主要还是 comparsion 结合 summary\n                      来进行分析。<strong data-nodeid=\"189159\"\n                        >对于非常发性的内存泄漏，比如偶发性，就需要在生产环境定时打印内存快照</strong\n                      >。请注意要选择用户访问较少的时间节点，比如说当地的凌晨\n                      3-4\n                      点，同时两个快照的打印时间点必须一致，这样用户访问的数据对内存影响较小。\n                    </p>\n                    <h3 data-nodeid=\"188935\">Router 中间件优化</h3>\n                    <p data-nodeid=\"188936\">\n                      在前一讲中，我们说了 Router\n                      存在的问题，这里顺便将这块进行一些优化，减少对 router\n                      模块的频繁修改。\n                    </p>\n                    <p data-nodeid=\"188937\">\n                      我们在中间件 middleware 文件夹中新增了一个 newRouter.js\n                      文件，主要介绍几个关键的实现点。\n                    </p>\n                    <p data-nodeid=\"188938\">\n                      第一个就是需要<strong data-nodeid=\"189168\"\n                        >将横杠转化为大写首字母</strong\n                      >，因此这里需要使用到这样的正则替换：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 去除非常规请求路径，将-转化为大写</span>\n</div></li><li><div class=\"code-word\">pathname = pathname.replace(<span class=\"hljs-string\">'..'</span>, <span class=\"hljs-string\">''</span>).replace(<span class=\"hljs-regexp\">/\\-(\\w)/g</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">all,letter</span>)=&gt;</span>letter.toUpperCase());\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188940\">\n                      上面代码中需要去除 ..\n                      的访问，防止用户利用非法请求路径，请求根目录的文件信息。\n                    </p>\n                    <p data-nodeid=\"188941\">\n                      第二就是我们<strong data-nodeid=\"189175\"\n                        >默认请求路径的最后一个是方法名</strong\n                      >，因此使用 /\n                      切割后，获取最后一个元素为请求的方法名，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">pathnameArr = pathname.split(<span class=\"hljs-string\">'/'</span>);\n</div></li><li><div class=\"code-word\">pathnameArr.shift();\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span>(pathnameArr.length &lt; <span class=\"hljs-number\">2</span>){\n</div></li><li><div class=\"code-word\">  baseFun.setResInfo(ctx, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">'path not found'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">404</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> next();\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> method = pathnameArr.pop();\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188943\">\n                      其他部分的代码基本相似，你要使用这个新的路由的话，直接在\n                      app.js 中打开这段注释即可。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> routerMiddleware = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/router'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//const routerMiddleware = require('./src/middleware/newRouter');</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> logCenter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/logCenter'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> session = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/middleware/session'</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188945\">\n                      打开以后，你就可以按照如下方式来请求了：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:3000/v1/test/index</span>\n</div></li><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:3000/content/test</span>\n</div></li><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:3000/v1/test/index-test</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"188947\">这样都可以返回正常的数据。</p>\n                    <h3 data-nodeid=\"188948\">总结</h3>\n                    <p data-nodeid=\"188949\">\n                      本讲先介绍了内存泄漏的概念，以及 Node.js\n                      的内存回收机制，其次介绍了一些内存泄漏分类，着重介绍了内存泄漏的分析方法，其中如何<strong\n                        data-nodeid=\"189185\"\n                        >一步步定位到泄漏的代码</strong\n                      >是本讲核心知识点，希望你可以多尝试一些内存泄漏的案例来自我分析，比如闭包会导致内存泄漏，那么应该如何进行分析和定位呢？可以将你的答案写在评论区。\n                    </p>\n                    <p data-nodeid=\"190262\">\n                      下一讲我们将进行一些压测工具的应用介绍，以及如何在压测过程中一步步进行性能分析优化，并且介绍一些常见性能优化方案。\n                    </p>\n                    <hr data-nodeid=\"190263\" />\n                    <p data-nodeid=\"190264\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"190272\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"190271\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"190265\">\n                      <strong data-nodeid=\"190276\">《大前端高薪训练营》</strong>\n                    </p>\n                    <p data-nodeid=\"190266\" class=\"te-preview-highlight\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"190280\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}