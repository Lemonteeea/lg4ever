{"title":"05 | 响应式：响应式内部的实现原理是怎样的？（上）","context":"\n                    <p data-nodeid=\"784\" class=\"\">\n                      上一节课我们学习了 Composition API 的核心 setup\n                      函数的实现，在 setup 函数中，我们多次使用一些 API\n                      让数据变成响应式，那么这节课我们就来深入学习响应式内部的实现原理。\n                    </p>\n                    <p data-nodeid=\"785\">\n                      除了组件化，Vue.js 另一个核心设计思想就是<strong\n                        data-nodeid=\"870\"\n                        >响应式</strong\n                      >。它的本质是当数据变化后会自动执行某个函数，映射到组件的实现就是，当数据变化后，会自动触发组件的重新渲染。<strong\n                        data-nodeid=\"871\"\n                        >响应式是 Vue.js 组件化更新渲染的一个核心机制</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"786\">\n                      在介绍 Vue.js 3.0 响应式实现之前，我们先来回顾一下 Vue.js\n                      2.x 响应式实现的部分： 它在内部通过 Object.defineProperty\n                      API\n                      劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新。我们用一张图可以直观地看清这个流程。\n                    </p>\n                    <p data-nodeid=\"787\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/36/C0/CgqCHl8YAPSAYotsAAG17TKWHiQ421.png\"\n                        alt=\"6.png\"\n                        data-nodeid=\"875\"\n                      />\n                    </p>\n                    <p data-nodeid=\"788\">\n                      在 Vue.js 2.x 中，Watcher 就是依赖，有专门针对组件渲染的\n                      render watcher。注意这里有两个流程，首先是<strong\n                        data-nodeid=\"881\"\n                        >依赖收集流程</strong\n                      >，组件在 render 的时候会访问模板中的数据，触发 getter 把\n                      render watcher\n                      作为依赖收集，并和数据建立联系；然后是派发通知流程，当我对这些数据修改的时候，会触发\n                      setter，通知 render watcher\n                      更新，进而触发了组件的重新渲染。\n                    </p>\n                    <p data-nodeid=\"789\">\n                      在导读章节，我们提到了 Object.defineProperty API\n                      的一些缺点：不能监听对象属性新增和删除；初始化阶段递归执行\n                      Object.defineProperty 带来的性能负担。\n                    </p>\n                    <p data-nodeid=\"790\">\n                      Vue.js 3.0 为了解决 Object.defineProperty 的这些缺陷，使用\n                      Proxy API 重写了响应式部分，并独立维护和发布整个\n                      reactivity 库，下面我们就一起来深入学习 Vue.js 3.0\n                      响应式部分的实现原理。\n                    </p>\n                    <h3 data-nodeid=\"791\">响应式对象的实现差异</h3>\n                    <p data-nodeid=\"792\">\n                      在\n                      <strong data-nodeid=\"890\">Vue.js 2.x 中</strong\n                      >构建组件时，只要我们在 data、props、computed\n                      中定义数据，那么它就是响应式的，举个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"random\"</span>&gt;</span>Random msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'msg reactive'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">methods</span>: {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-title\">random</span>(<span class=\"hljs-params\"></span>)</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-built_in\">Math</span>.random()\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"794\">\n                      上述组件初次渲染会显示“msg\n                      reactive”，当我们点击按钮的时候，会执行 random\n                      函数，random 函数会修改 this.msg，就会发现组件重新渲染了。\n                    </p>\n                    <p data-nodeid=\"795\">\n                      我们对这个例子做一些改动，模板部分不变，我们把 msg\n                      数据的定义放到created 钩子中：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-string\">'msg not reactive'</span>\n</div></li><li><div class=\"code-word\">  }, \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-attr\">methods</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-title\">random</span>(<span class=\"hljs-params\"></span>)</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-built_in\">Math</span>.random()\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"797\">\n                      此时，组件初次渲染显示“msg not\n                      reactive”，但是我们再次点击按钮就会发现组件并没有重新渲染。\n                    </p>\n                    <p data-nodeid=\"798\">\n                      这个问题相信你可能遇到过，其中的根本原因是我们在 created\n                      中定义的 this.msg 并不是响应式对象，所以 Vue.js\n                      内部不会对它做额外的处理。而 data 中定义的数据，Vue.js\n                      内部在组件初始化的过程中会把它变成响应式，这是一个相对黑盒的过程，用户通常不会感知到。\n                    </p>\n                    <p data-nodeid=\"799\">\n                      你可能会好奇，为什么我在 created 钩子函数中定义数据而不在\n                      data 中去定义？其实在 data\n                      中定义数据最终也是挂载到组件实例 this 上，这和我直接在\n                      created 钩子函数通过 this.xxx 定义的数据唯一区别就是，在\n                      data 中定义的数据<strong data-nodeid=\"900\"\n                        >是响应式的</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1045\" class=\"\">\n                      在一些场景下，如果我们仅仅想在组件上下文中共享某个变量，而不必去监测它的<del\n                        data-nodeid=\"1051\"\n                        >这个数据</del\n                      >变化，这时就特别适合在 created\n                      钩子函数中去定义这个变量，因为创建响应式的过程是有性能代价的，这相当于一种\n                      Vue.js\n                      应用的性能优化小技巧，你掌握了这一点就可以在合适的场景中应用了。\n                    </p>\n\n                    <p data-nodeid=\"801\">\n                      到了\n                      <strong data-nodeid=\"916\">Vue.js 3.0</strong>\n                      构建组件时，你可以不依赖于 Options API，而<strong\n                        data-nodeid=\"917\"\n                        >使用 Composition API</strong\n                      >\n                      去编写。对于刚才的例子，我们可以用 Composition API\n                      这样改写：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ state.msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"random\"</span>&gt;</span>Random msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> { reactive } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> state = reactive({\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'msg reactive'</span>\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> random = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">        state.msg = <span class=\"hljs-built_in\">Math</span>.random()\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        random,\n</div></li><li><div class=\"code-word\">        state\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"803\">\n                      可以看到，我们通过 setup\n                      函数实现和前面示例同样的功能。请注意，这里我们引入了\n                      <strong data-nodeid=\"923\"\n                        >reactive API，它可以把一个对象数据变成响应式。</strong\n                      >\n                      可以看出来 Composition API\n                      更推荐用户主动定义响应式对象，而非内部的黑盒处理。这样用户可以更加明确哪些数据是响应式的，如果你不想让数据变成响应式，就定义成它的原始数据类型即可。\n                    </p>\n                    <p data-nodeid=\"804\">\n                      也就是在 Vue.js 3.0 中，我们用 reactive\n                      这个有魔力的函数，把数据变成了响应式，那么它内部到底是怎么实现的呢？我们接下来一探究竟。\n                    </p>\n                    <h3 data-nodeid=\"805\">Reactive API</h3>\n                    <p data-nodeid=\"806\">\n                      我们先来看一下 reactive 函数的具体实现过程：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reactive</span> (<span class=\"hljs-params\">target</span>) </span>{\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (target &amp;&amp; target.__v_isReadonly) {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> target\n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> createReactiveObject(target, <span class=\"hljs-literal\">false</span>, mutableHandlers, mutableCollectionHandlers)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createReactiveObject</span>(<span class=\"hljs-params\">target, isReadonly, baseHandlers, collectionHandlers</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!isObject(target)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 目标必须是对象或数组类型</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> ((process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">\\`value cannot be made reactive: <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">String</span>(target)}</span>\\`</span>)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> target\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (target.__v_raw &amp;&amp; !(isReadonly &amp;&amp; target.__v_isReactive)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// target 已经是 Proxy 对象，直接返回</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 有个例外，如果是 readonly 作用于一个响应式对象，则继续</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> target\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (hasOwn(target, isReadonly ? <span class=\"hljs-string\">\"__v_readonly\"</span> <span class=\"hljs-comment\">/* readonly */</span> : <span class=\"hljs-string\">\"__v_reactive\"</span> <span class=\"hljs-comment\">/* reactive */</span>)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// target 已经有对应的 Proxy 了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> isReadonly ? target.__v_readonly : target.__v_reactive\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 只有在白名单里的数据类型才能变成响应式</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!canObserve(target)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> target\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 利用 Proxy 创建响应式</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> observed = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了</span>\n</div></li><li><div class=\"code-word\">  def(target, isReadonly ? <span class=\"hljs-string\">\"__v_readonly\"</span> <span class=\"hljs-comment\">/* readonly */</span> : <span class=\"hljs-string\">\"__v_reactive\"</span> <span class=\"hljs-comment\">/* reactive */</span>, observed)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> observed\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"808\">\n                      可以看到，reactive 内部通过 createReactiveObject 函数把\n                      target 变成了一个响应式对象。\n                    </p>\n                    <p data-nodeid=\"809\">\n                      在这个过程中，createReactiveObject\n                      函数主要做了以下几件事情。\n                    </p>\n                    <p data-nodeid=\"810\">\n                      1.函数首先判断 target\n                      是不是数组或者对象类型，如果不是则直接返回。所以<strong\n                        data-nodeid=\"936\"\n                        >原始数据 target 必须是对象或者数组</strong\n                      >。<br />\n                      2.如果对一个已经是响应式的对象再次执行\n                      reactive，还应该返回这个响应式对象，举个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { reactive } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> original = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span> }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> observed = reactive(original)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> observed2 = reactive(observed)\n</div></li><li><div class=\"code-word\">observed === observed2\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"812\">\n                      可以看到 observed 已经是响应式结果了，如果对它再去执行\n                      reactive，返回的值 observed2 和 observed\n                      还是同一个对象引用。\n                    </p>\n                    <p data-nodeid=\"813\">\n                      因为这里 reactive 函数会通过 target.__v_raw 属性来判断\n                      target 是否已经是一个响应式对象（因为响应式对象的 __v_raw\n                      属性会指向它自身，后面会提到），如果是的话则直接返回响应式对象。\n                    </p>\n                    <p data-nodeid=\"814\">\n                      3.如果对同一个原始数据多次执行 reactive\n                      ，那么会返回相同的响应式对象，举个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { reactive } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> original = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span> }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> observed = reactive(original)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> observed2 = reactive(original)\n</div></li><li><div class=\"code-word\">observed === observed2\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"816\">\n                      可以看到，原始数据 original 被反复执行\n                      reactive，但是响应式结果 observed 和 observed2\n                      是同一个对象。\n                    </p>\n                    <p data-nodeid=\"817\">\n                      所以这里 reactive 函数会通过 target.__v_reactive 判断\n                      target\n                      是否已经有对应的响应式对象（因为创建完响应式对象后，会给原始对象打上\n                      __v_reactive\n                      标识，后面会提到），如果有则返回这个响应式对象。\n                    </p>\n                    <p data-nodeid=\"818\">\n                      4.使用 canObserve 函数对 target 对象做一进步限制：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> canObserve = <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> (!value.__v_skip &amp;&amp;\n</div></li><li><div class=\"code-word\">   isObservableType(toRawType(value)) &amp;&amp;\n</div></li><li><div class=\"code-word\">   !<span class=\"hljs-built_in\">Object</span>.isFrozen(value))\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isObservableType = <span class=\"hljs-comment\">/*#__PURE__*/</span> makeMap(<span class=\"hljs-string\">'Object,Array,Map,Set,WeakMap,WeakSet'</span>)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"820\">\n                      比如，带有 __v_skip\n                      属性的对象、被冻结的对象，以及不在白名单内的对象如 Date\n                      类型的对象实例是不能变成响应式的。\n                    </p>\n                    <p data-nodeid=\"821\">\n                      5.通过 Proxy API 劫持 target 对象，把它变成响应式。我们把\n                      Proxy 函数返回的结果称作响应式对象，这里 Proxy\n                      对应的处理器对象会根据数据类型的不同而不同，我们稍后会重点分析基本数据类型的\n                      Proxy 处理器对象，reactive 函数传入的 baseHandlers 值是\n                      mutableHandlers。\n                    </p>\n                    <p data-nodeid=\"822\">6.给原始数据打个标识，如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">target.__v_reactive = observed\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"824\">\n                      这就是前面“对同一个原始数据多次执行 reactive\n                      ，那么会返回相同的响应式对象”逻辑的判断依据。\n                    </p>\n                    <p data-nodeid=\"825\">\n                      仔细想想看，响应式的实现方式无非就是劫持数据，Vue.js 3.0\n                      的 reactive API 就是通过 Proxy 劫持数据，而且由于 Proxy\n                      劫持的是整个对象，所以我们可以检测到任何对对象的修改，弥补了\n                      Object.defineProperty API 的不足。\n                    </p>\n                    <p data-nodeid=\"826\">\n                      接下来，我们继续看 Proxy 处理器对象 mutableHandlers\n                      的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> mutableHandlers = {\n</div></li><li><div class=\"code-word\">  get,\n</div></li><li><div class=\"code-word\">  set,\n</div></li><li><div class=\"code-word\">  deleteProperty,\n</div></li><li><div class=\"code-word\">  has,\n</div></li><li><div class=\"code-word\">  ownKeys\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"828\">\n                      它其实就是劫持了我们对 observed 对象的一些操作，比如：\n                    </p>\n                    <ul data-nodeid=\"829\">\n                      <li data-nodeid=\"830\">\n                        <p data-nodeid=\"831\">访问对象属性会触发 get 函数；</p>\n                      </li>\n                      <li data-nodeid=\"832\">\n                        <p data-nodeid=\"833\">设置对象属性会触发 set 函数；</p>\n                      </li>\n                      <li data-nodeid=\"834\">\n                        <p data-nodeid=\"835\">\n                          删除对象属性会触发 deleteProperty 函数；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"836\">\n                        <p data-nodeid=\"837\">in 操作符会触发 has 函数；</p>\n                      </li>\n                      <li data-nodeid=\"838\">\n                        <p data-nodeid=\"839\">\n                          通过 Object.getOwnPropertyNames 访问对象属性名会触发\n                          ownKeys 函数。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"840\">\n                      因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的\n                      get 和 set 函数就可以了。\n                    </p>\n                    <h4 data-nodeid=\"841\">依赖收集：get 函数</h4>\n                    <p data-nodeid=\"842\">\n                      <strong data-nodeid=\"986\"\n                        >依赖收集发生在数据访问的阶段</strong\n                      >，由于我们用 Proxy API\n                      劫持了数据对象，所以当这个响应式对象属性被访问的时候就会执行\n                      get 函数，我们来看一下 get 函数的实现，其实它是执行\n                      createGetter 函数的返回值，为了分析主要流程，这里省略了\n                      get 函数中的一些分支逻辑，isReadonly 也默认为 false：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createGetter</span>(<span class=\"hljs-params\">isReadonly = <span class=\"hljs-literal\">false</span></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span>(<span class=\"hljs-params\">target, key, receiver</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">\"__v_isReactive\"</span> <span class=\"hljs-comment\">/* isReactive */</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 代理 observed.__v_isReactive</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> !isReadonly\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">\"__v_isReadonly\"</span> <span class=\"hljs-comment\">/* isReadonly */</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 代理 observed.__v_isReadonly</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> isReadonly;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">\"__v_raw\"</span> <span class=\"hljs-comment\">/* raw */</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 代理 observed.__v_raw</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> target\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> targetIsArray = isArray(target)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// arrayInstrumentations 包含对数组一些方法修改的函数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.get(arrayInstrumentations, key, receiver)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 求值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-built_in\">Reflect</span>.get(target, key, receiver)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 内置 Symbol key 不需要依赖收集</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (isSymbol(key) &amp;&amp; builtInSymbols.has(key) || key === <span class=\"hljs-string\">'__proto__'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> res\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 依赖收集</span>\n</div></li><li><div class=\"code-word\">    !isReadonly &amp;&amp; track(target, <span class=\"hljs-string\">\"get\"</span> <span class=\"hljs-comment\">/* GET */</span>, key)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> isObject(res)\n</div></li><li><div class=\"code-word\">      ? isReadonly\n</div></li><li><div class=\"code-word\">        ?\n</div></li><li><div class=\"code-word\">        readonly(res)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span>\n</div></li><li><div class=\"code-word\">        : reactive(res)\n</div></li><li><div class=\"code-word\">      : res\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"844\">\n                      结合上述代码来看，get 函数主要做了四件事情，<strong\n                        data-nodeid=\"997\"\n                        >首先对特殊的 key 做了代理</strong\n                      >，这就是为什么我们在 createReactiveObject\n                      函数中判断响应式对象是否存在 __v_raw\n                      属性，如果存在就返回这个响应式对象本身。\n                    </p>\n                    <p data-nodeid=\"845\">\n                      <strong data-nodeid=\"1002\"\n                        >接着通过 Reflect.get 方法求值</strong\n                      >，如果 target 是数组且 key 命中了\n                      arrayInstrumentations，则执行对应的函数，我们可以大概看一下\n                      arrayInstrumentations 的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> arrayInstrumentations = {}\n</div></li><li><div class=\"code-word\">[<span class=\"hljs-string\">'includes'</span>, <span class=\"hljs-string\">'indexOf'</span>, <span class=\"hljs-string\">'lastIndexOf'</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">  arrayInstrumentations[key] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// toRaw 可以把响应式对象转成原始数据</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> arr = toRaw(<span class=\"hljs-built_in\">this</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, l = <span class=\"hljs-built_in\">this</span>.length; i &lt; l; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 依赖收集</span>\n</div></li><li><div class=\"code-word\">      track(arr, <span class=\"hljs-string\">\"get\"</span> <span class=\"hljs-comment\">/* GET */</span>, i + <span class=\"hljs-string\">''</span>)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 先尝试用参数本身，可能是响应式数据</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> res = arr[key](...args)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (res === -<span class=\"hljs-number\">1</span> || res === <span class=\"hljs-literal\">false</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果失败，再尝试把参数转成原始数据</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> arr[key](...args.map(toRaw))\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> res\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"847\">\n                      也就是说，当 target 是一个数组的时候，我们去访问\n                      target.includes、target.indexOf 或者 target.lastIndexOf\n                      就会执行 arrayInstrumentations\n                      代理的函数，除了调用数组本身的方法求值外，还对数组每个元素做了依赖收集。因为一旦数组的元素被修改，数组的这几个\n                      API\n                      的返回结果都可能发生变化，所以我们需要跟踪数组每个元素的变化。\n                    </p>\n                    <p data-nodeid=\"848\">\n                      回到 get 函数，第三步就是<strong data-nodeid=\"1009\"\n                        >通过 Reflect.get 求值，然后会执行 track\n                        函数收集依赖</strong\n                      >，我们稍后重点分析这个过程。\n                    </p>\n                    <p data-nodeid=\"849\">\n                      函数最后<strong data-nodeid=\"1015\"\n                        >会对计算的值 res 进行判断</strong\n                      >，如果它也是数组或对象，则递归执行 reactive 把 res\n                      变成响应式对象。这么做是因为 Proxy\n                      劫持的是对象本身，并不能劫持子对象的变化，这点和\n                      Object.defineProperty API 一致。但是 Object.defineProperty\n                      是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而\n                      Proxy 是在对象属性被访问的时候才递归执行下一步\n                      reactive，这其实是一种延时定义子对象响应式的实现，在性能上会有较大的提升。\n                    </p>\n                    <p data-nodeid=\"850\">\n                      整个 get 函数最核心的部分其实是<strong data-nodeid=\"1021\"\n                        >执行 track 函数收集依赖</strong\n                      >，下面我们重点分析这个过程。\n                    </p>\n                    <p data-nodeid=\"851\">我们先来看一下 track 函数的实现：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否应该收集依赖</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> shouldTrack = <span class=\"hljs-literal\">true</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 当前激活的 effect</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> activeEffect\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 原始数据对象 map</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> targetMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>()\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">track</span>(<span class=\"hljs-params\">target, type, key</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!shouldTrack || activeEffect === <span class=\"hljs-literal\">undefined</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">let</span> depsMap = targetMap.get(target)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!depsMap) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 每个 target 对应一个 depsMap</span>\n</div></li><li><div class=\"code-word\">    targetMap.set(target, (depsMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()))\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">let</span> dep = depsMap.get(key)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!dep) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 每个 key 对应一个 dep 集合</span>\n</div></li><li><div class=\"code-word\">    depsMap.set(key, (dep = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()))\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!dep.has(activeEffect)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 收集当前激活的 effect 作为依赖</span>\n</div></li><li><div class=\"code-word\">    dep.add(activeEffect)\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 当前激活的 effect 收集 dep 集合作为依赖</span>\n</div></li><li><div class=\"code-word\">    activeEffect.deps.push(dep)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"853\">\n                      分析这个函数的实现前，我们先想一下要收集的依赖是什么，我们的目的是实现响应式，就是当数据变化的时候可以自动做一些事情，比如执行某些函数，所以我们<strong\n                        data-nodeid=\"1028\"\n                        >收集的依赖就是数据变化后执行的副作用函数</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"854\">\n                      再来看实现，我们把 target 作为原始的数据，key\n                      作为访问的属性。我们创建了全局的 targetMap\n                      作为原始数据对象的 Map，它的键是 target，值是\n                      depsMap，作为依赖的 Map；这个 depsMap 的键是 target 的\n                      key，值是 dep 集合，dep\n                      集合中存储的是依赖的副作用函数。为了方便理解，可以通过下图表示它们之间的关系：\n                    </p>\n                    <p data-nodeid=\"855\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/36/B5/Ciqc1F8YAL6Afvr-AAEj_nQbDuE332.png\"\n                        alt=\"7.png\"\n                        data-nodeid=\"1032\"\n                      />\n                    </p>\n                    <p data-nodeid=\"856\">\n                      所以每次 track ，就是把当前激活的副作用函数 activeEffect\n                      作为依赖，然后收集到 target 相关的 depsMap 对应 key\n                      下的依赖集合 dep 中。\n                    </p>\n                    <p data-nodeid=\"857\">\n                      了解完依赖收集的过程，下节课我们来分析派发通知的过程。\n                    </p>\n                    <blockquote data-nodeid=\"858\">\n                      <p data-nodeid=\"859\" class=\"\">\n                        <strong data-nodeid=\"1044\"\n                          >本节课的相关代码在源代码中的位置如下：</strong\n                        ><br />\n                        packages/reactivity/src/baseHandlers.ts<br />\n                        packages/reactivity/src/effect.ts<br />\n                        packages/reactivity/src/reactive.ts\n                      </p>\n                    </blockquote>\n            "}