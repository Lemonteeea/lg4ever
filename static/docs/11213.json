{"title":"11 | Tree Shaking：移除 JavaScript 上下文中的未引用代码","context":"\n                    <p data-nodeid=\"76796\">\n                      时至今日，Tree Shaking\n                      对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree\n                      Shaking 译为“摇树”，它通常用于描述移除 JavaScript\n                      上下文中的未引用代码（dead-code）。\n                    </p>\n                    <p data-nodeid=\"76797\">\n                      据我观察，Tree Shaking\n                      也经常出现在诸多候选人的简历当中。然而可惜的是，大部分候选人都知道\n                      Tree Shaking\n                      的定义，但“知其然不知其所以然”，并没有在工程中真正实践过\n                      Tree Shaking 技术，更没有深入理解 Tree Shaking\n                      这个概念。社区上一些好的文章，比如<a\n                        href=\"https://github.com/wuomzfx/tree-shaking-test\"\n                        data-nodeid=\"76953\"\n                        >《你的 Tree-Shaking 并没什么卵用》</a\n                      >发布于 2018 年初，但就目前来看，其中内容也有些“过期”了。\n                    </p>\n                    <p data-nodeid=\"76798\">\n                      这一节，就让我们真正深入学习 Tree Shaking 这个概念。\n                    </p>\n                    <h3 data-nodeid=\"76799\">Tree Shaking 必备理论</h3>\n                    <p data-nodeid=\"76800\">\n                      Tree Shaking 概念很好理解，这个词最先在 Rollup\n                      社区流行，后续蔓延到整个前端生态。Tree Shaking\n                      背后的理论知识独成体系，我们先从其原理入手，试着分析并回答以下问题。\n                    </p>\n                    <h4 data-nodeid=\"76801\">\n                      问题一：Tree Shaking 为什么要依赖 ESM 规范？\n                    </h4>\n                    <p data-nodeid=\"76802\">\n                      事实上，Tree Shaking\n                      是在编译时进行无用代码消除的，因此它<strong\n                        data-nodeid=\"76964\"\n                        >需要在编译时确定依赖关系</strong\n                      >，进而确定哪些代码可以被“摇掉”，而 ESM 具备以下特点：\n                    </p>\n                    <ul data-nodeid=\"76803\">\n                      <li data-nodeid=\"76804\">\n                        <p data-nodeid=\"76805\">import 模块名只能是字符串常量</p>\n                      </li>\n                      <li data-nodeid=\"76806\">\n                        <p data-nodeid=\"76807\">\n                          import 一般只能在模块的最顶层出现\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76808\">\n                        <p data-nodeid=\"76809\">\n                          import binding 是 immutable 的\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76810\">\n                      这些特点使得 ESM 具有静态分析能力。而<strong\n                        data-nodeid=\"76973\"\n                        >CommonJS\n                        定义的模块化规范，只有在执行代码后，才能动态确定依赖模块</strong\n                      >，因此不具备 Tree Shaking 的先天条件。\n                    </p>\n                    <p data-nodeid=\"76811\">\n                      在传统编译型语言中，一般由编译器将无用代码在\n                      AST（抽象语法树）中删除，而前端 JavaScript\n                      并没有正统“编译器”这个概念，那么 Tree Shaking\n                      就需要在工程链中由工程化工具完成。\n                    </p>\n                    <h4 data-nodeid=\"76812\">\n                      问题二：什么是副作用模块，如何对副作用模块进行 Tree\n                      Shaking?\n                    </h4>\n                    <p data-nodeid=\"76813\">\n                      如果你熟悉函数式开发理念，可能听说过“副作用函数”，但什么是“副作用模块”呢？它又和\n                      Tree Shaking 有什么关联呢？很多人清楚的 Tree Shaking\n                      只是皮毛，而并不清楚 Tree Shaking\n                      并不能“摇掉”副作用模块，具体我们看这样一段代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(a, b)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> a + b\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">export <span class=\"hljs-keyword\">const</span> memoizedAdd = window.memoize(add)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76815\">\n                      当该模块被 import 时，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"76978\"\n                        >window.memoize</code\n                      >方法会被执行，那么对于工程化工具（比如\n                      Webpack）来说，分析思路是这样的：\n                    </p>\n                    <ul data-nodeid=\"76816\">\n                      <li data-nodeid=\"76817\">\n                        <p data-nodeid=\"76818\">\n                          创建一个纯函数<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"76981\"\n                            >add</code\n                          >，如果没有其他模块引用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"76983\"\n                            >add</code\n                          >函数，那么<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"76985\"\n                            >add</code\n                          >函数可以被 Tree Shaking 掉；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76819\">\n                        <p data-nodeid=\"76820\">\n                          接着调用<code data-backticks=\"1\" data-nodeid=\"76988\"\n                            >window.memoize</code\n                          >方法，并传入<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"76990\"\n                            >add</code\n                          >函数作为其参数；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76821\">\n                        <p data-nodeid=\"76822\">\n                          工程化工具（比如 Webpack）并不知道<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"76993\"\n                            >window.memoize</code\n                          >方法会做什么事情，也许<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"76995\"\n                            >window.memoize</code\n                          >方法会调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"76997\"\n                            >add</code\n                          >函数，并触发某些副作用（比如维护一个全局的 Cache\n                          Map）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76823\">\n                        <p data-nodeid=\"76824\">\n                          工程化工具（比如\n                          Webpack）为了安全起见，即便没有其他模块依赖的<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"77000\"\n                            >add</code\n                          >函数，那么也要将<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"77002\"\n                            >add</code\n                          >函数打包到最后的 bundle 中。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76825\">\n                      因此，具有副作用的模块难以被 Tree Shaking\n                      优化，即便开发者知道<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77005\"\n                        >window.memoize</code\n                      >方法是无副作用的。\n                    </p>\n                    <p data-nodeid=\"76826\">\n                      为了解决“具有副作用的模块难以被 Tree Shaking\n                      优化”这个问题，Webpack 给出了自己的方案，我们可以利用\n                      package.json 的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77008\"\n                        >sideEffects</code\n                      >属性来告诉工程化工具哪些模块具有副作用，哪些剩余模块没有副作用，可以被\n                      Tree Shaking 优化：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"your-project\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"sideEffects\"</span>: <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76828\">\n                      表示全部代码均无副作用，告知\n                      webpack，它可以安全地删除未用到的 export 导出。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"your-project\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"sideEffects\"</span>: [\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"./src/some-side-effectful-file.js\"</span>，\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"*.css\"</span>\n</div></li><li><div class=\"code-word\">  ]\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76830\">\n                      通过数组表示，<code data-backticks=\"1\" data-nodeid=\"77012\"\n                        >./src/some-side-effectful-file.js</code\n                      >和所有<code data-backticks=\"1\" data-nodeid=\"77014\"\n                        >.css</code\n                      >文件模块都有副作用。对于 Webpack 工具，<strong\n                        data-nodeid=\"77026\"\n                        >开发者可以在</strong\n                      ><a\n                        href=\"https://github.com/webpack/webpack/issues/6065#issuecomment-351060570\"\n                        data-nodeid=\"77021\"\n                        >module.rule</a\n                      ><strong data-nodeid=\"77027\">配置中声明副作用模块</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"76831\">\n                      事实上，仅对上面<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77029\"\n                        >add</code\n                      >函数，即便不通过声明 sideEffects，Webpack\n                      也足够智能，能够分析出可 Tree Shaking\n                      掉的部分，不过这需要我们对上述代码进行重构：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { memoize } from <span class=\"hljs-string\">'./util'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(a, b)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> a + b\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">export <span class=\"hljs-keyword\">const</span> memoizedAdd = memoize(add)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76833\">此时 Webpack 的分析逻辑：</p>\n                    <ul data-nodeid=\"76834\">\n                      <li data-nodeid=\"76835\">\n                        <p data-nodeid=\"76836\">\n                          <code data-backticks=\"1\" data-nodeid=\"77032\"\n                            >memoize</code\n                          >函数是一个 ESM 模块，我们去<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"77034\"\n                            >util.js</code\n                          >中检查一下<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"77036\"\n                            >memoize</code\n                          >函数内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76837\">\n                        <p data-nodeid=\"76838\">\n                          在<code data-backticks=\"1\" data-nodeid=\"77039\"\n                            >util.js</code\n                          >中，发现<code data-backticks=\"1\" data-nodeid=\"77041\"\n                            >memoize</code\n                          >函数是一个纯函数，因此如果<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"77043\"\n                            >add</code\n                          >函数没有被其他模块依赖，可以被安全 Tree Shaking 掉。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76839\">\n                      所以，我们能得出一个 Tree Shaking\n                      友好的最佳实践——在业务项目中，设置最小化副作用范围，同时通过合理的配置，给工程化工具最多的副作用信息。\n                    </p>\n                    <p data-nodeid=\"76840\">\n                      下面，我们再来看一个 Tree Shaking 友好的实践案例。\n                    </p>\n                    <h4 data-nodeid=\"76841\">\n                      一个 Tree Shaking 友好的导出模式\n                    </h4>\n                    <p data-nodeid=\"76842\">参考以下代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">\tadd(a, b) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">return</span> a + b\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\tsubtract(a, b) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">return</span> a - b\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76844\">以及：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Number</span> </span>{\n</div></li><li><div class=\"code-word\">\tconstructor(num) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">this</span>.num = num\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\tadd(otherNum) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.num + otherNum\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\tsubtract(otherNum) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.num - otherNum\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76846\">\n                      对于上述情况，以 Webpack 为例，<strong data-nodeid=\"77055\"\n                        >Webpack 将会趋向保留整个默认导出对象/class</strong\n                      >（Webpack 和 Rollup 只处理函数和顶层的 import/export\n                      变量，不能把没用到的类或对象内部的方法消除掉）。\n                    </p>\n                    <p data-nodeid=\"76847\">因此：</p>\n                    <ul data-nodeid=\"76848\">\n                      <li data-nodeid=\"76849\">\n                        <p data-nodeid=\"76850\">\n                          导出一个包含多项属性和方法的对象\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76851\">\n                        <p data-nodeid=\"76852\">\n                          导出一个包含多项属性和方法的 class\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76853\">\n                        <p data-nodeid=\"76854\">\n                          使用<code data-backticks=\"1\" data-nodeid=\"77060\"\n                            >export default</code\n                          >导出\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76855\">\n                      都不利于 Tree Shaking。即便现代化工程工具或 Webpack\n                      支持对于对象或 class 的方法属性剪裁（比如\n                      webpack-deep-scope-plugin 这个插件的设计，或 Webpack 和\n                      Rollup\n                      新版本的跟进），这些都产生了不必要的成本，增加了编译时负担。\n                    </p>\n                    <p data-nodeid=\"76856\">\n                      我们更加推荐的原则是：<strong data-nodeid=\"77068\"\n                        >原子化和颗粒化导出</strong\n                      >。如下代码，就是一个更好的实践：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(a, b)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> a + b\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">subtract</span><span class=\"hljs-params\">(a, b)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> a - b\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76858\">\n                      这种方式可以让 Webpack 更好地在编译时掌控和分析 Tree\n                      Shaking 信息，取得一个更优的 bundle size。\n                    </p>\n                    <h3 data-nodeid=\"76859\">\n                      前端工程生态和 Tree Shaking 实践\n                    </h3>\n                    <p data-nodeid=\"76860\">\n                      通过上述内容，我们可以看出 Tree Shaking 依托于 ESM\n                      静态分析的理论技术，而真正的 Tree Shaking\n                      过程，还需要依靠前端工程工具实现。Tree Shaking\n                      链路当然也就和前端工程生态绑定在一起，我们继续从工程生态层面，分析\n                      Tree Shaking 实践。\n                    </p>\n                    <h4 data-nodeid=\"76861\">Babel 和 Tree Shaking</h4>\n                    <p data-nodeid=\"76862\">\n                      Babel 已经成为现代化工程和基建方案的必备工具，但是考虑到\n                      Tree Shaking，需要开发者注意：<strong data-nodeid=\"77078\"\n                        >如果使用 Babel 对代码进行编译，Babel 默认会将 ESM\n                        编译为 CommonJS 模块规范</strong\n                      >。而我们从前面理论知识知道，Tree Shaking 必须依托于 ESM。\n                    </p>\n                    <p data-nodeid=\"80123\" class=\"\">\n                      为此，我们需要配置 Babel\n                      对于模块化的编译降级，具体配置项在\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-preset-env#modules\"\n                        data-nodeid=\"80127\"\n                        >babel-preset-env#modules</a\n                      >\n                      中可以找到。\n                    </p>\n\n                    <p data-nodeid=\"76864\">\n                      但既然是“前端工程生态”，那问题就没这么好解决。事实上，如果我们不使用\n                      Babel 将代码编译为 CommonJS\n                      规范的代码，某些工程链上的工具可能就要罢工了。比如\n                      Jest，Jest 是基于 Node.js 开发的，运行在 Node.js\n                      环境。因此使用 Jest 进行测试时，也就需要模块符合 CommonJS\n                      规范，那么如何处理这种“模块死锁”呢？\n                    </p>\n                    <p data-nodeid=\"76865\">\n                      思路之一是<strong data-nodeid=\"77090\"\n                        >根据不同的环境，采用不同的 Babel 配置</strong\n                      >。在 production 编译环境中，我们配置：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">production: {\n</div></li><li><div class=\"code-word\">   presets: [\n</div></li><li><div class=\"code-word\">    [\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-string\">'@babel/preset-env'</span>,\n</div></li><li><div class=\"code-word\">     {\n</div></li><li><div class=\"code-word\">      modules: <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">    ]\n</div></li><li><div class=\"code-word\">   ]\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76867\">在测试环境中：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">test: {\n</div></li><li><div class=\"code-word\">   presets: [\n</div></li><li><div class=\"code-word\">    [\n</div></li><li><div class=\"code-word\">     '@babel/preset-env',\n</div></li><li><div class=\"code-word\">     {\n</div></li><li><div class=\"code-word\">      modules: 'commonjs\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">    ]\n</div></li><li><div class=\"code-word\">   ]\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76869\">\n                      但是在测试环境中，编译了业务代码为 CommonJS\n                      规范并没有大功告成，我们还需要处理第三方模块代码。一些第三方模块代码为了方便进行\n                      Tree Shaking，暴露出符合 ESM\n                      模块的代码，对于这些模块，比如\n                      Library1、Library2，我们还需要进行处理，这时候需要配置\n                      Jest：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> path = require(<span class=\"hljs-string\">'path'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> librariesToRecompile = [\n</div></li><li><div class=\"code-word\"> <span class=\"hljs-string\">'Library1'</span>,\n</div></li><li><div class=\"code-word\"> <span class=\"hljs-string\">'Library2'</span>\n</div></li><li><div class=\"code-word\">].join(<span class=\"hljs-string\">'|'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> config = {\n</div></li><li><div class=\"code-word\"> transformIgnorePatterns: [\n</div></li><li><div class=\"code-word\">  \\`[\\\\/]node_modules[\\\\/](?!(${librariesToRecompile})).*$\\`\n</div></li><li><div class=\"code-word\"> ],\n</div></li><li><div class=\"code-word\"> transform: {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'^.+\\.jsx?$'</span>: path.resolve(__dirname, <span class=\"hljs-string\">'transformer.js'</span>)\n</div></li><li><div class=\"code-word\"> }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84905\" class=\"\">\n                      <code data-backticks=\"1\" data-nodeid=\"84906\"\n                        >transformIgnorePatterns</code\n                      >是 Jest 的一个配置项，默认值为<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84908\"\n                        >node_modules</code\n                      >，它表示：<code data-backticks=\"1\" data-nodeid=\"84910\"\n                        >node_modules</code\n                      >中的第三方模块代码，都不需要经过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84912\"\n                        >babel-jest</code\n                      >编译。因此，<strong data-nodeid=\"84920\"\n                        >我们自定义\n                        <code data-backticks=\"1\" data-nodeid=\"84916\"\n                          >transformIgnorePatterns</code\n                        >的值为一个包含了 Library1、Library2\n                        的正则表达式即可</strong\n                      >。\n                    </p>\n\n                    <h4 data-nodeid=\"76872\">Webpack 和 Tree Shaking</h4>\n                    <p data-nodeid=\"76873\">\n                      上面我们已经讲解了很多关于 Webpack 处理 Tree Shaking\n                      的内容了，这里我们进一步补充。事实上，<strong\n                        data-nodeid=\"77117\"\n                        >Webpack4.0 以上版本在 mode 为 production 时，会自动开启\n                        Tree Shaking 能力</strong\n                      >。默认 production mode 的配置如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> config = {\n</div></li><li><div class=\"code-word\"> mode: <span class=\"hljs-string\">'production'</span>,\n</div></li><li><div class=\"code-word\"> optimization: {\n</div></li><li><div class=\"code-word\">  usedExports: <span class=\"hljs-keyword\">true</span>,\n</div></li><li><div class=\"code-word\">  minimizer: [\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">new</span> TerserPlugin({...}) <span class=\"hljs-comment\">// 支持删除死代码的压缩器</span>\n</div></li><li><div class=\"code-word\">  ]\n</div></li><li><div class=\"code-word\"> }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76875\">\n                      其实，Webpack 真正执行模块去除，是依赖了\n                      TerserPlugin、UglifyJS 等压缩插件。<strong\n                        data-nodeid=\"77123\"\n                        >Webpack\n                        负责对模块进行分析和标记，而这些压缩插件负责根据标记结果，进行代码删除</strong\n                      >。Webpack 在分析时，有三类相关的标记：\n                    </p>\n                    <ul data-nodeid=\"76876\">\n                      <li data-nodeid=\"76877\">\n                        <p data-nodeid=\"76878\">\n                          harmony export，被使用过的 export 会被标记为 harmony\n                          export；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76879\">\n                        <p data-nodeid=\"76880\">\n                          unused harmony export，没被使用过的 export 标记为\n                          unused harmony export；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76881\">\n                        <p data-nodeid=\"76882\">\n                          harmony import，所有 import 标记为 harmony import。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76883\">\n                      上述标记实现的 Webpack 源码在<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77128\"\n                        >lib/dependencies/</code\n                      >文件中，这里不再进行源码解读了。具体过程主要是：\n                    </p>\n                    <ul data-nodeid=\"76884\">\n                      <li data-nodeid=\"76885\">\n                        <p data-nodeid=\"76886\">\n                          Webpack 在编译分析阶段，将每一个模块放入 ModuleGraph\n                          中维护；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76887\">\n                        <p data-nodeid=\"76888\">\n                          依靠 HarmonyExportSpecifierDependency 和\n                          HarmonyImportSpecifierDependency 分别识别和处理 import\n                          以及 export；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76889\">\n                        <p data-nodeid=\"76890\">\n                          依靠 HarmonyExportSpecifierDependency 识别 used export\n                          和 unused export。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76891\">\n                      至此，我们理解了使用 Webpack 进行 Tree Shaking\n                      的原理。接下来，我们再看看著名的公共库都是如何处理 Tree\n                      Shaking 的。\n                    </p>\n                    <h4 data-nodeid=\"76892\">Vue 和 Tree Shaking</h4>\n                    <p data-nodeid=\"76893\">\n                      在 Vue 2.0 版本中，Vue 对象会存在一些全局 API，比如：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> Vue from <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\">Vue.nextTick(() =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76895\">\n                      如果我们没有使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77137\"\n                        >Vue.nextTick</code\n                      >方法，那么<code data-backticks=\"1\" data-nodeid=\"77139\"\n                        >nextTick</code\n                      >这样的全局 API 就成了 dead code，且不容易被 Tree Shaking\n                      掉。为此，在 Vue 3 中，Vue 团队考虑了 Tree Shaking\n                      兼容，进行了重构，<strong data-nodeid=\"77145\"\n                        >全局 API 需要通过原生 ES Module\n                        的引用方式进行具名引用</strong\n                      >，对应前面的代码，需要：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { nextTick } from <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\">nextTick(() =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76897\">\n                      除了这些全局 API ，Vue 3.0\n                      也实现了很多内置的组件以及工具的具名导出。这些都是前端生态中，公共库拥抱\n                      Tree Shaking 的表现。\n                    </p>\n                    <p data-nodeid=\"76898\">\n                      此外，我们也可以灵活使用 build-time flags\n                      来帮助构建工具实现 Tree Shaking。以 Webpack<a\n                        href=\"https://webpack.js.org/plugins/define-plugin/\"\n                        data-nodeid=\"77150\"\n                        >DefinePlugin </a\n                      >为例，下面代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { validateoptions } from <span class=\"hljs-string\">'./validation'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(options)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">if</span> (!__PRODUCTION__) {\n</div></li><li><div class=\"code-word\">\t\tvalidateoptions(options)\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76900\">\n                      通过<code data-backticks=\"1\" data-nodeid=\"77153\"\n                        >__PRODUCTION__</code\n                      >变量，在 production 环境下，我们可以将<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77155\"\n                        >validateoptions</code\n                      >函数进行删除。\n                    </p>\n                    <h4 data-nodeid=\"76901\">\n                      如何设计一个兼顾 Tree Shaking 和易用性的公共库\n                    </h4>\n                    <p data-nodeid=\"76902\">\n                      上面我们分析了 Vue 拥抱 Tree Shaking\n                      的例子，下面我们应该从另一个更宏观的角度看待这个问题。作为一个公共库的设计者，我们应该如何兼顾\n                      Tree Shaking 和易用性的公共库呢？\n                    </p>\n                    <p data-nodeid=\"76903\">\n                      试想，如果我们以 ESM\n                      的方式对外暴露代码，那么就很难直接兼容 CommonJS\n                      规范，也就是说<strong data-nodeid=\"77168\"\n                        >在 Node.js 环境中，使用者如果直接以 require\n                        方式引用的话，就会得到报错</strong\n                      >。<strong data-nodeid=\"77169\"\n                        >如果以 CommonJS 规范对外暴露代码，又不利于 Tree\n                        Shaking</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"76904\">\n                      因此，如果想要一个 npm 包既能向外提供 ESM\n                      规范的代码，又能向外提供 CommonJS\n                      规范的代码，我们就只能通过“协约”来定义清楚。实际上，npm<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77171\"\n                        >package.json</code\n                      >以及社区工程化规范，解决了这个问题：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"Library\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"dist/index.cjs.js\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"module\"</span>: <span class=\"hljs-string\">\"dist/index.esm.js\"</span>,\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76906\">\n                      其实，标准 package.json 语法中，只有一个入口<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77174\"\n                        >main</code\n                      >。作为公共库设计者，我们通过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77176\"\n                        >main</code\n                      >来暴露 CommonJS 规范打包的代码<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77178\"\n                        >dist/index.cjs.js</code\n                      >；在 Webpack 等构建工具中，又支持了<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77180\"\n                        >module</code\n                      >——这个新的入口字段。因此，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77182\"\n                        >module</code\n                      >并非 package.json\n                      的标准字段，而是打包工具专用的字段，用来指定符合 ESM\n                      标准的入口文件。\n                    </p>\n                    <p data-nodeid=\"76907\">\n                      这样一来，当<code data-backticks=\"1\" data-nodeid=\"77185\"\n                        >require('Library')</code\n                      >时，Webpack 会找到：<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77187\"\n                        >dist/index.cjs.js</code\n                      >；当<code data-backticks=\"1\" data-nodeid=\"77189\"\n                        >import Library from 'Library'</code\n                      >时，Webpack 会找到：<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77191\"\n                        >dist/index.esm.js</code\n                      >。\n                    </p>\n                    <p data-nodeid=\"76908\">\n                      这里我们不妨举一个著名的公共库例子，那就是 Lodash。Lodash\n                      其实并不支持 Tree Shaking，其<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77194\"\n                        >package.json</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"lodash\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"version\"</span>: <span class=\"hljs-string\">\"5.0.0\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"license\"</span>: <span class=\"hljs-string\">\"MIT\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"private\"</span>: <span class=\"hljs-keyword\">true</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"lodash.js\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"engines\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"node\"</span>: <span class=\"hljs-string\">\"&gt;=4.0.0\"</span>\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"85861\" class=\"\">\n                      只有一个<code data-backticks=\"1\" data-nodeid=\"85863\"\n                        >main</code\n                      >入口，且<code data-backticks=\"1\" data-nodeid=\"85865\"\n                        >lodash.js</code\n                      >是 UMD 形式的代码，不利于做到 Tree Shaking。为了支持 Tree\n                      shakibng，lodash 打包出来专门的\n                      <a\n                        href=\"https://www.npmjs.com/package/lodash-es\"\n                        data-nodeid=\"85869\"\n                        >lodash-es</a\n                      >，其<code data-backticks=\"1\" data-nodeid=\"85871\"\n                        >package.json</code\n                      >：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"lodash.js\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"module\"</span>: <span class=\"hljs-string\">\"lodash.js\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"lodash-es\"</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"sideEffects\"</span>: <span class=\"hljs-keyword\">false</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"76912\">\n                      由上述代码可知，lodash-es<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77208\"\n                        >main</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"77210\"\n                        >module</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"77212\"\n                        >sideEffects</code\n                      >三字段齐全，通过 ESM 导出，天然支持了 Tree Shaking。\n                    </p>\n                    <p data-nodeid=\"76913\">\n                      总之，万变不离其宗，只要我们掌握了 Tree Shaking\n                      的原理，那么在涉及公共库时，就能做到游刃有余，以各种形式支持到\n                      Tree Shaking。当然，普遍做法是在第三方库打包构建时，参考\n                      antd，一般都会构建出 lib/ 和 es/ 两个文件夹，并配置<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"77215\"\n                        >package.json</code\n                      >的<code data-backticks=\"1\" data-nodeid=\"77217\">main</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"77219\"\n                        >module</code\n                      >字段即可。\n                    </p>\n                    <h4 data-nodeid=\"76914\">CSS 和 Tree Shaking</h4>\n                    <p data-nodeid=\"76915\">\n                      以上内容都是针对 JavaScript 代码的 Tree\n                      Shaking，作为前端工程师，我们当然也要考虑对 CSS 文件做\n                      Tree Shaking。\n                    </p>\n                    <p data-nodeid=\"76916\">\n                      实现思路也很简单，<strong data-nodeid=\"77228\"\n                        >CSS 的 Tree Shaking\n                        要在样式表中，找出没有被应用到选择器样式，进行删除</strong\n                      >。那么我们只需要：\n                    </p>\n                    <ul data-nodeid=\"76917\">\n                      <li data-nodeid=\"76918\">\n                        <p data-nodeid=\"76919\">遍历所有 CSS 文件的选择器；</p>\n                      </li>\n                      <li data-nodeid=\"76920\">\n                        <p data-nodeid=\"76921\">\n                          根据所有 CSS 文件的选择器，在 JavaScript\n                          代码中进行选择器匹配；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"76922\">\n                        <p data-nodeid=\"76923\">\n                          如果没有匹配到，则删除对应选择器的样式代码。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76924\">\n                      如何遍历所有 CSS 文件的选择器呢？Babel 依靠 AST\n                      技术，完成了对 JavaScript\n                      代码的遍历分析，而在样式世界中，PostCSS 就起到了 Babel\n                      的作用。PostCSS 提供了一个解析器，它能够将 CSS 解析成 AST\n                      抽象语法树，<strong data-nodeid=\"77237\"\n                        >我们可以通过 PostCSS 插件对 CSS 对应的 AST\n                        进行操作，达到 Tree Shaking 的目的</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"76925\">PostCSS 原理如下图：</p>\n                    <p data-nodeid=\"88219\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/05/E0/Cip5yGABPraACuJCAAGHB98AwXg855.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"88222\"\n                      /><br />\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABPsGAfsSVAAGgxx7GqrU331.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"88226\"\n                      />\n                    </p>\n\n                    <div data-nodeid=\"89167\" class=\"\">\n                      <p style=\"text-align: center\">PostCSS 原理图</p>\n                    </div>\n\n                    <p data-nodeid=\"90106\" class=\"\">\n                      这里给大家推荐\n                      <a\n                        href=\"https://github.com/FullHuman/purgecss/tree/master/packages/purgecss-webpack-plugin\"\n                        data-nodeid=\"90110\"\n                        >purgecss-webpack-plugin</a\n                      >，其原理也很简单：\n                    </p>\n\n                    <ul data-nodeid=\"76930\">\n                      <li data-nodeid=\"76931\">\n                        <p data-nodeid=\"76932\">\n                          监听 Webpack compilation 完成阶段，从 compilation\n                          中找到所有的 CSS 文件（对应源码）：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PurgeCSSPlugin</span> </span>{\n</div></li><li><div class=\"code-word\">  options: UserDefinedOptions;\n</div></li><li><div class=\"code-word\">  purgedStats: PurgedStats = {};\n</div></li><li><div class=\"code-word\">  constructor(options: UserDefinedOptions) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.options = options;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  apply(compiler: Compiler): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">    compiler.hooks.compilation.tap(\n</div></li><li><div class=\"code-word\">      pluginName,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">this</span>.initializePlugin.bind(<span class=\"hljs-keyword\">this</span>)\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"76934\">\n                      <li data-nodeid=\"76935\">\n                        <p data-nodeid=\"76936\">\n                          将所有的 CSS 文件交给 PostCss 处理（<a\n                            href=\"https://github.com/FullHuman/purgecss/blob/84da7ca98872bae29317f88c4295b400a6c02d06/packages/purgecss/src/index.ts#L274\"\n                            data-nodeid=\"77255\"\n                            >源码</a\n                          >关键部分，对 CSS AST 应用规则）：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">walkThroughCSS</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">    root: postcss.Root,\n</div></li><li><div class=\"code-word\">    selectors: ExtractorResultSets\n</div></li><li><div class=\"code-word\">  ): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">    root.walk((node) =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (node.type === <span class=\"hljs-string\">\"rule\"</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.evaluateRule(node, selectors);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (node.type === <span class=\"hljs-string\">\"atrule\"</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.evaluateAtRule(node);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (node.type === <span class=\"hljs-string\">\"comment\"</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (isIgnoreAnnotation(node, <span class=\"hljs-string\">\"start\"</span>)) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">this</span>.ignore = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// remove ignore annotation</span>\n</div></li><li><div class=\"code-word\">          node.remove();\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isIgnoreAnnotation(node, <span class=\"hljs-string\">\"end\"</span>)) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">this</span>.ignore = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// remove ignore annotation</span>\n</div></li><li><div class=\"code-word\">          node.remove();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"76938\">\n                      <li data-nodeid=\"76939\">\n                        <p data-nodeid=\"76940\">\n                          利用 PostCss 插件能力，基于 AST\n                          技术，找出无用代码并进行删除。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"76941\">\n                      核心删除未使用 CSS 代码的逻辑在<a\n                        href=\"https://github.com/FullHuman/purgecss/blob/84da7ca98872bae29317f88c4295b400a6c02d06/packages/purgecss/src/index.ts#L617\"\n                        data-nodeid=\"77262\"\n                        ><code data-backticks=\"1\" data-nodeid=\"77260\"\n                          >purge</code\n                        >\n                        方法中</a\n                      >，这里我们不再展开。\n                    </p>\n                    <h3 data-nodeid=\"76942\">总结</h3>\n                    <p data-nodeid=\"76943\">\n                      本小节，我们分析了 Tree Shaking\n                      相关知识，我们发现这一理论内容还需要配合构建工具完成落地，而这一系列过程不只是想象中那样简单。\n                    </p>\n                    <p data-nodeid=\"91050\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABPt6AAFyMAAGLjLOlwJM945.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"91053\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"76945\">\n                      这里我想给你留一个思考题，Rollup 是如何实现 Tree Shaking\n                      的呢？欢迎在留言区和我分享你的观点。\n                    </p>\n                    <p data-nodeid=\"76946\">\n                      更多内容，我们会结合下一讲“如何理解 AST\n                      实现和编译原理？”，带你实现一个真实的 AST\n                      的落地场景，完成一个简易版 Tree Shaking\n                      实现。我们下一讲再见！\n                    </p>\n            "}