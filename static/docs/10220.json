{"title":"19 | 事件轮询：如何理解浏览器中的 EventLoop？","context":"\n                    <p data-nodeid=\"1698\" class=\"\">\n                      上一讲我们探讨了 JavaScript\n                      引擎的内存管理及垃圾回收机制，那么这一讲依然要讨论和 JS\n                      引擎相关的 Eventloop，我会带你深入理解 JavaScript\n                      引擎所做的工作。\n                    </p>\n                    <p data-nodeid=\"1699\">\n                      我会先讲解浏览器端的 Eventloop\n                      的运行机制，待你对浏览器端有了一定的理解之后，再带你设计一些\n                      Node.js 的 Eventloop\n                      的底层逻辑。你可以发现，无论是浏览器端还是服务端，都在使用\n                      Eventloop，虽然两者机制不同，但都利用了 JavaScript\n                      语言的单线程和非阻塞的特点。希望你能扎实地掌握这部分内容，因为这对你在工作中编写高性能的\n                      JavaScript 代码有所帮助。\n                    </p>\n                    <p data-nodeid=\"1700\">\n                      那么依照惯例，在课程开始前请你先思考两个问题：\n                    </p>\n                    <ol data-nodeid=\"1701\">\n                      <li data-nodeid=\"1702\">\n                        <p data-nodeid=\"1703\">\n                          浏览器端的 Eventloop 起到了什么作用？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1704\">\n                        <p data-nodeid=\"1705\">\n                          Node.js 服务端的 Eventloop 的作用又表现在哪？\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1706\">\n                      现在开始跟着我一起探究浏览器端的 Eventloop 吧。\n                    </p>\n                    <h3 data-nodeid=\"1707\">浏览器的 Eventloop</h3>\n                    <p data-nodeid=\"1708\">\n                      Eventloop 是 JavaScript\n                      引擎异步编程背后需要特别关注的知识点。JS\n                      在单线程上执行所有操作，虽然是单线程，但是能够高效地解决问题，并能给我们带来一种“多线程”的错觉，这其实是通过使用一些比较合理的数据结构来达到此效果的。我们一起来看下\n                      JavaScript 引擎背后都有哪些东西在同时运转。\n                    </p>\n                    <p data-nodeid=\"1709\">\n                      <strong data-nodeid=\"1789\"\n                        >1.调用堆栈（call\n                        stack）负责跟踪所有要执行的代码</strong\n                      >。每当一个函数执行完成时，就会从堆栈中弹出（pop）该执行完成函数；如果有代码需要进去执行的话，就进行\n                      push 操作，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1710\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/17/42/CioPOWBHazGAfzOQAAIO77agDbw772.png\"\n                        alt=\"图片4.png\"\n                        data-nodeid=\"1792\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1711\">\n                      <strong data-nodeid=\"1797\"\n                        >2.事件队列（event queue）负责将新的 function\n                        发送到队列中进行处理</strong\n                      >。它遵循 queue\n                      的数据结构特性，先进先出，在该顺序下发送所有操作以进行执行。如下图所示：\n                    </p>\n                    <p data-nodeid=\"1712\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/17/46/Cgp9HWBHa0uAO5oEAAIrTDhci3M926.png\"\n                        alt=\"图片5.png\"\n                        data-nodeid=\"1800\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1713\">\n                      <strong data-nodeid=\"1805\"\n                        >3.每当调用事件队列（event\n                        queue）中的异步函数时，都会将其发送到浏览器 API</strong\n                      >。根据从调用堆栈收到的命令，API\n                      开始自己的单线程操作。其中 setTimeout\n                      方法就是一个比较典型的例子，在堆栈中处理 setTimeout\n                      操作时，会将其发送到相应的 API，该 API\n                      一直等到指定的时间将此操作送回进行处理。它将操作发送到哪里去呢？答案是事件队列（event\n                      queue）。这样，就有了一个循环系统，用于在 JavaScript\n                      中运行异步操作。\n                    </p>\n                    <p data-nodeid=\"1714\">\n                      <strong data-nodeid=\"1810\"\n                        >4.JavaScript 语言本身是单线程的，而浏览器 API\n                        充当单独的线程</strong\n                      >。事件循环（Eventloop）促进了这一过程，它会不断检查调用堆栈是否为空。如果为空，则从事件队列中添加新的函数进入调用栈（call\n                      stack）；如果不为空，则处理当前函数的调用。我们把整个过程串起来就是这样的一个循环执行流程，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1715\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/17/43/CioPOWBHaz-AIvXzAAMjXUqLjBw024.png\"\n                        alt=\"图片6.png\"\n                        data-nodeid=\"1813\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1716\">\n                      通过上面这张图就能很清晰地看出调用栈、事件队列以及\n                      Eventloop 和它们之间相互配合的关系。\n                    </p>\n                    <p data-nodeid=\"1717\">\n                      那么看完了 JS 引擎的全局流程图，我们再看看 Eventloop\n                      的内部都有哪些东西呢？简单来说 Eventloop\n                      通过内部两个队列来实现 Event Queue 放进来的异步任务。以\n                      setTimeout\n                      为代表的任务被称为宏任务，放到宏任务队列（macrotask\n                      queue）中；而以\n                      Promise&nbsp;为代表的任务被称为微任务，放到微任务队列（microtask\n                      queue）中。我们来看一下日常工作中经常遇到的哪些是宏任务，哪些是微任务，如下所示。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">macrotasks(宏任务): \n</div></li><li><div class=\"code-word\">script(整体代码),setTimeout,setInterval,setImmediate,I/O,UI rendering,<span class=\"hljs-function\">event listner\n</span></div></li><li><div class=\"code-word\"><span class=\"hljs-title\">microtasks</span><span class=\"hljs-params\">(微任务)</span>: \n</div></li><li><div class=\"code-word\">process.nextTick, Promises, Object.observe, MutationObserver\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1719\">\n                      我把主要的宏任务和微任务都列了出来，其实 Eventloop\n                      在处理宏任务和微任务的逻辑其实还是有些不一样的，执行的情况大致如下：\n                    </p>\n                    <ol data-nodeid=\"1720\">\n                      <li data-nodeid=\"1721\">\n                        <p data-nodeid=\"1722\">\n                          JavaScript 引擎首先从宏任务队列（macrotask\n                          queue）中取出第一个任务；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1723\">\n                        <p data-nodeid=\"1724\">\n                          执行完毕后，再将微任务（microtask\n                          queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1725\">\n                        <p data-nodeid=\"1726\">\n                          然后再从宏任务队列中取下一个，执行完毕后，再次将\n                          microtask queue 中的全部取出，循环往复，直到两个 queue\n                          中的任务都取完。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"2151\" class=\"te-preview-highlight\">\n                      总结起来就是：<strong data-nodeid=\"2161\"\n                        >一次 Eventloop\n                        循环会处理一个宏任务和所有这次循环中产生的微任务</strong\n                      >。<br />\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/17/45/CioPOWBHbTWAFHeGAAU2r3znzGU909.png\"\n                        alt=\"刘烨的js.png\"\n                        data-nodeid=\"2160\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"1728\">\n                      关于宏任务和微任务暂时先说到这里，更详细的内容我会在“21 |\n                      引擎进阶（上）：探究宏任务&amp;微任务的运行机制”中详细讲解。\n                    </p>\n                    <p data-nodeid=\"1729\">\n                      那么初步看完了浏览器中 Eventloop 的情况，我们再来看下在\n                      Node.js 服务端的 Eventloop 是怎么运作的。\n                    </p>\n                    <h3 data-nodeid=\"1730\">Node.js 的 Eventloop</h3>\n                    <p data-nodeid=\"1731\">\n                      关于在 Node.js 服务端 Eventloop，<a\n                        href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\"\n                        data-nodeid=\"1836\"\n                        >Node.js 官网</a\n                      >是这么描述的：\n                    </p>\n                    <blockquote data-nodeid=\"1732\">\n                      <p data-nodeid=\"1733\">\n                        <em data-nodeid=\"1841\"\n                          >When Node.js starts, it initializes the event loop,\n                          processes the provided input script (or drops into the\n                          REPL, which is not covered in this document) which may\n                          make async API calls, schedule timers, or call\n                          process.nextTick(), then begins processing the event\n                          loop.</em\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1734\">\n                      简单翻译过来就是：当 Node.js 开始启动时，会初始化一个\n                      Eventloop，处理输入的代码脚本，这些脚本会进行 API\n                      异步调用，process.nextTick()\n                      方法会开始处理事件循环。下面就是 Node.js 官网提供的\n                      Eventloop 事件循环参考流程。\n                    </p>\n                    <p data-nodeid=\"1735\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/17/46/Cgp9HWBHaxyAMv7yAAC2Vr6vRw4319.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"1845\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1736\">\n                      整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次\n                      Eventloop\n                      的循环过程。我们来分别看下这六个阶段都做了哪些事情。\n                    </p>\n                    <ul data-nodeid=\"1737\">\n                      <li data-nodeid=\"1738\">\n                        <p data-nodeid=\"1739\">\n                          <strong data-nodeid=\"1851\">Timers 阶段</strong\n                          >：这个阶段执行 setTimeout 和 setInterval。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1740\">\n                        <p data-nodeid=\"1741\">\n                          <strong data-nodeid=\"1856\">I/O callbacks 阶段</strong\n                          >：这个阶段主要执行系统级别的回调函数，比如 TCP\n                          连接失败的回调。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1742\">\n                        <p data-nodeid=\"1743\">\n                          <strong data-nodeid=\"1861\">idle，prepare 阶段</strong\n                          >：只是 Node.js 内部闲置、准备，可以忽略。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1744\">\n                        <p data-nodeid=\"1745\">\n                          <strong data-nodeid=\"1866\">poll 阶段</strong>：poll\n                          阶段是一个重要且复杂的阶段，几乎所有 I/O\n                          相关的回调，都在这个阶段执行（除了setTimeout、setInterval、setImmediate\n                          以及一些因为 exception\n                          意外关闭产生的回调），这个阶段的主要流程如下图所示。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1746\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/17/42/CioPOWBHawOAK71oAAFclaJ2RLA602.png\"\n                        alt=\"图片2.png\"\n                        data-nodeid=\"1869\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"1747\">\n                      <li data-nodeid=\"1748\">\n                        <p data-nodeid=\"1749\">\n                          <strong data-nodeid=\"1874\">check 阶段</strong>：执行\n                          setImmediate() 设定的 callbacks。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1750\">\n                        <p data-nodeid=\"1751\">\n                          <strong data-nodeid=\"1883\"\n                            >close callbacks 阶段</strong\n                          >：执行关闭请求的回调函数，比如 socket.on('close',\n                          ...)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1752\">\n                      除了把 Eventloop 的宏任务细分到不同阶段外。node\n                      还引入了一个新的任务队列 Process.nextTick()。根据<a\n                        href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick\"\n                        data-nodeid=\"1887\"\n                        >官方文档的解释</a\n                      >：\n                    </p>\n                    <blockquote data-nodeid=\"1753\">\n                      <p data-nodeid=\"1754\">\n                        process.nextTick()is not technically part of the event\n                        loop. Instead, thenextTickQueuewill be processed after\n                        the current operation is completed, regardless of the\n                        current phase of the event loop. Here,\n                        an&nbsp;operation&nbsp;is defined as a transition from\n                        the underlying C/C++ handler, and handling the\n                        JavaScript that needs to be executed.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1755\">\n                      可以认为，Process.nextTick()\n                      会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过\n                      microtask 队列）。\n                    </p>\n                    <p data-nodeid=\"1756\">\n                      Node.js\n                      和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而\n                      Node.js\n                      端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。\n                    </p>\n                    <p data-nodeid=\"1757\">\n                      这部分比较绕，你需要多琢磨几遍。那么讲完了\n                      Eventloop，你以为可能就够用了，但是很快你就会发现，Eventloop\n                      也会影响到渲染，下面的内容也许对你有帮助。\n                    </p>\n                    <h3 data-nodeid=\"1758\">EventLoop 对渲染的影响</h3>\n                    <p data-nodeid=\"1759\">\n                      想必你之前在业务开发中也遇到过 requestIdlecallback 和\n                      requestAnimationFrame，这两个函数在我们之前的内容中没有讲过，但是当你开始考虑它们在\n                      Eventloop\n                      的生命周期的哪一步触发，或者这两个方法的回调会在微任务队列还是宏任务队列执行的时候，才发现好像没有想象中那么简单。这两个方法其实也并不属于\n                      JS\n                      的原生方法，而是浏览器宿主环境提供的方法，因为它们牵扯到另一个问题：渲染。\n                    </p>\n                    <p data-nodeid=\"1760\">\n                      我们知道浏览器作为一个复杂的应用是多线程工作的，除了运行\n                      JS 的线程外，还有渲染线程、定时器触发线程、HTTP\n                      请求线程，等等。JS 线程可以读取并且修改\n                      DOM，而渲染线程也需要读取\n                      DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行。\n                    </p>\n                    <p data-nodeid=\"1761\">\n                      渲染原本就不应该出现在 Eventloop\n                      相关的知识体系里，但是因为 Eventloop 显然是在讨论 JS\n                      如何运行的问题，而渲染则是浏览器另外一个线程的工作。但是\n                      <a\n                        href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\"\n                        data-nodeid=\"1899\"\n                        >requestAnimationFrame</a\n                      >\n                      的出现却把这两件事情给关联起来，你可以看下 RAF\n                      的英文解释：\n                    </p>\n                    <blockquote data-nodeid=\"1762\">\n                      <p data-nodeid=\"1763\">\n                        <code data-backticks=\"1\" data-nodeid=\"1901\"\n                          >requestAnimationFrame()</code\n                        >method tells the browser that you wish to perform an\n                        animation and requests that the browser calls a\n                        specified function to update an animation&nbsp;before\n                        the next repaint.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1764\">\n                      通过调用 requestAnimationFrame\n                      我们可以在下次渲染之前执行回调函数。那下次渲染具体是哪个时间点呢？渲染和\n                      Eventloop 有什么关系呢？我们在\n                      <a\n                        href=\"https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity\"\n                        data-nodeid=\"1906\"\n                        >HTML协议对 Eventloop 的规范</a\n                      >\n                      里找到了答案。简单来说，就是在每一次 Eventloop\n                      的末尾，判断当前页面是否处于渲染时机，就是重新渲染。而这个所谓的渲染时机是这样定义的：\n                    </p>\n                    <blockquote data-nodeid=\"1765\">\n                      <p data-nodeid=\"1766\">\n                        Rendering opportunities are determined based on hardware\n                        constraints such as display refresh rates and other\n                        factors such as page performance or whether the page is\n                        in the background. Rendering opportunities typically\n                        occur at regular intervals.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1767\">\n                      有屏幕的硬件限制，比如 60Hz 刷新率，简而言之就是 1\n                      秒刷新了 60 次，16.6ms\n                      刷新一次。这个时候浏览器的渲染间隔时间就没必要小于\n                      16.6ms，因为就算渲染了屏幕上也看不到。当然浏览器也不能保证一定会每\n                      16.6ms 会渲染一次，因为还会受到处理器的性能、JavaScript\n                      执行效率等其他因素影响。\n                    </p>\n                    <p data-nodeid=\"1768\">\n                      回到 requestAnimationFrame，这个 API\n                      保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的\n                      setInterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了\n                      requestAnimationFrame\n                      更适合用来做针对每一帧来修改的动画效果。\n                    </p>\n                    <p data-nodeid=\"1769\">\n                      当然 requestAnimationFrame 不是 Eventloop\n                      里的宏任务，或者说它并不在 Eventloop\n                      的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的\n                      hook。另外需要注意的是微任务的认知概念也需要更新，在执行\n                      animation callback 时也有可能产生微任务（比如 promise 的\n                      callback），会放到 animation queue\n                      处理完后再执行。所以微任务并不是像之前说的那样在每一轮\n                      Eventloop 后处理，而是在 JS 的函数调用栈清空后处理。\n                    </p>\n                    <p data-nodeid=\"1770\">\n                      但是\n                      requestIdlecallback&nbsp;却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被\n                      requestIdlecallback\n                      利用起来执行一些优先级不高、不必立即执行的任务，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1771\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/17/45/Cgp9HWBHavCAdApzAACc58yaa0Q304.png\"\n                        alt=\"图片3.png\"\n                        data-nodeid=\"1915\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1772\">\n                      当然为了防止浏览器一直处于繁忙状态，导致\n                      requestIdlecallback\n                      可能永远无法执行回调，它还提供了一个额外的 timeout\n                      参数，为这个任务设置一个截止时间。浏览器就可以根据这个截止时间规划这个任务的执行。\n                    </p>\n                    <h3 data-nodeid=\"1773\">总结</h3>\n                    <p data-nodeid=\"1774\">\n                      那么现在让你回答我在开头提出的两个问题，你能准确说出来吗？回过头到文中仔细看看，相信不难回答。\n                    </p>\n                    <p data-nodeid=\"1775\">\n                      到这里，你基本就能理解 Eventloop\n                      在不同的端上的情况了。虽然说 Eventloop\n                      本身并不是一个难理解的概念，但是由于 JS\n                      不同平台的实现的差异，让这个知识点很难一下说清楚，因此我就拿出这一讲带你来分析\n                      Eventloop。希望你可以反复琢磨这一概念，将它理解透彻。\n                    </p>\n                    <p data-nodeid=\"1776\" class=\"\">\n                      下一讲我们来聊聊 JS\n                      的代码是如何被编译执行的。如果本讲的内容对你有帮助，就留言和我说说你的学习感悟吧。我们下一讲再见。\n                    </p>\n            "}