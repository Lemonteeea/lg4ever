{"title":"17 | useEffect 与 useLayoutEffect 区别在哪里？","context":"\n                    <p data-nodeid=\"48841\" class=\"\">\n                      在 React 的面试中会对 Hooks API\n                      进行一个区分度考察，重点往往会落在 useEffect 与\n                      useLayoutEffect\n                      上。很有意思，光从名字来看，它们就很相像，所以被点名的概率就很高。这一讲我们来重点讲解下这部分内容。\n                    </p>\n                    <h3 data-nodeid=\"48842\">审题</h3>\n                    <p data-nodeid=\"48843\">\n                      在第 04 讲<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=566&amp;sid=20-h5Url-0#/detail/pc?id=5794\"\n                        data-nodeid=\"48938\"\n                        >“类组件与函数组件有什么区别呢？”</a\n                      >中讲过该类型的题目，其中提到<strong data-nodeid=\"48944\"\n                        >描述区别，就是求同存异的过程。</strong\n                      >\n                      那我们可以直接用同样的思路来思考下这道题。\n                    </p>\n                    <p data-nodeid=\"48844\">\n                      先挖掘 useEffect 与 useLayoutEffect\n                      的共性，它们被用于解决什么问题，其次发掘独特的个性、各自适用的场景、设计原理以及未来趋势等。\n                    </p>\n                    <h3 data-nodeid=\"48845\">承题</h3>\n                    <p data-nodeid=\"48846\">\n                      根据以上的分析，该讲所讲解题目的答题思路就有了。\n                    </p>\n                    <p data-nodeid=\"48847\">\n                      首先是论述<strong data-nodeid=\"48953\">共同点</strong>：\n                    </p>\n                    <ul data-nodeid=\"48848\">\n                      <li data-nodeid=\"48849\">\n                        <p data-nodeid=\"48850\">\n                          <strong data-nodeid=\"48958\">使用方式</strong\n                          >，也就是列举使用方式上有什么相似处，共同用于解决什么问题；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48851\">\n                        <p data-nodeid=\"48852\">\n                          <strong data-nodeid=\"48963\">运用效果</strong\n                          >，使用后的执行效果上有什么相似处。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"48853\">\n                      其次是<strong data-nodeid=\"48969\">不同点</strong>：\n                    </p>\n                    <ul data-nodeid=\"48854\">\n                      <li data-nodeid=\"48855\">\n                        <p data-nodeid=\"48856\">\n                          <strong data-nodeid=\"48974\">使用场景</strong\n                          >，两者在使用场景的区分点在哪里，为什么可以或者不可以混用；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48857\">\n                        <p data-nodeid=\"48858\">\n                          <strong data-nodeid=\"48979\">独有能力</strong\n                          >，什么能力是其独有的，而另外一方没有的；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48859\">\n                        <p data-nodeid=\"48860\">\n                          <strong data-nodeid=\"48984\">设计原理</strong\n                          >，即从内部设计挖掘本质的原因；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48861\">\n                        <p data-nodeid=\"48862\">\n                          <strong data-nodeid=\"48989\">未来趋势</strong\n                          >，两者在未来的发展趋势上有什么区别，是否存在一方可能在使用频率上胜出或者淡出的情况。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"48863\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/90/3F/Ciqc1GAKhGuAeJVzAABnKbg5gv0029.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"48992\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"48864\">破题</h3>\n                    <h4 data-nodeid=\"48865\">共同点</h4>\n                    <p data-nodeid=\"48866\">\n                      <strong data-nodeid=\"48998\">使用方式</strong>\n                    </p>\n                    <p data-nodeid=\"48867\">\n                      如果你读过 React Hooks\n                      的官方文档，你可能会发现这么一段描述：useLayoutEffect\n                      的函数签名与 useEffect 相同。\n                    </p>\n                    <p data-nodeid=\"48868\">\n                      那什么是<strong data-nodeid=\"49005\">函数签名呢</strong\n                      >？函数签名就像我们在银行账号上签写的个人签名一样，独一无二，具有法律效应。以下面这段代码为例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">MyObject.prototype.myFunction(value)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"48870\">\n                      应用 MDN 的描述，在 JavaScript\n                      中的签名通常包括这样几个部分：\n                    </p>\n                    <ul data-nodeid=\"48871\">\n                      <li data-nodeid=\"48872\">\n                        <p data-nodeid=\"48873\">\n                          该函数是安装在一个名为&nbsp;MyObject&nbsp;的<a\n                            href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Object\"\n                            data-nodeid=\"49010\"\n                            >对象</a\n                          >上；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48874\">\n                        <p data-nodeid=\"48875\">\n                          该函数安装在&nbsp;MyObject&nbsp;的原型上（因此它是一个<a\n                            href=\"https://developer.mozilla.org/en-US/docs/Glossary/instance_method\"\n                            data-nodeid=\"49015\"\n                            >实例方法</a\n                          >，而不是一个<a\n                            href=\"https://developer.mozilla.org/en-US/docs/Glossary/static_method\"\n                            data-nodeid=\"49019\"\n                            >静态方法/类方法</a\n                          >）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48876\">\n                        <p data-nodeid=\"48877\">\n                          该函数的名称是&nbsp;myFunction；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48878\">\n                        <p data-nodeid=\"48879\">\n                          该函数接收一个叫&nbsp;value&nbsp;的参数，且没有进一步定义。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"48880\">\n                      那为什么说 useEffect 与 useLayoutEffect\n                      函数签名相同呢？它们俩的名字完全不同啊。这是因为在源码中，它们调用的是同一个函数。下面的这段代码是\n                      React useEffect 与 useLayoutEffect 在 ReactFiberHooks.js\n                      源码中的样子。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// useEffect</span>\n</div></li><li><div class=\"code-word\">useEffect(\n</div></li><li><div class=\"code-word\">   create: () =&gt; (() =&gt; <span class=\"hljs-keyword\">void</span>) | <span class=\"hljs-keyword\">void</span>,\n</div></li><li><div class=\"code-word\">   deps: Array&lt;mixed&gt; | <span class=\"hljs-keyword\">void</span> | <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\"> ): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">   currentHookNameInDev = <span class=\"hljs-string\">'useEffect'</span>;\n</div></li><li><div class=\"code-word\">   mountHookTypesDev();\n</div></li><li><div class=\"code-word\">   checkDepsAreArrayDev(deps);\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">return</span> mountEffect(create, deps);\n</div></li><li><div class=\"code-word\"> },\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">mountEffect</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">\t  create: () =&gt; (() =&gt; <span class=\"hljs-keyword\">void</span>) | <span class=\"hljs-keyword\">void</span>,\n</div></li><li><div class=\"code-word\">\t  deps: Array&lt;mixed&gt; | <span class=\"hljs-keyword\">void</span> | <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">\t): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">if</span> (__DEV__) {\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-comment\">// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</span>\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'undefined'</span> !== typeof jest) {\n</div></li><li><div class=\"code-word\">\t      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n</div></li><li><div class=\"code-word\">\t    }\n</div></li><li><div class=\"code-word\">\t  }\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">return</span> mountEffectImpl(\n</div></li><li><div class=\"code-word\">\t    UpdateEffect | PassiveEffect | PassiveStaticEffect,\n</div></li><li><div class=\"code-word\">\t    HookPassive,\n</div></li><li><div class=\"code-word\">\t    create,\n</div></li><li><div class=\"code-word\">\t    deps,\n</div></li><li><div class=\"code-word\">\t  );\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// useLayoutEffect</span>\n</div></li><li><div class=\"code-word\">useLayoutEffect(\n</div></li><li><div class=\"code-word\">   create: () =&gt; (() =&gt; <span class=\"hljs-keyword\">void</span>) | <span class=\"hljs-keyword\">void</span>,\n</div></li><li><div class=\"code-word\">   deps: Array&lt;mixed&gt; | <span class=\"hljs-keyword\">void</span> | <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\"> ): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">   currentHookNameInDev = <span class=\"hljs-string\">'useLayoutEffect'</span>;\n</div></li><li><div class=\"code-word\">   mountHookTypesDev();\n</div></li><li><div class=\"code-word\">   checkDepsAreArrayDev(deps);\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">return</span> mountLayoutEffect(create, deps);\n</div></li><li><div class=\"code-word\"> },\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">mountLayoutEffect</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">\t  create: () =&gt; (() =&gt; <span class=\"hljs-keyword\">void</span>) | <span class=\"hljs-keyword\">void</span>,\n</div></li><li><div class=\"code-word\">\t  deps: Array&lt;mixed&gt; | <span class=\"hljs-keyword\">void</span> | <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">\t): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">return</span> mountEffectImpl(UpdateEffect, HookLayout, create, deps);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"48882\">可以看出：</p>\n                    <ul data-nodeid=\"48883\">\n                      <li data-nodeid=\"48884\">\n                        <p data-nodeid=\"48885\">\n                          useEffect 先调用 mountEffect，再调用 mountEffectImpl；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48886\">\n                        <p data-nodeid=\"48887\">\n                          useLayoutEffect 会先调用 mountLayoutEffect，再调用\n                          mountEffectImpl。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"48888\">\n                      那么你会发现最终调用的都是同一个名为 mountEffectImpl\n                      的函数，入参一致，返回值也一致，所以函数签名是相同的。\n                    </p>\n                    <p data-nodeid=\"48889\">\n                      从代码角度而言，虽然是两个函数，但使用方式是完全一致的，甚至一定程度上可以相互替换。\n                    </p>\n                    <p data-nodeid=\"48890\">\n                      <strong data-nodeid=\"49032\">运用效果</strong>\n                    </p>\n                    <p data-nodeid=\"48891\">\n                      从运用效果上而言，useEffect 与 useLayoutEffect\n                      两者都是<strong data-nodeid=\"49038\">用于处理副作用</strong\n                      >，这些副作用包括改变\n                      DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。\n                    </p>\n                    <p data-nodeid=\"48892\">\n                      虽然看起来很像，但在执行效果上仍然有些许差异。React\n                      官方团队甚至直言，如果不能掌握\n                      useLayoutEffect，不妨直接使用 useEffect。在使用 useEffect\n                      时遇到了问题，再尝试使用 useLayoutEffect。\n                    </p>\n                    <h4 data-nodeid=\"48893\">不同点</h4>\n                    <p data-nodeid=\"48894\">\n                      <strong data-nodeid=\"49044\">使用场景</strong>\n                    </p>\n                    <p data-nodeid=\"48895\">\n                      虽然官方团队给出了一个看似友好的建议，但我们并不能将这样模糊的结果作为正式答案回复给面试官。所以两者的差异在哪里？我们不如用代码来说明。下面通过一个案例来讲解两者的区别。\n                    </p>\n                    <p data-nodeid=\"48896\">\n                      先使用 useEffect\n                      编写一个组件，在这个组件里面包含了两部分：\n                    </p>\n                    <ul data-nodeid=\"48897\">\n                      <li data-nodeid=\"48898\">\n                        <p data-nodeid=\"48899\">\n                          组件展示内容，也就是 className 为 square\n                          的部分会展示一个圆圈；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"48900\">\n                        <p data-nodeid=\"48901\">\n                          在 useEffect 中操作修改 square\n                          的样式，将它的样式重置到页面正中间。\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React, { useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"./styles.css\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> () =&gt; {\n</div></li><li><div class=\"code-word\">  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> greenSquare = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\".square\"</span>);\n</div></li><li><div class=\"code-word\">    greenSquare.style.transform = <span class=\"hljs-string\">\"translate(-50%, -50%)\"</span>;\n</div></li><li><div class=\"code-word\">    greenSquare.style.left = <span class=\"hljs-string\">\"50%\"</span>;\n</div></li><li><div class=\"code-word\">    greenSquare.style.top = <span class=\"hljs-string\">\"50%\"</span>;\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"App\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"square\"</span> /&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"48903\">\n                      下面再补充一下样式文件，其中 App\n                      样式中规中矩设置间距，square\n                      样式主要设置圈儿的颜色与大小，接下来就可以看看它的效果了。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">.App {\n</div></li><li><div class=\"code-word\">  text-align: center;\n</div></li><li><div class=\"code-word\">  margin: <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  padding: <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">.square {\n</div></li><li><div class=\"code-word\">  width: <span class=\"hljs-number\">100</span>px;\n</div></li><li><div class=\"code-word\">  height: <span class=\"hljs-number\">100</span>px;\n</div></li><li><div class=\"code-word\">  position: absolute;\n</div></li><li><div class=\"code-word\">  top: <span class=\"hljs-number\">50</span>px;\n</div></li><li><div class=\"code-word\">  left: <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  background: red;\n</div></li><li><div class=\"code-word\">  border-radius: <span class=\"hljs-number\">50</span>%;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"48905\">\n                      然后执行代码，\n                      你就会发现红圈在渲染后出现了肉眼可见的瞬移，一下飘到了中间。\n                    </p>\n                    <p data-nodeid=\"48906\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/08/32/Cip5yGAKhLOADIYUAAIoKyWYNqU863.gif\"\n                        alt=\"GIF1.gif\"\n                        data-nodeid=\"49053\"\n                      />\n                    </p>\n                    <p data-nodeid=\"48907\">\n                      那如果使用 useLayoutEffect\n                      又会怎么样呢？其他代码都不需要修改，只需要像下面这样，将\n                      useEffect 替换为 useLayoutEffect：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React, { useLayoutEffect } from \"react\";\n</div></li><li><div class=\"code-word\">import \"./styles.css\";\n</div></li><li><div class=\"code-word\">export default () =&gt; {\n</div></li><li><div class=\"code-word\">  useLayoutEffect(() =&gt; {\n</div></li><li><div class=\"code-word\">    const greenSquare = document.querySelector(\".square\");\n</div></li><li><div class=\"code-word\">    greenSquare.style.transform = \"translate(-50%, -50%)\";\n</div></li><li><div class=\"code-word\">    greenSquare.style.left = \"50%\";\n</div></li><li><div class=\"code-word\">    greenSquare.style.top = \"50%\";\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  return (\n</div></li><li><div class=\"code-word\">    &lt;div className=\"App\"&gt;\n</div></li><li><div class=\"code-word\">      &lt;div className=\"square\" /&gt;\n</div></li><li><div class=\"code-word\">    &lt;/div&gt;\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"48909\">\n                      接下来再看执行的效果，你会发现红圈是静止在页面中央，仿佛并没有使用代码强制调整样式的过程。\n                    </p>\n                    <p data-nodeid=\"48910\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/08/34/CgpVE2AKhLyANGs2AAIwo7CyA_E780.gif\"\n                        alt=\"GIF2.gif\"\n                        data-nodeid=\"49058\"\n                      />\n                    </p>\n                    <p data-nodeid=\"48911\">\n                      虽然在实际的项目中，我们并不会这么粗暴地去调整组件样式，但这个案例足以说明两者的区别与使用场景。在\n                      React\n                      社区中最佳的实践是这样推荐的，大多数场景下可以直接使用<strong\n                        data-nodeid=\"49068\"\n                        >useEffect</strong\n                      >，但是如果你的代码引起了页面闪烁，也就是引起了组件突然改变位置、颜色及其他效果等的情况下，就推荐使用<strong\n                        data-nodeid=\"49069\"\n                        >useLayoutEffect</strong\n                      >来处理。那么总结起来就是如果有直接操作 DOM 样式或者引起\n                      DOM 样式更新的场景更推荐使用 useLayoutEffect。\n                    </p>\n                    <p data-nodeid=\"48912\">\n                      那既然内部都是调用同一个函数，为什么会有这样的区别呢？在探讨这个问题时就需要从\n                      Hooks 的设计原理说起了。\n                    </p>\n                    <p data-nodeid=\"48913\">\n                      <strong data-nodeid=\"49074\">设计原理</strong>\n                    </p>\n                    <p data-nodeid=\"48914\">首先可以看下这个图：</p>\n                    <p data-nodeid=\"48915\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/08/34/CgpVE2AKhP6AFNRnAAB9M55aj8I408.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"49078\"\n                      />\n                    </p>\n                    <p data-nodeid=\"48916\">\n                      这个图表达了什么意思呢？首先所有的 Hooks，也就是\n                      useState、useEffect、useLayoutEffect 等，都是导入到了\n                      Dispatcher 对象中。在调用 Hook 时，会通过 Dispatcher\n                      调用对应的 Hook 函数。所有的 Hooks 会按顺序存入对应 Fiber\n                      的状态队列中，这样 React 就能知道当前的 Hook 属于哪个\n                      Fiber，这里就是<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=566&amp;sid=20-h5Url-0#/detail/pc?id=5806\"\n                        data-nodeid=\"49082\"\n                        >上一讲</a\n                      >所提到的<strong data-nodeid=\"49088\">Hooks 链表</strong\n                      >。但 Effect Hooks\n                      会有些不同，它涉及了一些额外的处理逻辑。每个 Fiber 的\n                      Hooks 队列中保存了 effect 节点，而每个 effect\n                      的类型都有可能不同，需要在合适的阶段去执行。\n                    </p>\n                    <p data-nodeid=\"48917\">\n                      那么 LayoutEffect 与普通的 Effect 都是\n                      effect，但标记并不一样，所以在调用时，就会有些许不同。回到前面的底层代码，你会发现只有第一个参数和第二个参数是不一样的，其中\n                      UpdateEffect、PassiveEffect、PassiveStaticEffect 就是\n                      Fiber 的标记；HookPassive 和 HookLayout 就是当前 Effect\n                      的标记。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// useEffect 调用的底层函数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">mountEffect</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">\t  create: () =&gt; (() =&gt; <span class=\"hljs-keyword\">void</span>) | <span class=\"hljs-keyword\">void</span>,\n</div></li><li><div class=\"code-word\">\t  deps: Array&lt;mixed&gt; | <span class=\"hljs-keyword\">void</span> | <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">\t): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">if</span> (__DEV__) {\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-comment\">// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests</span>\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'undefined'</span> !== typeof jest) {\n</div></li><li><div class=\"code-word\">\t      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n</div></li><li><div class=\"code-word\">\t    }\n</div></li><li><div class=\"code-word\">\t  }\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">return</span> mountEffectImpl(\n</div></li><li><div class=\"code-word\">\t    UpdateEffect | PassiveEffect | PassiveStaticEffect,\n</div></li><li><div class=\"code-word\">\t    HookPassive,\n</div></li><li><div class=\"code-word\">\t    create,\n</div></li><li><div class=\"code-word\">\t    deps,\n</div></li><li><div class=\"code-word\">\t  );\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// useLayoutEffect 调用的底层函数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">mountLayoutEffect</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">\t  create: () =&gt; (() =&gt; <span class=\"hljs-keyword\">void</span>) | <span class=\"hljs-keyword\">void</span>,\n</div></li><li><div class=\"code-word\">\t  deps: Array&lt;mixed&gt; | <span class=\"hljs-keyword\">void</span> | <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">\t): <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">return</span> mountEffectImpl(UpdateEffect, HookLayout, create, deps);\n</div></li><li><div class=\"code-word\">\t}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"48919\">\n                      标记为 HookLayout 的 effect 会在所有的 DOM\n                      变更之后同步调用，所以可以使用它来读取 DOM\n                      布局并同步触发重渲染。但既然是同步，就有一个问题，计算量较大的耗时任务必然会造成阻塞，所以这就需要根据实际情况酌情考虑了。如果非必要情况下，使用标准的\n                      useEffect 可以避免阻塞。这段代码在\n                      react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\n                      中，有兴趣的同学可以研读一下。\n                    </p>\n                    <h3 data-nodeid=\"48920\">答题</h3>\n                    <p data-nodeid=\"48921\">\n                      那么以上就是本讲的全部知识点了，内容并不太多，重点主要在于<strong\n                        data-nodeid=\"49097\"\n                        >分析思路</strong\n                      >。那么下面就可以进入答题环节了。\n                    </p>\n                    <blockquote data-nodeid=\"48922\">\n                      <p data-nodeid=\"48923\">\n                        useEffect 与 useLayoutEffect\n                        的区别在哪里？这个问题可以分为两部分来回答，共同点与不同点。\n                      </p>\n                      <p data-nodeid=\"48924\">\n                        它们的共同点很简单，底层的函数签名是完全一致的，都是调用的\n                        mountEffectImpl，在使用上也没什么差异，基本可以直接替换，也都是用于处理副作用。\n                      </p>\n                      <p data-nodeid=\"48925\">\n                        那不同点就很大了，useEffect 在 React\n                        的渲染过程中是被异步调用的，用于绝大多数场景，而\n                        LayoutEffect 会在所有的 DOM\n                        变更之后同步调用，主要用于处理 DOM\n                        操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在\n                        LayoutEffect 做计算量较大的耗时任务从而造成阻塞。\n                      </p>\n                      <p data-nodeid=\"48926\">\n                        在未来的趋势上，两个 API\n                        是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React\n                        团队的建议非常实用，如果实在分不清，先用\n                        useEffect，一般问题不大；如果页面有异常，再直接替换为\n                        useLayoutEffect 即可。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"48927\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/08/32/Cip5yGAKhRCAX99HAAD0YKYP40c980.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"49104\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"48928\">总结</h3>\n                    <p data-nodeid=\"48929\">\n                      本题仍然是一个讲区别的点，所以在整体思路上找相同与不同就可以。\n                    </p>\n                    <p data-nodeid=\"48930\">\n                      这里还有一个很有意思的地方，React\n                      的函数命名追求“望文生义”的效果，这里不是贬义，它在设计上就是希望你从名字猜出真实的作用。比如\n                      componentDidMount、componentDidUpdate\n                      等等虽然名字冗长，但容易理解。从 LayoutEffect\n                      这样一个命名就能看出，它想解决的也就是页面布局的问题。\n                    </p>\n                    <p data-nodeid=\"48931\">\n                      那么在实际的开发中，还有哪些你觉得不太容易理解的\n                      Hooks？或者容易出错的\n                      Hooks？不妨在留言区留言，我会与你一起交流讨论。\n                    </p>\n                    <p data-nodeid=\"49652\">\n                      这一讲就到这了，在下一讲中，将主要介绍 React Hooks\n                      的设计模式，到时见。\n                    </p>\n                    <hr data-nodeid=\"49653\" />\n                    <p data-nodeid=\"49654\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"49662\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image/M00/72/94/Ciqc1F_EZ0eANc6tAASyC72ZqWw643.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"49661\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"49655\">《大前端高薪训练营》</p>\n                    <p data-nodeid=\"49656\" class=\"te-preview-highlight\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"49667\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}