{"title":"08 | 字符串：如何正确回答面试中高频考察的字符串匹配算法？","context":"\n                    <p data-nodeid=\"1133\" class=\"\">\n                      这一节我们来讲字符串和它的相关操作。\n                    </p>\n                    <h3 data-nodeid=\"1134\">字符串是什么</h3>\n                    <p data-nodeid=\"1135\">\n                      字符串（string） 是由 n 个字符组成的一个有序整体（ n &gt;=\n                      0 ）。例如，s = \"BEIJING\" ，s 代表这个串的串名，BEIJING\n                      是串的值。这里的双引号不是串的值，作用只是为了将串和其他结构区分开。字符串的逻辑结构和线性表很相似，不同之处在于字符串针对的是字符集，也就是字符串中的元素都是字符，线性表则没有这些限制。\n                    </p>\n                    <p data-nodeid=\"1136\">\n                      在实际操作中，我们经常会用到一些特殊的字符串：\n                    </p>\n                    <ul data-nodeid=\"1137\">\n                      <li data-nodeid=\"1138\">\n                        <p data-nodeid=\"1139\">\n                          空串，指含有零个字符的串。例如，s =\n                          \"\"，书面中也可以直接用 Ø 表示。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1140\">\n                        <p data-nodeid=\"1141\">\n                          空格串，只包含空格的串。它和空串是不一样的，空格串中是有内容的，只不过包含的是空格，且空格串中可以包含多个空格。例如，s\n                          = \"&nbsp;&nbsp; \"，就是包含了 3 个空格的字符串。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1142\">\n                        <p data-nodeid=\"1143\">\n                          子串，串中任意连续字符组成的字符串叫作该串的子串。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1144\">\n                        <p data-nodeid=\"1145\">\n                          原串通常也称为主串。例如：a = \"BEI\"，b = \"BEIJING\"，c\n                          = \"BJINGEI\" 。\n                        </p>\n                        <ul data-nodeid=\"1146\">\n                          <li data-nodeid=\"1147\">\n                            <p data-nodeid=\"1148\">\n                              对于字符串 a 和 b 来说，由于 b 中含有字符串 a\n                              ，所以可以称 a 是 b 的子串，b 是 a 的主串；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"1149\">\n                            <p data-nodeid=\"1150\">\n                              而对于 c 和 a 而言，虽然 c 中也含有 a\n                              的全部字符，但不是连续的 \"BEI\" ，所以串 c 和 a\n                              没有任何关系。\n                            </p>\n                          </li>\n                        </ul>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1151\">\n                      当要判断两个串是否相等的时候，就需要定义相等的标准了。只有两个串的串值完全相同，这两个串才相等。根据这个定义可见，即使两个字符串包含的字符完全一致，它们也不一定是相等的。例如\n                      b = \"BEIJING\"，c = \"BJINGEI\"，则 b 和 c 并不相等。\n                    </p>\n                    <p data-nodeid=\"1152\">\n                      字符串的存储结构与线性表相同，也有顺序存储和链式存储两种。\n                    </p>\n                    <ul data-nodeid=\"1153\">\n                      <li data-nodeid=\"1154\">\n                        <p data-nodeid=\"1155\">\n                          字符串的顺序存储结构，是用一组地址连续的存储单元来存储串中的字符序列，一般是用定长数组来实现。有些语言会在串值后面加一个不计入串长度的结束标记符，比如\n                          \\0 来表示串值的终结。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1156\">\n                        <p data-nodeid=\"1157\">\n                          字符串的链式存储结构，与线性表是相似的，但由于串结构的特殊性（结构中的每个元素数据都是一个字符），如果也简单地将每个链结点存储为一个字符，就会造成很大的空间浪费。因此，一个结点可以考虑存放多个字符，如果最后一个结点未被占满时，可以使用\n                          \"#\" 或其他非串值字符补全，如下图所示：\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1158\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/1C/BB/Ciqc1F7gvwmAeOuQAACbWbwi7hs491.png\"\n                        alt=\"1.png\"\n                        data-nodeid=\"1279\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1159\">\n                      在链式存储中，每个结点设置字符数量的多少，与串的长度、可以占用的存储空间以及程序实现的功能相关。\n                    </p>\n                    <ul data-nodeid=\"1160\">\n                      <li data-nodeid=\"1161\">\n                        <p data-nodeid=\"1162\">\n                          如果字符串中包含的数据量很大，但是可用的存储空间有限，那么就需要提高空间利用率，相应地减少结点数量。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1163\">\n                        <p data-nodeid=\"1164\">\n                          而如果程序中需要大量地插入或者删除数据，如果每个节点包含的字符过多，操作字符就会变得很麻烦，为实现功能增加了障碍。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1165\">\n                      因此，串的链式存储结构除了在连接串与串操作时有一定的方便之外，总的来说，不如顺序存储灵活，在性能方面也不如顺序存储结构好。\n                    </p>\n                    <h3 data-nodeid=\"1166\">字符串的基本操作</h3>\n                    <p data-nodeid=\"1167\">\n                      字符串和线性表的操作很相似，但由于字符串针对的是字符集，所有元素都是字符，因此字符串的基本操作与线性表有很大差别。线性表更关注的是单个元素的操作，比如增删查一个元素，而字符串中更多关注的是查找子串的位置、替换等操作。接下来我们以顺序存储为例，详细介绍一下字符串对于另一个字符串的增删查操作。\n                    </p>\n                    <h4 data-nodeid=\"1168\">字符串的新增操作</h4>\n                    <p data-nodeid=\"1169\">\n                      字符串的新增操作和数组非常相似，都牵涉对插入字符串之后字符的挪移操作，所以时间复杂度是\n                      O(n)。\n                    </p>\n                    <p data-nodeid=\"1170\">\n                      例如，在字符串 s1 = \"123456\" 的正中间插入 s2 =\n                      \"abc\"，则需要让 s1 中的 \"456\" 向后挪移 3\n                      个字符的位置，再让 s2 的 \"abc\"\n                      插入进来。很显然，挪移的操作时间复杂度是\n                      O(n)。不过，对于特殊的插入操作时间复杂度也可以降低为\n                      O(1)。这就是在 s1 的最后插入\n                      s2，也叫作字符串的连接，最终得到 \"123456abc\"。\n                    </p>\n                    <h4 data-nodeid=\"1171\">字符串的删除操作</h4>\n                    <p data-nodeid=\"1172\">\n                      字符串的删除操作和数组同样非常相似，也可能会牵涉删除字符串后字符的挪移操作，所以时间复杂度是\n                      O(n)。\n                    </p>\n                    <p data-nodeid=\"1173\">\n                      例如，在字符串 s1 = \"123456\" 的正中间删除两个字符\n                      \"34\"，则需要删除 \"34\" 并让 s1 中的 \"56\" 向前挪移 2\n                      个字符的位置。很显然，挪移的操作时间复杂度是\n                      O(n)。不过，对于特殊的插入操作时间复杂度也可以降低为\n                      O(1)。这就是在 s1\n                      的最后删除若干个字符，不牵涉任何字符的挪移。\n                    </p>\n                    <h4 data-nodeid=\"1174\">字符串的查找操作</h4>\n                    <p data-nodeid=\"1175\">\n                      字符串的查找操作，是反映工程师对字符串理解深度的高频考点，这里需要你格外注意。\n                    </p>\n                    <p data-nodeid=\"1176\">\n                      例如，字符串 s = \"goodgoogle\"，判断字符串 t = \"google\" 在\n                      s 中是否存在。需要注意的是，如果字符串 t 的每个字符都在 s\n                      中出现过，这并不能证明字符串 t 在 s 中出现了。当 t = \"dog\"\n                      时，那么字符 \"d\"、\"o\"、\"g\" 都在 s\n                      中出现过，但他们并不连在一起。\n                    </p>\n                    <p data-nodeid=\"1177\">\n                      那么我们如何判断一个子串是否在字符串中出现过呢？这个问题也被称作子串查找或字符串匹配，接下来我们来重点分析。\n                    </p>\n                    <h4 data-nodeid=\"1178\">子串查找（字符串匹配）</h4>\n                    <p data-nodeid=\"1179\">\n                      首先，我们来定义两个概念，主串和模式串。我们在字符串 A\n                      中查找字符串 B，则 A 就是主串，B\n                      就是模式串。我们把主串的长度记为 n，模式串长度记为\n                      m。由于是在主串中查找模式串，因此，主串的长度肯定比模式串长，n&gt;m。因此，字符串匹配算法的时间复杂度就是\n                      n 和 m 的函数。\n                    </p>\n                    <p data-nodeid=\"1180\">\n                      假设要从主串 s = \"goodgoogle\" 中找到 t = \"google\"\n                      子串。根据我们的思考逻辑，则有：\n                    </p>\n                    <ul data-nodeid=\"1181\">\n                      <li data-nodeid=\"1182\">\n                        <p data-nodeid=\"1183\">\n                          首先，我们从主串 s 第 1 位开始，判断 s 的第 1\n                          个字符是否与 t 的第 1 个字符相等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1184\">\n                        <p data-nodeid=\"1185\">\n                          如果不相等，则继续判断主串的第 2 个字符是否与 t 的第1\n                          个字符相等。直到在 s 中找到与 t\n                          第一个字符相等的字符时，然后开始判断它之后的字符是否仍然与\n                          t 的后续字符相等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1186\">\n                        <p data-nodeid=\"1187\">\n                          如果持续相等直到 t 的最后一个字符，则匹配成功。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1188\">\n                        <p data-nodeid=\"1189\">\n                          如果发现一个不等的字符，则重新回到前面的步骤中，查找 s\n                          中是否有字符与 t 的第一个字符相等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1190\">\n                        <p data-nodeid=\"1191\">\n                          如下图所示，s 的第1 个字符和 t 的第 1\n                          个字符相等，则开始匹配后续。直到发现前三个字母都匹配成功，但\n                          s 的第 4 个字母匹配失败，则回到主串继续寻找和 t\n                          的第一个字符相等的字符。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1192\">\n                        <p data-nodeid=\"1193\">\n                          如下图所示，这时我们发现主串 s 第 5\n                          位开始相等，并且随后的 6\n                          个字母全匹配成功，则找到结果。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1194\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/1D/7B/Ciqc1F7h-hmAFsw0ADCjkl8SW7M434.gif\"\n                        alt=\"Lark20200611-171750.gif\"\n                        data-nodeid=\"1375\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1195\">\n                      这种匹配算法需要从主串中找到跟模式串的第 1\n                      个字符相等的位置，然后再去匹配后续字符是否与模式串相等。显然，从实现的角度来看，需要两层的循环。第一层循环，去查找第一个字符相等的位置，第二层循环基于此去匹配后续字符是否相等。因此，这种匹配算法的时间复杂度为\n                      O(nm)。其代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">s1</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    String s = <span class=\"hljs-string\">\"goodgoogle\"</span>;\n</div></li><li><div class=\"code-word\">    String t = <span class=\"hljs-string\">\"google\"</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> isfind = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; s.length() - t.length() + <span class=\"hljs-number\">1</span>; i++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (s.charAt(i) == t.charAt(<span class=\"hljs-number\">0</span>)) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> jc = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; t.length(); j++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (s.charAt(i + j) != t.charAt(j)) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                jc = j;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (jc == t.length() - <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">                isfind = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    System.out.println(isfind);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"1197\">字符串匹配算法的案例</h3>\n                    <p data-nodeid=\"1198\">\n                      最后我们给出一道面试中常见的高频题目，这也是对字符串匹配算法进行拓展，从而衍生出的问题，即查找出两个字符串的最大公共字串。\n                    </p>\n                    <p data-nodeid=\"5508\" class=\"\">\n                      假设有且仅有 1 个最大公共子串。比如，输入 a = \"13452439\"，\n                      b = \"123456\"。由于字符串 \"345\" 同时在 a 和 b\n                      中出现，且是同时出现在 a 和 b 中的最长子串。因此输出\n                      \"345\"。\n                    </p>\n\n                    <p data-nodeid=\"1200\">\n                      对于这个问题其实可以用动态规划的方法来解决，关于动态规划，我们会在后续的课程会讲到，所以在这里我们沿用前面的匹配算法。\n                    </p>\n                    <p data-nodeid=\"1201\">\n                      假设字符串 a 的长度为 n，字符串 b 的长度为\n                      m，可见时间复杂度是 n 和 m 的函数。\n                    </p>\n                    <ul data-nodeid=\"1202\">\n                      <li data-nodeid=\"1203\">\n                        <p data-nodeid=\"1204\">\n                          首先，你需要对于字符串 a 和 b\n                          找到第一个共同出现的字符，这跟前面讲到的匹配算法在主串中查找第一个模式串字符一样。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1205\">\n                        <p data-nodeid=\"1206\">\n                          然后，一旦找到了第一个匹配的字符之后，就可以同时在 a\n                          和 b 中继续匹配它后续的字符是否相等。这样 a 和 b\n                          中每个互相匹配的字串都会被访问一遍。全局还要维护一个最长子串及其长度的变量，就可以完成了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1207\">\n                      从代码结构来看，第一步需要两层的循环去查找共同出现的字符，这就是\n                      O(nm)。一旦找到了共同出现的字符之后，还需要再继续查找共同出现的字符串，这也就是又嵌套了一层循环。可见最终的时间复杂度是\n                      O(nmm)，即 O(nm²)。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">s2</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    String a = <span class=\"hljs-string\">\"123456\"</span>;\n</div></li><li><div class=\"code-word\">    String b = <span class=\"hljs-string\">\"13452439\"</span>;\n</div></li><li><div class=\"code-word\">    String maxSubStr = <span class=\"hljs-string\">\"\"</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> max_len = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">\t\t\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.length(); i++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; b.length(); j++){\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (a.charAt(i) == b.charAt(j)){\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> m=i, n=j; m&lt;a.length()&amp;&amp;n&lt;b.length(); m++,n++) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">if</span> (a.charAt(m) != b.charAt(n)){\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">                    }\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">if</span> (max_len &lt; m-i+<span class=\"hljs-number\">1</span>){\n</div></li><li><div class=\"code-word\">                        max_len = m-i+<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;         maxSubStr = a.substring(i, m+<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">                    }\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\t\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    System.out.println(maxSubStr);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"1209\">总结</h3>\n                    <p data-nodeid=\"1210\">\n                      这节课我们介绍了字符串匹配算法，它在平时代码编写中都比较常用。\n                    </p>\n                    <p data-nodeid=\"1211\">\n                      字符串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。但是，字符串的基本操作和线性表有很大差别：\n                    </p>\n                    <ul data-nodeid=\"1212\">\n                      <li data-nodeid=\"1213\">\n                        <p data-nodeid=\"1214\">\n                          在线性表的基本操作中，大多以“单个元素”作为操作对象；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1215\">\n                        <p data-nodeid=\"1216\">\n                          在字符串的基本操作中，通常以“串的整体”作为操作对象；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1217\">\n                        <p data-nodeid=\"1218\">\n                          字符串的增删操作和数组很像，复杂度也与之一样。但字符串的查找操作就复杂多了，它是参加面试、笔试常常被考察的内容。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"1219\">练习题</h3>\n                    <p data-nodeid=\"1220\">\n                      最后我们给出一道练习题。给定一个字符串，逐个翻转字符串中的每个单词。例如，输入:\n                      \"the sky is blue\"，输出: \"blue is sky the\"。\n                    </p>\n                    <p data-nodeid=\"1221\" class=\"\">\n                      希望你在课后自己去实践一下，如果你在字符串的使用方面遇到困难，欢迎在留言区和我交流。\n                    </p>\n            "}