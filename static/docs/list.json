[{"id":"100","title":"前端进击笔记","list":[{"title":"开篇词 | 前端进阶得打好基础，靠近业务","filename":"10001.json"},{"title":"导读 1 | 前端基础知识体系之专业知识篇","filename":"10002.json"},{"title":"导读 2 | 前端基础知识体系之项目经验篇","filename":"10003.json"},{"title":"01 | 重识 HTML，掌握页面基本结构和加载过程","filename":"10004.json"},{"title":"02 | CSS：页面布局的基本规则和方式","filename":"10005.json"},{"title":"03 | JavaScript 如何实现继承？","filename":"10006.json"},{"title":"04 | JavaScript 引擎如何执行 JavaScript 代码？","filename":"10007.json"},{"title":"05 | 单线程的 JavaScript 如何管理任务？","filename":"10008.json"},{"title":"06 | 一个网络请求是怎么进行的？","filename":"10009.json"},{"title":"07 | HTTP 协议和前端开发有什么关系？","filename":"10010.json"},{"title":"08 | 深入剖析浏览器中页面的渲染过程","filename":"10011.json"},{"title":"09 | 改善编程思维：从事件驱动到数据驱动","filename":"10012.json"},{"title":"10 | 掌握前端框架模板引擎的实现原理","filename":"10013.json"},{"title":"11 | 为什么小程序特立独行？","filename":"10014.json"},{"title":"12 | 单页应用与前端路由库设计原理","filename":"10015.json"},{"title":"13 | 代码构建与 Webpack 必备技能","filename":"10016.json"},{"title":"14 | 提升编程体验：组件化与模块化设计","filename":"10017.json"},{"title":"15 | 提升开发效率：数据抽象与配置化","filename":"10018.json"},{"title":"16 | 实战：三天实现管理端系统","filename":"10019.json"},{"title":"17 | Angular/React/Vue 三大前端框架的设计特色","filename":"10020.json"},{"title":"18 | 如何设计合适的状态管理方案？","filename":"10021.json"},{"title":"19 | 如何搭建前端监控体系为业务排忧解难？","filename":"10022.json"},{"title":"20 | 如何进行性能分析的自动化实现","filename":"10023.json"},{"title":"21 | 前端性能优化与解决方案","filename":"10024.json"},{"title":"22 | 如何进行技术方案调研与设计？","filename":"10025.json"},{"title":"23 | 如何设计一个前端项目","filename":"10026.json"},{"title":"24 | 通过前端工程化提升团队开发效率","filename":"10027.json"},{"title":"25 | 大型前端项目的痛点和优化方案","filename":"10028.json"},{"title":"26 | 如何通过前期准备和后期复盘让项目稳定上线","filename":"10029.json"},{"title":"结束语 | 如何进行前端职业规划？","filename":"10030.json"}]},{"id":"102","title":"JavaScript 核心原理精讲","list":[{"title":"开篇词 | 打好 JS 基石，走稳前端进阶之路","filename":"10201.json"},{"title":"01 | 代码基本功测试（上）：JS 的数据类型你了解多少？","filename":"10202.json"},{"title":"02 | 代码基本功测试（下）：如何实现一个深浅拷贝？","filename":"10203.json"},{"title":"03 | 继承实现：探究 JS 常见的 6 种继承方式","filename":"10204.json"},{"title":"04 | 继承进阶：如何实现 new、apply、call、bind 的底层逻辑？","filename":"10205.json"},{"title":"05 | 函数那些事：JS 闭包难点剖析","filename":"10206.json"},{"title":"06 | 进阶练习：带你一起实现 JSON.Stringify 方法","filename":"10207.json"},{"title":"07 | 数组原理（上）：帮你梳理眼花缭乱的数组 API","filename":"10208.json"},{"title":"08 | 数组原理（中）：如何理解 JS 的类数组？","filename":"10209.json"},{"title":"09 | 数组原理（下）：实现数组扁平化的 6 种方式","filename":"10210.json"},{"title":"10 | 数组排序（上）：如何用 JS 实现各种数组排序？","filename":"10211.json"},{"title":"11 | 数组排序（下）：sort 排序方法的实现原理","filename":"10212.json"},{"title":"12 | 进阶练习：带你手写 JS 数组多个方法的底层实现","filename":"10213.json"},{"title":"13 | 异步编程（上）：JS 异步编程都有哪些方案？","filename":"10214.json"},{"title":"14 | 异步编程（中）：如何深入理解异步编程的核心 Promise？","filename":"10215.json"},{"title":"15 | 异步编程（下）：如何理解 Generator、Async/await                  等异步编程的语法糖？","filename":"10216.json"},{"title":"16 | 进阶练习（上）：怎样轻松实现一个 EventEmitter？","filename":"10217.json"},{"title":"17 | 进阶练习（下）：如何实现符合 Promise/A+ 规范的 Promise？","filename":"10218.json"},{"title":"18 | 垃圾回收：释放内存，提升浏览器页面性能","filename":"10219.json"},{"title":"19 | 事件轮询：如何理解浏览器中的 EventLoop？","filename":"10220.json"},{"title":"20 | 原理解析：JS 代码是如何被浏览器引擎编译、执行的？","filename":"10221.json"},{"title":"21 | 引擎进阶（上）：探究宏任务 &amp; 微任务的运行机制","filename":"10222.json"},{"title":"22 | 引擎进阶（下）：如何理解 Process.nextTick 的原理？","filename":"10223.json"},{"title":"彩蛋 1 | 如何应对大厂面试官的灵魂拷问？","filename":"10224.json"},{"title":"彩蛋 2 | 前端开发如何有针对性地学习算法？","filename":"10225.json"},{"title":"结束语 | 面向未来，我们该如何提升自己？","filename":"10226.json"}]},{"id":"103","title":"深入浅出搞定 React","list":[{"title":"开篇词 | 这一次，真正吃透 React 知识链路与底层逻辑","filename":"10301.json"},{"title":"01 | JSX 代码是如何“摇身一变”成为 DOM 的？","filename":"10302.json"},{"title":"02 | 为什么 React 16 要更改组件的生命周期？（上）","filename":"10303.json"},{"title":"03 | 为什么 React 16 要更改组件的生命周期？（下）","filename":"10304.json"},{"title":"04 | 数据是如何在 React 组件之间流动的？（上）","filename":"10305.json"},{"title":"05 | 数据是如何在 React 组件之间流动的？（下）","filename":"10306.json"},{"title":"06 | React-Hooks 设计动机与工作模式（上）","filename":"10307.json"},{"title":"07 | React-Hooks 设计动机与工作模式（下）","filename":"10308.json"},{"title":"08 | 深入 React-Hooks 工作机制：“原则”的背后，是“原理”","filename":"10309.json"},{"title":"09 | 真正理解虚拟 DOM：React 选它，真的是为了性能吗？","filename":"10310.json"},{"title":"10 | React 中的“栈调和”（Stack Reconciler）过程是怎样的？","filename":"10311.json"},{"title":"11 | setState 到底是同步的，还是异步的？","filename":"10312.json"},{"title":"12 | 如何理解 Fiber 架构的迭代动机与设计思想？","filename":"10313.json"},{"title":"13 | ReactDOM.render 是如何串联渲染链路的？（上）","filename":"10314.json"},{"title":"14 | ReactDOM.render 是如何串联渲染链路的？（中）","filename":"10315.json"},{"title":"15 | ReactDOM.render 是如何串联渲染链路的？（下）","filename":"10316.json"},{"title":"16 | 剖析 Fiber 架构下 Concurrent 模式的实现原理","filename":"10317.json"},{"title":"17 | 特别的事件系统：React 事件与 DOM 事件有何不同？","filename":"10318.json"},{"title":"18 | 揭秘 Redux 设计思想与工作原理（上）","filename":"10319.json"},{"title":"19 | 揭秘 Redux 设计思想与工作原理（下）","filename":"10320.json"},{"title":"20 | 从 Redux 中间件实现原理切入，理解“面向切面编程”","filename":"10321.json"},{"title":"21 | 从 React-Router 切入，系统学习前端路由解决方案","filename":"10322.json"},{"title":"22 | 思路拓展：如何打造高性能的 React 应用？","filename":"10323.json"},{"title":"23 | 跟 React 学设计模式：掌握编程“套路”，打造高质量应用","filename":"10324.json"},{"title":"结束语 | 聊聊 React 17，谈谈学习前端框架的心法","filename":"10325.json"}]},{"id":"104","title":"前端面试宝典之 React 篇","list":[{"title":"开篇词 | 如何拿下大厂前端面试","filename":"10401.json"},{"title":"01 | 你真的了解 React 吗？","filename":"10402.json"},{"title":"02 | 为什么 React 要用 JSX？","filename":"10403.json"},{"title":"03 | 如何避免生命周期中的坑？","filename":"10404.json"},{"title":"04 | 类组件与函数组件有什么区别呢？","filename":"10405.json"},{"title":"05 | 如何设计 React 组件？","filename":"10406.json"},{"title":"06 | setState 是同步更新还是异步更新？","filename":"10407.json"},{"title":"07 | 如何面向组件跨层级通信？","filename":"10408.json"},{"title":"08 | 列举一种你了解的 React 状态管理框架","filename":"10409.json"},{"title":"09 | Virtual DOM 的工作原理是什么？","filename":"10410.json"},{"title":"10 | 与其他框架相比，React 的 diff 算法有何不同？","filename":"10411.json"},{"title":"11 | 如何解释 React 的渲染流程？","filename":"10412.json"},{"title":"12 | React 的渲染异常会造成什么后果？","filename":"10413.json"},{"title":"13 | 如何分析和调优性能瓶颈？","filename":"10414.json"},{"title":"14 | 如何避免重复渲染？","filename":"10415.json"},{"title":"15 | 如何提升 React 代码可维护性？","filename":"10416.json"},{"title":"16 | React Hook 的使用限制有哪些？","filename":"10417.json"},{"title":"17 | useEffect 与 useLayoutEffect 区别在哪里？","filename":"10418.json"},{"title":"18 | 谈谈 React Hook 的设计模式","filename":"10419.json"},{"title":"19 | React-Router 的实现原理及工作方式分别是什么？","filename":"10420.json"},{"title":"20 | React 中你常用的工具库有哪些？","filename":"10421.json"},{"title":"彩蛋 | 如何写一份大厂 HR 满意的简历？","filename":"10422.json"},{"title":"结束语 | 沉淀知识体系，精进个人成长","filename":"10423.json"}]},{"id":"105","title":"重学数据结构与算法","list":[{"title":"开篇词 | 数据结构与算法，应该这样学！","filename":"10501.json"},{"title":"01 | 复杂度：如何衡量程序运行的效率？","filename":"10502.json"},{"title":"02 | 数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度","filename":"10503.json"},{"title":"03 | 增删查：掌握数据处理的基本操作,以不变应万变","filename":"10504.json"},{"title":"04 | 如何完成线性表结构下的增删查？","filename":"10505.json"},{"title":"05 | 栈：后进先出的线性表，如何实现增删查？","filename":"10506.json"},{"title":"06 | 队列：先进先出的线性表，如何实现增删查？","filename":"10507.json"},{"title":"07 | 数组：如何实现基于索引的查找？","filename":"10508.json"},{"title":"08 | 字符串：如何正确回答面试中高频考察的字符串匹配算法？","filename":"10509.json"},{"title":"09 | 树和二叉树：分支关系与层次结构下，如何有效实现增删查？","filename":"10510.json"},{"title":"10 | 哈希表：如何利用好高效率查找的“利器”？","filename":"10511.json"},{"title":"11 | 递归：如何利用递归求解汉诺塔问题？","filename":"10512.json"},{"title":"12 | 分治：如何利用分治法完成数据查找？","filename":"10513.json"},{"title":"13 | 排序：经典排序算法原理解析与优劣对比","filename":"10514.json"},{"title":"14 | 动态规划：如何通过最优子结构，完成复杂问题求解？","filename":"10515.json"},{"title":"15 | 定位问题才能更好地解决问题：开发前的复杂度分析与技术选型","filename":"10516.json"},{"title":"16 | 真题案例（一）：算法思维训练","filename":"10517.json"},{"title":"17 | 真题案例（二）：数据结构训练","filename":"10518.json"},{"title":"18 | 真题案例（三）：力扣真题训练","filename":"10519.json"},{"title":"19 | 真题案例（四）：大厂真题实战演练","filename":"10520.json"},{"title":"20 | 代码之外，技术面试中你应该具备哪些软素质？","filename":"10521.json"},{"title":"21 | 面试中如何建立全局观，快速完成优质的手写代码？","filename":"10522.json"},{"title":"加餐 | 课后练习题详解","filename":"10523.json"},{"title":"结束语 | 勤修内功，构建你的核心竞争力","filename":"10524.json"}]},{"id":"106","title":"趣学设计模式","list":[{"title":"开篇词 | 设计模式：程序员的基本功，你离及格还差多少？","filename":"10601.json"},{"title":"01 | 学习思维：怎样才能学好 Java 设计模式？","filename":"10602.json"},{"title":"02 | 组合思维：Unix 哲学到底给现代编程带来哪些重要启示？","filename":"10603.json"},{"title":"03 | 分层思维：为什么要做代码分层架构？","filename":"10604.json"},{"title":"04 | 工程思维：如何用软件工程方法解决开发难题？","filename":"10605.json"},{"title":"05 | 对象思维：面向对象编程有哪些优势？","filename":"10606.json"},{"title":"06 | 迭代思维：如何高效编程？","filename":"10607.json"},{"title":"07 | 单一原则：如何跳出错误抽象的误区？","filename":"10608.json"},{"title":"08 | 简单原则：如何写出“简单”代码？","filename":"10609.json"},{"title":"09 | 最少原则：如何实现“最少知识”代码？","filename":"10610.json"},{"title":"10 | 表达原则：如何让源代码成为一种逻辑线索？","filename":"10611.json"},{"title":"11 | 职责原则：如何在代码设计中实现职责分离？","filename":"10612.json"},{"title":"12 | 面向对象原则：面向对象编程框架到底长什么样？","filename":"10613.json"},{"title":"13 | 反转原则：如何减少代码间的相互影响？","filename":"10614.json"},{"title":"14 | 惯例原则：如何提升编程中的沟通效率？","filename":"10615.json"},{"title":"15 | 分离原则：如何将复杂问题拆分成小问题？","filename":"10616.json"},{"title":"16 | 契约原则：如何做好 API 接口设计？","filename":"10617.json"},{"title":"17 | 单例模式：如何有效进行程序初始化？","filename":"10618.json"},{"title":"18 | 建造者模式：如何创建不同形式的复杂对象？","filename":"10619.json"},{"title":"19 | 抽象工厂模式：如何统一不同代码风格下的代码级别？","filename":"10620.json"},{"title":"20 | 工厂方法模式：如何解决生成对象时的不确定性？","filename":"10621.json"},{"title":"21 | 原型模式：什么场景下需要用到对象拷贝？","filename":"10622.json"},{"title":"22 | 适配器模式：如何处理不同 API 接口的兼容性？","filename":"10623.json"},{"title":"23 | 桥接模式：如何实现抽象协议与不同实现的绑定？","filename":"10624.json"},{"title":"24 | 组合模式：如何用树形结构处理对象之间的复杂关系？","filename":"10625.json"},{"title":"25 | 装饰模式：如何在基础组件上扩展新功能？","filename":"10626.json"},{"title":"26 | 门面模式：如何实现 API 网关的高可用性？","filename":"10627.json"},{"title":"27 | 享元模式：如何通过共享对象减少内存加载消耗？","filename":"10628.json"},{"title":"28 | 代理模式：如何控制和管理对象的访问？","filename":"10629.json"},{"title":"29 | 访问者模式：如何实现对象级别的矩阵结构？","filename":"10630.json"},{"title":"30 | 模板方法模式：如何实现同一模板框架下的算法扩展？","filename":"10631.json"},{"title":"31 | 策略模式：如何解决不同活动策略的营销推荐场景？","filename":"10632.json"},{"title":"32 | 状态模式：如何通过有限状态机监控功能的“状态变化”？","filename":"10633.json"},{"title":"33 | 观察者模式：如何发送消息变化的通知？","filename":"10634.json"},{"title":"34 | 备忘录模式：如何在聊天会话中记录历史消息？","filename":"10635.json"},{"title":"35 | 中介者模式：如何通过中间层来解决耦合过多的问题？","filename":"10636.json"},{"title":"36 | 迭代器模式：如何实现遍历数据时的职责分离？","filename":"10637.json"},{"title":"37 | 解释器模式：如何实现一个自定义配置规则功能？","filename":"10638.json"},{"title":"38 | 命令模式：如何在一次请求中封装多个参数？","filename":"10639.json"},{"title":"39 | 责任链模式：如何解决审核、过滤场景问题？","filename":"10640.json"},{"title":"结束语 | 扬帆起航，从心开始","filename":"10641.json"}]},{"id":"107","title":"程序员的数学课","list":[{"title":"开篇词 | 数学，编程能力的营养根基","filename":"10701.json"},{"title":"01 | 从计数开始，程序员必知必会的数制转换法","filename":"10702.json"},{"title":"02 | 逻辑与沟通，怎样才能讲出有逻辑的话？","filename":"10703.json"},{"title":"03 | 用数学决策，如何规划好投入、转化和产出？","filename":"10704.json"},{"title":"04 | 万物可数学，经典公式是如何在生活中应用的？","filename":"10705.json"},{"title":"05 | 求极值：如何找到复杂业务的最优解？","filename":"10706.json"},{"title":"06 | 向量及其导数：计算机如何完成对海量高维度数据计算？","filename":"10707.json"},{"title":"07 | 线性回归：如何在离散点中寻找数据规律？","filename":"10708.json"},{"title":"08 | 加乘法则：如何计算复杂事件发生的概率？","filename":"10709.json"},{"title":"09 | 似然估计：如何利用 MLE 对参数进行估计？","filename":"10710.json"},{"title":"10 | 信息熵：事件的不确定性如何计算？","filename":"10711.json"},{"title":"11 | 灰度实验：如何设计灰度实验并计算实验的收益？","filename":"10712.json"},{"title":"12 | 统计学方法：如何证明灰度实验效果不是偶然得到的？","filename":"10713.json"},{"title":"13 | 复杂度：如何利用数学推导对程序进行优化？","filename":"10714.json"},{"title":"14 | 程序的循环：如何利用数学归纳法进行程序开发？","filename":"10715.json"},{"title":"15 | 递归：如何计算汉诺塔问题的移动步数？","filename":"10716.json"},{"title":"16 | 二分法：如何利用指数爆炸优化程序？","filename":"10717.json"},{"title":"17 | 动态规划：如何利用最优子结构解决问题？","filename":"10718.json"},{"title":"18 | AI 入门：利用 3 个公式搭建最简 AI 框架","filename":"10719.json"},{"title":"19 | 逻辑回归：如何让计算机做出二值化决策？","filename":"10720.json"},{"title":"20 | 决策树：如何对 NP 难复杂问题进行启发式求解？","filename":"10721.json"},{"title":"21 | 神经网络与深度学习：计算机是如何理解图像、文本和语音的？","filename":"10722.json"},{"title":"22 | 面试中那些坑了无数人的算法题","filename":"10723.json"},{"title":"23 | 站在生活的十字路口，如何用数学抉择？","filename":"10724.json"},{"title":"结束语 | 数学底子好，学啥都快","filename":"10725.json"}]},{"id":"108","title":"Vue.js 3.0 核心源码内参","list":[{"title":"开篇词 | 解析 Vue.js 源码，提升编码能力","filename":"10801.json"},{"title":"导读 | 一文看懂 Vue.js 3.0 的优化","filename":"10802.json"},{"title":"模块一导读 | 组件的实现：直击 Vue 核心的实现","filename":"10803.json"},{"title":"01 | 组件渲染：vnode 到真实 DOM 是如何转变的？","filename":"10804.json"},{"title":"02 | 组件更新：完整的 DOM diff 流程是怎样的？（上）","filename":"10805.json"},{"title":"03 | 组件更新：完整的 DOM diff 流程是怎样的？（下）","filename":"10806.json"},{"title":"模块二导读 | 逻辑复用最佳实践：Composition API","filename":"10807.json"},{"title":"04 | Setup：组件渲染前的初始化过程是怎样的？","filename":"10808.json"},{"title":"05 | 响应式：响应式内部的实现原理是怎样的？（上）","filename":"10809.json"},{"title":"07 | 计算属性：计算属性比普通函数好在哪里？","filename":"10810.json"},{"title":"08 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","filename":"10811.json"},{"title":"06 | 响应式：响应式内部的实现原理是怎样的？（下）","filename":"10812.json"},{"title":"09 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","filename":"10813.json"},{"title":"10 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","filename":"10814.json"},{"title":"11 | 依赖注入：子孙组件如何共享数据？","filename":"10815.json"},{"title":"12 | 模板解析：构造 AST 的完整流程是怎样的？（上）","filename":"10816.json"},{"title":"模块三导读 | 编译和优化：了解编译过程和背后的优化思想","filename":"10817.json"},{"title":"13 | 模板解析：构造 AST 的完整流程是怎样的？（下）","filename":"10818.json"},{"title":"14 | AST 转换：AST 节点内部做了哪些转换？（上）","filename":"10819.json"},{"title":"15 | AST 转换：AST 节点内部做了哪些转换？（下）","filename":"10820.json"},{"title":"16 | 生成代码：AST 如何生成可运行的代码？（上）","filename":"10821.json"},{"title":"17 | 生成代码：AST 如何生成可运行的代码？（下）","filename":"10822.json"},{"title":"模块四导读 | 实用特性：探索更多实用特性背后的原理","filename":"10823.json"},{"title":"18 | Props：Props 的初始化和更新流程是怎样的？","filename":"10824.json"},{"title":"19 | 插槽：如何实现内容分发？","filename":"10825.json"},{"title":"20 | 指令：指令完整的生命周期是怎样的？","filename":"10826.json"},{"title":"21 | v-model：双向绑定到底是怎么实现的？","filename":"10827.json"},{"title":"模块五导读 | 内置组件：学习 Vue 内置组件的实现原理","filename":"10828.json"},{"title":"22 | Teleport 组件：如何脱离当前组件渲染子组件？","filename":"10829.json"},{"title":"23 | KeepAlive 组件：如何让组件在内存中缓存和调度？","filename":"10830.json"},{"title":"24 | Transition 组件：过渡动画的实现原理是怎样的？（上）","filename":"10831.json"},{"title":"25 | Transition 组件：过渡动画的实现原理是怎样的？（下）","filename":"10832.json"},{"title":"特别放送导读 | 研究 Vue 官方生态的实现原理","filename":"10833.json"},{"title":"26 | Vue Router：如何实现一个前端路由？（上）","filename":"10834.json"},{"title":"27 |  Vue Router：如何实现一个前端路由？（下）","filename":"10835.json"},{"title":"结束语 | 终点也是起点","filename":"10836.json"}]},{"id":"109","title":"前端性能优化方法与实战","list":[{"title":"开篇词 | 开启刻意练习之路，进阶前端性能技术专家","filename":"10901.json"},{"title":"01 | 体系总览：性能优化体系及关键指标设定","filename":"10902.json"},{"title":"02 | 性能瓶颈点：从 URL 输入到页面加载整过程分析","filename":"10903.json"},{"title":"03 | 案例分析：移动端 M 站性能优化落地注意事项","filename":"10904.json"},{"title":"04 | 指标采集：首屏时间指标采集具体办法","filename":"10905.json"},{"title":"05 | 指标采集：白屏、卡顿、网络环境指标采集方法","filename":"10906.json"},{"title":"06 | 工具实践：性能 SDK 及上报策略设计","filename":"10907.json"},{"title":"07 | 平台实践：如何从 0 到 1 搭建前端性能平台","filename":"10908.json"},{"title":"08 | 诊断清单：如何实现监控预警并进行问题诊断","filename":"10909.json"},{"title":"09 | 优化手段：首屏秒开的 4 重保障","filename":"10910.json"},{"title":"10 | 优化手段：白屏 300ms 和界面流畅优化技巧","filename":"10911.json"},{"title":"11 | 工具实践：如何进行性能专项测试","filename":"10912.json"},{"title":"12 | 理论分析：Hybrid 下的性能优化整体分析","filename":"10913.json"},{"title":"13 | 高级进阶：保证首次加载为秒开的离线包设计","filename":"10914.json"},{"title":"14 | 高级进阶：瞒天过海的骨架屏及 SSR 优化手段","filename":"10915.json"},{"title":"15 | 高级进阶：WebView 层及代码架构层面优化","filename":"10916.json"},{"title":"16 | 黑科技：详解预请求、预加载及预渲染机制","filename":"10917.json"},{"title":"17 | 横向对比：百度、阿里云、美团性能方案对比","filename":"10918.json"},{"title":"18 | 性能演进：RN、Flutter、小程序和 Enhance Hybrid","filename":"10919.json"},{"title":"19 | 成长之路：前端技术专业能力与业务产出平衡","filename":"10920.json"},{"title":"结束语 | 开启性能优化实践之路","filename":"10921.json"}]},{"id":"110","title":"前端高手进阶","list":[{"title":"开篇词：带你一起筑建前端工程师的“护城河”","filename":"11001.json"},{"title":"第01讲：你真的熟悉 HTML 标签吗？","filename":"11002.json"},{"title":"第02讲：如何高效操作 DOM 元素？","filename":"11003.json"},{"title":"第03讲：3 个使用场景助你用好 DOM 事件","filename":"11004.json"},{"title":"第04讲：掌握 CSS 精髓：布局","filename":"11005.json"},{"title":"第05讲：如何管理你的 CSS 代码？","filename":"11006.json"},{"title":"加餐1：手写 CSS 预处理","filename":"11007.json"},{"title":"第06讲：浏览器如何渲染页面？","filename":"11008.json"},{"title":"第07讲：关于 JavaScript 的数据类型，你知多少？","filename":"11009.json"},{"title":"第08讲：为什么说函数是 JavaScript 的一等公民？","filename":"11010.json"},{"title":"第09讲：为什么代码没有按照编写顺序执行？","filename":"11011.json"},{"title":"第10讲：怎么复用你的代码？","filename":"11012.json"},{"title":"第11讲：为什么说 JavaScript 不适合大型项目？","filename":"11013.json"},{"title":"第12讲：浏览器如何执行 JavaScript 代码？","filename":"11014.json"},{"title":"第13讲：区分浏览器中的进程与线程","filename":"11015.json"},{"title":"加餐2：手写 Promise、async/await","filename":"11016.json"},{"title":"第14讲：HTTP 协议和它的“补丁”们","filename":"11017.json"},{"title":"第15讲：如何让浏览器更快地加载网络资源？","filename":"11018.json"},{"title":"第16讲：浏览器同源策略与跨域方案详解","filename":"11019.json"},{"title":"第17讲：前后端如何有效沟通？","filename":"11020.json"},{"title":"第18讲：你是怎么理解“组件”这个概念的？","filename":"11021.json"},{"title":"第19讲：把路由放在前端意味着什么？","filename":"11022.json"},{"title":"第20讲：详解组件通信之状态管理","filename":"11023.json"},{"title":"第21讲：你的代码到底是怎么编译的？","filename":"11024.json"},{"title":"第22讲：如何合理搭建前端项目？","filename":"11025.json"},{"title":"第23讲：谈性能优化到底在谈什么？","filename":"11026.json"},{"title":"第24讲：你的代码是怎么成为黑客工具的？","filename":"11027.json"},{"title":"第25讲：Node.js == 全栈？","filename":"11028.json"},{"title":"第26讲：常用的数据结构了解多少？","filename":"11029.json"},{"title":"第27讲：到底该不该了解算法？","filename":"11030.json"},{"title":"第28讲：你都了解过哪些编程方式？","filename":"11031.json"},{"title":"第29讲：框架到底用了哪些设计模式？","filename":"11032.json"},{"title":"第30讲：前端热点技术之 Serverless","filename":"11033.json"},{"title":"第31讲：微前端与功能的可重用性","filename":"11034.json"},{"title":"彩蛋：如何获得心仪的 Offer？","filename":"11035.json"},{"title":"结束语：谈谈前端工程师的职业规划（如何跳槽、如何晋升）","filename":"11036.json"}]},{"id":"111","title":"TypeScript 入门实战笔记","list":[{"title":"开篇词 | 你为什么要选择 TypeScript？","filename":"11101.json"},{"title":"01 | 如何快速搭建 TypeScript 学习开发环境？","filename":"11102.json"},{"title":"02 | 简单基础类型：TypeScript 与 JavaScript 有何不同？","filename":"11103.json"},{"title":"03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？","filename":"11104.json"},{"title":"04 | 什么是字面量类型、类型推断、类型拓宽和类型缩小？","filename":"11105.json"},{"title":"05 | 函数类型：返回值类型和参数类型到底如何定义？","filename":"11106.json"},{"title":"06 | 类类型：如何高效使用类型化的面向对象编程利器？","filename":"11107.json"},{"title":"07 | 接口类型与类型别名：这两者的用法与区别分别是什么？","filename":"11108.json"},{"title":"08 | 高级类型：如何快速读懂联合类型和交叉类型的含义？","filename":"11109.json"},{"title":"09 | 枚举类型：详解常见枚举类型的 7 种用法","filename":"11110.json"},{"title":"10 | 泛型：如何正确使用泛型约束类型变量？","filename":"11111.json"},{"title":"11 | 类型守卫：如何有效地保障类型的安全性？","filename":"11112.json"},{"title":"12 | 类型兼容：如何判断一个类型是否可以赋值给其他类型？","filename":"11113.json"},{"title":"13 | 必备增强类型系统的方式大盘点，让你的开发如虎添翼","filename":"11114.json"},{"title":"14 | 掌握 TypeScript 这些官方工具类型，让你的开发事半功倍","filename":"11115.json"},{"title":"15 | 类型编程：如何打造属于自己的工具类型？","filename":"11116.json"},{"title":"16 | tsconfig.json 配置：如何定制 TypeScript 的行为？","filename":"11117.json"},{"title":"17 | 来自 100 +项目经历的常见 TypeScript 错误汇总分析","filename":"11118.json"},{"title":"18 | 手把手教你使用 TypeScript 开发 Node.js 应用","filename":"11119.json"},{"title":"19 | 使用 TypeScript 开发 Web 应用的最佳实践","filename":"11120.json"},{"title":"20 | 如何将 JavaScript 应用切换至 TypeScript？","filename":"11121.json"},{"title":"结束语 | TypeScript 的这些实用技能，你不得不知","filename":"11122.json"}]},{"id":"112","title":"前端基础建设与架构 30 讲","list":[{"title":"开篇词 | 像架构师一样思考，突破技术成长瓶颈","filename":"11201.json"},{"title":"导读 | 前端技术发展回顾和架构升级之路","filename":"11202.json"},{"title":"01 | npm 安装机制及企业级部署私服原理","filename":"11203.json"},{"title":"02 | Yarn 的安装理念及如何破解依赖管理困境","filename":"11204.json"},{"title":"03 | CI 环境上的 npm 优化及更多工程化问题解析","filename":"11205.json"},{"title":"04 | 横向对比主流构建工具，了解构建工具的设计考量","filename":"11206.json"},{"title":"05 | Vite 实现：从源码分析出发，构建 bundleless 开发工程","filename":"11207.json"},{"title":"06 | core-js 及垫片理念：设计一个“最完美”的 Polyfill 方案","filename":"11208.json"},{"title":"07 | 梳理混乱的 Babel，不再被编译报错困扰","filename":"11209.json"},{"title":"08 | 探索前端工具链生态，制定一个统一标准化 babel-preset","filename":"11210.json"},{"title":"09 | 从实战出发，从 0 到 1 构建一个符合标准的公共库","filename":"11211.json"},{"title":"10 | 代码拆分和按需加载：缩减 bundle size，把性能做到极致","filename":"11212.json"},{"title":"11 | Tree Shaking：移除 JavaScript 上下文中的未引用代码","filename":"11213.json"},{"title":"12 | 如何理解 AST 实现和编译原理？","filename":"11214.json"},{"title":"13 | 工程化思维处理方案：如何实现应用主题切换功能？","filename":"11215.json"},{"title":"14 | 解析 Webpack 源码，实现自己的构建工具","filename":"11216.json"},{"title":"15 | 从编译到运行，跨端解析小程序多端方案","filename":"11217.json"},{"title":"16 | 原生跨平台技术：移动端跨平台到 Flutter 的技术变革","filename":"11218.json"},{"title":"17 | 学习 axios：封装一个结构清晰的 Fetch 库","filename":"11219.json"},{"title":"18 | 对比 Koa 和 Redux：分析前端中的中间件理念","filename":"11220.json"},{"title":"19 | 如何理解软件开发灵活性和高定制性？","filename":"11221.json"},{"title":"20 | 如何理解前端中面向对象的思想？","filename":"11222.json"},{"title":"21 | 如何利用 JavaScript 实现经典数据结构？","filename":"11223.json"},{"title":"22 | 剖析前端中的数据结构应用场景","filename":"11224.json"},{"title":"23 | npm script：打造一体化的构建和部署流程","filename":"11225.json"},{"title":"24 | 自动化代码检查：剖析 Lint 工具和工程化接入&amp;优化方案","filename":"11226.json"},{"title":"25 | 如何设计一个前端 + 移动端离线包方案？","filename":"11227.json"},{"title":"26 | 如何设计一个“万能”项目脚手架？","filename":"11228.json"},{"title":"27 | 同构渲染架构：实现一个 SSR 应用","filename":"11229.json"},{"title":"28 | 设计性能守卫系统：完善 CI/CD 流程","filename":"11230.json"},{"title":"29 | 实践打造网关：改造企业 BFF 方案","filename":"11231.json"},{"title":"30 | 实现高可用：使用 Puppeteer 生成性能最优的海报系统","filename":"11232.json"},{"title":"结束语 | 再谈项目的基建和架构，个人的价值和方向","filename":"11233.json"}]},{"id":"113","title":"前端工程化精讲","list":[{"title":"开篇词 | 建立上帝视角，全面系统掌握前端效率工程化","filename":"11301.json"},{"title":"01 | 项目基石：前端脚手架工具探秘","filename":"11302.json"},{"title":"02 | 界面调试：热更新技术如何开着飞机修引擎？","filename":"11303.json"},{"title":"03 | 构建提速：如何正确使用 SourceMap？","filename":"11304.json"},{"title":"04 | 接口调试：Mock 工具如何快速进行接口调试？","filename":"11305.json"},{"title":"05 | 编码效率：如何提高编写代码的效率？","filename":"11306.json"},{"title":"06 | 团队工具：如何利用云开发提升团队开发效率？","filename":"11307.json"},{"title":"07 | 低代码工具：如何用更少的代码实现更灵活的需求？","filename":"11308.json"},{"title":"08 | 无代码工具：如何做到不写代码就能高效交付？","filename":"11309.json"},{"title":"09 | 构建总览：前端构建工具的演进","filename":"11310.json"},{"title":"10 | 流程分解：Webpack 的完整构建流程","filename":"11311.json"},{"title":"11 | 编译提效：如何为 Webpack 编译阶段提速？","filename":"11312.json"},{"title":"12 | 打包提效：如何为 Webpack 打包阶段提速？","filename":"11313.json"},{"title":"13 | 缓存优化：那些基于缓存的优化方案","filename":"11314.json"},{"title":"14 | 增量构建：Webpack 中的增量构建","filename":"11315.json"},{"title":"15 | 版本特性：Webpack 5 中的优化细节","filename":"11316.json"},{"title":"16 | 无包构建：盘点那些 No-bundle 的构建方案","filename":"11317.json"},{"title":"17 | 部署初探：为什么一般不在开发环境下部署代码？","filename":"11318.json"},{"title":"18 | 工具盘点：掌握那些流行的代码部署工具","filename":"11319.json"},{"title":"19 | 安装提效：部署流程中的依赖安装效率优化","filename":"11320.json"},{"title":"20 | 流程优化：部署流程中的构建流程策略优化","filename":"11321.json"},{"title":"21 | 容器方案：从构建到部署，容器化方案的优势有哪些？","filename":"11322.json"},{"title":"22 | 案例分析：搭建基本的前端高效部署系统","filename":"11323.json"},{"title":"结束语 | 前端效率工程化的未来展望","filename":"11324.json"}]},{"id":"114","title":"数据结构与算法面试宝典","list":[{"title":"开篇词 |&nbsp;告别盲目刷题，击破算法面试","filename":"11401.json"},{"title":"01 | 栈：从简单栈到单调栈，解决经典栈问题","filename":"11402.json"},{"title":"02 | 队列：FIFO 队列与单调队列的深挖与扩展","filename":"11403.json"},{"title":"03 | 优先级队列：堆与优先级队列，筛选最优元素","filename":"11404.json"},{"title":"04 | 链表：如何利用“假头、新链表、双指针”解决链表题？（上）","filename":"11405.json"},{"title":"05 | 链表：如何利用“假头、新链表、双指针”解决链表题？（下）","filename":"11406.json"},{"title":"06 | 树：如何深度运用树的遍历？","filename":"11407.json"},{"title":"07 | 并查集：如何利用两行代码写并查集？","filename":"11408.json"},{"title":"加餐与答疑 | 第一期 ：一问一答","filename":"11409.json"},{"title":"08&nbsp;| 排序：如何利用合并与快排的小技巧，解决算法难题？","filename":"11410.json"},{"title":"09&nbsp;| 二分搜索：为什么说有序皆可用二分？","filename":"11411.json"},{"title":"10&nbsp;| 双指针：如何掌握最长、定长、最短区间问题的解题决窍？","filename":"11412.json"},{"title":"11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？","filename":"11413.json"},{"title":"12&nbsp;| 回溯：我把回溯总结成一个公式，回溯题一出就用它","filename":"11414.json"},{"title":"13&nbsp;| 搜索：如何掌握 DFS 与 BFS 的解题套路？","filename":"11415.json"},{"title":"14 | DP：我是怎么治好“DP&nbsp;头痛症”的？","filename":"11416.json"},{"title":"15&nbsp;| 字符串查找：为什么我最终选择了 BM 算法？","filename":"11417.json"},{"title":"16&nbsp;| 如何利用 DP 与单调队列寻找最大矩形？","filename":"11418.json"},{"title":"17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？","filename":"11419.json"},{"title":"18&nbsp;| 单词接龙：如何巧用深搜与广搜的变形？","filename":"11420.json"},{"title":"19&nbsp;| 最小体力消耗路径：如何突破经典题型，掌握解题模板？","filename":"11421.json"},{"title":"20&nbsp;| 5 种解法，如何利用常量空间求解最长有效括号长度？","filename":"11422.json"},{"title":"21&nbsp;| 安排会议室：如何利用多种方法安排会议室？","filename":"11423.json"},{"title":"22 |&nbsp;数据结构模板：如何让解题变成搭积木？","filename":"11424.json"},{"title":"23 |&nbsp;算法模板：如何让高频算法考点秒变默写题？","filename":"11425.json"},{"title":"彩蛋 | 聊聊我的大厂面试经历，谈谈我对算法学习的看法","filename":"11426.json"},{"title":"结束语 |&nbsp;算法的精进之路","filename":"11427.json"}]},{"id":"201","title":"计算机网络通关 29 讲","list":[{"title":"开篇词 | 一次搞定计算机网络，高效修炼程序员内功","filename":"20101.json"},{"title":"课前导读 | 程序员如何打好计算机领域的基础？","filename":"20102.json"},{"title":"01 | 漫游互联网：什么是蜂窝移动网络？","filename":"20103.json"},{"title":"02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？","filename":"20104.json"},{"title":"03 | TCP 的封包格式：TCP 为什么要粘包和拆包？","filename":"20105.json"},{"title":"04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？","filename":"20106.json"},{"title":"05 | UDP 协议：TCP 协议和 UDP 协议的优势和劣势？","filename":"20107.json"},{"title":"加餐 | 模块一思考题解答","filename":"20108.json"},{"title":"06 | IPv4 协议：路由和寻址的区别是什么？","filename":"20109.json"},{"title":"07 | IPv6 协议：Tunnel 技术是什么？","filename":"20110.json"},{"title":"08 | 局域网：NAT 是如何工作的？","filename":"20111.json"},{"title":"09 | TCP 实战：如何进行 TCP 抓包调试？","filename":"20112.json"},{"title":"加餐 | 模块二思考题解答","filename":"20113.json"},{"title":"10 | Socket 编程：epoll 为什么用红黑树？","filename":"20114.json"},{"title":"11 | 流和缓冲区：缓冲区的 flip 是怎么回事？","filename":"20115.json"},{"title":"12 | 网络 I/O 模型：BIO、NIO 和 AIO 有什么区别？","filename":"20116.json"},{"title":"13 | 面试中如何回答“怎样实现 RPC 框架”的问题？","filename":"20117.json"},{"title":"加餐 | 模块三思考题解答","filename":"20118.json"},{"title":"14 | DNS 域名解析系统：CNAME 记录的作用是？","filename":"20119.json"},{"title":"15 | 内容分发网络：请简述 CDN 回源如何工作？","filename":"20120.json"},{"title":"16 | HTTP 协议面试通关：强制缓存和协商缓存的区别是？","filename":"20121.json"},{"title":"17 | 流媒体技术：直播网站是如何实现的？","filename":"20122.json"},{"title":"18 | 爬虫和反爬虫：如何防止黑产爬取我的数据？","filename":"20123.json"},{"title":"加餐 | 模块四思考题解答","filename":"20124.json"},{"title":"19 | 网络安全概述：对称、非对称加密的区别是？","filename":"20125.json"},{"title":"20 | 信任链：为什么可以相信一个 HTTPS 网站？","filename":"20126.json"},{"title":"21 | 攻防手段介绍：如何抵御 SYN 拒绝攻击？","filename":"20127.json"},{"title":"加餐 | 模块五思考题解答","filename":"20128.json"},{"title":"结束语 | 未来需要怎样的工程师","filename":"20129.json"}]},{"id":"301","title":"成为会带团队的技术人","list":[{"title":"开篇词 | 在管理艺术中寻找确定性的“工程逻辑”","filename":"30101.json"},{"title":"01 | 稳定性（一）：如何应对事故并做好复盘？","filename":"30102.json"},{"title":"02 | 稳定性（二）：可用性治理的三个关键要点","filename":"30103.json"},{"title":"03 | 稳定性（三）：那些年源源不断的“红包”事故","filename":"30104.json"},{"title":"04 | 技术债务：如何带领团队从困境中突围而出？","filename":"30105.json"},{"title":"05 | 大项目：把握关键点，谋定而后动","filename":"30106.json"},{"title":"06 | 业务理解：深入业务是做好架构的前提","filename":"30107.json"},{"title":"07 | 架构设计：治理好系统复杂度才最务实","filename":"30108.json"},{"title":"08 | 定目标：让你的方向与公司的方向保持一致","filename":"30109.json"},{"title":"09 | 追过程：如何用 PDCA 做过程管理？","filename":"30110.json"},{"title":"10 | 奖优罚劣：怎样传递我们\"要什么\"与“不要什么”？","filename":"30111.json"},{"title":"11 | 勤沟通：在信任的基础上，让沟通简单且纯粹","filename":"30112.json"},{"title":"12 | 建机制：规则流程越建越多，为何效果却越来越差？","filename":"30113.json"},{"title":"13 | 知人善用：借事修人，借人成事","filename":"30114.json"},{"title":"14 | 找到人：招聘是 Leader 的责任，不是 HR 的","filename":"30115.json"},{"title":"15 | 能落地：90 天试用期，转正时我们要考察什么？","filename":"30116.json"},{"title":"16 | 升级汰换：“心要慈，刀要快”","filename":"30117.json"},{"title":"17 | 晋升：是不是技术到位、项目做好就够了？","filename":"30118.json"},{"title":"18 | 跨团队：没有汇报线的人和事就是推不动？","filename":"30119.json"},{"title":"19 | 做规划：除了交付和稳定性，还要规划什么？","filename":"30120.json"},{"title":"20 | 接手新团队：士气低、交付迟、事故多发，如何下手解决？","filename":"30121.json"},{"title":"结束语 | 岁月静好，技术人依然要负重前行","filename":"30122.json"}]}]