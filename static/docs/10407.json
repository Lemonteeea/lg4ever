{"title":"06 | setState 是同步更新还是异步更新？","context":"\n                    <p data-nodeid=\"893\" class=\"\">\n                      本讲我们一起来探讨“setState\n                      是同步更新还是异步更新”，这个问题在面试中应该如何回答。\n                    </p>\n                    <h3 data-nodeid=\"894\">破题</h3>\n                    <p data-nodeid=\"895\">\n                      “是 A 还是 B\n                      ”是一个在面试中经常会被问到的问题类型，这类问题有相当强的迷惑性，因为在不同的场景中会有不同的选择：\n                    </p>\n                    <ul data-nodeid=\"896\">\n                      <li data-nodeid=\"897\">\n                        <p data-nodeid=\"898\">可能是 A；</p>\n                      </li>\n                      <li data-nodeid=\"899\">\n                        <p data-nodeid=\"900\">也可能是 B；</p>\n                      </li>\n                      <li data-nodeid=\"901\">\n                        <p data-nodeid=\"902\">\n                          甚至 A 和 B 同时存在的可能性也是有的。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"903\">\n                      所以就需要把问题放在具体的场景中探讨，才能有更加全面准确的回答。在面对类似的问题时，要先把场景理清楚，再去思考如何回答，一定不要让自己犯“想当然”的错误。这是回答类似问题第一个需要注意的点。\n                    </p>\n                    <p data-nodeid=\"904\">\n                      回到 setState 本身上来，setState\n                      用于变更状态，触发组件重新渲染，更新视图\n                      UI。有很多应聘者，并不清楚 state\n                      在什么时候会被更新，所以难以解释到底是同步的还是异步的，也不清楚这个问题具体涉及哪些概念？\n                    </p>\n                    <p data-nodeid=\"905\">\n                      本题也是大厂面试中的一道高频题，常被用作检验应聘者的资深程度。\n                    </p>\n                    <p data-nodeid=\"906\">\n                      以上就是这个问题的“碎碎念”了，接下来是整理答题思路。\n                    </p>\n                    <h3 data-nodeid=\"907\">承题</h3>\n                    <p data-nodeid=\"908\">\n                      回到问题本身上来，其实思路很简单，只要能说清楚什么是同步场景，什么是异步场景，那问题自然而然就解决了。\n                    </p>\n                    <p data-nodeid=\"909\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/3D/Cip5yF_YUpOAALIlAABNx0PyF94306.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"1010\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"910\">入手</h3>\n                    <p data-nodeid=\"911\">\n                      在分析场景之前，需要先补充一个很重要的知识点，即合成事件，同样它也是\n                      React 面试中很容易被考察的点。合成事件与 setState\n                      的触发更新有千丝万缕的关系，也只有在了解合成事件后，我们才能继续聊\n                      setState。\n                    </p>\n                    <h4 data-nodeid=\"912\">合成事件</h4>\n                    <p data-nodeid=\"913\">\n                      在没有合成事件前，大家是如何处理事件的呢？由于很多同学都是直接从\n                      React 和 Vue\n                      开始入门的，所以很可能不太清楚这样一个在过去非常常见的场景。\n                    </p>\n                    <p data-nodeid=\"914\">\n                      假设一个列表的 ul 标签下面有 10000 个 li\n                      标签。现在需要添加点击事件，通过点击获取当前 li\n                      标签中的文本。那该如何操作？如果按照现在 React\n                      的编写方式，就是为每一个 li 标签添加 onclick 事件。有\n                      10000 个 li 标签，则会添加 10000\n                      个事件。这是一种非常不友好的方式，会对页面的性能产生影响。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;ul&gt;\n</div></li><li><div class=\"code-word\">  &lt;li onclick=\"geText(this)\"&gt;1&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li onclick=\"geText(this)\"&gt;2&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li onclick=\"geText(this)\"&gt;3&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li onclick=\"geText(this)\"&gt;4&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li onclick=\"geText(this)\"&gt;5&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &nbsp;...\n</div></li><li><div class=\"code-word\">  &lt;li onclick=\"geText(this)\"&gt;10000&lt;/li&gt;\n</div></li><li><div class=\"code-word\">&lt;/ul&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"916\">\n                      那该怎么优化呢？最恰当的处理方式是采用<strong\n                        data-nodeid=\"1021\"\n                        >事件委托</strong\n                      >。通过将事件绑定在 ul 标签上这样的方式来解决。当 li\n                      标签被点击时，由事件冒泡到父级的 ul 标签去触发，并在 ul\n                      标签的 onclick 事件中，确认是哪一个 li\n                      标签触发的点击事件。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;ul id=\"test\"&gt;\n</div></li><li><div class=\"code-word\">  &lt;li&gt;1&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li&gt;2&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li&gt;3&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li&gt;4&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li&gt;5&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li&gt;10000&lt;/li&gt;\n</div></li><li><div class=\"code-word\">&lt;/ul&gt;\n</div></li><li><div class=\"code-word\">&lt;script&gt;\n</div></li><li><div class=\"code-word\">  function getEventTarget(e) {\n</div></li><li><div class=\"code-word\">      e = e || window.event;\n</div></li><li><div class=\"code-word\">      return e.target || e.srcElement; \n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  var ul = document.getElementById('test');\n</div></li><li><div class=\"code-word\">  ul.onclick = function(event) {\n</div></li><li><div class=\"code-word\">      var target = getEventTarget(event);\n</div></li><li><div class=\"code-word\">      alert(target.innerHTML);\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">&lt;/script&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"918\">\n                      同样，出于性能考虑，合成事件也是如此：\n                    </p>\n                    <ul data-nodeid=\"919\">\n                      <li data-nodeid=\"920\">\n                        <p data-nodeid=\"921\">\n                          React 给 document 挂上事件监听；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"922\">\n                        <p data-nodeid=\"923\">DOM 事件触发后冒泡到 document；</p>\n                      </li>\n                      <li data-nodeid=\"924\">\n                        <p data-nodeid=\"925\">\n                          React 找到对应的组件，造出一个合成事件出来；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"926\">\n                        <p data-nodeid=\"927\">并按组件树模拟一遍事件冒泡。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"928\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/3E/CgpVE1_YUqKAA-jWAACt3Mh2xk8536.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"1029\"\n                      />\n                    </p>\n                    <div data-nodeid=\"929\">\n                      <p style=\"text-align: center\">\n                        React 17 之前的事件冒泡流程图\n                      </p>\n                    </div>\n                    <p data-nodeid=\"930\">\n                      所以这就造成了，在一个页面中，只能有一个版本的\n                      React。如果有多个版本，事件就乱套了。值得一提的是，这个问题在\n                      React 17 中得到了解决，事件委托不再挂在 document\n                      上，而是挂在 DOM 容器上，也就是 ReactDom.Render\n                      所调用的节点上。\n                    </p>\n                    <p data-nodeid=\"931\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/3E/Cip5yF_YUzCAWTyoAAB1ljK7rSM539.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1033\"\n                      />\n                    </p>\n                    <div data-nodeid=\"932\">\n                      <p style=\"text-align: center\">\n                        React 17 后的事件冒泡流程图\n                      </p>\n                    </div>\n                    <p data-nodeid=\"933\">\n                      那到底哪些事件会被捕获生成合成事件呢？可以从 React\n                      的源码测试文件中一探究竟。下面的测试快照中罗列了大量的事件名，也只有在这份快照中的事件，才会被捕获生成合成事件。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// react/packages/react-dom/src/__tests__/__snapshots__/ReactTestUtils-test.js.snap</span>\n</div></li><li><div class=\"code-word\">Array [\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"abort\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"animationEnd\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"animationIteration\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"animationStart\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"auxClick\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"beforeInput\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"blur\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"canPlay\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"canPlayThrough\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"cancel\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"change\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"click\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"close\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"compositionEnd\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"compositionStart\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"compositionUpdate\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"contextMenu\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"copy\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"cut\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"doubleClick\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"drag\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"dragEnd\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"dragEnter\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"dragExit\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"dragLeave\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"dragOver\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"dragStart\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"drop\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"durationChange\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"emptied\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"encrypted\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"ended\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"error\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"focus\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"gotPointerCapture\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"input\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"invalid\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"keyDown\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"keyPress\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"keyUp\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"load\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"loadStart\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"loadedData\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"loadedMetadata\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"lostPointerCapture\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"mouseDown\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"mouseEnter\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"mouseLeave\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"mouseMove\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"mouseOut\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"mouseOver\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"mouseUp\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"paste\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pause\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"play\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"playing\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerCancel\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerDown\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerEnter\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerLeave\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerMove\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerOut\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerOver\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"pointerUp\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"progress\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"rateChange\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"reset\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"scroll\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"seeked\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"seeking\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"select\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"stalled\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"submit\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"suspend\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"timeUpdate\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"toggle\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"touchCancel\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"touchEnd\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"touchMove\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"touchStart\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"transitionEnd\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"volumeChange\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"waiting\"</span>,\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-string\">\"wheel\"</span>,\n</div></li><li><div class=\"code-word\">\t]\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"935\">\n                      在有了合成事件的基础后，就更容易理解后续的内容了。\n                    </p>\n                    <h4 data-nodeid=\"936\">调用顺序</h4>\n                    <p data-nodeid=\"937\">\n                      setState 是不是异步的？我们来从头梳理。\n                    </p>\n                    <p data-nodeid=\"938\">\n                      <strong data-nodeid=\"1041\">异步场景</strong>\n                    </p>\n                    <p data-nodeid=\"939\">\n                      通常我们认为 setState 是异步的，就像这样一个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; state = {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; count: <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; componentDidMount(){\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count: <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}, () =&gt; {\n</div></li><li><div class=\"code-word\">            console.log(<span class=\"hljs-keyword\">this</span>.state.count) <span class=\"hljs-comment\">//1</span>\n</div></li><li><div class=\"code-word\">         })\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; console.log(<span class=\"hljs-keyword\">this</span>.state.count) <span class=\"hljs-comment\">// 0</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; render(){\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; ...\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"941\">\n                      由于我们接受 setState\n                      是异步的，所以会认为回调函数是异步回调，打出 0 的\n                      console.log 会先执行，打出 1 的会后执行。\n                    </p>\n                    <p data-nodeid=\"942\">那接下来这个案例的答案是什么呢？</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">    state = {\n</div></li><li><div class=\"code-word\">        count: <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    componentDidMount(){\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">           count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">         }, () =&gt; {\n</div></li><li><div class=\"code-word\">            console.log(<span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">         })\n</div></li><li><div class=\"code-word\">         <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">           count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">         }, () =&gt; {\n</div></li><li><div class=\"code-word\">            console.log(<span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">         })\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render(){\n</div></li><li><div class=\"code-word\">        ...\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"944\">\n                      如果你觉得答案是\n                      1,2，那肯定就错了。这种迷惑性极强的考题在面试中非常常见，因为它反直觉。\n                    </p>\n                    <p data-nodeid=\"945\">\n                      如果重新仔细思考，你会发现当前拿到的 this.state.count\n                      的值并没有变化，都是 0，所以输出结果应该是 1,1。\n                    </p>\n                    <p data-nodeid=\"946\">\n                      当然，也可以在 setState 函数中获取修改后的 state\n                      值进行修改。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">    state = {\n</div></li><li><div class=\"code-word\">        count: <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    componentDidMount(){\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">this</span>.setState(\n</div></li><li><div class=\"code-word\">          preState=&gt; ({\n</div></li><li><div class=\"code-word\">            count:preState.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">        }),()=&gt;{\n</div></li><li><div class=\"code-word\">           console.log(<span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">        })\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">this</span>.setState(\n</div></li><li><div class=\"code-word\">          preState=&gt;({\n</div></li><li><div class=\"code-word\">            count:preState.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">        }),()=&gt;{\n</div></li><li><div class=\"code-word\">           console.log(<span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">        })\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render(){\n</div></li><li><div class=\"code-word\">        ...\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"948\">\n                      这些通通是异步的回调，如果你以为输出结果是\n                      1,2，那就又错了，实际上是 2,2。\n                    </p>\n                    <p data-nodeid=\"949\">\n                      为什么会这样呢？当调用 setState\n                      函数时，就会把当前的操作放入队列中。React\n                      根据队列内容，合并 state\n                      数据，完成后再逐一执行回调，根据结果更新虚拟\n                      DOM，触发渲染。所以回调时，state\n                      已经合并计算完成了，输出的结果就是 2,2 了。\n                    </p>\n                    <p data-nodeid=\"950\">\n                      这非常反直觉，那为什么 React\n                      团队选择了这样一个行为模式，而不是同步进行呢？一种常见的说法是为了优化。通过异步的操作方式，累积更新后，批量合并处理，减少渲染次数，提升性能。但同步就不能批量合并吗？这显然不能完全作为\n                      setState 设计成异步的理由。\n                    </p>\n                    <p data-nodeid=\"951\">\n                      在 17 年的时候就有人提出这样一个疑问“<a\n                        href=\"https://github.com/facebook/react/issues/11527\"\n                        data-nodeid=\"1054\"\n                        >为什么 setState 是异步的</a\n                      >”，这个问题得到了官方团队的回复，原因有 2 个。\n                    </p>\n                    <ul data-nodeid=\"952\">\n                      <li data-nodeid=\"953\">\n                        <p data-nodeid=\"954\">\n                          <strong data-nodeid=\"1060\">保持内部一致性</strong\n                          >。如果改为同步更新的方式，尽管 setState\n                          变成了同步，但是 props 不是。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"955\">\n                        <p data-nodeid=\"956\">\n                          <strong data-nodeid=\"1065\"\n                            >为后续的架构升级启用并发更新</strong\n                          >。为了完成异步渲染，React 会在 setState\n                          时，根据它们的数据来源分配不同的优先级，这些数据来源有：事件回调句柄、动画效果等，再根据优先级并发处理，提升渲染性能。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"957\">\n                      从 React 17\n                      的角度分析，异步的设计无疑是正确的，使异步渲染等最终能在\n                      React 落地。那什么情况下它是同步的呢？\n                    </p>\n                    <p data-nodeid=\"958\">\n                      <strong data-nodeid=\"1070\">同步场景</strong>\n                    </p>\n                    <p data-nodeid=\"959\">\n                      异步场景中的案例使我们建立了这样一个认知：setState\n                      是异步的，但下面这个案例又会颠覆你的认知。如果我们将\n                      setState 放在 setTimeout 事件中，那情况就完全不同了。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">    state = {\n</div></li><li><div class=\"code-word\">        count: <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    componentDidMount(){\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">this</span>.setState({ count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span> });\n</div></li><li><div class=\"code-word\">        console.log(<span class=\"hljs-keyword\">this</span>.state.count);\n</div></li><li><div class=\"code-word\">        setTimeout(() =&gt; {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">this</span>.setState({ count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span> });\n</div></li><li><div class=\"code-word\">          console.log(<span class=\"hljs-string\">\"setTimeout: \"</span> + <span class=\"hljs-keyword\">this</span>.state.count);\n</div></li><li><div class=\"code-word\">        }, <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render(){\n</div></li><li><div class=\"code-word\">        ...\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"961\">\n                      那这时输出的应该是什么呢？如果你认为是 0,0，那么又错了。\n                    </p>\n                    <p data-nodeid=\"962\">\n                      正确的结果是 0,2。因为 setState\n                      并不是真正的异步函数，它实际上是通过队列延迟执行操作实现的，通过\n                      isBatchingUpdates 来判断 setState 是先存进 state\n                      队列还是直接更新。值为 true 则执行异步操作，false\n                      则直接同步更新。\n                    </p>\n                    <p data-nodeid=\"963\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/47/Cip5yF_YYfCAXIxiAAEJsQbj_hs785.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"1076\"\n                      /><br />\n                      在 onClick、onFocus\n                      等事件中，由于合成事件封装了一层，所以可以将\n                      isBatchingUpdates 的状态更新为 true；在 React\n                      的生命周期函数中，同样可以将 isBatchingUpdates\n                      的状态更新为 true。那么在 React\n                      自己的生命周期事件和合成事件中，可以拿到 isBatchingUpdates\n                      的控制权，将状态放进队列，控制执行节奏。而在外部的原生事件中，并没有外层的封装与拦截，无法更新\n                      isBatchingUpdates 的状态为 true。这就造成\n                      isBatchingUpdates 的状态只会为 false，且立即执行。所以在\n                      addEventListener&nbsp;、setTimeout、setInterval\n                      这些原生事件中都会同步更新。\n                    </p>\n                    <h3 data-nodeid=\"964\">回答</h3>\n                    <p data-nodeid=\"965\">接下来我们可以答题了。</p>\n                    <blockquote data-nodeid=\"966\">\n                      <p data-nodeid=\"967\">\n                        setState 并非真异步，只是看上去像异步。在源码中，通过\n                        isBatchingUpdates 来判断<br />\n                        setState 是先存进 state 队列还是直接更新，如果值为 true\n                        则执行异步操作，为 false 则直接更新。\n                      </p>\n                      <p data-nodeid=\"968\">\n                        那么什么情况下 isBatchingUpdates 会为 true 呢？在 React\n                        可以控制的地方，就为 true，比如在 React\n                        生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。\n                      </p>\n                      <p data-nodeid=\"969\">\n                        但在 React 无法控制的地方，比如原生事件，具体就是在\n                        addEventListener&nbsp;、setTimeout、setInterval\n                        等事件中，就只能同步更新。\n                      </p>\n                      <p data-nodeid=\"970\">\n                        一般认为，做异步设计是为了性能优化、减少渲染次数，React\n                        团队还补充了两点。\n                      </p>\n                      <ol data-nodeid=\"971\">\n                        <li data-nodeid=\"972\">\n                          <p data-nodeid=\"973\">\n                            保持内部一致性。如果将 state 改为同步更新，那尽管\n                            state 的更新是同步的，但是 props不是。\n                          </p>\n                        </li>\n                        <li data-nodeid=\"974\">\n                          <p data-nodeid=\"975\">启用并发更新，完成异步渲染。</p>\n                        </li>\n                      </ol>\n                    </blockquote>\n                    <p data-nodeid=\"976\">\n                      综上所述，我们可以整理出下面的知识导图。\n                    </p>\n                    <p data-nodeid=\"977\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/01/3E/CgpVE1_YU2KAStLdAAFVKxh7Dyg317.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"1092\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"978\">进阶</h3>\n                    <p data-nodeid=\"979\">\n                      这是一道经常会出现的 React setState\n                      笔试题：下面的代码输出什么呢？\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  state  = {\n</div></li><li><div class=\"code-word\">      count: <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    componentDidMount() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>});\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-keyword\">this</span>.state.count);\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>});\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-keyword\">this</span>.state.count);\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    setTimeout(() =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">this</span>.setState({count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>});\n</div></li><li><div class=\"code-word\">      console.log(<span class=\"hljs-keyword\">this</span>.state.count);\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">this</span>.setState({count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>});\n</div></li><li><div class=\"code-word\">      console.log(<span class=\"hljs-keyword\">this</span>.state.count);\n</div></li><li><div class=\"code-word\">    }, <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"981\">我们可以进行如下的分析：</p>\n                    <ul data-nodeid=\"982\">\n                      <li data-nodeid=\"983\">\n                        <p data-nodeid=\"984\">\n                          首先第一次和第二次的 console.log，都在 React\n                          的生命周期事件中，所以是异步的处理方式，则输出都为 0；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"985\">\n                        <p data-nodeid=\"986\">\n                          而在 setTimeout 中的 console.log\n                          处于原生事件中，所以会同步的处理再输出结果，但需要注意，虽然\n                          count 在前面经过了两次的 this.state.count +\n                          1，但是每次获取的 this.state.count\n                          都是初始化时的值，也就是 0；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"987\">\n                        <p data-nodeid=\"988\">\n                          所以此时 count 是 1，那么后续在 setTimeout\n                          中的输出则是 2 和 3。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"989\">所以完整答案是 0,0,2,3。</p>\n                    <h3 data-nodeid=\"990\">总结</h3>\n                    <p data-nodeid=\"991\">\n                      在本讲中，我们掌握了判断 setState\n                      是同步还是异步的核心关键点：更新队列。不得不再强调一下，看\n                      setState\n                      的输出结果是面试的常考点。所以在面试前，可以再针对性的看一下这部分内容，然后自己执行几次试试。\n                    </p>\n                    <p data-nodeid=\"992\">\n                      下一讲我将为你介绍另一个常考点，React 的跨组件通信。\n                    </p>\n                    <p data-nodeid=\"993\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"1107\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image/M00/72/94/Ciqc1F_EZ0eANc6tAASyC72ZqWw643.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"1106\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"994\">《大前端高薪训练营》</p>\n                    <p data-nodeid=\"995\" class=\"te-preview-highlight\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"1112\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}