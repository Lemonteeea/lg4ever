{"title":"11 | setState 到底是同步的，还是异步的？","context":"\n                    <p data-nodeid=\"853\" class=\"\">\n                      setState 对于许多的 React\n                      开发者来说，像是一个“最熟悉的陌生人”：\n                    </p>\n                    <ul data-nodeid=\"854\">\n                      <li data-nodeid=\"855\">\n                        <p data-nodeid=\"856\">\n                          当你入门 React 的时候，接触的第一波 API 里一定有\n                          setState——数据驱动视图，没它就没法创造变化；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"857\">\n                        <p data-nodeid=\"858\">\n                          当你项目的数据流乱作一团的时候，层层排查到最后，始作俑者也往往是\n                          setState——工作机制太复杂，文档又不说清楚，只能先“摸着石头过河”。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"859\">\n                      久而久之，setState 的工作机制渐渐与 React\n                      调和算法并驾齐驱，成了 React\n                      核心原理中区分度最高的知识模块之一。本讲我们就紧贴 React\n                      源码和时下最高频的面试题目，帮你从根儿上理解 setState\n                      工作流。\n                    </p>\n                    <h3 data-nodeid=\"860\">从一道面试题说起</h3>\n                    <p data-nodeid=\"861\">\n                      这是一道变体繁多的面试题，在 BAT\n                      等一线大厂的面试中考察频率非常高。首先题目会给出一个这样的\n                      App 组件，在它的内部会有如下代码所示的几个不同的 setState\n                      操作：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"./styles.css\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>{\n</div></li><li><div class=\"code-word\">  state = {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  increment = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'increment setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'increment setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  triple = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'triple setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'triple setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  reduce = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'reduce setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">count</span>: <span class=\"hljs-keyword\">this</span>.state.count - <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">      });\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'reduce setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">    },<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  render(){\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.increment}</span>&gt;</span>点我增加<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.triple}</span>&gt;</span>点我增加三倍<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.reduce}</span>&gt;</span>点我减少<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"863\">接着我把组件挂载到 DOM 上：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-dom\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./App\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> rootElement = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"root\"</span>);\n</div></li><li><div class=\"code-word\">ReactDOM.render(\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span>,\n</div></li><li><div class=\"code-word\">  rootElement\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"865\">\n                      此时浏览器里渲染出来的是如下图所示的三个按钮：\n                    </p>\n                    <p data-nodeid=\"866\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6C/16/Ciqc1F-qYzOAEHeBAAAouh3EFik606.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"955\"\n                      />\n                    </p>\n                    <p data-nodeid=\"867\">\n                      此时有个问题，若从左到右依次点击每个按钮，控制台的输出会是什么样的？读到这里，建议你先暂停\n                      1\n                      分钟在脑子里跑一下代码，看看和下图实际运行出来的结果是否有出入。\n                    </p>\n                    <p data-nodeid=\"868\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6D/8A/Ciqc1F-uMdqAVUoFAAIqtDlymxs173.png\"\n                        alt=\"图片4.png\"\n                        data-nodeid=\"959\"\n                      />\n                    </p>\n                    <p data-nodeid=\"869\">\n                      如果你是一个熟手 React 开发，那么 increment\n                      这个方法的输出结果想必难不倒你——正如许许多多的 React\n                      入门教学所声称的那样，“setState\n                      是一个异步的方法”，这意味着当我们执行完 setState 后，state\n                      本身并不会立刻发生改变。 因此紧跟在 setState 后面输出的\n                      state\n                      值，仍然会维持在它的初始状态（0）。在同步代码执行完毕后的某个“神奇时刻”，state\n                      才会“恰恰好”地增加到 1。\n                    </p>\n                    <p data-nodeid=\"870\">\n                      但这个“神奇时刻”到底何时发生，所谓的“恰恰好”又如何界定呢？如果你对这个问题搞不太清楚，那么\n                      triple 方法的输出对你来说就会有一定的迷惑性——setState\n                      一次不好使， setState 三次也没用，state\n                      到底是在哪个环节发生了变化呢？\n                    </p>\n                    <p data-nodeid=\"871\">\n                      带着这样的困惑，你决定先抛开一切去看看 reduce\n                      方法里是什么光景，结果更令人大跌眼镜，reduce 方法里的\n                      setState 竟然是同步更新的！这......到底是我们初学 React\n                      时拿到了错误的基础教程，还是电脑坏了？\n                    </p>\n                    <p data-nodeid=\"872\">\n                      要想理解眼前发生的这魔幻的一切，我们还得从 setState\n                      的工作机制里去找线索。\n                    </p>\n                    <h3 data-nodeid=\"873\">异步的动机和原理——批量更新的艺术</h3>\n                    <p data-nodeid=\"874\">\n                      我们首先要认知的一个问题：在 setState\n                      调用之后，都发生了哪些事情？基于截止到现在的专栏知识储备，你可能会更倾向于站在生命周期的角度去思考这个问题，得出一个如下图所示的结论：\n                    </p>\n                    <p data-nodeid=\"875\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6D/8A/Ciqc1F-uMeSAYK6FAABN0Vwnq5M814.png\"\n                        alt=\"图片3.png\"\n                        data-nodeid=\"968\"\n                      />\n                    </p>\n                    <p data-nodeid=\"876\">\n                      从图上我们可以看出，一个完整的更新流程，涉及了包括\n                      re-render（重渲染） 在内的多个步骤。re-render 本身涉及对\n                      DOM 的操作，它会带来较大的性能开销。假如说“一次 setState\n                      就触发一个完整的更新流程”这个结论成立，那么每一次 setState\n                      的调用都会触发一次\n                      re-render，我们的视图很可能没刷新几次就卡死了。这个过程如我们下面代码中的箭头流程图所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">  count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>    ===&gt;    shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">  count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>    ===&gt;    shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">  count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>    ===&gt;    shouldComponentUpdate-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"878\">\n                      事实上，这正是 setState 异步的一个重要的动机——<strong\n                        data-nodeid=\"975\"\n                        >避免频繁的 re-render</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"879\">\n                      在实际的 React 运行时中，setState 异步的实现方式有点类似于\n                      Vue 的 $nextTick 和浏览器里的 Event-Loop：<strong\n                        data-nodeid=\"981\"\n                        >每来一个\n                        setState，就把它塞进一个队列里“攒起来”。等时机成熟，再把“攒起来”的\n                        state 结果做合并，最后只针对最新的 state\n                        值走一次更新流程。这个过程，叫作“批量更新”</strong\n                      >，批量更新的过程正如下面代码中的箭头流程图所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">  count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>    ===&gt;    入队，[count+<span class=\"hljs-number\">1</span>的任务]\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">  count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>    ===&gt;    入队，[count+<span class=\"hljs-number\">1</span>的任务，count+<span class=\"hljs-number\">1</span>的任务]\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">  count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>    ===&gt;    入队, [count+<span class=\"hljs-number\">1</span>的任务，count+<span class=\"hljs-number\">1</span>的任务, count+<span class=\"hljs-number\">1</span>的任务]\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\">                                          ↓\n</div></li><li><div class=\"code-word\">                                         合并 state，[count+<span class=\"hljs-number\">1</span>的任务]\n</div></li><li><div class=\"code-word\">                                          ↓\n</div></li><li><div class=\"code-word\">                                         执行 count+<span class=\"hljs-number\">1</span>的任务\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"881\">\n                      值得注意的是，只要我们的同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次\n                      +1 最终只有一次生效，是因为在同一个方法中多次 setState\n                      的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React\n                      只会为其保留最后一次的更新）。因此就算我们在 React\n                      中写了这样一个 100 次的 setState 循环：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">test = () =&gt; {\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'循环100次 setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span>(let i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'循环100次 setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"883\">\n                      也只是会增加 state 任务入队的次数，并不会带来频繁的\n                      re-render。当 100 次调用结束后，仅仅是 state\n                      的任务队列内容发生了变化， state 本身并不会立刻改变：\n                    </p>\n                    <p data-nodeid=\"884\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6D/8B/Ciqc1F-uMfKALHLXAAEBeCrt5lE676.png\"\n                        alt=\"图片5.png\"\n                        data-nodeid=\"986\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"885\">\n                      “同步现象”背后的故事：从源码角度看 setState 工作流\n                    </h3>\n                    <p data-nodeid=\"886\">\n                      读到这里，相信你对异步这回事多少有些眉目了。接下来我们就要重点理解刚刚代码里最诡异的一部分——setState\n                      的同步现象：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">reduce = () =&gt; {\n</div></li><li><div class=\"code-word\">  setTimeout(() =&gt; {\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'reduce setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      count: <span class=\"hljs-keyword\">this</span>.state.count - <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'reduce setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  },<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"888\">\n                      从题目上看，setState 似乎是在 setTimeout\n                      函数的“保护”之下，才有了同步这一“特异功能”。事实也的确如此，假如我们把\n                      setTimeout 摘掉，setState 前后的 console 表现将会与\n                      increment 方法中无异：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">reduce = () =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// setTimeout(() =&gt; {</span>\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'reduce setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">    count: <span class=\"hljs-keyword\">this</span>.state.count - <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'reduce setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// },0);</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"890\">点击后的输出结果如下图所示：</p>\n                    <p data-nodeid=\"891\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6D/96/CgqCHl-uMguADJiMAAEld6KAKBI013.png\"\n                        alt=\"图片6.png\"\n                        data-nodeid=\"993\"\n                      />\n                    </p>\n                    <p data-nodeid=\"892\">\n                      现在问题就变得清晰多了：为什么 setTimeout 可以将 setState\n                      的执行顺序从异步变为同步？\n                    </p>\n                    <p data-nodeid=\"893\">\n                      这里我先给出一个结论：<strong data-nodeid=\"1000\"\n                        >并不是 setTimeout 改变了 setState，而是 setTimeout 帮助\n                        setState “逃脱”了 React 对它的管控。只要是在 React\n                        管控下的 setState，一定是异步的</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"894\">\n                      接下来我们就从 React 源码里，去寻求佐证这个结论的线索。\n                    </p>\n                    <blockquote data-nodeid=\"895\">\n                      <p data-nodeid=\"896\">\n                        tips：时下虽然市场里的 React 16、React 17 十分火热，但就\n                        setState 这块知识来说，React 15\n                        仍然是最佳的学习素材。因此下文所有涉及源码的分析，都会围绕\n                        React 15 展开。关于 React 16 之后 Fiber 机制给 setState\n                        带来的改变，我们会有专门一讲来分析，不在本讲的讨论范围内。\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"897\">解读 setState 工作流</h4>\n                    <p data-nodeid=\"898\">\n                      我们阅读任何框架的源码，都应该带着问题、带着目的去读。React\n                      中对于功能的拆分是比较细致的，setState\n                      这部分涉及了多个方法。为了方便你理解，我这里先把主流程提取为一张大图：\n                    </p>\n                    <p data-nodeid=\"899\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/04/81/Cip5yF_yswuAWzDfAAEc1lISh-Q211.png\"\n                        alt=\"3.png\"\n                        data-nodeid=\"1007\"\n                      />\n                    </p>\n                    <p data-nodeid=\"900\">\n                      接下来我们就沿着这个流程，逐个在源码中对号入座。首先是\n                      setState 入口函数：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">ReactComponent.prototype.setState = function (partialState, callback) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.updater.enqueueSetState(<span class=\"hljs-keyword\">this</span>, partialState);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (callback) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.updater.enqueueCallback(<span class=\"hljs-keyword\">this</span>, callback, <span class=\"hljs-string\">'setState'</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"902\">\n                      入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去。这里我们以对象形式的入参为例，可以看到它直接调用了\n                      this.updater.enqueueSetState 这个方法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">enqueueSetState: function (publicInstance, partialState) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 根据 this 拿到对应的组件实例</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance, <span class=\"hljs-string\">'setState'</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这个 queue 对应的就是一个组件实例的 state 数组</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n</div></li><li><div class=\"code-word\">  queue.push(partialState);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//  enqueueUpdate 用来处理当前的组件实例</span>\n</div></li><li><div class=\"code-word\">  enqueueUpdate(internalInstance);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"904\">\n                      这里我总结一下，enqueueSetState 做了两件事：\n                    </p>\n                    <ul data-nodeid=\"905\">\n                      <li data-nodeid=\"906\">\n                        <p data-nodeid=\"907\">\n                          将新的 state 放进组件的状态队列里；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"908\">\n                        <p data-nodeid=\"909\">\n                          用 enqueueUpdate 来处理将要更新的实例对象。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"910\">\n                      继续往下走，看看 enqueueUpdate 做了什么：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">enqueueUpdate</span><span class=\"hljs-params\">(component)</span> </span>{\n</div></li><li><div class=\"code-word\">  ensureInjected();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!batchingStrategy.isBatchingUpdates) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span>\n</div></li><li><div class=\"code-word\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span>\n</div></li><li><div class=\"code-word\">  dirtyComponents.push(component);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (component._updateBatchNumber == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    component._updateBatchNumber = updateBatchNumber + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"912\">\n                      这个 enqueueUpdate\n                      非常有嚼头，它引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates属性直接决定了当下是要走更新流程，还是应该排队等待；其中的batchedUpdates\n                      方法更是能够直接发起更新流程。由此我们可以大胆推测，<strong\n                        data-nodeid=\"1021\"\n                        >batchingStrategy 或许正是 React\n                        内部专门用于管控批量更新的对象</strong\n                      >。<br />\n                      接下来，我们就一起来研究研究这个 batchingStrategy。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * batchingStrategy源码\n</div></li><li><div class=\"code-word\">**/\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> ReactDefaultBatchingStrategy = {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 全局唯一的锁标识</span>\n</div></li><li><div class=\"code-word\">  isBatchingUpdates: <span class=\"hljs-keyword\">false</span>,\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 发起更新动作的方法</span>\n</div></li><li><div class=\"code-word\">  batchedUpdates: function(callback, a, b, c, d, e) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 缓存锁变量</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> alreadyBatchingStrategy = ReactDefaultBatchingStrategy. isBatchingUpdates\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 把锁“锁上”</span>\n</div></li><li><div class=\"code-word\">    ReactDefaultBatchingStrategy. isBatchingUpdates = <span class=\"hljs-function\"><span class=\"hljs-keyword\">true</span>\n</span></div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(alreadyBatchingStrategy)</span> {\n</div></li><li><div class=\"code-word\">      callback(a, b, c, d, e)\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 启动事务，将 callback 放进事务里执行</span>\n</div></li><li><div class=\"code-word\">      transaction.perform(callback, <span class=\"hljs-keyword\">null</span>, a, b, c, d, e)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"914\">\n                      batchingStrategy\n                      对象并不复杂，你可以理解为它是一个“锁管理器”。\n                    </p>\n                    <p data-nodeid=\"915\">\n                      这里的“锁”，是指 React 全局唯一的 isBatchingUpdates\n                      变量，isBatchingUpdates 的初始值是\n                      false，意味着“当前并未进行任何批量更新操作”。每当 React\n                      调用 batchedUpdate\n                      去执行更新动作时，会先把这个锁给“锁上”（置为\n                      true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入\n                      dirtyComponents\n                      里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是\n                      React 面对大量状态仍然能够实现有序分批处理的基石。\n                    </p>\n                    <p data-nodeid=\"916\">\n                      理解了批量更新整体的管理机制，还需要注意 batchedUpdates\n                      中，有一个引人注目的调用：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">transaction.perform(callback, <span class=\"hljs-keyword\">null</span>, a, b, c, d, e)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"918\">\n                      这行代码为我们引出了一个更为硬核的概念——React 中的\n                      Transaction（事务）机制。\n                    </p>\n                    <h4 data-nodeid=\"919\">\n                      理解 React 中的 Transaction（事务） 机制\n                    </h4>\n                    <p data-nodeid=\"920\">\n                      Transaction 在 React 源码中的分布可以说非常广泛。如果你在\n                      Debug React 项目的过程中，发现函数调用栈中出现了\n                      initialize、perform、close、closeAll 或者 notifyAll\n                      这样的方法名，那么很可能你当前就处于一个 Trasaction 中。\n                    </p>\n                    <p data-nodeid=\"921\">\n                      Transaction 在 React 源码中表现为一个核心类，React\n                      官方曾经这样描述它：<strong data-nodeid=\"1033\"\n                        >Transaction 是创建一个黑盒</strong\n                      >，该黑盒能够封装任何的方法。因此，那些需要在函数运行前、后运行的方法可以通过此方法封装（即使函数运行中有异常抛出，这些固定的方法仍可运行），实例化\n                      Transaction 时只需提供相关的方法即可。\n                    </p>\n                    <p data-nodeid=\"922\">\n                      这段话初读有点拗口，这里我推荐你结合 React\n                      源码中的一段针对 Transaction 的注释来理解它：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">* &lt;pre&gt;\n</div></li><li><div class=\"code-word\"> *                       wrappers (injected at creation time)\n</div></li><li><div class=\"code-word\"> *                                      +        +\n</div></li><li><div class=\"code-word\"> *                                      |        |\n</div></li><li><div class=\"code-word\"> *                    +-----------------|--------|--------------+\n</div></li><li><div class=\"code-word\"> *                    |                 v        |              |\n</div></li><li><div class=\"code-word\"> *                    |      +---------------+   |              |\n</div></li><li><div class=\"code-word\"> *                    |   +--|    wrapper1   |---|----+         |\n</div></li><li><div class=\"code-word\"> *                    |   |  +---------------+   v    |         |\n</div></li><li><div class=\"code-word\"> *                    |   |          +-------------+  |         |\n</div></li><li><div class=\"code-word\"> *                    |   |     +----|   wrapper2  |--------+   |\n</div></li><li><div class=\"code-word\"> *                    |   |     |    +-------------+  |     |   |\n</div></li><li><div class=\"code-word\"> *                    |   |     |                     |     |   |\n</div></li><li><div class=\"code-word\"> *                    |   v     v                     v     v   | wrapper\n</div></li><li><div class=\"code-word\"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants\n</div></li><li><div class=\"code-word\"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained\n</div></li><li><div class=\"code-word\"> * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;\n</div></li><li><div class=\"code-word\"> *                    | |   | |   |   |         |   |   | |   | |\n</div></li><li><div class=\"code-word\"> *                    | |   | |   |   |         |   |   | |   | |\n</div></li><li><div class=\"code-word\"> *                    | |   | |   |   |         |   |   | |   | |\n</div></li><li><div class=\"code-word\"> *                    | +---+ +---+   +---------+   +---+ +---+ |\n</div></li><li><div class=\"code-word\"> *                    |  initialize                    close    |\n</div></li><li><div class=\"code-word\"> *                    +-----------------------------------------+\n</div></li><li><div class=\"code-word\"> * &lt;/pre&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"924\">\n                      说白了，Transaction 就像是一个“壳子”，它首先会将目标函数用\n                      wrapper（一组 initialize 及 close 方法称为一个 wrapper）\n                      封装起来，同时需要使用 Transaction 类暴露的 perform\n                      方法去执行它。如上面的注释所示，在 anyMethod\n                      执行之前，perform 会先执行所有 wrapper 的 initialize\n                      方法，执行完后，再执行所有 wrapper 的 close 方法。这就是\n                      React 中的事务机制。\n                    </p>\n                    <h4 data-nodeid=\"925\">“同步现象”的本质</h4>\n                    <p data-nodeid=\"926\">\n                      下面结合对事务机制的理解，我们继续来看在\n                      ReactDefaultBatchingStrategy\n                      这个对象。ReactDefaultBatchingStrategy\n                      其实就是一个批量更新策略事务，它的 wrapper\n                      有两个：FLUSH_BATCHED_UPDATES 和 RESET_BATCHED_UPDATES。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> RESET_BATCHED_UPDATES = {\n</div></li><li><div class=\"code-word\">  initialize: emptyFunction,\n</div></li><li><div class=\"code-word\">  close: function () {\n</div></li><li><div class=\"code-word\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> FLUSH_BATCHED_UPDATES = {\n</div></li><li><div class=\"code-word\">  initialize: emptyFunction,\n</div></li><li><div class=\"code-word\">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)\n</div></li><li><div class=\"code-word\">};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"928\">\n                      我们把这两个 wrapper 套进 Transaction\n                      的执行机制里，不难得出一个这样的流程：\n                    </p>\n                    <p data-nodeid=\"929\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/2E/Ciqc1F-x-tyAbioYAACikzik89A130.png\"\n                        alt=\"图片5.png\"\n                        data-nodeid=\"1049\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6630\" class=\"te-preview-highlight\">\n                      到这里，相信你对 isBatchingUpdates\n                      管控下的批量更新机制已经了然于胸。但是 setState\n                      为何会表现同步这个问题，似乎还是没有从当前展示出来的源码里得到根本上的回答。这是因为\n                      batchedUpdates 这个方法，不仅仅会在 setState\n                      之后才被调用。若我们在 React 源码中全局搜索\n                      batchedUpdates，会发现调用它的地方很多，但与更新流有关的只有这两个地方：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// ReactMount.js</span>\n</div></li><li><div class=\"code-word\">_renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 实例化组件</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> componentInstance = instantiateReactComponent(nextElement);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始渲染直接调用 batchedUpdates 进行同步渲染</span>\n</div></li><li><div class=\"code-word\">  ReactUpdates.batchedUpdates(\n</div></li><li><div class=\"code-word\">    batchedMountComponentIntoNode,\n</div></li><li><div class=\"code-word\">    componentInstance,\n</div></li><li><div class=\"code-word\">    container,\n</div></li><li><div class=\"code-word\">    shouldReuseMarkup,\n</div></li><li><div class=\"code-word\">    context\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"932\">\n                      这段代码是在首次渲染组件时会执行的一个方法，我们看到它内部调用了一次\n                      batchedUpdates，这是因为在组件的渲染过程中，会按照顺序调用各个生命周期函数。开发者很有可能在声明周期函数中调用\n                      setState。因此，我们需要通过开启 batch\n                      来确保所有的更新都能够进入 dirtyComponents\n                      里去，进而确保初始渲染流程中所有的 setState 都是生效的。\n                    </p>\n                    <p data-nodeid=\"933\">\n                      下面代码是 React\n                      事件系统的一部分。当我们在组件上绑定了事件之后，事件中也有可能会触发\n                      setState。为了确保每一次 setState 都有效，React\n                      同样会在此处手动开启批量更新。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// ReactEventListener.js</span>\n</div></li><li><div class=\"code-word\">dispatchEvent: function (topLevelType, nativeEvent) {\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 处理事件</span>\n</div></li><li><div class=\"code-word\">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">finally</span> {\n</div></li><li><div class=\"code-word\">    TopLevelCallbackBookKeeping.release(bookKeeping);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"935\">\n                      话说到这里，一切都变得明朗了起来：isBatchingUpdates\n                      这个变量，在 React\n                      的生命周期函数以及合成事件执行前，已经被 React\n                      悄悄修改为了 true，这时我们所做的 setState\n                      操作自然不会立即生效。当函数执行完毕后，事务的 close\n                      方法会再把 isBatchingUpdates 改为 false。\n                    </p>\n                    <p data-nodeid=\"936\">\n                      以开头示例中的 increment 方法为例，整个过程像是这样：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">increment = () =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 进来先锁上</span>\n</div></li><li><div class=\"code-word\">  isBatchingUpdates = <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'increment setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">    count: <span class=\"hljs-keyword\">this</span>.state.count + <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'increment setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 执行完函数再放开</span>\n</div></li><li><div class=\"code-word\">  isBatchingUpdates = <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"938\">\n                      很明显，在 isBatchingUpdates 的约束下，setState\n                      只能是异步的。而当 setTimeout\n                      从中作祟时，事情就会发生一点点变化：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">reduce = () =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 进来先锁上</span>\n</div></li><li><div class=\"code-word\">  isBatchingUpdates = <span class=\"hljs-function\"><span class=\"hljs-keyword\">true</span>\n</span></div></li><li><div class=\"code-word\">  <span class=\"hljs-title\">setTimeout</span><span class=\"hljs-params\">(()</span> =&gt; {\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'reduce setState前的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      count: <span class=\"hljs-keyword\">this</span>.state.count - <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'reduce setState后的count'</span>, <span class=\"hljs-keyword\">this</span>.state.count)\n</div></li><li><div class=\"code-word\">  },<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 执行完函数再放开</span>\n</div></li><li><div class=\"code-word\">  isBatchingUpdates = <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"940\">\n                      会发现，咱们开头锁上的那个 isBatchingUpdates，对\n                      setTimeout 内部的执行逻辑完全没有约束力。因为\n                      isBatchingUpdates 是在同步代码中变化的，而 setTimeout\n                      的逻辑是异步执行的。当 this.setState\n                      调用真正发生的时候，isBatchingUpdates 早已经被重置为了\n                      false，这就使得当前场景下的 setState\n                      具备了立刻发起同步更新的能力。所以咱们前面说的没错——<strong\n                        data-nodeid=\"1061\"\n                        >setState\n                        并不是具备同步这种特性，只是在特定的情境下，它会从 React\n                        的异步管控中“逃脱”掉</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"941\">总结</h3>\n                    <p data-nodeid=\"942\">\n                      道理很简单，原理却很复杂。最后，我们再一次面对面回答一下标题提出的问题，对整个\n                      setState 工作流做一个总结。\n                    </p>\n                    <p data-nodeid=\"943\">\n                      setState\n                      并不是单纯同步/异步的，它的表现会因调用场景的不同而不同：在\n                      React 钩子函数及合成事件中，它表现为异步；而在\n                      setTimeout、setInterval 等函数中，包括在 DOM\n                      原生事件中，它都表现为同步。这种差异，本质上是由 React\n                      事务机制和批量更新机制的工作方式来决定的。\n                    </p>\n                    <p data-nodeid=\"944\" class=\"\">\n                      行文至此，相信你已经对 setState\n                      有了知根知底的理解。我们整篇文章的讨论，目前都建立在 React\n                      15 的基础上。React 16 以来，整个 React\n                      核心算法被重写，setState\n                      也不可避免地被“Fiber化”。那么到底什么是“Fiber”，它到底怎样改变着包括\n                      setState 在内的 React\n                      的各个核心技术模块，这就是我们下面两讲要重点讨论的问题了。\n                    </p>\n            "}