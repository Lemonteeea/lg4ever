{"title":"19 | React-Router 的实现原理及工作方式分别是什么？","context":"\n                    <p data-nodeid=\"16212\" class=\"\">\n                      如果你在社区留言询问 React\n                      的状态管理库用什么，那评论区的回复会直接争破头，“Redux\n                      天下第一”“Mobx 万岁”，当然还有使用 Hooks 的 useReducer\n                      派。但如果说起 React 路由，那毫无争议就是 React Router\n                      了，别无二家。对于这样一个在生态中具有统治地位的常用库，我们就必须严肃对待了，因为在面试中大概率会被问到，而问的方向往往会从实现原理与工作方式两个维度去展开。这一讲我们就来具体分析下这个问题应该如何作答。\n                    </p>\n                    <h3 data-nodeid=\"16213\">审题</h3>\n                    <p data-nodeid=\"16214\">\n                      其实在真实的面试中通常不会出现像标题这样的提问方式，会更细化一点，比如“它的原理是什么”“它的代码组织方式是怎样的”“它的设计模式是什么样的”“某个功能是如何实现的”，等等。我们不会去穷尽所有细化的问题，而是通过<strong\n                        data-nodeid=\"16297\"\n                        >梳理脉络</strong\n                      >的方式去掌握它。这些问题实际上分为两类——what is it 和 how\n                      does it works，也就是标题中所提到的实现原理与工作方式。\n                    </p>\n                    <p data-nodeid=\"16215\">\n                      首先聊一下<strong data-nodeid=\"16307\">实现原理</strong\n                      >。实现原理应该<strong data-nodeid=\"16308\"\n                        >由外到内</strong\n                      >去探索，每个库的根本原理是立足于自身生态以外的。React\n                      Router 的基础原理是什么呢？这需要我们跳出 React\n                      生态去寻求答案，也只有掌握了根本原理后才能回到 React\n                      Router 内部，去梳理它的实践方案。\n                    </p>\n                    <p data-nodeid=\"16216\">\n                      其次是<strong data-nodeid=\"16318\">工作方式</strong\n                      >。工作方式的探索应该是<strong data-nodeid=\"16319\"\n                        >从整体到局部</strong\n                      >的。从宏观视角挖掘 React Router 的架构设计模式，比如\n                      React Router\n                      内部的模块有哪些，分别采取了什么模式进行设计并运行，又是如何完成协同工作的；从局部挖掘模块的实现方式，比如\n                      A 模块是如何实现的，其内在的原理又是怎么样的。\n                    </p>\n                    <p data-nodeid=\"16217\">\n                      那么在理清了以上的主线之后，我们才不会惧怕更细化的问题，这就是抓大放小，抓主要放次要。\n                    </p>\n                    <h3 data-nodeid=\"16218\">承题</h3>\n                    <p data-nodeid=\"16219\">\n                      基于以上的分析可以整理答题思路了，将答案简化到两个方向上去。\n                    </p>\n                    <ol data-nodeid=\"16220\">\n                      <li data-nodeid=\"16221\">\n                        <p data-nodeid=\"16222\">\n                          实现原理，包含基础原理与 React Router 内部的实践方案。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"16223\">\n                        <p data-nodeid=\"16224\">\n                          工作方式，包含整体设计模式与关键模块的实现方案。那如何定义关键模块呢？最简单的方案莫过于打开官方文档扫一眼提到过的模块，那就是最常用且最容易被提问的知识点。当然你也许会想，这样去准备会不会太简单了，面试官不会拿更冷门儿的内容来提问吗？要知道，生僻冷门的知识点在面试中就算考倒了应聘者也没有什么意义。面试是为了甄别应聘者的技能熟练度，所以只要抓住常用内容就好了。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"16225\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/0A/A0/CgpVE2ASbeOAT09tAABSj878oCQ150.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"16327\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"16226\">破题</h3>\n                    <h4 data-nodeid=\"16227\">实现原理</h4>\n                    <p data-nodeid=\"16228\">\n                      <strong data-nodeid=\"16333\">基础原理</strong>\n                    </p>\n                    <p data-nodeid=\"16229\">\n                      现在的网页大部分是以<strong data-nodeid=\"16355\"\n                        >单页应用（SPA）的方案</strong\n                      >完成交付。当我们访问\n                      <a href=\"http://example.com\" data-nodeid=\"16341\"\n                        >http://example.com</a\n                      >/a 或者\n                      <a href=\"http://example.com\" data-nodeid=\"16345\"\n                        >http://example.com</a\n                      >/b 时，路由完全由前端开发者在<strong data-nodeid=\"16356\"\n                        >网页层自行控制</strong\n                      >。通俗点来讲，就是通过浏览器中的 JavaScript\n                      控制页面路由。但在过去的多页应用（MPA）时代，路由完全是由<strong\n                        data-nodeid=\"16357\"\n                        >服务端进行控制</strong\n                      >的。\n                    </p>\n                    <p data-nodeid=\"16230\">\n                      为什么会有这样一个变化呢？技术并不是凭空出现的，往往先有需求，再有方案，只有理解其中的原因才能体会技术的深刻变化。\n                    </p>\n                    <p data-nodeid=\"16231\">\n                      前端在路由上经历了<strong data-nodeid=\"16368\"\n                        >四次变化</strong\n                      >，最初的路由管理权<strong data-nodeid=\"16369\"\n                        >由后端完全控制</strong\n                      >，前端页面通过在模板中插入后端语言变量的方式完成开发。这个时代最明显的技术特征是\n                      Java 的\n                      JSP。这样的开发方式效率很低，在工作协同上，前后端相互严重依赖。\n                    </p>\n                    <p data-nodeid=\"16232\">\n                      但当\n                      <strong data-nodeid=\"16375\">AJAX 技术</strong\n                      >兴起后，前端网页不再与后端页面直接耦合了，工程也得以分离。这个时代最明显的特征是多个\n                      HTML 页面，并由 Nginx\n                      等静态文件服务完成托管，这是第二次变化。在这次变化中解除了前后端开发者的直接依赖，前端开发者可以自行维护独立的前端工程。但在这个工程中，有多个\n                      HTML 需要维护，它们各自分离，需要引用不同的 JS 与\n                      CSS，对于工程复用又是一个难题。\n                    </p>\n                    <p data-nodeid=\"16233\">\n                      于是迎来了第三次变化，在这次变化中，最明显的是\n                      <strong data-nodeid=\"16397\"\n                        >JavaScript 成为前端开发的主角</strong\n                      >，无论是 HTML、CSS 还是路由都通过 JavaScript\n                      来控制。在这个阶段中，最具特征的技术栈是<strong\n                        data-nodeid=\"16398\"\n                        >AngularJS</strong\n                      >。我们要知道，前端并不能真正地去控制路由，比如请求\n                      <a href=\"http://example.com\" data-nodeid=\"16387\"\n                        >http://example.com</a\n                      >/a 与\n                      <a href=\"http://example.com\" data-nodeid=\"16391\"\n                        >http://example.com</a\n                      >/b，一定会返回两个页面，这就需要一种方案去模拟路由，所以\n                      <strong data-nodeid=\"16399\">Hash 路由</strong\n                      >作为一个折中的解决方案登上了舞台。类似下面这样，通过在\n                      Hash 中添加路由路径的方式控制前端路由。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//example.com#a</span>\n</div></li><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//example.com#b</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"16235\">\n                      Hash 路由在实践上非常成功，使得<strong data-nodeid=\"16405\"\n                        >开发者的注意力得以从前端的繁杂信息中进一步收敛</strong\n                      >。在现代前端工程中，你会发现大部分的代码都是由 JavaScript\n                      独立完成的，这在最初是完全不可想象的。\n                    </p>\n                    <p data-nodeid=\"16236\">\n                      接下来随着浏览器对 HTML5 中 History pushState\n                      的支持，前端路由迎来了第四次变化。这次我们终于可以不再写\n                      #a 这样的路由了，而是回归到最初的写法——<a\n                        href=\"http://example.com/a\"\n                        data-nodeid=\"16409\"\n                        >http://example.com/a</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"16237\">\n                      那为什么 History pushState 可以办到呢？它分两部分进行。\n                    </p>\n                    <p data-nodeid=\"16238\">\n                      第一部分<strong data-nodeid=\"16421\">在浏览器完成</strong\n                      >，HTML5 引入了 history.pushState() 和\n                      history.replaceState() 两个函数，它们分别可以<strong\n                        data-nodeid=\"16422\"\n                        >添加和修改历史记录条目</strong\n                      >。在浏览器侧的表现行为则是：\n                    </p>\n                    <ul data-nodeid=\"16239\">\n                      <li data-nodeid=\"16240\">\n                        <p data-nodeid=\"16241\">\n                          pushState 修改当前浏览器地址栏中的网址路径；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"16242\">\n                        <p data-nodeid=\"16243\">\n                          replaceState 则是替换网址路径。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"16244\">\n                      使用 pushState 和 replaceState\n                      时，浏览器并不会刷新当前页面，而仅仅修改网址，此时如果用户刷新页面才会重新拉取。\n                      所以需要注意，既然\n                      <a href=\"http://example.com/\" data-nodeid=\"16428\"\n                        >http://example.com</a\n                      >\n                      本身指向编译产出物 index.html，那么\n                      <a href=\"http://example.com/\" data-nodeid=\"16432\"\n                        >http://example.com/</a\n                      >a 也需要指向 index.html，那就需要在服务端去配置完成。\n                    </p>\n                    <p data-nodeid=\"16245\">\n                      所以第二部分是在服务端的进行配置修改，被称为\n                      historyApiFallback。如果你了解过 webpack\n                      的配置，那么一定看见过\n                      historyApiFallback，它的作用就是将所有 404 请求响应到\n                      index.html。那么同理需要在 Nginx 或者 Node 层去配置\n                      historyApiFallback，同样是将 404 请求响应到 index.html\n                      就可以了。至此，前端路由才算完全完成，那 React Router\n                      内部是怎样呢？\n                    </p>\n                    <p data-nodeid=\"16246\">\n                      <strong data-nodeid=\"16438\">实践方案</strong>\n                    </p>\n                    <p data-nodeid=\"16247\">\n                      翻开 React Router 的代码，你会发现 React Router\n                      提供了三个库，分别是 react-router、react-router-dom 及\n                      react-router-native。但如果细看，你会发现 react-router\n                      是没有 UI 层的，react-router-dom = react-router + Dom\n                      UI，而 react-router-native = react-router + native UI。DOM\n                      版本与 Native\n                      版本最大限度地复用了同一个底层路由逻辑，如下图所示。\n                    </p>\n                    <p data-nodeid=\"16248\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/92/B5/CgqCHmASbgeAENJNAAAVuHLm4y4724.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"16442\"\n                      />\n                    </p>\n                    <p data-nodeid=\"16249\">\n                      在 DOM 版本中提供的基础路由是\n                      <strong data-nodeid=\"16448\">BrowserRouter</strong\n                      >，它的源码是这样的：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { Router } from <span class=\"hljs-string\">\"react-router\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { createBrowserHistory as createHistory } from <span class=\"hljs-string\">\"history\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BrowserRouter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  history = createHistory(<span class=\"hljs-keyword\">this</span>.props);\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> &lt;Router history={<span class=\"hljs-keyword\">this</span>.history} children={<span class=\"hljs-keyword\">this</span>.props.children} /&gt;;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"16251\">\n                      那这段源码做了什么呢？我们可以看到在 render 部分直接应用了\n                      react-router 中的 Router 组件，在 history 属性中赋值了\n                      createBrowserHistory 生成的变量。在 react-router-native\n                      版本中代码完全一样，只是把 createBrowserHistory 替换成了\n                      createMemoryHistory。所以真正的路由处理角色其实是\n                      <a\n                        href=\"https://github.com/ReactTraining/history\"\n                        data-nodeid=\"16452\"\n                        >history 库</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"16252\">\n                      总结一下，在 React Router 中路由通过<strong\n                        data-nodeid=\"16463\"\n                        >抽象 history 库统一管理完成</strong\n                      >，history 库支持BrowserHistory 与 MemoryHistory\n                      两种类型。打开源码看一下 BrowserHistory\n                      实际上调用的就是浏览器的 History\n                      API，也就是基础原理的部分，那为什么还有 MemoryHistory\n                      呢？因为 React Native\n                      并不是运行在浏览器环境中，所以需要在内存中构建一个自己的版本，原理上就是一个数组，有兴趣的同学可以看一下<a\n                        href=\"https://github.com/ReactTraining/history/blob/master/packages/history/index.ts\"\n                        data-nodeid=\"16461\"\n                        >这块代码</a\n                      >的 886 行。\n                    </p>\n                    <h4 data-nodeid=\"16253\">工作方式</h4>\n                    <p data-nodeid=\"16254\">\n                      <strong data-nodeid=\"16468\">设计模式</strong>\n                    </p>\n                    <p data-nodeid=\"16255\">\n                      <strong data-nodeid=\"16472\">Monorepo</strong>\n                    </p>\n                    <p data-nodeid=\"16256\">\n                      要理解 React Router\n                      的设计模式，我们不妨先看一下代码目录结构。如下图所示，整个代码被分割成了四个文件夹，这四个文件夹又各自是一个库，那这四个库如何联动的呢？这里用到了<strong\n                        data-nodeid=\"16478\"\n                        >Monorepo</strong\n                      >的设计。\n                    </p>\n                    <p data-nodeid=\"16257\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/92/B5/CgqCHmASbiOABcqaAAEoQ_5ks_g452.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"16481\"\n                      />\n                    </p>\n                    <p data-nodeid=\"16258\">\n                      与 Monorepo 相对的概念是<strong data-nodeid=\"16499\"\n                        >Multirepo</strong\n                      >。Multirepo 就是我们常用的开发模式，<strong\n                        data-nodeid=\"16500\"\n                        >一个仓库对应一个工程</strong\n                      >，<strong data-nodeid=\"16501\">子团队自行维护</strong\n                      >。如果这几个工程存在强协同，需要在一个迭代周期中完成新功能上线，那沟通协调成本就非常大了，你需要等别的工程发布更新后才能开发。所以在这里\n                      React Router 使用了 Monorepo\n                      的工程架构，使工程代码对团队中的每一个人都<strong\n                        data-nodeid=\"16502\"\n                        >具备透明度</strong\n                      >。在同一次迭代中，库之间互相引用代码也更为容易。关于\n                      Multirepo 和 Monorepo 的区别如下图所示：\n                    </p>\n                    <p data-nodeid=\"16259\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/92/AA/Ciqc1GASbiuAZi47AAMc6IEs2Ww683.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"16505\"\n                      />\n                    </p>\n                    <p data-nodeid=\"16260\">\n                      通常会使用\n                      <strong data-nodeid=\"16511\">Lerna</strong> 作为开发管理\n                      Monorepo 的开发工具，它的主要用户包括\n                      Babel、React、umi、React Router 等。个人感觉最有意思的点是\n                      Lerna 这个名字非常贴切。Lerna\n                      是希腊神话中的九头蛇，赫拉克勒斯的十二功绩之一就是猎杀九头蛇。看着九头蛇这个形象，像不像一个仓库里面存放了多个可用的库呢？\n                    </p>\n                    <p data-nodeid=\"16261\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/0A/A1/CgpVE2ASbjKAWA1yAAaff6ihcKs486.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"16514\"\n                      />\n                    </p>\n                    <div data-nodeid=\"16262\">\n                      <p style=\"text-align: center\">图片源自 React 官网</p>\n                    </div>\n                    <p data-nodeid=\"16263\">\n                      <strong data-nodeid=\"16518\">Context</strong>\n                    </p>\n                    <p data-nodeid=\"16264\">\n                      第二个比较重要的设计模式是使用 Context API\n                      完成数据共享。在第 05 讲\n                      <a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=566#/detail/pc?id=5795\"\n                        data-nodeid=\"16522\"\n                        >“如何设计 React 组件？”</a\n                      >中详细介绍了相关的内容，这里就不再赘述了。你可以自行阅读下\n                      <a\n                        href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/RouterContext.js\"\n                        data-nodeid=\"16526\"\n                        >packages/react-router/modules/RouterContext.js</a\n                      >、<a\n                        href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js\"\n                        data-nodeid=\"16530\"\n                        >packages/react-router/modules/Router.js</a\n                      >\n                      文件。除此以外再阅读下\n                      <a\n                        href=\"https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/withRouter.js\"\n                        data-nodeid=\"16534\"\n                        >packages/react-router/modules/withRouter.js</a\n                      >\n                      的源码。\n                    </p>\n                    <p data-nodeid=\"16265\">\n                      <strong data-nodeid=\"16539\">关键模块</strong>\n                    </p>\n                    <p data-nodeid=\"16266\">\n                      在了解整体架构设计后，我们就可以开始梳理关键模块了。那该怎么梳理呢？梳理其实就是一种通过结构化展示认知的方式。你可以从整体到局部，从宏观到微观，从外到内。但如果没有很好的思路，那就分类，分类是永远不过时的梳理技巧。从功能角度，我们可以把\n                      React Router 的组件分为三类：\n                    </p>\n                    <ul data-nodeid=\"16267\">\n                      <li data-nodeid=\"16268\">\n                        <p data-nodeid=\"16269\">\n                          Context 容器，分别是 Router 与\n                          MemoryRouter，主要提供上下文消费容器；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"16270\">\n                        <p data-nodeid=\"16271\">\n                          直接消费者，提供路由匹配功能，分别是\n                          Route、Redirect、Switch；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"16272\">\n                        <p data-nodeid=\"16273\">\n                          与平台关联的功能组件，分别是 react-router-dom 中的\n                          Link、NavLink 以及 react-router-native 中的\n                          DeepLinking。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"16274\">\n                      在有分类以后，是不是感觉对整体模块有一种尽在掌握的感觉？那接下来就可以答题了。\n                    </p>\n                    <h3 data-nodeid=\"16275\">答题</h3>\n                    <blockquote data-nodeid=\"18010\">\n                      <p data-nodeid=\"18011\">\n                        React Router 路由的基础实现原理分为两种，如果是切换 Hash\n                        的方式，那么依靠浏览器 Hash 变化即可；如果是切换网址中的\n                        Path，就要用到 HTML5 History API 中的\n                        pushState、replaceState\n                        等。在使用这个方式时，还需要在服务端完成\n                        historyApiFallback 配置。\n                      </p>\n                      <p data-nodeid=\"18012\">\n                        在 React Router 内部主要依靠 history 库完成，这是由\n                        React Router\n                        自己封装的库，为了实现跨平台运行的特性，内部提供两套基础\n                        history，一套是直接使用浏览器的 History API，用于支持\n                        react-router-dom；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持\n                        react-router-native。\n                      </p>\n                      <p data-nodeid=\"18013\">\n                        React Router\n                        的工作方式可以分为设计模式与关键模块两个部分。从设计模式的角度出发，在架构上通过\n                        Monorepo 进行库的管理。Monorepo\n                        具有团队间透明、迭代便利的优点。其次在整体的数据通信上使用了\n                        Context API 完成上下文传递。\n                      </p>\n                      <p data-nodeid=\"18014\" class=\"te-preview-highlight\">\n                        在关键模块上，主要分为三类组件：第一类是&nbsp;Context\n                        容器，比如 Router 与\n                        MemoryRouter；第二类是消费者组件，用以匹配路由，主要有\n                        Route、Redirect、Switch\n                        等；第三类是与平台关联的功能组件，比如\n                        Link、NavLink、DeepLinking 等。\n                      </p>\n                    </blockquote>\n\n                    <p data-nodeid=\"16281\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/0A/9E/Cip5yGASblWAeI84AAESDjKgi9U468.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"16552\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"16282\">总结</h3>\n                    <p data-nodeid=\"16283\">\n                      本讲我们聊了 React Router\n                      的相关内容。但我希望你掌握的不只是 React Router\n                      的内容，而是一套对于开源库的学习方法，通过这个方法再举一反三到其他的开源库中完成学习并掌握。\n                    </p>\n                    <p data-nodeid=\"16284\">\n                      在这里为你留一个关于 React Router 的小问题：如果我当前在 A\n                      页面编辑文字内容，不小心点击了返回，可能会退回 B\n                      页面，那如何阻断这个过程呢？希望你能将解决方案留言在评论区。\n                    </p>\n                    <p data-nodeid=\"16285\">\n                      下一讲是本专栏的最后一篇，我将和你一起梳理 React 生态。\n                    </p>\n                    <hr data-nodeid=\"16286\" />\n                    <p data-nodeid=\"16287\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"16561\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image/M00/72/94/Ciqc1F_EZ0eANc6tAASyC72ZqWw643.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"16560\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"16288\">《大前端高薪训练营》</p>\n                    <p data-nodeid=\"16289\" class=\"\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"16566\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}