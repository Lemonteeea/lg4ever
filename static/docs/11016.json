{"title":"加餐2：手写 Promise、async/await","context":"\n                    <p data-nodeid=\"909\" class=\"\">\n                      Promise、async/await\n                      已经逐渐成为主流的异步处理方式，所以了解其实现原理非常重要。这一课时我们就来讲讲\n                      Promise 和 async/await 的实现。\n                    </p>\n                    <h3 data-nodeid=\"910\">Promise/A+ 规范</h3>\n                    <p data-nodeid=\"911\">\n                      在编写 Promise 之前，我们必须了解 Promise/A+\n                      规范。由于内容较长，下面我总结了几点，更详细的内容可以查阅\n                      <a href=\"https://promisesaplus.com/\" data-nodeid=\"1027\"\n                        >Promise/A+ 规范</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"912\">\n                      Promise 是一个对象或者函数，对外提供了一个 then\n                      函数，内部拥有 3 个状态。\n                    </p>\n                    <h4 data-nodeid=\"913\">then 函数</h4>\n                    <p data-nodeid=\"914\">then 函数接收两个函数作为可选参数：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">promise.then(onFulfilled, onRejected)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"916\">同时遵循下面几个规则：</p>\n                    <ul data-nodeid=\"917\">\n                      <li data-nodeid=\"918\">\n                        <p data-nodeid=\"919\">\n                          如果可选参数不为函数时应该被忽略；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"920\">\n                        <p data-nodeid=\"921\">\n                          两个函数都应该是异步执行的，即放入事件队列等待下一轮\n                          tick，而非立即执行；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"922\">\n                        <p data-nodeid=\"923\">\n                          当调用 onFulfilled 函数时，会将当前 Promise\n                          的值作为参数传入；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"924\">\n                        <p data-nodeid=\"925\">\n                          当调用 onRejected 函数时，会将当前 Promise\n                          的失败原因作为参数传入；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"926\">\n                        <p data-nodeid=\"927\">then 函数的返回值为 Promise。</p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"928\">Promise 状态</h4>\n                    <p data-nodeid=\"929\">\n                      Promise 的 3 个状态分别为 pending、fulfilled 和 rejected。\n                    </p>\n                    <ul data-nodeid=\"930\">\n                      <li data-nodeid=\"931\">\n                        <p data-nodeid=\"932\">\n                          pending：“等待”状态，可以转移到 fulfilled 或者\n                          rejected 状态\n                        </p>\n                      </li>\n                      <li data-nodeid=\"933\">\n                        <p data-nodeid=\"934\">\n                          fulfilled：“执行”（或“履行”）状态，是 Promise\n                          的最终态，表示执行成功，该状态下不可再改变。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"935\">\n                        <p data-nodeid=\"936\">\n                          rejected：“拒绝”状态，是 Promise\n                          的最终态，表示执行失败，该状态不可再改变。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"937\">Promise 解决过程</h4>\n                    <p data-nodeid=\"1136\" class=\"te-preview-highlight\">\n                      Promise 解决过程是一个抽象的操作，即接收一个 promise\n                      和一个值 x，目的就是对 Promise\n                      形式的执行结果进行统一处理。需要考虑以下 4 种情况。\n                    </p>\n\n                    <p data-nodeid=\"939\">\n                      <strong data-nodeid=\"1048\"\n                        >情况 1： x 等于 promise</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"940\">\n                      抛出一个 TypeError 错误，拒绝 promise。\n                    </p>\n                    <p data-nodeid=\"941\">\n                      <strong data-nodeid=\"1053\"\n                        >情况 2：x 为 Promise 的实例</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"942\">\n                      如果 x 处于等待状态，那么 promise 继续等待至 x\n                      执行或拒绝，否则根据 x 的状态执行/拒绝 promise。\n                    </p>\n                    <p data-nodeid=\"943\">\n                      <strong data-nodeid=\"1058\">情况 3：x 为对象或函数</strong>\n                    </p>\n                    <p data-nodeid=\"944\">\n                      该情况的核心是取出 x.then 并调用，在调用的时候将 this 指向\n                      x。将 then 回调函数中得到结果 y 传入新的 Promise\n                      解决过程中，形成一个递归调用。其中，如果执行报错，则以对应的错误为原因拒绝\n                      promise。\n                    </p>\n                    <p data-nodeid=\"945\">\n                      这一步是处理拥有 then()\n                      函数的对象或函数，这类对象或函数我们称之为“thenable”。注意，它只是拥有\n                      then() 函数，并不是 Promise 实例。\n                    </p>\n                    <p data-nodeid=\"946\">\n                      <strong data-nodeid=\"1064\"\n                        >情况 4：如果 x 不为对象或函数</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"947\">以 x 作为值，执行 promise。</p>\n                    <h3 data-nodeid=\"948\">Promise 实现</h3>\n                    <p data-nodeid=\"949\">\n                      下面我们就根据规范来逐步实现一个 Promise。\n                    </p>\n                    <h4 data-nodeid=\"950\">Promise() 函数及状态</h4>\n                    <p data-nodeid=\"951\">\n                      由于 Promise 只有 3 个 状态，这里我们可以先创建 3\n                      个“常量”来消除魔术字符串：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">var&nbsp;PENDING&nbsp;=&nbsp;'pending'\n</div></li><li><div class=\"code-word\">var&nbsp;FULFILLED&nbsp;=&nbsp;'fulfilled'\n</div></li><li><div class=\"code-word\">var&nbsp;REJECTED&nbsp;=&nbsp;'rejected\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"953\">\n                      由于 Promise\n                      可以被实例化，所以可以定义成类或函数，这里为了增加难度，先考虑在\n                      ES5 环境下实现，所以写成构造函数的形式。\n                    </p>\n                    <p data-nodeid=\"954\">\n                      使用过 Promise 的人肯定知道，在创建 Promise\n                      的时候会传入一个回调函数，该回调函数会接收两个参数，分别用来执行或拒绝当前\n                      Promise。同时考虑到 Promise\n                      在执行时可能会有返回值，在拒绝时会给出拒绝原因，我们分别用\n                      value 和 reason 两个变量来表示。具体代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">Promise</span>(<span class=\"hljs-params\">execute</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;<span class=\"hljs-keyword\">var</span>&nbsp;self&nbsp;=&nbsp;<span class=\"hljs-keyword\">this</span>;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;self.state&nbsp;=&nbsp;PENDING;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(self.state&nbsp;===&nbsp;PENDING)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.state&nbsp;=&nbsp;FULFILLED;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.value&nbsp;=&nbsp;value;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(self.state&nbsp;===&nbsp;PENDING)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.state&nbsp;=&nbsp;REJECTED;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.reason&nbsp;=&nbsp;reason;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;<span class=\"hljs-keyword\">try</span>&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;execute(resolve,&nbsp;reject);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">catch</span>&nbsp;(e)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;reject(e);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"956\">\n                      我们在第 09 课时中提过，Promise\n                      是单次执行的，所以需要判断状态为 PENDING 的时候再执行函数\n                      resolve() 或函数 reject() 。同时 Promise\n                      的内部异常不能直接抛出，所以要进行异常捕获。\n                    </p>\n                    <h4 data-nodeid=\"957\">then() 函数</h4>\n                    <p data-nodeid=\"958\">\n                      每个 Promise 实例都有一个 then() 函数，该函数会访问\n                      Promise 内部的值或拒绝原因，所以通过函数原型 prototype\n                      来实现。then()\n                      函数接收两个回调函数作为参数，于是写成下面的形式：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">onFulfilled, onRejected</span>) </span>{\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"960\">\n                      根据第 1\n                      条原则，如果可选参数不为函数时应该被忽略，所以在函数\n                      then() 内部加上对参数的判断：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">onFulfilled = <span class=\"hljs-keyword\">typeof</span> onFulfilled === <span class=\"hljs-string\">\"function\"</span> ? onFulfilled : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">return</span> x\n</div></li><li><div class=\"code-word\">};\n</div></li><li><div class=\"code-word\">onRejected = <span class=\"hljs-keyword\">typeof</span> onRejected === <span class=\"hljs-string\">\"function\"</span> ? onRejected : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">throw</span> e\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"962\">\n                      根据第 2\n                      条规则，传入的回调函数是异步执行的。要模拟异步，可以通过\n                      setTimeout 来延迟执行。再根据第 3 条和第 4 条规则，应根据\n                      Promise 的状态来执行对应的回调，执行状态下调用\n                      onFulfilled() 函数，拒绝状态下调用 onRejected() 函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">switch</span> (self.state) {\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">case</span> FULFILLED:\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; onFulfilled(self.value);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; })\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">case</span> REJECTED:\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; onRejected(self.reason);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; })\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">case</span> PENDING:\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// todo</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"964\">\n                      等待状态下就有些麻烦了，需要等到 Promise\n                      状态转变时才能调用。\n                    </p>\n                    <p data-nodeid=\"965\">\n                      按照常规处理方式，可以建立一个监听，监听 Promise\n                      的状态值改变。由于浏览器环境和 Node.js\n                      环境的事件监听不一样，考虑兼容性，这种实现会比较复杂。\n                    </p>\n                    <p data-nodeid=\"966\">\n                      换个角度来看，在不考虑异常的情况下 Promise\n                      的状态改变只依赖于构造函数中的 resolve() 函数和 reject()\n                      函数执行。所以可考虑将 onFulfilled() 和 onRejected()\n                      函数先保存到 Promise 属性 onFulfilledFn 和 onRejectedFn\n                      中，等到状态改变时再调用。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">case</span> PENDING:\n</div></li><li><div class=\"code-word\">&nbsp; self.onFulfilledFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; onFulfilled(self.value);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">&nbsp; self.onRejectedFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; onRejected(self.reason);\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">break</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"968\">\n                      最后看第 5 条规则，then() 被调用时应该返回一个新的\n                      Promise，所以在上面的 3\n                      种状态的处理逻辑中，都应该创建并返回一个 Promise\n                      实例。以执行状态为例，可以改成下面的样子。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">case</span> FULFILLED:\n</div></li><li><div class=\"code-word\">&nbsp; promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; onFulfilled(self.value);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; reject(e)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; })\n</div></li><li><div class=\"code-word\">&nbsp; });\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"970\">\n                      同时，它带来的另一个效果是<strong data-nodeid=\"1086\"\n                        >支持链式调用</strong\n                      >。在链式调用的情况下，如果 Promise\n                      实例处于等待状态，那么需要保存多个 resolve() 或 reject()\n                      函数，所以 onFulfilledFn 和 onRejectedFn 应该改成数组。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">case</span> PENDING:\n</div></li><li><div class=\"code-word\">&nbsp; promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; self.onFulfilledFn.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; onFulfilled(self.value);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; reject(e)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; });\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; self.onRejectedFn.push(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; onRejected(self.reason);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; reject(e)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; })\n</div></li><li><div class=\"code-word\">&nbsp; });\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"972\">\n                      对应的，Promise 构造函数中应该初始化属性 onFulfilledFn 和\n                      onRejectedFn 为数组，同时 resolve() 和 reject()\n                      函数在改变状态时应该调用这个数组中的函数，并且这个调用过程应该是异步的。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Promise</span>(<span class=\"hljs-params\">execute</span>) </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">&nbsp; self.onFulfilledFn = [];\n</div></li><li><div class=\"code-word\">&nbsp; self.onRejectedFn = [];\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">  function resolve(value) {\n</div></li><li><div class=\"code-word\">    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">      ...\n</div></li><li><div class=\"code-word\">  &nbsp; &nbsp; self.onFulfilledFn.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">f</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp;   &nbsp; &nbsp; f(self.value)\n</div></li><li><div class=\"code-word\">  &nbsp; &nbsp; })\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>) </span>{\n</div></li><li><div class=\"code-word\">    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">      ...\n</div></li><li><div class=\"code-word\">  &nbsp; &nbsp; self.onRejectedFn.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">f</span>) </span>{\n</div></li><li><div class=\"code-word\">  &nbsp; &nbsp; &nbsp; f(self.reason)\n</div></li><li><div class=\"code-word\">  &nbsp; &nbsp; })\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"974\">resolvePromise() 函数</h4>\n                    <p data-nodeid=\"975\">\n                      前面提到解决过程函数有两个参数及 3 种情况，先来考虑第 1\n                      种情况，promise 与 x 相等，应该直接抛出 TypeError 错误：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolvePromise</span>(<span class=\"hljs-params\">promise, x</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (promise === x) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"x 不能与 promise 相等\"</span>));\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"977\">\n                      情况 2，x 为 Promise 的实例，应该尝试让 promise 接受 x\n                      的状态，怎么接受呢？\n                    </p>\n                    <p data-nodeid=\"978\">\n                      直接改变 promise\n                      状态肯定是不可取的，首先状态信息属于内部变量，其次也无法调用属性\n                      onResolvedFn 和 onFulfilledFn\n                      中的待执行函数。所以必须要通过调用 promise 在构造时的函数\n                      resolve() 和 reject() 来改变。\n                    </p>\n                    <p data-nodeid=\"979\">\n                      如果 x 处于等待状态，那么 promise\n                      继续保持等待状态，等待解决过程函数 resolvePromise()\n                      执行，否则应该用相同的值执行或拒绝\n                      promise。我们无法从外部拒绝或执行一个 Promise\n                      实例，只能通过调用构造函数传入的 resolve() 和 reject()\n                      函数来实现。所以还需要把这两个函数作为参数传递到\n                      resolvePromise 函数中。\n                    </p>\n                    <p data-nodeid=\"980\">\n                      在函数 resolvePromise() 内部加上情况 2 的判断，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolvePromise</span>(<span class=\"hljs-params\">promise, x, resolve, reject</span>) </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">  if (x <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Promise</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (x.state === FULFILLED) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; resolve(x.value)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (x.state === REJECTED) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; reject(x.reason)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; x.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">y</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; resolvePromise(promise, y, resolve, reject)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }, reject)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"982\">\n                      再来实现情况 3，将 x.then\n                      取出然后执行，并将执行结果放入解决过程函数\n                      resolvePromise() 中。 考虑到 x 可能只是一个 thenable\n                      而非真正的 Promise，所以在调用 then()\n                      函数的时候要设置一个变量 excuted\n                      避免重复调用。同时记得在执行时添加异常捕获并及时拒绝当前\n                      promise。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> ((x !== <span class=\"hljs-literal\">null</span>) &amp;&amp; ((<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'object'</span>) || (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">'function'</span>))) {\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">var</span> executed;\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">var</span> then = x.then;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> then === <span class=\"hljs-string\">\"function\"</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; then.call(x, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">y</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (executed) <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; executed = <span class=\"hljs-literal\">true</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> resolvePromise(promise, y, resolve, reject)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; }, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (executed) <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; executed = <span class=\"hljs-literal\">true</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; reject(e);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; })\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; resolve(x);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">&nbsp; } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (executed) <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; executed = <span class=\"hljs-literal\">true</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; reject(e);\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"984\">\n                      情况 4 就很简单了，直接把 x 作为值执行。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">resolve(x);\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"986\">Promise 测试</h3>\n                    <p data-nodeid=\"987\">\n                      编写测试代码永远是一个好习惯，为了验证编写的 Promise\n                      正确性，引用一个专门用来测试 Promise 规范性的模块\n                      <a\n                        href=\"https://github.com/promises-aplus/promises-tests\"\n                        data-nodeid=\"1100\"\n                        >promises-aplus-tests</a\n                      >，该模块内置了数百个测试案例，支持命令行一键测试。只是在导出模块的时候需要遵循\n                      CommonJS 规范，并且按照要求导出对应的函数。<a\n                        href=\"https://github.com/yalishizhude/course/tree/master/plus2\"\n                        data-nodeid=\"1104\"\n                        >最终代码地址请点击这里获取</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"988\">测试结果如下图所示：</p>\n                    <p data-nodeid=\"989\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/2B/DD/CgqCHl7_DEeALZgpAAALJ4MkJtQ487.png\"\n                        alt=\"image (16).png\"\n                        data-nodeid=\"1109\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"990\">async/await</h3>\n                    <p data-nodeid=\"991\">\n                      async 是 ES2017\n                      标准推出的用于处理异步操作的关键字，从本质上来说，它就是\n                      Generator 函数的语法糖。\n                    </p>\n                    <h4 data-nodeid=\"992\">什么是 Generator 函数？</h4>\n                    <p data-nodeid=\"993\">\n                      Generator 函数是 ES6 提出的除 Promise 之外的另一种<strong\n                        data-nodeid=\"1118\"\n                        >异步解决方案</strong\n                      >，不同于常见的异步回调，它的用法有些“奇怪”。这里我们只简单介绍一下它的主要用法。\n                    </p>\n                    <p data-nodeid=\"994\">\n                      当声明一个 Generator 函数时，需要在 function\n                      关键字与函数名之间加上一个星号，像下面这样：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">function* fn() {\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"996\">\n                      当调用 Generator\n                      函数后，函数并不会立即执行，而是返回一个迭代器对象。\n                    </p>\n                    <ul data-nodeid=\"997\">\n                      <li data-nodeid=\"998\">\n                        <p data-nodeid=\"999\">\n                          函数体内部使用 yield 表达式，定义不同的内部状态。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1000\">\n                        <p data-nodeid=\"1001\">\n                          当函数体外部调用迭代器的 next()\n                          函数时，函数会执行到下一个 yield\n                          表达式的位置，并返回一个对象，该对象包含属性 value 和\n                          done，value 是调用 next() 函数时传入的参数，done\n                          为布尔值表示是否执行完成。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1002\">\n                      下面是一个将异步回调函数改写成 Generator 函数的示例代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncFn</span>(<span class=\"hljs-params\">cb</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; setTimeout(cb, <span class=\"hljs-number\">1000</span>, <span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-keyword\">yield</span> asyncFn(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; it.next(data);\n</div></li><li><div class=\"code-word\">&nbsp; })\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-built_in\">console</span>.log(result)  <span class=\"hljs-comment\">// 1</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> it = fn() \n</div></li><li><div class=\"code-word\">it.next()\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1004\">下面讲讲这段代码的执行逻辑。</p>\n                    <ul data-nodeid=\"1005\">\n                      <li data-nodeid=\"1006\">\n                        <p data-nodeid=\"1007\">\n                          asyncFn() 是一个自定义的异步回调函数，1 秒后返回数值\n                          1。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1008\">\n                        <p data-nodeid=\"1009\">\n                          先调用 Generator 函数得到迭代器\n                          it，但此时函数并没有执行，需要执行迭代器的 next()\n                          函数才能调用函数 fn() 。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1010\">\n                        <p data-nodeid=\"1011\">\n                          Generator 函数 fn() 内部调用异步函数 asyncFn 时使用了\n                          yield 关键字，代表此处暂停执行，等到异步函数 asyncFn\n                          执行完成后再执行后面的代码。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1012\">\n                        <p data-nodeid=\"1013\">\n                          1 秒后，匿名回调函数内部得到的返回值 1，通过 it.next()\n                          函数返回这个值，并告诉迭代器继续执行后面的\n                          console.log。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"1014\">async/await 原理</h4>\n                    <p data-nodeid=\"1015\">\n                      虽然说 Generator\n                      函数号称是解决异步回调问题，但却带来了一些麻烦，比如函数外部无法捕获异常，比如多个\n                      yield 会导致调试困难。所以相较之下 Promise\n                      是更优秀的异步解决方案。\n                    </p>\n                    <p data-nodeid=\"1016\">\n                      async/await 做的事情就是将 Generator 函数转换成\n                      Promise。下面代码描述的是 async 的实现逻辑：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">generator2promise</span>(<span class=\"hljs-params\">generatorFn</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;(<span class=\"hljs-params\"></span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">var</span>&nbsp;gen&nbsp;=&nbsp;generatorFn.apply(<span class=\"hljs-keyword\">this</span>,&nbsp;<span class=\"hljs-built_in\">arguments</span>);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-keyword\">new</span>&nbsp;<span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;(<span class=\"hljs-params\">resolve,&nbsp;reject</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;<span class=\"hljs-title\">step</span>(<span class=\"hljs-params\">key,&nbsp;arg</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">try</span>&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">var</span>&nbsp;info&nbsp;=&nbsp;gen[key](arg);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">var</span>&nbsp;value&nbsp;=&nbsp;info.value;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">catch</span>&nbsp;(error)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(error);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span>&nbsp;(info.done)&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(value);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"hljs-keyword\">else</span>&nbsp;{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;<span class=\"hljs-built_in\">Promise</span>.resolve(value).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;(<span class=\"hljs-params\">value</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step(<span class=\"hljs-string\">\"next\"</span>,&nbsp;value);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>&nbsp;(<span class=\"hljs-params\">err</span>)&nbsp;</span>{\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step(<span class=\"hljs-string\">\"throw\"</span>,&nbsp;err);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;step(<span class=\"hljs-string\">\"next\"</span>);\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;&nbsp;&nbsp;});\n</div></li><li><div class=\"code-word\">&nbsp;&nbsp;};\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1018\">\n                      它将 Generator\n                      函数包装成了一个新的匿名函数，调用这个匿名函数时返回一个\n                      Promise。在这个 Promise 内部会创建一个 step()\n                      函数，该函数负责递归调用 Generator\n                      函数对应的迭代器，当迭代器执行完成时执行当前的\n                      Promise，失败时则拒绝 Promise。\n                    </p>\n                    <h3 data-nodeid=\"1019\">总结</h3>\n                    <p data-nodeid=\"1020\">\n                      本课时通过代码实例深入分析了 Promise/A+ 规范以及\n                      async/await 的实现原理。对于手写 Promise\n                      的过程，重点不在于实现结果，而在于实现过程，即先理解清楚规范，然后根据规范一步一步地去实现和优化。对于\n                      async/await 语法糖，结合 Generator\n                      函数，理解其封装原理即可。\n                    </p>\n                    <p data-nodeid=\"1021\" class=\"\">\n                      最后布置一道练习题：学完本课时内容后，试着自己动手写一个\n                      Promise，看看能否通过测试用例。\n                    </p>\n            "}