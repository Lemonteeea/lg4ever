{"title":"09 | 缓存与应用：多级缓存策略介绍与应用要点","context":"\n                    <p data-nodeid=\"7696\" class=\"\">\n                      在上一讲中我们介绍了网络 I/O\n                      的优化方案，也就是应用缓存来减少网络 I/O 或者用高性能网络\n                      I/O 替换性能较低的网络\n                      I/O。将缓存应用好，也并非一件简单的事情，需要详细地学习和掌握缓存的基础知识。其次在本讲中我会应用\n                      Node.js\n                      来实践开发一个多级缓存的库，让你进一步掌握缓存的应用要点。\n                    </p>\n                    <h3 data-nodeid=\"7697\">缓存概念</h3>\n                    <p data-nodeid=\"7698\">\n                      从我的理解上来介绍，<strong data-nodeid=\"7799\"\n                        >缓存是临时的一块存储空间</strong\n                      >，用于存放<strong data-nodeid=\"7800\"\n                        >访问频次较高的数据</strong\n                      >，用空间换响应速度，核心是减少用户对<strong\n                        data-nodeid=\"7801\"\n                        >数据库的查询压力</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"7699\">\n                      从以上概念介绍中，我们需要整理出以下几个关键词：\n                    </p>\n                    <ul data-nodeid=\"7700\">\n                      <li data-nodeid=\"7701\">\n                        <p data-nodeid=\"7702\">\n                          <strong data-nodeid=\"7807\">临时</strong\n                          >，为了避免存储空间的浪费，我们应该尽量设置数据缓存的时间，当过期时自动销毁；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7703\">\n                        <p data-nodeid=\"7704\">\n                          <strong data-nodeid=\"7812\">存储空间</strong\n                          >，一般选择读写性能较高的内存（本地内存或者共享内存），有些会应用\n                          SSD 进一步提升性能；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7705\">\n                        <p data-nodeid=\"7706\">\n                          <strong data-nodeid=\"7817\">访问频次较高的数据</strong\n                          >，为了避免存储空间的浪费，应该尽量选择访问频次较高的数据，切莫将任何数据放入缓存；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7707\">\n                        <p data-nodeid=\"7708\">\n                          <strong data-nodeid=\"7822\">数据库的查询压力</strong\n                          >，我们需要将一些复杂的数据库查询进行缓存，减少数据库访问压力，从而提升用户的响应速度。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7709\">\n                      在了解了基础概念后，我们再来看下缓存中常见的几个问题，这也是面试过程中常被问及的问题。\n                    </p>\n                    <h3 data-nodeid=\"7710\">缓存问题</h3>\n                    <p data-nodeid=\"7711\">\n                      如果没有应用好缓存，将会<strong data-nodeid=\"7830\"\n                        >导致一些不可见或者说很难定位的现网事故</strong\n                      >，主要是三点：缓存雪崩、缓存击穿和缓存穿透。\n                    </p>\n                    <h4 data-nodeid=\"7712\">1.缓存雪崩</h4>\n                    <p data-nodeid=\"7713\">\n                      在上面概念中，提到了一个关键词叫作临时，因此大部分数据都有一个过期时间的概念，假设我们有一批数据是通过定时服务从数据库写入缓存中，然后我们统一设置了过期时间。当这个时间节点到了，但是由于某种原因数据又没有从数据库写入缓存，导致这时候所有的数据都会前往数据库查询数据，从而引起数据库查询压力，导致数据库并发过大而瘫痪无法正常服务。\n                    </p>\n                    <p data-nodeid=\"7714\">那么应该如何应对呢？</p>\n                    <p data-nodeid=\"7715\">\n                      （1）<strong data-nodeid=\"7839\"\n                        >避免所有数据都设置同一个过期时间节点</strong\n                      >，应该按数据类型、数据更新时效性来设置。\n                    </p>\n                    <p data-nodeid=\"7716\">\n                      （2）<strong data-nodeid=\"7845\"\n                        >数据过期时间应大于数据更新节点时间</strong\n                      >，并考虑更新时长，同时增加更新失败异常告警提示。\n                    </p>\n                    <p data-nodeid=\"7717\">\n                      （3）对于一些相对较高频次或者数据库查询压力较大的数据，<strong\n                        data-nodeid=\"7851\"\n                        >可不设置过期时间</strong\n                      >，主动从程序上来控制该数据的移除或者更替。\n                    </p>\n                    <h4 data-nodeid=\"7718\">2.缓存穿透</h4>\n                    <p data-nodeid=\"7719\">\n                      在上面概念中，提到了一个关键句叫作访问频繁较高的数据，这里就会出现一种情况，比如说查询信息一直是<strong\n                        data-nodeid=\"7858\"\n                        >空数据</strong\n                      >，空数据按理不属于访问频繁较高的数据，所以经过了缓存，但是并没有缓存该空数据，而是直接穿透进入了数据库，虽然数据库查询也是空数据，但是还是需要经过数据库的查询，这种现象就是击穿了缓存直接前往了数据库查询。\n                    </p>\n                    <p data-nodeid=\"7720\">那么应该如何应对呢？</p>\n                    <p data-nodeid=\"7721\">\n                      （1）<strong data-nodeid=\"7865\">过滤非正常请求数据</strong\n                      >，比如一些从参数就可以知道为空的数据，可以直接从程序上处理。\n                    </p>\n                    <p data-nodeid=\"7722\">\n                      （2）<strong data-nodeid=\"7871\">缓存空的结果</strong\n                      >，为了提升性能，可以将一些查询为空的结果也缓存起来，这样下次用户再进行访问时，可以直接从缓存中判断返回。\n                    </p>\n                    <p data-nodeid=\"7723\">\n                      （3）由于第 2\n                      种方案在空数据较多时会浪费内存空间，我们可以将这些空数据的键名，使用<strong\n                        data-nodeid=\"7877\"\n                        >布隆过滤器</strong\n                      >来缓存到缓存，这样可以尽可能地减少内存占用，并且更加高效。\n                    </p>\n                    <h4 data-nodeid=\"7724\">3.缓存击穿</h4>\n                    <p data-nodeid=\"7725\">\n                      这个概念和缓存雪崩有点类似，但不是大面积的缓存过期失效，而是某个访问频次较高的数据失效了，从而导致这一刻高并发的请求全部穿透到了数据库，从而数据库并发压力较高，响应较慢，也进一步导致数据库异常，影响其他业务。\n                    </p>\n                    <p data-nodeid=\"7726\">那么应该如何应对呢？</p>\n                    <p data-nodeid=\"7727\">\n                      （1）高频数据、查询较为复杂的数据，可以不设置过期时间，但是需要程序去维护数据的更替删除。\n                    </p>\n                    <p data-nodeid=\"7728\">\n                      （2）如果需要缓存过期时间，要大于缓存更新时间，避免过期无法找到键。\n                    </p>\n                    <p data-nodeid=\"7729\">\n                      （3）使用原子操作方案，当多个数据都需要前往数据库查询同一个数据时，告知程序缓存正在生成中，并且告知其他程序可以读取上一次缓存数据，避免同时读取同一份数据。\n                    </p>\n                    <h3 data-nodeid=\"7730\">实现多级缓存</h3>\n                    <p data-nodeid=\"7731\">\n                      在上一讲中我们已经介绍了两种缓存方案：\n                    </p>\n                    <ul data-nodeid=\"7732\">\n                      <li data-nodeid=\"7733\">\n                        <p data-nodeid=\"7734\">\n                          <strong data-nodeid=\"7889\">本地缓存</strong>\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7735\">\n                        <p data-nodeid=\"7736\">\n                          <strong data-nodeid=\"7893\">共享内存</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7737\">\n                      接下来我们主要基于这两个缓存来实现一个 Node.js\n                      缓存库，以方便后续在项目中应用。\n                    </p>\n                    <h4 data-nodeid=\"7738\">1.代码实现</h4>\n                    <p data-nodeid=\"7739\">\n                      关于本地缓存，我们可以借助一个第三方库\n                      <a\n                        href=\"https://github.com/node-cache/node-cache?fileGuid=3HCRkDrgCrR8h6rY\"\n                        data-nodeid=\"7899\"\n                        >node-cache</a\n                      >，redis 的话则使用\n                      <a\n                        href=\"https://github.com/NodeRedis/node-redis?fileGuid=3HCRkDrgCrR8h6rY\"\n                        data-nodeid=\"7903\"\n                        >node-redis</a\n                      >\n                      第三方库，为了实现方便，这里就不详细地介绍 redis\n                      安装和配置了，而是借助\n                      <a\n                        href=\"https://app.redislabs.com/?fileGuid=3HCRkDrgCrR8h6rY\"\n                        data-nodeid=\"7907\"\n                        >redis 云服务</a\n                      >。这里我已经申请了一个，具体信息如下，你可以使用以下云服务配置，由于是免费的，也可以自行去申请试用。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">host: <span class=\"hljs-string\">'redis-17353.c245.us-east-1-3.ec2.cloud.redislabs.com'</span>,\n</div></li><li><div class=\"code-word\">port: <span class=\"hljs-number\">17353</span>,\n</div></li><li><div class=\"code-word\">password: <span class=\"hljs-string\">'nodejs@2021'</span>,\n</div></li><li><div class=\"code-word\">db: <span class=\"hljs-number\">0</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7741\">\n                      接下来我们在项目的 lib 中新增一个 cache.js ，在 cache.js\n                      中来实现多级缓存的代码。\n                    </p>\n                    <p data-nodeid=\"7742\">\n                      还需要提供三种方案，一种是直接<strong data-nodeid=\"7923\"\n                        >使用本地缓存</strong\n                      >，一种是<strong data-nodeid=\"7924\"\n                        >使用 redis 缓存</strong\n                      >，还有一种就是<strong data-nodeid=\"7925\">都使用</strong\n                      >，因此我们需要为 Cache 这个类设置 2\n                      个参数，构造函数实现如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">constructor</span>(localCacheEnable=true, redisEnable=true) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">this</span>.localCacheEnable = localCacheEnable;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">this</span>.redisEnable = redisEnable;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(localCacheEnable){\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">this</span>.myCache = <span class=\"hljs-keyword\">new</span> NodeCache();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(redisEnable) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">this</span>.client = redis.createClient({\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">'redis-17353.c245.us-east-1-3.ec2.cloud.redislabs.com'</span>,\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">17353</span>,\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-attr\">password</span>: <span class=\"hljs-string\">'nodejs@2021'</span>,\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-attr\">db</span>: <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">            });\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7744\">\n                      在本地缓存 localCacheEnable 为 true\n                      时，才会本地缓存初始化；在 redis 缓存 redisEnable 为 true\n                      的时候，我们才会初始化 redis 缓存。\n                    </p>\n                    <p data-nodeid=\"7745\">\n                      接下来我们主要看 2 个核心方法的实现，一个是 get\n                      获取缓存内容，一个是 set 设置缓存内容。\n                    </p>\n                    <p data-nodeid=\"7746\">get 获取缓存内容的实现代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">    <span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\">     * \n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@description </span>获取缓存信息\n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">{string}</span> </span>key \n</div></li><li><div class=\"code-word\">     */\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">async</span> get(key) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">let</span> value;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.localCacheEnable) {\n</div></li><li><div class=\"code-word\">            value = <span class=\"hljs-keyword\">this</span>.myCache.get(key);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`local value is <span class=\"hljs-subst\">${value}</span>\\`</span>);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(!value &amp;&amp; <span class=\"hljs-keyword\">this</span>.redisEnable) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">                value = <span class=\"hljs-keyword\">await</span> promisify(<span class=\"hljs-keyword\">this</span>.client.get).bind(<span class=\"hljs-keyword\">this</span>.client)(key);\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`redis value is <span class=\"hljs-subst\">${value}</span>\\`</span>)\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">catch</span> (err){\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-built_in\">console</span>.log(err);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> value;\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7748\">\n                      代码逻辑比较清晰，首先判断是否打开了本地缓存，如果有则先从本地缓存中获取，如果没有则查看\n                      redis\n                      缓存是否打开，并且是否存在缓存数据。上面这段代码中，需要将\n                      redis 的 get 方法转化为 promise，所以应用到了 util\n                      工具中的 promisify。\n                    </p>\n                    <p data-nodeid=\"7749\">set 方法的实现代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">   <span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\">     * \n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@description </span>保存缓存信息\n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">{string}</span> </span>key 缓存key\n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">{string}</span> </span>value 缓存值\n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">{int}</span> </span>expire 过期时间/秒\n</div></li><li><div class=\"code-word\">     * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">{boolean}</span> </span>cacheLocal 是否本地缓存\n</div></li><li><div class=\"code-word\">     */\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">async</span> set(key, value, expire=<span class=\"hljs-number\">10</span>, cacheLocal=<span class=\"hljs-literal\">false</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">let</span> localCacheRet, redisRet;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.localCacheEnable &amp;&amp; cacheLocal) {\n</div></li><li><div class=\"code-word\">            localCacheRet = <span class=\"hljs-keyword\">this</span>.myCache.set(key, value, expire);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.redisEnable) { \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">                redisRet = <span class=\"hljs-keyword\">await</span> promisify(<span class=\"hljs-keyword\">this</span>.client.set).bind(<span class=\"hljs-keyword\">this</span>.client)(key, value, <span class=\"hljs-string\">'EX'</span>, expire);\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">catch</span> (err){\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-built_in\">console</span>.log(err);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> localCacheRet || redisRet;\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7751\">\n                      首先还是判断是否启用了本地缓存，同时判断该数据参数是否需要进行本地数据缓存操作，如果都需要则会调用\n                      node-cache 的 set\n                      方法缓存到本地内存中。接下来就判断是否需要进行 redis\n                      缓存，如果需要则调用 node-redis 的 set 方法进行缓存。\n                    </p>\n                    <p data-nodeid=\"7752\">\n                      以上就是 2 个核心方法的实现，其他方法比如说 delete\n                      方法可以参照去实现。接下来我们主要看下业务侧的应用以及演示效果。\n                    </p>\n                    <h4 data-nodeid=\"7753\">2.效果演示</h4>\n                    <p data-nodeid=\"7754\">\n                      我们在 controller 中新增一个 cache.js，并且新增 3\n                      个方法，分别是 local、 redis 和 both，然后在中间件 router\n                      中新增相应的路由配置。\n                    </p>\n                    <p data-nodeid=\"7755\">\n                      在 cache.js 中，我们首先需要创建 3\n                      个类型的缓存对象，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> cache = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../lib/cache'</span>)(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span>); <span class=\"hljs-comment\">// 本地缓存</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> redisCache = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../lib/cache'</span>)(<span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// redis 缓存</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> bothCache = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'../lib/cache'</span>)(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 本地+redis</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7757\">\n                      我们先来看下本地缓存的应用实现，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">async</span> local() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> cacheKey = <span class=\"hljs-string\">'sum_result'</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-keyword\">await</span> cache.get(cacheKey);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(!result){\n</div></li><li><div class=\"code-word\">            result = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">1000000000</span>; i++){\n</div></li><li><div class=\"code-word\">                result = result + i;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            cache.set(cacheKey, result, <span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">true</span>).then();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.resApi(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-string\">'success'</span>, <span class=\"hljs-string\">\\`sum 0 - 1000000000 is <span class=\"hljs-subst\">${result}</span>\\`</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7759\">\n                      这块代码的逻辑还是与<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6790&amp;fileGuid=3HCRkDrgCrR8h6rY\"\n                        data-nodeid=\"7942\"\n                        >《08 | 优化设计：在 I/O 方面应该注意哪些要点？》</a\n                      >的类似，都是一个耗 CPU\n                      的计算，首先我们获取缓存内容，如果没有则去计算，计算完成后再缓存到本地内存中。与上一讲不同的是，我们将本地缓存的操作交给了\n                      cache 库。\n                    </p>\n                    <p data-nodeid=\"7760\">\n                      redis 和 both 两个方法的实现基本是一样的，只是应用的 cache\n                      实例不一样，不过在 both\n                      中缓存时间也设置得不一样，为了更容易演示，我们只看 both\n                      就可以了，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"> <span class=\"hljs-keyword\">async</span> both() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> cacheKey = <span class=\"hljs-string\">'sum_result'</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-keyword\">await</span> bothCache.get(cacheKey);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(!result){ <span class=\"hljs-comment\">// result 为函数本地内存缓存</span>\n</div></li><li><div class=\"code-word\">            result = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">1000000000</span>; i++){\n</div></li><li><div class=\"code-word\">                result = result + i;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            bothCache.set(cacheKey, result, <span class=\"hljs-number\">600</span>, <span class=\"hljs-literal\">true</span>).then();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">//bothCache.set(cacheKey, result, 600, true).then();</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.resApi(<span class=\"hljs-literal\">true</span>, <span class=\"hljs-string\">'success'</span>, <span class=\"hljs-string\">\\`sum 0 - 1000000000 is <span class=\"hljs-subst\">${result}</span>\\`</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7762\">接下来我们用以下命令启动该服务：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">pm2 start pm2.config.js --env development\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7764\">启动成功后，我们先访问如下地址：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:3000/v1/local-cache</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7766\">\n                      你会发现第一次访问较慢，而接下来的 10\n                      秒内访问响应都非常快，这就是本地缓存的作用。同样的方式，我们去访问以下地址：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:3000/v1/redis-cache</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7768\">\n                      也是得出一样的结论。虽然两者效果上是一致的，但是在性能上是有一定差距的，这点在之前的<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6790&amp;fileGuid=3HCRkDrgCrR8h6rY\"\n                        data-nodeid=\"7953\"\n                        >《08 | 优化设计：在 I/O 方面应该注意哪些要点？》</a\n                      >中已经详细说明过。\n                    </p>\n                    <p data-nodeid=\"7769\">接下来我们访问如下地址：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:3000/v1/both-cache</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7982\" class=\"te-preview-highlight\">\n                      然后打开 PM2 中的日志路径，由于\n                      <a\n                        href=\"https://github.com/love-flutter/nodejs-column\"\n                        data-nodeid=\"7986\"\n                        >GitHub 代码</a\n                      >中默认的是 /data/nodejs-column-io/info.log\n                      路径（注意如果没有该路径 PM2\n                      会启动失败，需要先创建路径，也可以放在其他路径下），我们打开日志文件目录。\n                    </p>\n\n                    <p data-nodeid=\"7772\">\n                      在访问 both-cache\n                      地址后，你会看到缓存会优先从本地缓存中获取，接下来我们重启下服务，使用如下命令：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">pm2 restart&nbsp;nodejs-column-io\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7774\">\n                      然后我们再次访问时，你会发现缓存信息只能从 redis\n                      中获取了，<strong data-nodeid=\"7963\"\n                        >因为本地重启，内存被释放，所以没有数据了</strong\n                      >，因此在应用过程中，建议本地和 redis\n                      缓存同时使用，避免因为现网版本发版或者异常重启导致的缓存穿透击穿现象，从而可能引发服务异常问题。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">2021</span>-<span class=\"hljs-number\">02</span>-<span class=\"hljs-number\">27</span> <span class=\"hljs-number\">11</span>:<span class=\"hljs-number\">25</span> +<span class=\"hljs-number\">08</span>:<span class=\"hljs-number\">00</span>: local value is undefined\n</div></li><li><div class=\"code-word\"><span class=\"hljs-number\">2021</span>-<span class=\"hljs-number\">02</span>-<span class=\"hljs-number\">27</span> <span class=\"hljs-number\">11</span>:<span class=\"hljs-number\">25</span> +<span class=\"hljs-number\">08</span>:<span class=\"hljs-number\">00</span>: redis value is <span class=\"hljs-number\">499999999067109000</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7776\">\n                      以上就是多级缓存的实现方案，该库的其他方法你可以自行去补充实现，作为一个小作业，原理基本上是一致的，有任何问题都欢迎在评论区留言。\n                    </p>\n                    <h3 data-nodeid=\"7777\">总结</h3>\n                    <p data-nodeid=\"7778\">\n                      本讲主要介绍了缓存的一些基础知识，着重要掌握的是缓存的三个问题：雪崩、穿透和击穿，这也是面试中常考的点，接下来就是应用\n                      Node.js\n                      实践开发了一个多级缓存的库，可以简单快速地应用本地缓存和\n                      redis 缓存，需要掌握其实现以及后续扩展的实现方法。\n                    </p>\n                    <p data-nodeid=\"7779\">\n                      接下来我们要进入第二个部分，系统相关的实践案例分析，下一讲我们先来讲解如何监控和保护进程安全。\n                    </p>\n                    <hr data-nodeid=\"7780\" />\n                    <p data-nodeid=\"7781\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"7972\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"7971\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"7782\">\n                      <strong data-nodeid=\"7976\">《大前端高薪训练营》</strong>\n                    </p>\n                    <p data-nodeid=\"7783\" class=\"\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"7980\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}