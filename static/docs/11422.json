{"title":"20&nbsp;| 5 种解法，如何利用常量空间求解最长有效括号长度？","context":"\n                    <p data-nodeid=\"1\">\n                      在本讲，我将带你继续探究“一题多解”，结合前面学习过且面试常考的知识点，比如区间问题、双指针、动态规划、栈、贪心，从多个角度去求解一个题目，通过逐步分析已知条件、提取题目特点，进而将不熟悉的题目变成我们擅长求解的题目，最终攻克“最长有效括号长度”的难题。\n                    </p>\n                    <p data-nodeid=\"2\">在正式介绍前，我有两点说明。</p>\n                    <ol data-nodeid=\"3\">\n                      <li data-nodeid=\"4\">\n                        <p data-nodeid=\"5\">\n                          这类题目的解法非常多，但本讲仅重点介绍其中 5\n                          种具有代表性的解法。目的是让你在算法面试时，能够展开更多的解题思路。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6\">\n                        <p data-nodeid=\"7\">\n                          并不是每种解法都能够利用常量空间，如果用到，我会特别注明。\n                        </p>\n                      </li>\n                    </ol>\n                    <h3 data-nodeid=\"8\">题目</h3>\n                    <p data-nodeid=\"9\">\n                      给你一个只包含<code data-backticks=\"1\" data-nodeid=\"296\"\n                        >('</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"298\">')'</code\n                      >的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n                    </p>\n                    <p data-nodeid=\"10\">输入：s = \"(()\"</p>\n                    <p data-nodeid=\"11\">输出：2</p>\n                    <p data-nodeid=\"12\">解释：最长有效括号子串是 \"()\"</p>\n                    <p data-nodeid=\"13\">注意，“有效”需要满足两个条件：</p>\n                    <ul data-nodeid=\"14\">\n                      <li data-nodeid=\"15\">\n                        <p data-nodeid=\"16\">连续子串；</p>\n                      </li>\n                      <li data-nodeid=\"17\">\n                        <p data-nodeid=\"18\">\n                          子串有效指的是每个左括号 '(' 都可以找到相应的右括号\n                          ')' 完成<strong data-nodeid=\"324\">一一配对</strong>。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"19\">\n                      在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"328\"\n                        >01 | 栈：从简单栈到单调栈，解决经典栈问题</a\n                      >”的“例\n                      1”中，我们介绍过如何判断一个字符串是否合法（即有效）。只不过，在这个题中，我们要从一个字符串中找到一个子串，需要满足“<strong\n                        data-nodeid=\"334\"\n                        >最长且合法</strong\n                      >”。\n                    </p>\n                    <p data-nodeid=\"20\">当我们拿到题目，最容易想到的思路是：</p>\n                    <ul data-nodeid=\"21\">\n                      <li data-nodeid=\"22\">\n                        <p data-nodeid=\"23\">\n                          一共有 O(N<sup>2</sup>) 个连续子串\n                        </p>\n                      </li>\n                      <li data-nodeid=\"24\">\n                        <p data-nodeid=\"25\">判断每个连续子串是否合法</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"26\">\n                      如果直接按上述思路开始进行暴力求解，那么时间复杂度就会上升到\n                      O(N<sup>3</sup>)。因此，在求解前，我们应该根据已知条件，认真分析题目的特点，然后和暴力破解法\n                      Say GoodBye。\n                    </p>\n                    <h3 data-nodeid=\"27\">合法字符串的特性</h3>\n                    <p data-nodeid=\"28\">\n                      首先我们看一下合法字符串长什么样？有什么样的特点？一般而言，括号对匹配成功的合法字符串，有三种情况。\n                    </p>\n                    <ul data-nodeid=\"29\">\n                      <li data-nodeid=\"30\">\n                        <p data-nodeid=\"31\">\n                          <strong data-nodeid=\"367\">相连</strong\n                          >：指很多个配对成功的括号连在一起，比如 [\"()\", \"()()\",\n                          \"()()()\"]。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"32\">\n                        <p data-nodeid=\"33\">\n                          <strong data-nodeid=\"386\">嵌套</strong\n                          >：指内外层层相套，但是它们能够合法配对成功，比如\n                          [\"()\", \"(())\", \"((()))\"]。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34\">\n                        <p data-nodeid=\"35\">\n                          <strong data-nodeid=\"401\">相连 + 嵌套</strong\n                          >：指相连和嵌套混合的情况，但是它们是合法的字符串，比如\n                          [\"()(())\", \"(())()\"]。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"36\">\n                      注意，在后文中，我们将用“相连”“嵌套”“相连+嵌套”特指这三种情况。\n                    </p>\n                    <h3 data-nodeid=\"37\">特点 1： 区间</h3>\n                    <p data-nodeid=\"38\">\n                      我们发现，括号能够配对的时候，总是有一个左括号 +\n                      一个右括号，如果我们将左括号的下标当成一个区间的左端点，右括号的下标当成一个区间的右端点。\n                    </p>\n                    <p data-nodeid=\"39\">\n                      那么用区间来表示一个合法字符串，会得到什么有趣的特点呢？下面我们仍然从合法字符串的\n                      3 种情况展开。\n                    </p>\n                    <ul data-nodeid=\"40\">\n                      <li data-nodeid=\"41\">\n                        <p data-nodeid=\"42\">\n                          相连：比如\"()()()\"，就可以得到区间 [[0,1], [2,3],\n                          [4,5]]。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"43\">\n                        <p data-nodeid=\"44\">\n                          嵌套：比如\"(())\"，就可以得到区间 [[0,3], [1,2]]。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"45\">\n                        <p data-nodeid=\"46\">\n                          相连+嵌套：比如\"()(())\"，就可以得到区间 [[0,1], [2,5],\n                          [3,4]]。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"47\">\n                      我们尝试定义一下<strong data-nodeid=\"463\"\n                        >区间的连接性。</strong\n                      >\n                    </p>\n                    <blockquote data-nodeid=\"6639\">\n                      <p data-nodeid=\"6640\">\n                        如果两个区间 &lt;a, b&gt;, &lt;c, d&gt; 满足下面 2\n                        个条件之一：\n                      </p>\n                      <ol data-nodeid=\"6641\">\n                        <li data-nodeid=\"6642\">\n                          <p data-nodeid=\"6643\">\n                            有公共点，即 not ( (b &lt; c) || d &lt; a) )；\n                          </p>\n                        </li>\n                        <li data-nodeid=\"6644\">\n                          <p data-nodeid=\"6645\">\n                            b &lt; c &amp;&amp; b + 1 == c 或者 d &lt; a\n                            &amp;&amp; d + 1 == a。\n                          </p>\n                        </li>\n                      </ol>\n                      <p data-nodeid=\"6646\" class=\"\">\n                        我们就称这两个区间具有连接性。\n                      </p>\n                    </blockquote>\n\n                    <p data-nodeid=\"57\">\n                      我这里给出三个例子，帮你理清<strong data-nodeid=\"491\"\n                        >区间的连接性</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"58\">\n                      例 1：区间 [1,2], [3,4] 是否具有连接性？答案是！因为区间\n                      [1,2] 的右端点 2 加上 1 就是区间 [3,4] 的左端点（满足条件\n                      2）。\n                    </p>\n                    <p data-nodeid=\"59\">\n                      例 2：区间 [0,5] 和区间 [2,5]\n                      是否具有连接性？答案是！因为它们是有公共点的，因此我们认为它们具有连接性。\n                    </p>\n                    <p data-nodeid=\"60\">\n                      例 3：区间 [0, 1] 和区间 [3,4]\n                      则不具有连接性。因为这两个区间不满足条件 1，也不满足条件\n                      2。\n                    </p>\n                    <p data-nodeid=\"61\">\n                      那么定义好区间的连接性之后，有什么用途呢？这样操作后，我们就可以把原始的题目分为两步：\n                    </p>\n                    <ol data-nodeid=\"62\">\n                      <li data-nodeid=\"63\">\n                        <p data-nodeid=\"64\">\n                          得到所有配对的左括号与右括号的下标；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"65\">\n                        <p data-nodeid=\"66\">\n                          给定一系列区间，找到<strong data-nodeid=\"538\"\n                            >最长的区域</strong\n                          >，这个区域被具有<strong data-nodeid=\"539\"\n                            >相连性的区间</strong\n                          >覆盖。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"67\">针对第 2 步，我们进一步举例说明。</p>\n                    <p data-nodeid=\"68\">\n                      例 1：当给定的区间为 [1, 2], [3,4]\n                      的时候，我们可以找到一个最长的区域 [1,\n                      4]，这个区域是由具有相连性的两个区间覆盖的。\n                    </p>\n                    <p data-nodeid=\"69\">\n                      例 2：当给定的区间集合为 [0, 1], [3,4], [5,6], [6,9]\n                      的时候，最长的区域为 [3, 9]。由 [3,4], [5,6], [6,9]\n                      这三个具有相连性的区间覆盖。\n                    </p>\n                    <blockquote data-nodeid=\"12005\">\n                      <p data-nodeid=\"12006\">\n                        注意，我们<strong data-nodeid=\"12014\"\n                          >不要求区域内的区间两两满足相连性</strong\n                        >。\n                      </p>\n                    </blockquote>\n                    <blockquote data-nodeid=\"22772\">\n                      <p data-nodeid=\"22773\">\n                        比如 [3,4] 和 [5,6] 具有连接性，但是 [3,4] 和 [6,9]\n                        不具有连接性。在操作时，我们可以这样操作：\n                      </p>\n                      <p data-nodeid=\"22774\">\n                        Step 1. [3,4] 和 [5,6] 具有连接性，合并成一个大区间\n                        [3,6]；\n                      </p>\n                      <p data-nodeid=\"22775\" class=\"\">\n                        Step 2. [3,6] 与 [6,9] 具有连接性，合并成一个大区间\n                        [3,9]。\n                      </p>\n                    </blockquote>\n\n                    <p data-nodeid=\"74\">\n                      例 3：给定一个区间 [0, 1]，那么最长区域就是 [0, 1]。\n                    </p>\n                    <blockquote data-nodeid=\"75\">\n                      <p data-nodeid=\"76\">\n                        注意：一个合法的括号配对字符串不会生成一个单独的很长的区间，比如\n                        [0, 10]。如果 s[0]= '(' 与 s[10]=')'\n                        配对成功，那么必然是一种<strong data-nodeid=\"676\"\n                          >嵌套</strong\n                        >的合法字符串，内部还会有很多区间<strong\n                          data-nodeid=\"677\"\n                          >必须</strong\n                        >要给出来。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"77\" class=\"\">\n                      第一步的处理，可以直接使用栈（参考“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"681\"\n                        >01 | 栈：从简单栈到单调栈，解决经典栈问题</a\n                      >”的“例 1”）。而第二步的处理需要用到贪心算法（参考“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"685\"\n                        >11 | 贪心：这种思想，没有模板，如何才能掌握它？</a\n                      >”的“例 2”）。\n                    </p>\n                    <p data-nodeid=\"78\">\n                      基于这样的思路，我们就可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 采用重叠的最长的区间的做法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = s == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : s.length();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 两两配对的时候，我们将它们看成一个区间</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 配对的时候，需要用到栈</span>\n</div></li><li><div class=\"code-word\">    Stack&lt;Integer&gt; st = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 用来存放区间</span>\n</div></li><li><div class=\"code-word\">    List&lt;<span class=\"hljs-keyword\">int</span>[]&gt; ranges = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 是否配对成功？</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!st.isEmpty()) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> topIdx = st.pop();\n</div></li><li><div class=\"code-word\">          ranges.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[]{topIdx, i});\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        st.push(i);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将区间两端点进行排序</span>\n</div></li><li><div class=\"code-word\">    Collections.sort(ranges, <span class=\"hljs-keyword\">new</span> Comparator&lt;<span class=\"hljs-keyword\">int</span>[]&gt;() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] b)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> a[<span class=\"hljs-number\">0</span>] - b[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 由于得到了很多区间，我们需要取相互覆盖的区间的最长值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 比如，我们认为[3,4], [5,6]是相互连续且覆盖的区间</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> start = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> end = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ranges.size(); i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> from = ranges.get(i)[<span class=\"hljs-number\">0</span>], to = ranges.get(i)[<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果和[start, end]这个区间相连</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (from &lt;= end + <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">        end = Math.max(end, to);\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果不相连!</span>\n</div></li><li><div class=\"code-word\">        start = from;\n</div></li><li><div class=\"code-word\">        end = to;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      ans = Math.max(ans, end - start + <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"80\">\n                      <p data-nodeid=\"81\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.overlapped.ranges.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"691\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.overlapped.ranges.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"695\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.overlapped.ranges.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"699\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"82\">\n                      <strong data-nodeid=\"704\">复杂度分析</strong\n                      >：从字符串中提取区间，只需要 O(N)\n                      的时间复杂度。然后我们需要对区间进行排序，最差情况下有\n                      O(N/2) 个区间，那么排序的时间复杂度会上升到\n                      O(NlgN)。最后的贪心算法时间复杂度为\n                      O(N)。因此，整个问题的时间复杂度为 O(NlgN)，空间复杂度为\n                      O(N)。\n                    </p>\n                    <p data-nodeid=\"83\">\n                      关于求解最长相连通的区间问题，这里我还给你留了一个练习题。你可以做一做。\n                    </p>\n                    <p data-nodeid=\"84\">\n                      <strong data-nodeid=\"710\">练习题 1</strong\n                      >：给定一系列区间，将重合的区间合并在一起。\n                    </p>\n                    <p data-nodeid=\"85\">\n                      输入：A = [[1,2], [2,3], [2,6], [7, 8]]\n                    </p>\n                    <p data-nodeid=\"86\">输出：[[1, 6], [7,8]]</p>\n                    <blockquote data-nodeid=\"87\">\n                      <p data-nodeid=\"88\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"742\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"746\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"750\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"89\">\n                      我们发现，实际上整个问题的时间复杂度是由排序带来的，那么，有没有可能优化掉排序呢？我们先来看一下题目中生成区间的代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> (!st.isEmpty()) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> topIdx = st.pop();\n</div></li><li><div class=\"code-word\">      ranges.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[]{topIdx, i});\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"91\">\n                      不难发现，在右括号找到左括号匹配成功的时候，总是记录下左括号下标&lt;，右括号下标\n                      &gt;。\n                    </p>\n                    <p data-nodeid=\"92\">\n                      题目中，左括号的下标本来就是有序的，那么我们可以使用一个数组\n                      pairPos[] 来记录这个匹配成功的区间信息。采用的原则如下：\n                    </p>\n                    <blockquote data-nodeid=\"93\">\n                      <p data-nodeid=\"94\">\n                        pairPos[左括号的下标] = 右括号的下标<br />\n                        pairPos[右括号的下标] = -1\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95\">就是下图所示的样子：</p>\n                    <p data-nodeid=\"25461\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1RKAcPyaAABQVW99prM208.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"25464\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"97\">\n                      也就意味着，我们将区间信息成对放在了 &lt;i,\n                      pairPos[i]&gt;，其中 i\n                      是一个字符串中配对成功的左括号的下标。\n                    </p>\n                    <p data-nodeid=\"98\">\n                      那么，基于这个思想，我们可以优化代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 采用重叠的最长的区间的做法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = s == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : s.length();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 两两配对的时候，我们将它们看成一个区间</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 配对的时候，需要用到栈</span>\n</div></li><li><div class=\"code-word\">    Stack&lt;Integer&gt; st = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录每个点对应的位置</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] pairPos = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N];\n</div></li><li><div class=\"code-word\">    Arrays.fill(pairPos, -<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!st.isEmpty()) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> topIdx = st.pop();\n</div></li><li><div class=\"code-word\">          pairPos[topIdx] = i;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        st.push(i);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 由于得到了很多区间，我们需要取相互覆盖的区间的最长值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 比如，我们认为[3,4], [5,6]是相互连续且覆盖的区间</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> start = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> end = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (pairPos[i] == -<span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">continue</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> from = i, to = pairPos[i];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果和[start, end]这个区间相交</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (from &lt;= end + <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">        end = Math.max(end, to);\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果不相交!</span>\n</div></li><li><div class=\"code-word\">        start = from;\n</div></li><li><div class=\"code-word\">        end = to;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      ans = Math.max(ans, end - start + <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"100\">\n                      <p data-nodeid=\"101\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.overlapped.ranges.no.sort.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"785\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.overlapped.ranges.no.sort.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"789\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.overlapped.ranges.no.sort.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"793\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"102\">\n                      <strong data-nodeid=\"798\">复杂度分析</strong\n                      >：时间复杂度为 O(N)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"103\">\n                      接下来我们再看题目的另外一个特点，连续性。\n                    </p>\n                    <h3 data-nodeid=\"104\">特点 2：连续性</h3>\n                    <p data-nodeid=\"105\">\n                      通过“特点\n                      1”的分析，我们将问题处理成区间的连接性问题。不难发现，所谓<strong\n                        data-nodeid=\"806\"\n                        >相连性</strong\n                      >，就是要求：\n                    </p>\n                    <blockquote data-nodeid=\"106\">\n                      <p data-nodeid=\"107\">\n                        求解出来的最长区间，里面的每个字符都可以配对成功。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"108\">\n                      那么，这个条件必然等价于，这个区间里面的下标，一旦排序之后，必然由相邻的整数构成。下面我们分别举例进行说明。\n                    </p>\n                    <ul data-nodeid=\"109\">\n                      <li data-nodeid=\"110\">\n                        <p data-nodeid=\"111\">\n                          相连：比如 \"()()()\"，就可以得到区间 [[0,1], [2,3],\n                          [4,5]]。排序后，得到整数列表 [0,1,2,3,4,5]。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"112\">\n                        <p data-nodeid=\"113\">\n                          嵌套：比如 \"(())\"，就可以得到区间 [[0,3],\n                          [1,2]]。排序后，得到整数列表 [0,1,2,3]\n                        </p>\n                      </li>\n                      <li data-nodeid=\"114\">\n                        <p data-nodeid=\"115\">\n                          相连+嵌套：比如 \"()(())\"，就可以得到区间 [[0,1],\n                          [2,5], [3,4]]。排序后，得到整数列表 [0,1,2,3,4,5]。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"116\">\n                      当找到一个不能匹配的位置 NOT 的时候，我们不可能在 NOT\n                      的左边找一个位置 left_pos，在 NOT 的右边找一个位置\n                      right_pos，并且使得 [left_pos, right_pos]\n                      是一个合法的字符串。\n                    </p>\n                    <p data-nodeid=\"117\">上面描述的情况如下图所示：</p>\n                    <p data-nodeid=\"28107\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1R6AeHe4AABDrO9g1wg080.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"28110\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"119\">我们可以使用反证法进行证明。</p>\n                    <p data-nodeid=\"120\">\n                      证明：假设存在一个<strong data-nodeid=\"910\"\n                        >位置 NOT，不能找到一个左括号与之匹配</strong\n                      >。但是我们可以找到 left_pos &lt; NOT 和 right_pos &gt;\n                      NOT，并且使得 [left_pos, right_pos]\n                      是一个合法括号的字符串。\n                    </p>\n                    <p data-nodeid=\"121\">\n                      首先，由于 [left_pos, right_pos]\n                      是一个合法的括号配对的子串，那么可以肯定，这个区间里面的每一个字符应该都有左括号与之匹配。但是这一结论与“NOT\n                      找不到左括号匹配”相矛盾。因此，我们就证明了合法字符串的连续性。\n                    </p>\n                    <p data-nodeid=\"122\">\n                      那么，我们是不是可以进行如下操作呢？\n                    </p>\n                    <p data-nodeid=\"123\">\n                      Step 1.\n                      把所有配对成功的下标，都放到一个数组中，然后再把这个数组排序。\n                    </p>\n                    <p data-nodeid=\"124\">\n                      Step 2. 找到最长的相邻整数构成的列表，输出其长度。\n                    </p>\n                    <p data-nodeid=\"125\">\n                      为了方便你理解 Step 2\n                      中“最长的相邻整数构成的列表”，这里我给你举个例子：\n                    </p>\n                    <blockquote data-nodeid=\"126\">\n                      <p data-nodeid=\"127\">\n                        当给定的数组为 A[] = {0,1,3,4,5,6,8,9}\n                        时，最长的相邻整数列表为 [3,4,5,6]，输出长度 4。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"128\">\n                      那么，基于这样的思路，我们可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = s == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : s.length();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (N &lt;= <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 拿到所有的区间</span>\n</div></li><li><div class=\"code-word\">    List&lt;Integer&gt; pairs = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 栈</span>\n</div></li><li><div class=\"code-word\">    Stack&lt;Integer&gt; st = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 我们想找到每个位置匹配的地方</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!st.empty()) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 我们可以找到i匹配的位置中st.top();</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> idx = st.pop();\n</div></li><li><div class=\"code-word\">          pairs.add(idx);\n</div></li><li><div class=\"code-word\">          pairs.add(i);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        st.push(i);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 我们将pairs放在一起，然后排个序</span>\n</div></li><li><div class=\"code-word\">    Collections.sort(pairs);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录最长的匹配连续区域</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 所有的匹配成功的区域，都是连在一起的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 那么把序之后，这些数字应该是连续的，中间没有中断过</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> preValue = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> rangeStart = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pairs.size(); i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 拿到当前值</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> cur = pairs.get(i);\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果之前有值</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果值不再连续</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (cur != preValue + <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 那么从[rangeStart, i)就是一个合法区间</span>\n</div></li><li><div class=\"code-word\">          ans = Math.max(ans, i - rangeStart);\n</div></li><li><div class=\"code-word\">          rangeStart = i;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      preValue = cur;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    ans = Math.max(ans, pairs.size() - rangeStart);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"130\">\n                      <p data-nodeid=\"131\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.sort.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"936\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.sort.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"940\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.sort.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"944\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"132\">\n                      <strong data-nodeid=\"949\">复杂度分析</strong\n                      >：最差情况下，会有 N\n                      个整数放到数组中排序，所以时间复杂度为\n                      O(NlgN)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"133\">\n                      我们继续从<strong data-nodeid=\"955\">相连性</strong\n                      >出发，请你思考，这里是否必须要做排序？既然都相连了，我们就把所有配对成功的字符标记为\n                      1，没有配对成功的字符标记为 -INF，如下图所示：\n                    </p>\n                    <p data-nodeid=\"30753\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1SmAcTFFAABBSfs1TJc166.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"30756\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"135\">\n                      那么，原问题就成功转化为“求一个数组的最大子数组”问题。并且，最大子数组和即是原问题的输出。\n                    </p>\n                    <p data-nodeid=\"136\">\n                      基于这个思想，我们可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = s == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : s.length();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (N &lt;= <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 我们要找到每个位置对应的pair在什么地方</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] pairPos = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N];\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    Arrays.fill(pairPos, -<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    Stack&lt;Integer&gt; st = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果遇到右括号，我们看看能不能找到匹配的位置</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果可以找到匹配的位置</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!st.isEmpty()) {\n</div></li><li><div class=\"code-word\">          pairPos[i] = st.peek();\n</div></li><li><div class=\"code-word\">          pairPos[st.peek()] = i;\n</div></li><li><div class=\"code-word\">          st.pop();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        st.push(i);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 接下来，我们只需要在pairPos数组中找到连续的，中间不带-1的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 最长的就可以了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> tmp_sum = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> max_sum = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果遇到了-1，那么我们就让tmp_sum变得足够小</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> v = (pairPos[i] == -<span class=\"hljs-number\">1</span>) ? Integer.MIN_VALUE / <span class=\"hljs-number\">2</span> : <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      tmp_sum = Math.max(tmp_sum, <span class=\"hljs-number\">0</span>) + v;\n</div></li><li><div class=\"code-word\">      max_sum = Math.max(max_sum, tmp_sum);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> max_sum;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"138\">\n                      <p data-nodeid=\"139\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.maxSum.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"964\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.maxSum.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"968\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.maxSum.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"972\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"140\">\n                      <strong data-nodeid=\"977\">复杂度分析</strong\n                      >：时间复杂度为 O(N)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"141\">\n                      然后，我们再看一下这个题目的下一个特点与解法。\n                    </p>\n                    <h3 data-nodeid=\"142\">特点 3：最长</h3>\n                    <p data-nodeid=\"143\">\n                      我们从题目中看到了“最长”二字，这不禁让我想起一个总结：\n                    </p>\n                    <blockquote data-nodeid=\"144\">\n                      <p data-nodeid=\"145\">\n                        如果题目中出现“最大”“最小”“最长”等字眼，那么可以尝试往\n                        DP 的方向思考。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"146\">\n                      因此，这里我们就尝试往 DP 的方向去想一想，首先还是拿出“ DP\n                      分析 6 步法”。\n                    </p>\n                    <h4 data-nodeid=\"33399\" class=\"\">1. 最后一步</h4>\n\n                    <p data-nodeid=\"150\">\n                      DP\n                      问题的关键是最后一步。对于处理一维的字符串而言，最后一步肯定就是处理字符串的最后一个字符。最后一个字符可以分为两种情况：左括号、右括号。\n                    </p>\n                    <ul data-nodeid=\"151\">\n                      <li data-nodeid=\"152\">\n                        <p data-nodeid=\"153\">\n                          <strong data-nodeid=\"989\">左括号</strong\n                          >：此时肯定找不到括号与这个字符配对，所以包含最后一个字符的有效子串长长度为\n                          0。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"154\">\n                        <p data-nodeid=\"155\">\n                          <strong data-nodeid=\"994\">右括号</strong\n                          >：如果最后一个字符为右括号，那么我们再看它前面的那个字符，这个字符也只有\n                          2 种情况（左括号，右括号）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"156\">\n                      <strong data-nodeid=\"998\">1） 左括号</strong>\n                    </p>\n                    <p data-nodeid=\"157\">情况如下图所示：</p>\n                    <p data-nodeid=\"36039\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1TeAfxoVAAAwGzXzYXE754.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"36042\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"159\">\n                      此时，最后一个字符可以和它前面的字符配对成功。但是需要注意：包含最后一个括号的合法子串长度可能是\n                      2，也可能比 2 大。因为可能有如下 2 种情况：\n                    </p>\n                    <p data-nodeid=\"160\">\n                      情况\n                      1，前面字符串不是有效的合法子串，此时最后一个括号的合法子串长度是\n                      2。如下图所示：\n                    </p>\n                    <p data-nodeid=\"38681\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1T2AfNJEAAAml_3glHM796.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"38684\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"162\">\n                      情况\n                      2，前面的字符串也是有效的合法子串。我们需要加上这部分的合法子串的长度。此时最后一个括号的合法子串长度大于\n                      2。如下图所示：\n                    </p>\n                    <p data-nodeid=\"41323\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1UaAbKiSAAAm9tN7Ki4051.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"41326\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"164\">\n                      <strong data-nodeid=\"1015\">2）右括号</strong>\n                    </p>\n                    <p data-nodeid=\"165\">\n                      如果最后一个括号之前的字符是右括号，如下图所示：\n                    </p>\n                    <p data-nodeid=\"43965\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1UuAFzKtAAAkOnef54E673.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"43968\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"167\">\n                      那么我们只需要跳过前面那一段有效合法子串，看一下“问号”位置（与最后一个字符可能匹配的位置\n                      pairPos）是否可以与最后一个字符匹配。\n                    </p>\n                    <ul data-nodeid=\"168\">\n                      <li data-nodeid=\"169\">\n                        <p data-nodeid=\"170\">\n                          如果问号位置（s[pairPos]）是一个右括号，那么最后一个字符肯定匹配失败；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"171\">\n                        <p data-nodeid=\"172\">\n                          如果问号位置（s[pairPos]）是一个左括号，那么就可以配对成功。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"173\">\n                      在配对成功的情况下，我们还需要加上之前的合法子串的长度。情况如下：\n                    </p>\n                    <p data-nodeid=\"46607\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1VGAUHJ7AAAmQDHoCG4924.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"46610\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"175\">\n                      我们可以将这里分情况的思路用思维导图整理如下：\n                    </p>\n                    <p data-nodeid=\"49249\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1VeABDTPAADVrM03_Jg627.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"49252\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"177\">\n                      分情况讨论总是很烦，所以这里我给你总结成两条原则：\n                    </p>\n                    <ul data-nodeid=\"178\">\n                      <li data-nodeid=\"179\">\n                        <p data-nodeid=\"180\">\n                          配对失败，那么此字符的合法子串长度为 0；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"181\">\n                        <p data-nodeid=\"182\">\n                          配对成功，还需要加上之前的合法长度。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"54527\" class=\"\">2. 子问题</h4>\n\n                    <p data-nodeid=\"186\">\n                      我们可以用 f(x) 表示以字符 s[x]\n                      为右端点的，合法子串的长度。\n                    </p>\n                    <h4 data-nodeid=\"51891\" class=\"\">3. 递推关系</h4>\n\n                    <p data-nodeid=\"190\">\n                      有了\"f(x)\"\n                      的含义，可以写出递推的伪代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 我们要求解 f(i)</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> s[i-<span class=\"hljs-number\">1</span>] == <span class=\"hljs-string\">'('</span>:\n</div></li><li><div class=\"code-word\">    f(i) = <span class=\"hljs-number\">2</span> + f(i-<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 加上前面合法的子串长度</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">    preValidLen = f(i-<span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 找到问号位置</span>\n</div></li><li><div class=\"code-word\">    pairPos = i - preLen - <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> pairPos &gt;= <span class=\"hljs-number\">0</span> and s[pairPos] == <span class=\"hljs-string\">'('</span>:\n</div></li><li><div class=\"code-word\">        f(i) = i + <span class=\"hljs-number\">1</span> - pairPos\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> pairPos - <span class=\"hljs-number\">1</span> &gt;= <span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\">// 如果之前还有合法的子串</span>\n</div></li><li><div class=\"code-word\">            f(i) += f(pairPos-<span class=\"hljs-number\">1</span>)            \n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"59785\" class=\"\">4. f(x) 的表达</h4>\n\n                    <p data-nodeid=\"196\">\n                      我们发现，x 只是字符串 s\n                      的下标，那么只需使用一个一维的数组 dp[] 就可以表示 f(x)\n                      了。\n                    </p>\n                    <h4 data-nodeid=\"61099\" class=\"\">5. 初始条件与边界</h4>\n\n                    <p data-nodeid=\"200\">\n                      在计算的时候，f(i) 会依赖 f(i-1) 以及 f(i-2)，还有\n                      f(pairPos-1)。这里提醒我们：\n                    </p>\n                    <ul data-nodeid=\"201\">\n                      <li data-nodeid=\"202\">\n                        <p data-nodeid=\"203\">\n                          由 f(i)依赖\n                          f(i-1)、f(i-2)，可知初始计算的时候，至少应该先计算出两项的值，也就是计算出\n                          f(0) 和 f(1)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"204\">\n                        <p data-nodeid=\"205\">\n                          由于我们并不清楚f(pairPos-1)具体的值是多少，所以在处理的时候，要注意判断是否越界。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"65035\" class=\"\">6. 计算顺序</h4>\n\n                    <p data-nodeid=\"209\">\n                      如果我们从左往右遍历字符串，那么计算的时候，需要注意：\n                    </p>\n                    <ul data-nodeid=\"210\">\n                      <li data-nodeid=\"211\">\n                        <p data-nodeid=\"212\">\n                          处理字符串为空，或者长度为 1 的特殊情况；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"213\">\n                        <p data-nodeid=\"214\">\n                          优先计算头两个字符的 f() 函数值；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"215\">\n                        <p data-nodeid=\"216\">注意 pairPos 的越界的处理。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"217\">\n                      至此，我们就可以写出动态规划求解的代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 拿到字符串的长度</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = s == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : s.length();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (N &lt;= <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] dp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[N];\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 前面两个字符的情况</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 只有当()为字符串的时候，这两个是dp[0] = 0, dp[1] = 2;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 其他都是dp[0] = dp[1] = 0;</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (s.charAt(<span class=\"hljs-number\">0</span>) == <span class=\"hljs-string\">'('</span> &amp;&amp; s.charAt(<span class=\"hljs-number\">1</span>) == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">      dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">      ans = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">2</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// dp[i] = 0; // java的数组默认会初始化</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 所以dp[i] = 0;可以跳过</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 看一下preChar</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> preChar = s.charAt(i - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (preChar == <span class=\"hljs-string\">'('</span>) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 前面是xxx()的结构</span>\n</div></li><li><div class=\"code-word\">          dp[i] = <span class=\"hljs-number\">2</span> + dp[i - <span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 前面是一个 xxx))的结构</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 那么只需要找到更之前的字符就可以了</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> preLen = dp[i - <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">          \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// [start, i-1] = preLen</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// i - start = preLen</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> start = i - preLen;\n</div></li><li><div class=\"code-word\">          \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 那么找到与 i 配对的位置</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> pairPos = start - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">          \n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (pairPos &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; s.charAt(pairPos) == <span class=\"hljs-string\">'('</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果能够与i匹配成功</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 那么形成的结构就是xx((xxxx))</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 我们还需要看一下之前的长度是不是可以加上去</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> curLen = i + <span class=\"hljs-number\">1</span> - pairPos;\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 之前还有长度吗？</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (pairPos - <span class=\"hljs-number\">1</span> &gt;= <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">              curLen += dp[pairPos - <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            \n</div></li><li><div class=\"code-word\">            dp[i] = curLen;\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      ans = Math.max(ans, dp[i]);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"219\">\n                      <p data-nodeid=\"220\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.dp.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1072\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.dp.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1076\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.dp.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1080\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"221\">\n                      <strong data-nodeid=\"1085\">复杂度分析</strong\n                      >：时间复杂度为 O(N)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"222\">\n                      在使用 DP 的过程中，我们发现，可以浓缩成一个原则：\n                    </p>\n                    <blockquote data-nodeid=\"223\">\n                      <p data-nodeid=\"224\">配对成功，就加上之前的合法长度。</p>\n                    </blockquote>\n                    <p data-nodeid=\"225\">\n                      那么，基于这个原则我们还有没有其他解法呢？\n                    </p>\n                    <h3 data-nodeid=\"226\">特点 4：栈的性质</h3>\n                    <p data-nodeid=\"227\">\n                      在特点 1 和特点 2\n                      中，都用到了栈来找到每一个字符的匹配字符的位置（如果存在）。下面我们再看一下，当一个<strong\n                        data-nodeid=\"1094\"\n                        >合法的字符串利用栈来进行匹配处理的时候，有什么样的性质。</strong\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">stack = []\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">for</span> i in <span class=\"hljs-title\">range</span><span class=\"hljs-params\">(len(s)</span>):\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> s[i] == <span class=\"hljs-string\">')'</span>:\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> not stack.empty():\n</div></li><li><div class=\"code-word\">            topIdx = stack.pop()\n</div></li><li><div class=\"code-word\">            &lt;topIdx, i&gt;匹配成功\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 问题1: 如果这里栈为空，怎么办？</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 问题3: 如果这里栈非空，怎么办？</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 问题2:遇到栈为空，无法弹怎么办？</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span>:\n</div></li><li><div class=\"code-word\">       stack.push(i)\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"229\">问题 1：弹栈之后的空栈</h4>\n                    <p data-nodeid=\"67653\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1XKAD1HBAAAn8fF7k04289.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"67656\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"231\">\n                      当我们需要为红框中的右括号 s[i]\n                      进行匹配，并且弹栈之后，栈为空。那么我们可以得到一个<strong\n                        data-nodeid=\"1108\"\n                        >结论 1</strong\n                      >：\n                    </p>\n                    <blockquote data-nodeid=\"232\">\n                      <p data-nodeid=\"233\">\n                        此时，整个字符串从<strong data-nodeid=\"1118\"\n                          >开头</strong\n                        >到<strong data-nodeid=\"1119\">当前位置</strong\n                        >是一个合法有效的字符串。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"234\">\n                      但是，这个<strong data-nodeid=\"1125\">结论 1</strong\n                      >会遇到下面这种坑。\n                    </p>\n                    <p data-nodeid=\"235\">\n                      例 1：给定的字符串是 \")))()\"，当我们处理最后一个字符 s[4]\n                      的时候，弹栈之后，栈肯定为空。但是，我们不能认为 [0, 4]\n                      是一个有效的合法子串。\n                    </p>\n                    <p data-nodeid=\"236\">\n                      那么，是不是结论 1\n                      不对呢？其实不尽然，只是我们有可能需要重新定义字符串的开头。\n                    </p>\n                    <h4 data-nodeid=\"237\">问题 2：空栈无法弹</h4>\n                    <p data-nodeid=\"238\">\n                      假设，字符串是 s = \"))))\"。如果按照结论 1\n                      来进行操作，每个位置都会得到空栈，我们可以得到每个位置的最长合法子串，如下图所示：\n                    </p>\n                    <p data-nodeid=\"70273\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1XuANhxQAAAhM5RDpyM877.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"70276\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"240\">\n                      显然，这样处理是不合适的。那么问题出在哪里呢？\n                    </p>\n                    <p data-nodeid=\"241\">\n                      在特点 2 中，我们证明了合法字符串必须满足<strong\n                        data-nodeid=\"1155\"\n                        >连续性</strong\n                      >，那么当我们找到一个右括号，但是找不到任何左括号与之配对的时候，就可以扔掉左边的字符了。\n                    </p>\n                    <p data-nodeid=\"72893\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/B2/CioPOWCL1YGAVc7NAAAiApZoIyg024.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"72896\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"243\">\n                      这也就意味着，在找到一个字符\n                      s[i]，找不到匹配的时候，需要切掉 [0,i] 这部分子串。\n                    </p>\n                    <p data-nodeid=\"244\">\n                      当然，为了处理方便，我们不会真正去切这个子串，而是重新定义一个\n                      start 变量来表示新的字符串的起始位置。\n                    </p>\n                    <p data-nodeid=\"245\">\n                      在切掉 [0, i] 这部分子串的时候，就可以有如下操作：\n                    </p>\n                    <blockquote data-nodeid=\"246\">\n                      <p data-nodeid=\"247\">\n                        当 s[i] 为右括号，栈为空的时候，设置新的字符串的起始点\n                        start = i + 1。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"248\">\n                      打上这个<strong data-nodeid=\"1188\">补丁</strong\n                      >之后，字符串 s = \"))))\"\n                      就可以正确处理了。到此时，我们发现，并不是结论 1\n                      不对，而是结论 1 中的“开头\n                      start”在遇到空栈无法弹的时候，需要重新定义。\n                    </p>\n                    <h4 data-nodeid=\"249\">问题 3：弹栈后非空</h4>\n                    <p data-nodeid=\"75513\" class=\"\">\n                      如果弹栈之后，栈非空，那么必然是遇到了 s =\n                      \"((()()(）\"这种字符串。当我们处理最后一个字符（会将 6\n                      弹栈），如下图所示：\n                    </p>\n\n                    <p data-nodeid=\"78127\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/B2/CioPOWCL1ZSAPT-dAABPNjtrapU237.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"78130\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"252\">\n                      但是，弹栈之后，栈顶元素就变成了 1。我们发现 (1, 7]\n                      这段区间都是一个有效的合法区间。因此，弹栈之后，栈非空的情况：区间（存留的栈顶元素，i]\n                      是一个合法的子串。\n                    </p>\n                    <p data-nodeid=\"253\">\n                      处理好问题 1、问题 2、问题 3\n                      之后，我们就可以写出如下代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 拿到字符串的长度</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = s == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : s.length();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (N &lt;= <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    Stack&lt;Integer&gt; st = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 最长的有效长度</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> start = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">')'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果从[start, i]这个区间里面</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 右括号已经可以匹配掉所有的左括号了</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (st.isEmpty()) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 问题2:更新新字符串的开头</span>\n</div></li><li><div class=\"code-word\">          start = i + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">          st.pop();\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 注意问题1，3在这里统一处理</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> base =\n</div></li><li><div class=\"code-word\">              st.isEmpty() ? start : st.peek() + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">          ans = Math.max(ans, i - base + <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">/* 如果字符是左括号 */</span>\n</div></li><li><div class=\"code-word\">        st.push(i);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-comment\">// end for</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"255\">\n                      <p data-nodeid=\"256\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1211\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1215\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.stack.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1219\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"257\">\n                      <strong data-nodeid=\"1224\">复杂度分析</strong\n                      >：时间复杂度为 O(N)，空间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"258\">\n                      前面我们介绍的算法<strong data-nodeid=\"1230\">最优</strong\n                      >情况下，时间复杂度都是 O(N)，但是空间复杂度也都为\n                      O(N)。有没有可能优化一下空间复杂度呢？\n                    </p>\n                    <h3 data-nodeid=\"259\">特点 5：合法字符串的性质</h3>\n                    <p data-nodeid=\"260\">\n                      如果优化空间复杂度，我们需要再挖掘一下合法子串的性质。对于任意一个合法子串，都必然满足以下两个性质。\n                    </p>\n                    <ul data-nodeid=\"261\">\n                      <li data-nodeid=\"262\">\n                        <p data-nodeid=\"263\">\n                          合法性质\n                          1：对于任意一个合法子串，当我们从左往右遍历这个子串的时候，左括号的数目永远\n                          &gt;= 右括号的数目。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"264\">\n                        <p data-nodeid=\"265\">\n                          合法性质\n                          2：对于任意一个合法子串，当我们从右往左遍历这个子串的时候，右括号的数目永远\n                          &gt;= 左括号的数目。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"266\">那么，我们是否可以反推呢？</p>\n                    <p data-nodeid=\"267\">\n                      1） 利用合法性质\n                      1，我们从左往右遍历，找到一个最长的区间，使其总是满足左括号的数目\n                      &gt;= 右括号的数目。那么当左括号数目 ==\n                      右括号数目，此时就可以得到一个最长的合法子串，我们记为maxEquLength1。\n                    </p>\n                    <p data-nodeid=\"268\">\n                      2）利用合法性质\n                      2，我们从右往左遍历，找到一个最长的区间，使其总是满足右括号的数目\n                      &gt;= 左括号的数目。那么当左括号数目 ==\n                      右括号数目，此时就可以得到一个最长的合法子串，我们记为\n                      maxEquLength2。\n                    </p>\n                    <p data-nodeid=\"269\">\n                      最后，再取这两者的最大值：max(maxEquLength1,\n                      maxEquLength2)。\n                    </p>\n                    <p data-nodeid=\"270\">\n                      那么，有没有可能只从左向右遍历一次呢？答案是不行！\n                    </p>\n                    <p data-nodeid=\"271\">\n                      原因是：如果只利用合法性质 1\n                      从左向右遍历，那么无法处理字符串 s =\n                      \"(()\"；如果只利用合法性质 2\n                      从右向左遍历，那么无法处理字符串 s = \"())\"。\n                    </p>\n                    <p data-nodeid=\"272\">\n                      结合以上分析，我们可以写出如下代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = s == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : s.length();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (N &lt;= <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 合法子串性质1</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 1. 最长</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 2. 在任何时间，左括号数量 &gt;= 右括号数量</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 左括号的数量</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> leftBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 右括号的数量</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> rightBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 第一次扫描的区间的长度</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> maxEquLength1 = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 取出这个字符</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      leftBraceNumber += c == <span class=\"hljs-string\">'('</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      rightBraceNumber += c == <span class=\"hljs-string\">')'</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 我们总是想让括号的数目 &gt;= 右括号的数目</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果不成立了！</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 我们去掉左边的任何一部分，都不会合得条件再次成立</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 所以直接需要让两个计数器归0</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (rightBraceNumber &gt; leftBraceNumber) {\n</div></li><li><div class=\"code-word\">        leftBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        rightBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果计数相等的时候</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (leftBraceNumber == rightBraceNumber) {\n</div></li><li><div class=\"code-word\">        maxEquLength1 =\n</div></li><li><div class=\"code-word\">          Math.max(maxEquLength1,\n</div></li><li><div class=\"code-word\">                   leftBraceNumber + rightBraceNumber);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      \n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-comment\">// end for</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 合法子串性质2</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 1. 最长</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 2. 在任何时间，左括号数量 &lt;= 右括号数量</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果不利用 性质2，那么无法处理(()这种情况</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> maxEquLength2 = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    leftBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    rightBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = N - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 取出字符</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">char</span> c = s.charAt(i);\n</div></li><li><div class=\"code-word\">      leftBraceNumber += c == <span class=\"hljs-string\">'('</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      rightBraceNumber += c == <span class=\"hljs-string\">')'</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (leftBraceNumber &gt; rightBraceNumber) {\n</div></li><li><div class=\"code-word\">        leftBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        rightBraceNumber = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (leftBraceNumber == rightBraceNumber) {\n</div></li><li><div class=\"code-word\">        maxEquLength2 =\n</div></li><li><div class=\"code-word\">          Math.max(maxEquLength2,\n</div></li><li><div class=\"code-word\">                   leftBraceNumber + rightBraceNumber);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-comment\">// end for</span>\n</div></li><li><div class=\"code-word\">    \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 最后取两者中最长的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> Math.max(maxEquLength1, maxEquLength2);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"274\">\n                      <p data-nodeid=\"275\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.DoublePointer.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1253\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.DoublePointer.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1257\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.DoublePointer.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1261\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"276\">\n                      <strong data-nodeid=\"1266\">复杂度分析</strong\n                      >：时间复杂度为 O(N)，空间复杂度为 O(1)。\n                    </p>\n                    <p data-nodeid=\"277\">\n                      在这里，我们抓住了合法字符串的性质 1 和性质\n                      2，然后利用贪心算法在 O(1) 空间内解决了这个题目。<strong\n                        data-nodeid=\"1272\"\n                        >在做题的时候，如果挖掘出题目的更多信息，再匹配到合适的算法，就能够帮助我们巧妙地破题</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"278\">总结</h3>\n                    <p data-nodeid=\"279\">\n                      在本讲，我们通过一个<strong data-nodeid=\"1279\"\n                        >括号匹配</strong\n                      >的题目，深入挖掘了题目的特点，然后再使用上各种算法与数据结构，得到了各种巧妙的解法。我将本讲的内容整理成了思维导图，帮助你总结思路：\n                    </p>\n                    <p data-nodeid=\"80739\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1aOATORpAAFh_9bKaaY147.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"80742\"\n                      />\n                    </p>\n\n                    <h3 data-nodeid=\"281\">思考题</h3>\n                    <p data-nodeid=\"282\">最后，我还给你留了一个思考题。</p>\n                    <p data-nodeid=\"283\">\n                      思考题：数字 n\n                      代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且\n                      有效的 括号组合。\n                    </p>\n                    <p data-nodeid=\"284\">示例 1</p>\n                    <p data-nodeid=\"285\">输入：n = 3</p>\n                    <p data-nodeid=\"286\">\n                      输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n                    </p>\n                    <blockquote data-nodeid=\"287\">\n                      <p data-nodeid=\"288\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1313\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1317\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/20.Braces/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"1321\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"289\">\n                      你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于这道括号的题目就介绍到这里。接下来，下一讲介绍“21\n                      |\n                      安排会议室：如何利用多种方法安排会议室？”，让我们继续前进。\n                    </p>\n            "}