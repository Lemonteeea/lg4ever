{"title":"07 | 梳理混乱的 Babel，不再被编译报错困扰","context":"\n                    <p data-nodeid=\"21749\" class=\"\">\n                      今天我和你分享的话题和 Babel 相关。Babel\n                      在前端中占有举足轻重的历史地位，几乎所有的大型前端应用项目都离不开\n                      Babel 的支持。同时，Babel\n                      不仅仅是一个工具，更是一个<strong data-nodeid=\"21755\"\n                        >工具链（toolchain）</strong\n                      >，是前端基建中绝对重要的一环。\n                    </p>\n\n                    <p data-nodeid=\"24286\">\n                      对于很多前端工程师来说，你可能配置过\n                      Babel，也可能看过一些关于 Babel\n                      插件或原理的文章。但我认为，“配置工程师”只是我们的起点，通过阅读几篇\n                      Babel 插件编写的文章并不能让我们真正掌握 Babel\n                      的设计思想和原理。\n                    </p>\n                    <p data-nodeid=\"24287\">\n                      对于 Babel\n                      的学习，不能停留在配置层面，我们需要从更高的角度认识 Babel\n                      在工程上的方方面面和设计思想。这一讲就让我们深入 Babel\n                      生态，了解前端基建工程中最重要的一环。\n                    </p>\n\n                    <h3 data-nodeid=\"14744\">Babel 是什么</h3>\n                    <p data-nodeid=\"14745\">借用 Babel 官方的一句话简短介绍：</p>\n                    <blockquote data-nodeid=\"14746\">\n                      <p data-nodeid=\"14747\">Babel is a JavaScript compiler.</p>\n                    </blockquote>\n                    <p data-nodeid=\"14748\">\n                      Babel 其实就是一个 JavaScript\n                      的“编译器”。但是一个简单的编译器如何会成为影响前端项目的“大杀器”呢？究其原因，主要是前端语言特性和宿主（浏览器/Node.js\n                      等）环境高速发展，但<strong data-nodeid=\"14913\"\n                        >宿主环境对新语言特性的支持无法做到即时，而开发者又需要兼容各种宿主环境</strong\n                      >，因此语言特性的降级成为刚需。\n                    </p>\n                    <p data-nodeid=\"14749\">\n                      另一方面，前端框架“<strong data-nodeid=\"14919\"\n                        >自定义 DSL</strong\n                      >”的风格越来越凸显，使得前端各种“姿势”的代码被编译为\n                      JavaScript 的需求成为标配。因此 Babel\n                      的职责半径越来越大，它需要完成以下内容：\n                    </p>\n                    <ul data-nodeid=\"14750\">\n                      <li data-nodeid=\"14751\">\n                        <p data-nodeid=\"14752\">\n                          语法转换，一般是高级语言特性的降级；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14753\">\n                        <p data-nodeid=\"14754\">\n                          Polyfill（垫片/补丁）特性的实现和接入；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14755\">\n                        <p data-nodeid=\"14756\">源码转换，比如 JSX 等。</p>\n                      </li>\n                    </ul>\n                    <blockquote data-nodeid=\"14757\">\n                      <p data-nodeid=\"14758\">\n                        <a\n                          href=\"https://babeljs.io/videos.html\"\n                          data-nodeid=\"14925\"\n                          >更多需求，点击这里查看</a\n                        >。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"27448\" class=\"\">\n                      为了完成这些编译工作，Babel\n                      不能大包大揽地实现一切，更不能用面条式毫无设计模式可言的方式来\n                      Coding。因此，Babel\n                      的设计，在工程化的角度上，需要秉承以下理念：\n                    </p>\n\n                    <ul data-nodeid=\"29996\">\n                      <li data-nodeid=\"29997\">\n                        <p data-nodeid=\"29998\">\n                          <strong data-nodeid=\"30007\">可插拔</strong\n                          >（Pluggable），比如 Babel\n                          需要有一套灵活的插件机制，召集第三方开发者力量，同时还需要方便接入各种工具；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29999\">\n                        <p data-nodeid=\"30000\">\n                          <strong data-nodeid=\"30012\">可调式</strong\n                          >（Debuggable），比如 Babel 在编译过程中，要提供一套\n                          Source\n                          Map，来帮助使用者在编译结果和编译前源码之间建立映射关系，方便调试；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"30001\">\n                        <p data-nodeid=\"30002\" class=\"\">\n                          <strong data-nodeid=\"30021\">基于协定</strong\n                          >（Compact），Compact\n                          可以简单翻译为基于协定，主要是指实现灵活的配置方式，比如你熟悉的\n                          Babel<a\n                            href=\"https://2ality.com/2015/12/babel6-loose-mode.html\"\n                            data-nodeid=\"30019\"\n                            >loose 模式</a\n                          >，Babel 提供 loose\n                          选项，帮助开发者在“尽量还原规范”和“更小的编译产出体积”之间，找到平衡。\n                        </p>\n                      </li>\n                    </ul>\n\n                    <p data-nodeid=\"14767\">\n                      我们总结一下，<strong data-nodeid=\"14952\"\n                        >编译是 Babel 的核心目标</strong\n                      >，因此它自身的实现基于编译原理，深入\n                      AST（抽象语法树）来生成目标代码；同时，Babel\n                      需要工程化协作，需要和各种工具（如 Webpack）相互配合，因此\n                      Babel 一定是庞大复杂的。\n                    </p>\n                    <p data-nodeid=\"14768\">\n                      接下来，我们继续深入\n                      Babel，了解这个“庞然大物”的运作方式和实现原理。\n                    </p>\n                    <h3 data-nodeid=\"14769\">Babel Monorepo 架构包解析</h3>\n                    <p data-nodeid=\"24920\" class=\"\">\n                      为了以最完美的方式支撑上述职责，Babel\n                      的“家族”可谓枝繁叶茂。Babel 是一个使用 Lerna 构建的\n                      Monorepo 风格的仓库，在其<a\n                        href=\"https://github.com/babel/babel/tree/main/packages\"\n                        data-nodeid=\"24924\"\n                        ><code data-backticks=\"1\" data-nodeid=\"24923\"\n                          >./packages</code\n                        ></a\n                      >目录下有 140\n                      多个包，这些包我经过整合分类，并按照重要性筛选出来，可以用下面这张图片简单概括：\n                    </p>\n\n                    <p data-nodeid=\"14771\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/84/CgqCHl_toZGAYAFJAAFicXOL898453.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"14962\"\n                      />\n                    </p>\n                    <p data-nodeid=\"14772\">\n                      其中 Babel\n                      部分包你可能见过或者使用过，但并不确定它们起到了什么作用；有些包，你可能都没有听说过。总的来说，可以分为两种情况：\n                    </p>\n                    <ul data-nodeid=\"14773\">\n                      <li data-nodeid=\"14774\">\n                        <p data-nodeid=\"14775\">\n                          Babel\n                          一些包的意义是在工程上起作用，因此对于业务来说是不透明的，比如一些插件可能被\n                          Babel preset 预设机制打包对外输出；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14776\">\n                        <p data-nodeid=\"14777\">\n                          Babel 一些包是为了纯工程项目使用，或者运行目标在\n                          Node.js 环境中，相对来讲你对这些会更熟悉。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"14778\">\n                      下面，我会对一些“Babel\n                      家族重点成员”进行梳理，并简单说说它们的基本原理。\n                    </p>\n                    <p data-nodeid=\"14779\">\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-core\"\n                        data-nodeid=\"14969\"\n                        >@babel/core</a\n                      >\n                      <strong data-nodeid=\"14975\"\n                        >是 Babel 实现转换的核心</strong\n                      >，它可以根据配置，进行源码的编译转换：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> babel = require(<span class=\"hljs-string\">\"@babel/core\"</span>);\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">babel.transform(code, options, function(err, result) {\n</div></li><li><div class=\"code-word\">  result; <span class=\"hljs-comment\">// =&gt; { code, map, ast }</span>\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14781\">\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-cli\"\n                        data-nodeid=\"14978\"\n                        >@babel/cli</a\n                      >\n                      <strong data-nodeid=\"14992\">是 Babel 提供的命令行</strong\n                      >，它可以在终端中通过命令行方式运行，编译文件或目录。我们简单说一下它的实现原理：@babel/cli\n                      使用了\n                      <a\n                        href=\"https://github.com/babel/babel/blob/main/packages/babel-cli/package.json#L26\"\n                        data-nodeid=\"14986\"\n                        >commander</a\n                      >\n                      库搭建基本的命令行开发。以编译文件为例，其关键部分<a\n                        href=\"https://github.com/babel/babel/blob/main/packages/babel-cli/package.json#L26\"\n                        data-nodeid=\"14990\"\n                        >源码如下</a\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> * as util from <span class=\"hljs-string\">\"./util\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> results = await Promise.all(\n</div></li><li><div class=\"code-word\">  _filenames.map(<span class=\"hljs-function\">async <span class=\"hljs-title\">function</span> <span class=\"hljs-params\">(filename: string)</span>: Promise&lt;Object&gt; </span>{\n</div></li><li><div class=\"code-word\">    let sourceFilename = filename;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (cliOptions.outFile) {\n</div></li><li><div class=\"code-word\">      sourceFilename = path.relative(\n</div></li><li><div class=\"code-word\">        path.dirname(cliOptions.outFile),\n</div></li><li><div class=\"code-word\">        sourceFilename,\n</div></li><li><div class=\"code-word\">      );\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 获取文件名</span>\n</div></li><li><div class=\"code-word\">    sourceFilename = slash(sourceFilename);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> await util.compile(filename, {\n</div></li><li><div class=\"code-word\">        ...babelOptions,\n</div></li><li><div class=\"code-word\">        sourceFileName: sourceFilename,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 获取 sourceMaps 配置项</span>\n</div></li><li><div class=\"code-word\">        sourceMaps:\n</div></li><li><div class=\"code-word\">          babelOptions.sourceMaps === <span class=\"hljs-string\">\"inline\"</span>\n</div></li><li><div class=\"code-word\">            ? <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">            : babelOptions.sourceMaps,\n</div></li><li><div class=\"code-word\">      });\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">catch</span> (err) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (!cliOptions.watch) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">throw</span> err;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      console.error(err);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }),\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14783\">\n                      在上述代码中，@babel/cli 使用了<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"14994\"\n                        >util.compile</code\n                      >方法执行关键的编译操作，而该方法定义在\n                      <a\n                        href=\"https://github.com/babel/babel/blob/master/packages/babel-cli/src/babel/util.js#L80\"\n                        data-nodeid=\"14998\"\n                        >babel-cli/src/babel/util.js</a\n                      >\n                      中：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> * as babel from <span class=\"hljs-string\">\"@babel/core\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 核心编译方法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">compile</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">  filename: string,\n</div></li><li><div class=\"code-word\">  opts: Object | Function,\n</div></li><li><div class=\"code-word\">): Promise&lt;Object&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 编译配置</span>\n</div></li><li><div class=\"code-word\">  opts = {\n</div></li><li><div class=\"code-word\">    ...opts,\n</div></li><li><div class=\"code-word\">    caller: CALLER,\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Promise((resolve, reject) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 调用 transformFile 方法执行编译过程</span>\n</div></li><li><div class=\"code-word\">    babel.transformFile(filename, opts, (err, result) =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (err) reject(err);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> resolve(result);\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14785\">\n                      由此可见，@babel/cli 负责获取配置内容，并最终依赖了\n                      @babel/core 完成编译。\n                    </p>\n                    <p data-nodeid=\"14786\">\n                      事实上，我们可以在 @babel/cli 的 package.json 中找到线索：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-string\">\"peerDependencies\"</span>: {\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-string\">\"@babel/core\"</span>: <span class=\"hljs-string\">\"^7.0.0-0\"</span>\n</div></li><li><div class=\"code-word\">},\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14788\">\n                      这一部分的源码在\n                      <a\n                        href=\"https://github.com/babel/babel/blob/master/packages/babel-cli/package.json#L39\"\n                        data-nodeid=\"15005\"\n                        >peerDependencies</a\n                      >\n                      当中，你可以课后再次学习。\n                    </p>\n                    <p data-nodeid=\"14789\">\n                      现在，你应该进一步体会到了 @babel/core 的作用，<strong\n                        data-nodeid=\"15018\"\n                        >作为 @babel/cli 的关键依赖，@babel/core\n                        提供了基础的编译能力</strong\n                      >。至于为什么在 @babel/cli 中，使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"15012\"\n                        >peerDependencies</code\n                      >，你可以在\n                      <a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=584#/detail/pc?id=5908\"\n                        data-nodeid=\"15016\"\n                        >03 讲“CI 环境上的 npm 优化及更多工程化问题解析”</a\n                      >中找到答案。\n                    </p>\n                    <p data-nodeid=\"14790\">\n                      我们花时间梳理 @babel/cli 和 @babel/core\n                      包，希望帮助你对于 Babel\n                      各个包之间的协同分工有个整体感知，这也是 Monorepo\n                      风格仓库常见的设计形式。接下来，我们再继续看更多“家族成员”。\n                    </p>\n                    <p data-nodeid=\"14791\">\n                      <a\n                        href=\"https://github.com/babel/babel/tree/main/packages/babel-standalone\"\n                        data-nodeid=\"15022\"\n                        >@babel/standalone</a\n                      >这个包非常有趣，它可以在非 Node.js\n                      环境（比如浏览器环境）自动编译含有 text/babel 或 text/jsx\n                      的 type 值的 script 标签，并进行编译，如下面代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;\n</div></li><li><div class=\"code-word\">&lt;script type=\"text/babel\"&gt;\n</div></li><li><div class=\"code-word\">\tconst getMessage = () =&gt; \"Hello World\";\n</div></li><li><div class=\"code-word\">\tdocument.getElementById('output').innerHTML = getMessage();\n</div></li><li><div class=\"code-word\">&lt;/script&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14793\">\n                      其工作原理藏在\n                      <a\n                        href=\"https://github.com/babel/babel/tree/main/packages/babel-standalone\"\n                        data-nodeid=\"15027\"\n                        >babel-standalone</a\n                      >\n                      的<a\n                        href=\"https://github.com/babel/babel/blob/0641a15030565e7f47ef0c5ff25f36264c182b11/packages/babel-standalone/src/transformScriptTags.js#L132\"\n                        data-nodeid=\"15031\"\n                        >核心源码</a\n                      >中，最后的编译行为由：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> {\n</div></li><li><div class=\"code-word\">  transformFromAst as babelTransformFromAst,\n</div></li><li><div class=\"code-word\">  transform as babelTransform,\n</div></li><li><div class=\"code-word\">  buildExternalHelpers as babelBuildExternalHelpers,\n</div></li><li><div class=\"code-word\">} from <span class=\"hljs-string\">\"@babel/core\"</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14795\">\n                      来提供。因此，我们又看到了另一个基于 @babel/core\n                      的应用：@babel/standalone。\n                    </p>\n                    <p data-nodeid=\"14796\">\n                      <strong data-nodeid=\"15046\"\n                        >@babel/standalone 可以在浏览器中直接执行</strong\n                      >，因此这个包对于<strong data-nodeid=\"15047\"\n                        >浏览器环境动态插入高级语言特性的脚本</strong\n                      >、<strong data-nodeid=\"15048\">在线自动解析编译</strong\n                      >非常有意义。我们知道的 Babel\n                      官网也用到了这个包，JSFiddle、JS Bin 等也都是\n                      @babel/standalone 的受益者。\n                    </p>\n                    <p data-nodeid=\"14797\">\n                      我认为，在前端发展方向之一——Web IDE\n                      和智能化方向上，相信类似的设计和技术将会有更多的施展空间，@babel/standalone\n                      对于我们的现代化前端发展思路，应该有启发。\n                    </p>\n                    <p data-nodeid=\"35098\" class=\"te-preview-highlight\">\n                      至此，我们看到了 @babel/core 被多个 Babel 包应用，而\n                      @babel/core 的能力由更底层的\n                      <strong data-nodeid=\"35116\">@babel/parser</strong\n                      >、<strong data-nodeid=\"35117\">@babel/code-frame</strong\n                      >、<strong data-nodeid=\"35118\">@babel/generator</strong\n                      >、<strong data-nodeid=\"35119\"\n                        >@babel/traverse、@babel/types</strong\n                      >等包提供。这些“家族成员”提供了更基础的 AST 处理能力。\n                    </p>\n\n                    <p data-nodeid=\"14799\" class=\"\">\n                      我们先看\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-parser\"\n                        data-nodeid=\"15075\"\n                        >@babel/parser</a\n                      >，它是 Babel 用来对 JavaScript 语言解析的解析器。\n                    </p>\n                    <p data-nodeid=\"14800\">\n                      @babel/parser 的实现主要依赖并参考了\n                      <a\n                        href=\"https://github.com/acornjs/acorn\"\n                        data-nodeid=\"15080\"\n                        >acorn</a\n                      >\n                      和\n                      <a\n                        href=\"https://github.com/acornjs/acorn-jsx\"\n                        data-nodeid=\"15084\"\n                        >acorn-jsx</a\n                      >，典型用法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">require(<span class=\"hljs-string\">\"@babel/parser\"</span>).parse(<span class=\"hljs-string\">\"code\"</span>, {\n</div></li><li><div class=\"code-word\">  sourceType: <span class=\"hljs-string\">\"module\"</span>,\n</div></li><li><div class=\"code-word\">  plugins: [\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"jsx\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"flow\"</span>\n</div></li><li><div class=\"code-word\">  ]\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14802\">\n                      parse<a\n                        href=\"https://github.com/babel/babel/blob/main/packages/babel-parser/src/index.js#L18\"\n                        data-nodeid=\"15089\"\n                        >源码实现</a\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">parse</span><span class=\"hljs-params\">(input: string, options?: Options)</span>: File </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (options?.sourceType === <span class=\"hljs-string\">\"unambiguous\"</span>) {\n</div></li><li><div class=\"code-word\">    options = {\n</div></li><li><div class=\"code-word\">      ...options,\n</div></li><li><div class=\"code-word\">    };\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">      options.sourceType = <span class=\"hljs-string\">\"module\"</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 获取相应的编译器</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> parser = getParser(options, input);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 使用编译器将源代码转为 ast</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> ast = parser.parse();\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (parser.sawUnambiguousESM) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ast;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (parser.ambiguousScriptDifferentAst) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          options.sourceType = <span class=\"hljs-string\">\"script\"</span>;\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> getParser(options, input).parse();\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span> {}\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        ast.program.sourceType = <span class=\"hljs-string\">\"script\"</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> ast;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">catch</span> (moduleError) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">        options.sourceType = <span class=\"hljs-string\">\"script\"</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> getParser(options, input).parse();\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">catch</span> {}\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">throw</span> moduleError;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> getParser(options, input).parse();\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14804\">\n                      由此可见，<code data-backticks=\"1\" data-nodeid=\"15092\"\n                        >require(\"@babel/parser\").parse()</code\n                      >方法可以返回给我们一个针对源码编译得到的 AST，这里的 AST\n                      符合<a\n                        href=\"https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md\"\n                        data-nodeid=\"15096\"\n                        >Babel AST 格式</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"14805\">\n                      有了 AST，我们<strong data-nodeid=\"15107\"\n                        >还需要对 AST 完成修改，才能产出编译后的代码</strong\n                      >。这就需要对 AST 进行遍历，此时\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-traverse\"\n                        data-nodeid=\"15105\"\n                        >@babel/traverse</a\n                      >\n                      就派上用场了，使用方式如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">traverse(ast, {\n</div></li><li><div class=\"code-word\">  enter(path) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (path.isIdentifier({ name: <span class=\"hljs-string\">\"n\"</span> })) {\n</div></li><li><div class=\"code-word\">      path.node.name = <span class=\"hljs-string\">\"x\"</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14807\">\n                      遍历的同时，如何对 AST\n                      上指定内容进行修改呢？这就又要引出另外一个“家族成员”，<a\n                        href=\"https://babeljs.io/docs/en/babel-types\"\n                        data-nodeid=\"15111\"\n                        >@babel/types</a\n                      >\n                      <strong data-nodeid=\"15117\"\n                        >包提供了对具体的 AST 节点的修改能力</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"14808\">\n                      得到了编译后的 AST 之后，最后一步：使用\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-generator\"\n                        data-nodeid=\"15121\"\n                        >@babel/generator</a\n                      >\n                      <strong data-nodeid=\"15127\"\n                        >对新的 AST 进行聚合并生成 JavaScript 代码</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> output = generate(\n</div></li><li><div class=\"code-word\">  ast,\n</div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">/* options */</span>\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  code\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14810\">\n                      这样一个典型的 Babel 底层编译流程就出来了，如下图：\n                    </p>\n                    <p data-nodeid=\"14811\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/8A/CgqCHl_u4niAOtOmAAEw7EQpjEI596.png\"\n                        alt=\"Lark20210101-165010.png\"\n                        data-nodeid=\"15131\"\n                      />\n                    </p>\n                    <div data-nodeid=\"14812\">\n                      <p style=\"text-align: center\">Babel 底层编译流程图</p>\n                    </div>\n                    <p data-nodeid=\"14813\">\n                      上图也是 Babel 插件运作实现的基础。基于 AST 的操作，Babel\n                      将上述所有能力开放给插件，让第三方能够更方便地操作\n                      AST，并聚合成最后编译产出的代码。\n                    </p>\n                    <p data-nodeid=\"14814\">\n                      基于以上原理，Babel\n                      具备了编译处理能力，但在工程中运用时，我们一般不会感知这些内容，你可能也很少直接操作\n                      @babel/core、@babel/types 等，而应该对 @babel/preset-env\n                      更加熟悉，毕竟\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-preset-env\"\n                        data-nodeid=\"15136\"\n                        >@babel/preset-env</a\n                      >\n                      <strong data-nodeid=\"15142\"\n                        >是直接暴露给开发者在业务中运用的包能力</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"14815\">\n                      在工程中，我们需要 Babel\n                      做到的是编译降级，而这个编译降级一般通过\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-preset-env\"\n                        data-nodeid=\"15146\"\n                        >@babel/preset-env</a\n                      >\n                      来配置。@babel/preset-env\n                      允许我们配置需要支持的目标环境（一般是浏览器范围或 Node.js\n                      版本范围），利用\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-polyfill\"\n                        data-nodeid=\"15150\"\n                        >babel-polyfill</a\n                      >\n                      完成补丁的接入。结合上一讲内容，<strong\n                        data-nodeid=\"15160\"\n                        >@babel/polyfill 其实就是 core-js 和 regenerator-runtime\n                        两个包的结合，@babel/polyfill 源码层面，通过\n                        build-dist.sh 脚本，利用 browserify 进行打包</strong\n                      >，参考<a\n                        href=\"https://github.com/babel/babel/blob/main/packages/babel-polyfill/scripts/build-dist.sh\"\n                        data-nodeid=\"15158\"\n                        >源码</a\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">#!/bin/sh\n</div></li><li><div class=\"code-word\">set -ex\n</div></li><li><div class=\"code-word\">mkdir -p dist\n</div></li><li><div class=\"code-word\">yarn browserify lib/index.js \\\n</div></li><li><div class=\"code-word\">  --insert-global-vars 'global' \\\n</div></li><li><div class=\"code-word\">  --plugin bundle-collapser/plugin \\\n</div></li><li><div class=\"code-word\">  --plugin derequire/plugin \\\n</div></li><li><div class=\"code-word\">  &gt;dist/polyfill.js\n</div></li><li><div class=\"code-word\">yarn uglifyjs dist/polyfill.js \\\n</div></li><li><div class=\"code-word\">  --compress keep_fnames,keep_fargs \\\n</div></li><li><div class=\"code-word\">  --mangle keep_fnames \\\n</div></li><li><div class=\"code-word\">  &gt;dist/polyfill.min.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14817\">\n                      <strong data-nodeid=\"15165\"\n                        >注意：@babel/polyfill 目前已经计划废弃</strong\n                      >，新的 Babel 生态（@babel/preset-env V7.4.0\n                      版本）鼓励开发者直接在代码中引入 core-js 和\n                      regenerator-runtime。但是不管直接导入 core-js 和\n                      regenerator-runtime，还是直接导入 @babel/polyfill\n                      都是引入了全量的 polyfills，@babel/preset-env\n                      如何根据目标适配环境，按需引入业务中所需要的 polyfills\n                      呢？\n                    </p>\n                    <p data-nodeid=\"14818\">\n                      事实上，@babel/preset-env 通过\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-preset-env#targets\"\n                        data-nodeid=\"15169\"\n                        >targets 参数</a\n                      >，按照 browserslist 规范，结 合<a\n                        href=\"https://www.npmjs.com/package/core-js-compat\"\n                        data-nodeid=\"15173\"\n                        >core-js-compat</a\n                      >，筛选出适配环境所需的 polyfills（或\n                      plugins），关键源码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">export <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title\">declare</span><span class=\"hljs-params\">((api, opts)</span> </span>=&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 规范参数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">    bugfixes,\n</div></li><li><div class=\"code-word\">    configPath,\n</div></li><li><div class=\"code-word\">    debug,\n</div></li><li><div class=\"code-word\">    exclude: optionsExclude,\n</div></li><li><div class=\"code-word\">    forceAllTransforms,\n</div></li><li><div class=\"code-word\">    ignoreBrowserslistConfig,\n</div></li><li><div class=\"code-word\">    include: optionsInclude,\n</div></li><li><div class=\"code-word\">    loose,\n</div></li><li><div class=\"code-word\">    modules,\n</div></li><li><div class=\"code-word\">    shippedProposals,\n</div></li><li><div class=\"code-word\">    spec,\n</div></li><li><div class=\"code-word\">    targets: optionsTargets,\n</div></li><li><div class=\"code-word\">    useBuiltIns,\n</div></li><li><div class=\"code-word\">    corejs: { version: corejs, proposals },\n</div></li><li><div class=\"code-word\">    browserslistEnv,\n</div></li><li><div class=\"code-word\">  } = normalizeOptions(opts);\n</div></li><li><div class=\"code-word\">  let hasUglifyTarget = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取对应 targets</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> targets = getTargets(\n</div></li><li><div class=\"code-word\">    (optionsTargets: InputTargets),\n</div></li><li><div class=\"code-word\">    { ignoreBrowserslistConfig, configPath, browserslistEnv },\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> include = transformIncludesAndExcludes(optionsInclude);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> exclude = transformIncludesAndExcludes(optionsExclude);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取需要兼容的内容</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> compatData = getPluginList(shippedProposals, bugfixes);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> modulesPluginNames = getModulesPluginNames({\n</div></li><li><div class=\"code-word\">    modules,\n</div></li><li><div class=\"code-word\">    transformations: moduleTransformations,\n</div></li><li><div class=\"code-word\">    shouldTransformESM: modules !== <span class=\"hljs-string\">\"auto\"</span> || !api.caller?.(supportsStaticESM),\n</div></li><li><div class=\"code-word\">    shouldTransformDynamicImport:\n</div></li><li><div class=\"code-word\">      modules !== <span class=\"hljs-string\">\"auto\"</span> || !api.caller?.(supportsDynamicImport),\n</div></li><li><div class=\"code-word\">    shouldTransformExportNamespaceFrom: !shouldSkipExportNamespaceFrom,\n</div></li><li><div class=\"code-word\">    shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait),\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取目标 plugin 名称</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> pluginNames = filterItems(\n</div></li><li><div class=\"code-word\">    compatData,\n</div></li><li><div class=\"code-word\">    include.plugins,\n</div></li><li><div class=\"code-word\">    exclude.plugins,\n</div></li><li><div class=\"code-word\">    transformTargets,\n</div></li><li><div class=\"code-word\">    modulesPluginNames,\n</div></li><li><div class=\"code-word\">    getOptionSpecificExcludesFor({ loose }),\n</div></li><li><div class=\"code-word\">    pluginSyntaxMap,\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">  removeUnnecessaryItems(pluginNames, overlappingPlugins);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> polyfillPlugins = getPolyfillPlugins({\n</div></li><li><div class=\"code-word\">    useBuiltIns,\n</div></li><li><div class=\"code-word\">    corejs,\n</div></li><li><div class=\"code-word\">    polyfillTargets: targets,\n</div></li><li><div class=\"code-word\">    include: include.builtIns,\n</div></li><li><div class=\"code-word\">    exclude: exclude.builtIns,\n</div></li><li><div class=\"code-word\">    proposals,\n</div></li><li><div class=\"code-word\">    shippedProposals,\n</div></li><li><div class=\"code-word\">    regenerator: pluginNames.has(<span class=\"hljs-string\">\"transform-regenerator\"</span>),\n</div></li><li><div class=\"code-word\">    debug,\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> pluginUseBuiltIns = useBuiltIns !== <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 根据 pluginNames，返回一个 plugins 配置列表</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> plugins = Array.from(pluginNames)\n</div></li><li><div class=\"code-word\">    .map(pluginName =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (\n</div></li><li><div class=\"code-word\">        pluginName === <span class=\"hljs-string\">\"proposal-class-properties\"</span> ||\n</div></li><li><div class=\"code-word\">        pluginName === <span class=\"hljs-string\">\"proposal-private-methods\"</span> ||\n</div></li><li><div class=\"code-word\">        pluginName === <span class=\"hljs-string\">\"proposal-private-property-in-object\"</span>\n</div></li><li><div class=\"code-word\">      ) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> [\n</div></li><li><div class=\"code-word\">          getPlugin(pluginName),\n</div></li><li><div class=\"code-word\">          {\n</div></li><li><div class=\"code-word\">            loose: loose\n</div></li><li><div class=\"code-word\">              ? <span class=\"hljs-string\">\"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error\"</span>\n</div></li><li><div class=\"code-word\">              : <span class=\"hljs-string\">\"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error\"</span>,\n</div></li><li><div class=\"code-word\">          },\n</div></li><li><div class=\"code-word\">        ];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> [\n</div></li><li><div class=\"code-word\">        getPlugin(pluginName),\n</div></li><li><div class=\"code-word\">        { spec, loose, useBuiltIns: pluginUseBuiltIns },\n</div></li><li><div class=\"code-word\">      ];\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">    .concat(polyfillPlugins);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> { plugins };\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14820\">\n                      这部分内容你可以与上一讲“core-js\n                      及垫片理念：设计一个‘最完美’的 Polyfill\n                      方案”相结合，相信你会对前端“按需\n                      polyfill”有一个更加清晰的认知。\n                    </p>\n                    <p data-nodeid=\"14821\">\n                      至于 Babel 家族的其他成员，相信你也一定见过\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-plugin-transform-runtime\"\n                        data-nodeid=\"15179\"\n                        >@babel/plugin-transform-runtime</a\n                      >，它可以<strong data-nodeid=\"15189\"\n                        >重复使用 Babel 注入的 helpers 函数</strong\n                      >，达到<strong data-nodeid=\"15190\">节省代码大小</strong\n                      >的目的。\n                    </p>\n                    <p data-nodeid=\"14822\">比如，对于这样一段简单的代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span></span>{}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14824\">Babel 在编译后，得到：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">_instanceof</span><span class=\"hljs-params\">(left, right)</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (right != <span class=\"hljs-keyword\">null</span> &amp;&amp; typeof Symbol !== <span class=\"hljs-string\">\"undefined\"</span> &amp;&amp;   right[Symbol.hasInstance]) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> !!right[Symbol.hasInstance](left); \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> left <span class=\"hljs-keyword\">instanceof</span> right; \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">_classCallCheck</span><span class=\"hljs-params\">(instance, Constructor)</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!_instanceof(instance, Constructor)) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TypeError(<span class=\"hljs-string\">\"Cannot call a class as a function\"</span>); }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> Person = <span class=\"hljs-function\">function <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  _classCallCheck(<span class=\"hljs-keyword\">this</span>, Person);\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14826\">\n                      其中<code data-backticks=\"1\" data-nodeid=\"15194\"\n                        >_instanceof</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"15196\"\n                        >_classCallCheck</code\n                      >都是 Babel 内置的 helpers 函数。如果每个 class\n                      编译结果都在代码中植入这些 helpers\n                      具体内容，对产出代码体积就会有明显恶化影响。在启用\n                      @babel/plugin-transform-runtime\n                      插件后，上述代码的编译结果可以变为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> _interopRequireDefault = require(<span class=\"hljs-string\">\"@babel/runtime/helpers/interopRequireDefault\"</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> _classCallCheck2 = _interopRequireDefault(require(<span class=\"hljs-string\">\"@babel/runtime/helpers/classCallCheck\"</span>));\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> Person = <span class=\"hljs-function\">function <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  (<span class=\"hljs-number\">0</span>, _classCallCheck2.<span class=\"hljs-keyword\">default</span>)(<span class=\"hljs-keyword\">this</span>, Person);\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14828\">\n                      从上述代码我们可以看到，_classCallCheck\n                      作为模块依赖被引入文件中，基于打包工具的 cache\n                      能力，从而减少了产出代码体积。需要注意的是，观察以上代码，_classCallCheck2\n                      这个 helper 由\n                      <a\n                        href=\"https://babeljs.io/docs/en/babel-runtime\"\n                        data-nodeid=\"15205\"\n                        >@babel/runtime</a\n                      >\n                      给出，这就又由一条线，牵出来了 Babel\n                      家族的另一个包：@babel/runtime。\n                    </p>\n                    <p data-nodeid=\"14829\">\n                      <strong data-nodeid=\"15219\">@babel/runtime</strong>含有\n                      Babel 编译所需的一些运行时 helpers 函数，<strong\n                        data-nodeid=\"15220\"\n                        >供业务代码引入模块化的 Babel helpers 函数</strong\n                      >，同时它提供了\n                      <a\n                        href=\"https://www.npmjs.com/package/regenerator-runtime\"\n                        data-nodeid=\"15217\"\n                        >regenerator-runtime</a\n                      >，对 generator 和 async 函数进行编译降级。\n                    </p>\n                    <p data-nodeid=\"14830\">总结一下：</p>\n                    <ul data-nodeid=\"14831\">\n                      <li data-nodeid=\"14832\">\n                        <p data-nodeid=\"14833\">\n                          @babel/plugin-transform-runtime 需要和 @babel/runtime\n                          配合使用；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14834\">\n                        <p data-nodeid=\"14835\">\n                          @babel/plugin-transform-runtime 用于编译时，作为\n                          devDependencies 使用；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14836\">\n                        <p data-nodeid=\"14837\">\n                          @babel/plugin-transform-runtime 将业务代码编译，引用\n                          @babel/runtime 提供的\n                          helpers，达到缩减编译产出体积的目的；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14838\">\n                        <p data-nodeid=\"14839\">\n                          @babel/runtime 用于运行时，作为 dependencies 使用。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"14840\">\n                      另外，@babel/plugin-transform-runtime 和 @babel/runtime\n                      结合还有一个作用：<strong data-nodeid=\"15231\"\n                        >它除了可以对产出代码瘦身以外，还能避免污染全局作用域</strong\n                      >。比如一个生成器函数：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">function* foo() {}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14842\">正常经过 Babel 编译后，产出：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> _marked = [foo].map(regeneratorRuntime.mark);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> regeneratorRuntime.wrap(\n</div></li><li><div class=\"code-word\">    function foo$(_context) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">switch</span> ((_context.prev = _context.next)) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"end\"</span>:\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> _context.stop();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    _marked[<span class=\"hljs-number\">0</span>],\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14844\">\n                      其中 regeneratorRuntime 需要是一个全局变量，<strong\n                        data-nodeid=\"15238\"\n                        >上述编译后代码污染了全局空间</strong\n                      >。结合 @babel/plugin-transform-runtime 和\n                      @babel/runtime，可以将上述代码转换为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 特别命名为 _regenerator 和 _regenerator2,避免污染命名空间</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> _regenerator = require(<span class=\"hljs-string\">\"@babel/runtime/regenerator\"</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> _regenerator2 = _interopRequireDefault(_regenerator);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">_interopRequireDefault</span><span class=\"hljs-params\">(obj)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class=\"hljs-keyword\">default</span>: obj };\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> _marked = [foo].map(_regenerator2.<span class=\"hljs-keyword\">default</span>.mark);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 编译 await 为自执行的 generator 模式</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> _regenerator2.<span class=\"hljs-keyword\">default</span>.wrap(\n</div></li><li><div class=\"code-word\">    function foo$(_context) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">switch</span> ((_context.prev = _context.next)) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"end\"</span>:\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> _context.stop();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    _marked[<span class=\"hljs-number\">0</span>],\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14846\">\n                      此时，regenerator 由\n                      <code data-backticks=\"1\" data-nodeid=\"15240\"\n                        >require(\"@babel/runtime/regenerator\")</code\n                      >导出，且导出结果被赋值为一个文件作用域内的 _regenerator\n                      变量，从而避免了污染。\n                    </p>\n                    <p data-nodeid=\"14847\">\n                      理清了这层关系，相信你在使用 Babel\n                      家族成员时，能够更准确地从原理层面理解各项配置功能。\n                    </p>\n                    <p data-nodeid=\"14848\">\n                      最后，我们再梳理其他几个重要的 Babel\n                      家族成员及其能力和实现原理。\n                    </p>\n                    <ul data-nodeid=\"14849\">\n                      <li data-nodeid=\"14850\">\n                        <p data-nodeid=\"14851\">\n                          <a\n                            href=\"https://babeljs.io/docs/en/plugins\"\n                            data-nodeid=\"15248\"\n                            >@babel/plugin</a\n                          >是 Babel 插件集合。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14852\">\n                        <p data-nodeid=\"14853\">\n                          <strong data-nodeid=\"15256\"\n                            >@babel/plugin-syntax-* 是 Babel 的语法插件</strong\n                          >。它的作用是扩展 @babel/parser\n                          的一些能力，提供给工程使用。比如\n                          @babel/plugin-syntax-top-level-await 插件，提供了使用\n                          top level await 新特性的能力。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14854\">\n                        <p data-nodeid=\"14855\">\n                          <strong data-nodeid=\"15263\"\n                            >@babel/plugin-proposal-*\n                            用于编译转换在提议阶段的语言特性</strong\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14856\">\n                        <p data-nodeid=\"14857\">\n                          <strong data-nodeid=\"15270\"\n                            >@babel/plugin-transform-* 是 Babel\n                            的转换插件</strong\n                          >。比如简单的\n                          @babel/plugin-transform-react-display-name\n                          插件，可以自动适配 React 组件 DisplayName，比如：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> foo = React.createClass({}); <span class=\"hljs-comment\">// React &lt;= 15</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> bar = createReactClass({});  <span class=\"hljs-comment\">// React 16+</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14859\">\n                      上述调用，经过\n                      @babel/plugin-transform-react-display-name，可以被编译为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> foo = React.createClass({\n</div></li><li><div class=\"code-word\">  displayName: <span class=\"hljs-string\">\"foo\"</span>\n</div></li><li><div class=\"code-word\">}); <span class=\"hljs-comment\">// React &lt;= 15</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> bar = createReactClass({\n</div></li><li><div class=\"code-word\">  displayName: <span class=\"hljs-string\">\"bar\"</span>\n</div></li><li><div class=\"code-word\">}); <span class=\"hljs-comment\">// React 16+</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"14861\">\n                      <li data-nodeid=\"14862\">\n                        <p data-nodeid=\"14863\">\n                          <a\n                            href=\"https://babeljs.io/docs/en/babel-template\"\n                            data-nodeid=\"15274\"\n                            >@babel/template</a\n                          >\n                          封装了基于 AST 的模板能力，可以将字符串代码转换为\n                          AST。比如在生成一些辅助代码（helper）时会用到这个库。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14864\">\n                        <p data-nodeid=\"14865\">\n                          @<a\n                            href=\"https://babeljs.io/docs/en/babel-node\"\n                            data-nodeid=\"15279\"\n                            >babel/node</a\n                          >\n                          类似 Node.js Cli，@babel/node\n                          提供在命令行执行高级语法的环境，也就是说，相比于\n                          Node.js Cli，它加入了对更多特性的支持。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"14866\">\n                        <p data-nodeid=\"14867\">\n                          <a\n                            href=\"https://babeljs.io/docs/en/babel-register\"\n                            data-nodeid=\"15283\"\n                            >@babel/register</a\n                          >\n                          实际上是为 require 增加了一个 hook，使用之后，所有被\n                          Node.js 引用的文件都会先被 Babel 转码。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"14868\">\n                      <strong data-nodeid=\"15289\">这里请注意</strong>@babel/node\n                      和\n                      @babel/register，都是在运行时进行编译转换，因此运行时性能上会有影响。在生产环境中，我们一般不直接使用。\n                    </p>\n                    <p data-nodeid=\"14869\">\n                      上述内容看似枯燥，涉及了一般对于业务开发者黑盒的编译产出、源码层面的实现原理、各个包直接的分工协调和组织，可能对于你来说，做到真正理解并非一夕之功。接下来，我们从更加宏观地角度来加深认识。\n                    </p>\n                    <h3 data-nodeid=\"14870\">\n                      Babel 工程生态架构设计和分层理念\n                    </h3>\n                    <p data-nodeid=\"14871\">\n                      了解了上述内容，也许你会想问，在平时开发中出镜率极高的\n                      babel-loader 怎么没有看到？事实上，Babel\n                      的生态是内聚的，也是开放的。我们通过 Babel\n                      对代码的编译过程，可以从微观上缩小为前端基建的一个环节，这个环节融入整个工程中，也需要和其他环节相互配合。而\n                      <a\n                        href=\"https://github.com/babel/babel-loader\"\n                        data-nodeid=\"15295\"\n                        >babel-loader</a\n                      >\n                      <strong data-nodeid=\"15301\"\n                        >就是 Babel 结合 Webpack，融入整个基建环节的例子</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"14872\">\n                      在 Webpack 编译生命周期中，babel-loader 作为一个 Webpack\n                      loader，承担着文件编译职责。我们暂且将 babel-loader 放到\n                      Babel 家族中，先来看看下面这张“全家福”。\n                    </p>\n                    <p data-nodeid=\"14873\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/04/5A/Cip5yF_tojyAfvQeAAMW8bbGBAY698.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"15305\"\n                      />\n                    </p>\n                    <div data-nodeid=\"14874\">\n                      <p style=\"text-align: center\">Babel 家族分层模型图</p>\n                    </div>\n                    <p data-nodeid=\"14875\">\n                      如上图所示，Babel 生态基本按照：辅助层 → 基础层 → 胶水层 →\n                      应用层，四级结构完成。其中部分环节角色的界定有些模糊，比如\n                      @babel/highlight 也可以作为应用层工具出现。\n                    </p>\n                    <p data-nodeid=\"14876\">\n                      <strong data-nodeid=\"15315\"\n                        >基础层提供了基础的编译能力</strong\n                      >，完成分词、解析\n                      AST、生成产出代码的工作。基础层中，我们将一些抽象能力下沉为辅助层，这些抽象能力被基础层使用。同时，在基础层之上，我们构建了如\n                      @babel/preset-env\n                      等预设/插件能力，这些类似“胶水”的包，完成了代码编译降级所需补丁的构建、运行时逻辑的模块化抽象等工作。在<strong\n                        data-nodeid=\"15316\"\n                        >最上层，Babel 生态提供了终端命令行</strong\n                      >、Webpack loader、浏览器端编译等应用级别的能力。\n                    </p>\n                    <p data-nodeid=\"14877\">\n                      分层的意义在于应用，下面我们从一个应用场景来具体分析，看看\n                      Babel 工程化设计能够给我们带来什么样的启示。\n                    </p>\n                    <h4 data-nodeid=\"14878\">\n                      从 @babel/eslint-parser 看 Babel 工程化启示\n                    </h4>\n                    <p data-nodeid=\"14879\">\n                      相信你一定认识\n                      <a\n                        href=\"https://github.com/eslint/eslint\"\n                        data-nodeid=\"15322\"\n                        >ESLint</a\n                      >，它可以用来帮助我们<strong data-nodeid=\"15328\"\n                        >审查 ECMAScript/JavaScript 代码</strong\n                      >，其原理也是基于 AST 语法分析，进行规则校验。那这和我们的\n                      Babel 有什么关联呢？\n                    </p>\n                    <p data-nodeid=\"14880\">\n                      试想一下，如果我们的业务代码使用了较多的试验性 ECMAScript\n                      语言特性，那么 ESLint\n                      如何识别这些新的语言特性，做到新特性的代码检查呢？\n                    </p>\n                    <p data-nodeid=\"14881\">\n                      事实上，<strong data-nodeid=\"15339\"\n                        >ESLint 的解析工具只支持最终进入 ECMAScript\n                        语言标准的特性</strong\n                      >，如果想对试验性特性或者 Flow/TypeScript\n                      进行代码检查，ESLint 提供了更换 parser 的能力。而\n                      <a\n                        href=\"https://github.com/babel/babel/tree/main/eslint/babel-eslint-parser\"\n                        data-nodeid=\"15337\"\n                        >@babel/eslint-parser</a\n                      >\n                      就是配合 ESLint 检验合法 Babel 代码的解析器。\n                    </p>\n                    <p data-nodeid=\"14882\">\n                      实现原理也很简单，ESLint 支持\n                      <a\n                        href=\"https://eslint.org/docs/developer-guide/working-with-custom-parsers\"\n                        data-nodeid=\"15343\"\n                        >custom-parser</a\n                      >，它允许我们使用自定义的第三方编译器，比如下面是一个使用了\n                      espree 作为一个 custom-parser 的场景：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"parser\"</span>: <span class=\"hljs-string\">\"./path/to/awesome-custom-parser.js\"</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> espree = require(<span class=\"hljs-string\">\"espree\"</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// awesome-custom-parser.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">exports</span>.parseForESLint = function(code, options) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        ast: espree.parse(code, options),\n</div></li><li><div class=\"code-word\">        services: {\n</div></li><li><div class=\"code-word\">            foo: function() {\n</div></li><li><div class=\"code-word\">                console.log(<span class=\"hljs-string\">\"foo\"</span>);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        },\n</div></li><li><div class=\"code-word\">        scopeManager: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">        visitorKeys: <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">    };\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14884\">\n                      @babel/eslint-parser<a\n                        href=\"https://github.com/babel/babel/blob/main/eslint/babel-eslint-parser/src/index.js\"\n                        data-nodeid=\"15348\"\n                        >源码</a\n                      >的实现，保留了相同的模板，它通过自定的 parser，最终返回了\n                      ESLint 所需要的 AST 内容，根据具体的 ESLint rules\n                      进行代码审查：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"> <span class=\"hljs-function\">export function <span class=\"hljs-title\">parseForESLint</span><span class=\"hljs-params\">(code, options = {})</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> normalizedOptions = normalizeESLintConfig(options);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> ast = baseParse(code, normalizedOptions);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> scopeManager = analyzeScope(ast, normalizedOptions);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> { ast, scopeManager, visitorKeys };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"14886\">\n                      上述代码中，ast 是\n                      <a\n                        href=\"https://github.com/estree/estree\"\n                        data-nodeid=\"15353\"\n                        >estree</a\n                      >\n                      兼容的格式，可以被 ESLint 理解。<strong\n                        data-nodeid=\"15359\"\n                        >visitor Keys 定义了自定义的编译 AST 能力，ScopeManager\n                        定义了新（试验）特性自定义的作用域</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"14887\">\n                      由此可见，Babel\n                      生态和前端工程中的各个环节都是打通开放的。它<strong\n                        data-nodeid=\"15365\"\n                        >可以以 babel-loader 的形式和 Webpack 协作，也可以以\n                        @babel/eslint-parser 的方式和 ESLint 合作</strong\n                      >。现代化的前端工程是一环扣一环的，作为工程链上的任意一环，插件化能力、协作能力将是设计的重点和关键。\n                    </p>\n                    <h3 data-nodeid=\"14888\">总结</h3>\n                    <p data-nodeid=\"14889\">\n                      作为前端开发者，你可能会被如何配置 Babel、Webpack\n                      这些工具所困扰，出现“配置到自己的项目中，就各种报错”的问题。\n                    </p>\n                    <p data-nodeid=\"14890\">\n                      此时，你可能花费了一天的时间，通过 Google\n                      找到了最终的配置解法，但是解决之道却没搞清楚，得过且过，今后依然被类似的困境袭扰；你可能看过一些关于\n                      Babel 插件和原理的文章，自以为掌握了\n                      AST、窥探了编译，但真正手写一个分词器 Tokenizer\n                      就一头雾水。\n                    </p>\n                    <p data-nodeid=\"14891\">\n                      我们需要对 Babel\n                      进行系统学习，学习目的是了解其工程化设计，方便我们在前端基建的过程中做到“最佳配置实践”，做到“不再被编译报错”所困扰。\n                    </p>\n                    <p data-nodeid=\"14892\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/04/5C/CgpVE1_tolmAct9gAAFdbBBSMZI815.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"15372\"\n                      />\n                    </p>\n                    <p data-nodeid=\"14893\" class=\"\">\n                      希望本讲能对大家的学习和工作带来一些启发，更多相关内容我们会在“从实战出发，从\n                      0 到 1 构建一个符合标准的公共库”“如何理解 AST\n                      实现和编译原理？”等小节中继续探索！\n                    </p>\n            "}