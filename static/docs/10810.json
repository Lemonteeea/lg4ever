{"title":"07 | 计算属性：计算属性比普通函数好在哪里？","context":"\n                    <p data-nodeid=\"3992\" class=\"\">\n                      上一节课，我们学习了响应式的实现原理，这节课我们将学习一个非常常用的响应式\n                      API——<strong data-nodeid=\"4071\">计算属性</strong>。\n                    </p>\n                    <p data-nodeid=\"3993\">\n                      计算属性是 Vue.js 开发中一个非常实用的 API\n                      ，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。当依赖发生变化时，计算属性可以自动重新计算获取新值，所以使用起来非常方便。\n                    </p>\n                    <p data-nodeid=\"3994\">\n                      在 Vue.js 2.x\n                      中，相信你对计算属性的应用已经如数家珍了，我们可以在组件对象中定义\n                      computed 属性。到了 Vue.js 3.0 ，虽然也可以在组件中沿用\n                      Vue.js 2.x 的使用方式，但是我们也可以单独使用计算属性\n                      API。\n                    </p>\n                    <p data-nodeid=\"3995\">\n                      计算属性本质上还是对依赖的计算，那么为什么我们不直接用函数呢？在\n                      Vue.js 3.0 中计算属性的 API\n                      又是如何实现呢？接下来，就请你带着这些疑问，随我一起深入其实现原理的学习吧。\n                    </p>\n                    <h3 data-nodeid=\"3996\">计算属性 API： computed</h3>\n                    <p data-nodeid=\"3997\">\n                      Vue.js 3.0 提供了一个 computed 函数作为计算属性\n                      API，我们先来看看它是如何使用的。\n                    </p>\n                    <p data-nodeid=\"3998\">我们举个简单的例子：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">1</span>) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> plusOne = computed(() =&gt; count.value + <span class=\"hljs-number\">1</span>) \n</div></li><li><div class=\"code-word\">console.log(plusOne.value) <span class=\"hljs-comment\">// 2 </span>\n</div></li><li><div class=\"code-word\">plusOne.value++ <span class=\"hljs-comment\">// error </span>\n</div></li><li><div class=\"code-word\">count.value++ \n</div></li><li><div class=\"code-word\">console.log(plusOne.value) <span class=\"hljs-comment\">// 3</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4000\">\n                      从代码中可以看到，我们先使用 ref API 创建了一个响应式对象\n                      count，然后使用 computed API 创建了另一个响应式对象\n                      plusOne，它的值是 count.value + 1，当我们修改 count.value\n                      的时候， plusOne.value 就会自动发生变化。\n                    </p>\n                    <p data-nodeid=\"4001\">\n                      注意，这里我们直接修改 plusOne.value\n                      会报一个错误，这是因为如果我们传递给 computed\n                      的是一个函数，那么这就是一个 getter\n                      函数，我们只能获取它的值，而不能直接修改它。\n                    </p>\n                    <p data-nodeid=\"4002\">\n                      在 getter\n                      函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个响应式对象，就是计算属性的依赖。\n                    </p>\n                    <p data-nodeid=\"4003\">\n                      当然，有时候我们也希望能够直接修改 computed\n                      的返回值，那么我们可以给 computed 传入一个对象：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">1</span>) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> plusOne = computed({ \n</div></li><li><div class=\"code-word\">  get: () =&gt; count.value + <span class=\"hljs-number\">1</span>, \n</div></li><li><div class=\"code-word\">  set: val =&gt; { \n</div></li><li><div class=\"code-word\">    count.value = val - <span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\">plusOne.value = <span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\">console.log(count.value) <span class=\"hljs-comment\">// 0</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4005\">\n                      在这个例子中，结合上述代码可以看到，我们给 computed\n                      函数传入了一个拥有 getter 函数和 setter 函数的对象，getter\n                      函数和之前一样，还是返回 count.value + 1；而 setter\n                      函数，请注意，这里我们修改 plusOne.value 的值就会触发\n                      setter 函数，其实 setter\n                      函数内部实际上会根据传入的参数修改计算属性的依赖值\n                      count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍\n                      getter，所以这样获取的值也就发生了变化。\n                    </p>\n                    <p data-nodeid=\"4006\">\n                      好了，我们现在已经知道了 computed API\n                      的两种使用方式了，接下来就看看它是怎样实现的：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">computed</span><span class=\"hljs-params\">(getterOrOptions)</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// getter 函数 </span>\n</div></li><li><div class=\"code-word\">  let getter \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// setter 函数 </span>\n</div></li><li><div class=\"code-word\">  let setter \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 标准化参数 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (isFunction(getterOrOptions)) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 表面传入的是 getter 函数，不能修改计算属性的值 </span>\n</div></li><li><div class=\"code-word\">    getter = getterOrOptions \n</div></li><li><div class=\"code-word\">    setter = (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) \n</div></li><li><div class=\"code-word\">      ? () =&gt; { \n</div></li><li><div class=\"code-word\">        console.warn(<span class=\"hljs-string\">'Write operation failed: computed value is readonly'</span>) \n</div></li><li><div class=\"code-word\">      } \n</div></li><li><div class=\"code-word\">      : NOOP \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">    getter = getterOrOptions.get \n</div></li><li><div class=\"code-word\">    setter = getterOrOptions.set \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 数据是否脏的 </span>\n</div></li><li><div class=\"code-word\">  let dirty = <span class=\"hljs-keyword\">true</span> \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 计算结果 </span>\n</div></li><li><div class=\"code-word\">  let value \n</div></li><li><div class=\"code-word\">  let computed \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建副作用函数 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> runner = effect(getter, { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 延时执行 </span>\n</div></li><li><div class=\"code-word\">    lazy: <span class=\"hljs-keyword\">true</span>, \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 </span>\n</div></li><li><div class=\"code-word\">    computed: <span class=\"hljs-keyword\">true</span>, \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 调度执行的实现 </span>\n</div></li><li><div class=\"code-word\">    scheduler: () =&gt; { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (!dirty) { \n</div></li><li><div class=\"code-word\">        dirty = <span class=\"hljs-keyword\">true</span> \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 派发通知，通知运行访问该计算属性的 activeEffect </span>\n</div></li><li><div class=\"code-word\">        trigger(computed, <span class=\"hljs-string\">\"set\"</span> <span class=\"hljs-comment\">/* SET */</span>, <span class=\"hljs-string\">'value'</span>) \n</div></li><li><div class=\"code-word\">      } \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  }) \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建 computed 对象 </span>\n</div></li><li><div class=\"code-word\">  computed = { \n</div></li><li><div class=\"code-word\">    __v_isRef: <span class=\"hljs-keyword\">true</span>, \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 暴露 effect 对象以便计算属性可以停止计算 </span>\n</div></li><li><div class=\"code-word\">    effect: runner, \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">get <span class=\"hljs-title\">value</span><span class=\"hljs-params\">()</span> </span>{ \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 计算属性的 getter </span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (dirty) { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 只有数据为脏的时候才会重新计算 </span>\n</div></li><li><div class=\"code-word\">        value = runner() \n</div></li><li><div class=\"code-word\">        dirty = <span class=\"hljs-keyword\">false</span> \n</div></li><li><div class=\"code-word\">      } \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 依赖收集，收集运行访问该计算属性的 activeEffect </span>\n</div></li><li><div class=\"code-word\">      track(computed, <span class=\"hljs-string\">\"get\"</span> <span class=\"hljs-comment\">/* GET */</span>, <span class=\"hljs-string\">'value'</span>) \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> value \n</div></li><li><div class=\"code-word\">    }, \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">set <span class=\"hljs-title\">value</span><span class=\"hljs-params\">(newValue)</span> </span>{ \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 计算属性的 setter </span>\n</div></li><li><div class=\"code-word\">      setter(newValue) \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> computed \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4008\">\n                      从代码中可以看到，computed\n                      函数的流程主要做了三件事情：标准化参数，创建副作用函数和创建\n                      computed 对象。我们来详细分析一下这几个步骤。\n                    </p>\n                    <p data-nodeid=\"4009\">\n                      首先是<strong data-nodeid=\"4090\">标准化参数</strong\n                      >。computed 函数接受两种类型的参数，一个是 getter\n                      函数，一个是拥有 getter 和 setter\n                      函数的对象，通过判断参数的类型，我们初始化了函数内部定义的\n                      getter 和 setter 函数。\n                    </p>\n                    <p data-nodeid=\"4010\">\n                      接着是<strong data-nodeid=\"4096\"\n                        >创建副作用函数 runner</strong\n                      >。computed 内部通过 effect 创建了一个副作用函数，它是对\n                      getter\n                      函数做的一层封装，另外我们这里要注意第二个参数，也就是\n                      effect 函数的配置对象。其中 lazy 为 true 表示 effect\n                      函数返回的 runner 并不会立即执行；computed 为 true\n                      用于表示这是一个 computed effect，用于 trigger\n                      阶段的优先级排序，我们稍后会分析；scheduler\n                      表示它的调度运行的方式，我们也稍后分析。\n                    </p>\n                    <p data-nodeid=\"4011\">\n                      最后是<strong data-nodeid=\"4102\"\n                        >创建 computed 对象并返回</strong\n                      >，这个对象也拥有 getter 和 setter 函数。当 computed\n                      对象被访问的时候会触发 getter，然后会判断是否\n                      dirty，如果是就执行 runner，然后做依赖收集；当我们直接设置\n                      computed 对象时会触发 setter，即执行 computed\n                      函数内部定义的 setter 函数。\n                    </p>\n                    <h4 data-nodeid=\"4012\">计算属性的运行机制</h4>\n                    <p data-nodeid=\"4013\">\n                      computed\n                      函数的逻辑会有一点绕，不过不要紧，我们可以结合一个应用\n                      computed\n                      计算属性的例子，来理解整个计算属性的运行机制。分析之前我们需要记住\n                      computed 内部两个重要的变量，第一个 dirty\n                      表示一个计算属性的值是否是“脏的”，用来判断需不需要重新计算，第二个\n                      value 表示计算属性每次计算后的结果。\n                    </p>\n                    <p data-nodeid=\"4014\">现在，我们来看这个示例：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt; \n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span> \n</span></div></li><li><div class=\"code-word\">    {{ plusOne }} \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> \n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"plus\"</span>&gt;</span>plus<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span> \n</div></li><li><div class=\"code-word\">&lt;/template&gt; \n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"> \n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> { ref, computed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span> \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> { \n</div></li><li><div class=\"code-word\">    setup() { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>) \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> plusOne = computed(<span class=\"hljs-function\">() =&gt;</span> { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> count.value + <span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\">      }) \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">plus</span>(<span class=\"hljs-params\"></span>) </span>{ \n</div></li><li><div class=\"code-word\">        count.value++ \n</div></li><li><div class=\"code-word\">      } \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> { \n</div></li><li><div class=\"code-word\">        plusOne, \n</div></li><li><div class=\"code-word\">        plus \n</div></li><li><div class=\"code-word\">      } \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4016\">\n                      可以看到，在这个例子中我们利用 computed API\n                      创建了计算属性对象 plusOne，它传入的是一个 getter\n                      函数，为了和后面计算属性对象的 getter\n                      函数区分，我们把它称作 computed\n                      getter。另外，组件模板中引用了 plusOne 变量和 plus 函数。\n                    </p>\n                    <p data-nodeid=\"4017\">\n                      组件渲染阶段会访问 plusOne，也就触发了 plusOne 对象的\n                      getter 函数：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">get <span class=\"hljs-title\">value</span><span class=\"hljs-params\">()</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 计算属性的 getter </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (dirty) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 只有数据为脏的时候才会重新计算 </span>\n</div></li><li><div class=\"code-word\">    value = runner() \n</div></li><li><div class=\"code-word\">    dirty = <span class=\"hljs-keyword\">false</span> \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 依赖收集，收集运行访问该计算属性的 activeEffect </span>\n</div></li><li><div class=\"code-word\">  track(computed, <span class=\"hljs-string\">\"get\"</span> <span class=\"hljs-comment\">/* GET */</span>, <span class=\"hljs-string\">'value'</span>) \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> value \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4019\">\n                      由于默认 dirty 是 true，所以这个时候会执行 runner\n                      函数，并进一步执行 computed getter，也就是 count.value +\n                      1，因为访问了 count 的值，并且由于 count\n                      也是一个响应式对象，所以就会触发 count\n                      对象的依赖收集过程。\n                    </p>\n                    <p data-nodeid=\"4020\">\n                      请注意，由于是在 runner 执行的时候访问\n                      count，所以这个时候的 activeEffect 是 runner 函数。runner\n                      函数执行完毕，会把 dirty 设置为 false，并进一步执行\n                      track（computed,\"get\",'value') 函数做依赖收集，这个时候\n                      runner 已经执行完了，所以 activeEffect\n                      是组件副作用渲染函数。\n                    </p>\n                    <p data-nodeid=\"4021\">\n                      所以你要特别注意这是两个依赖收集过程：对于 plusOne\n                      来说，它收集的依赖是组件副作用渲染函数；对于 count\n                      来说，它收集的依赖是 plusOne 内部的 runner 函数。\n                    </p>\n                    <p data-nodeid=\"4022\">\n                      然后当我们点击按钮的时候，会执行 plus 函数，函数内部通过\n                      count.value++ 修改 count\n                      的值，并派发通知。请注意，这里不是直接调用 runner\n                      函数，而是把 runner 作为参数去执行 scheduler\n                      函数。我们来回顾一下 trigger 函数内部对于 effect\n                      函数的执行方式:\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> run = (effect) =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 调度执行 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (effect.options.scheduler) { \n</div></li><li><div class=\"code-word\">    effect.options.scheduler(effect) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 直接运行 </span>\n</div></li><li><div class=\"code-word\">    effect() \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4024\">\n                      computed API 内部创建副作用函数时，已经配置了 scheduler\n                      函数，如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">scheduler: () =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!dirty) { \n</div></li><li><div class=\"code-word\">    dirty = <span class=\"hljs-keyword\">true</span> \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 派发通知，通知运行访问该计算属性的 activeEffect </span>\n</div></li><li><div class=\"code-word\">    trigger(computed, <span class=\"hljs-string\">\"set\"</span> <span class=\"hljs-comment\">/* SET */</span>, <span class=\"hljs-string\">'value'</span>) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4026\">\n                      它并没有对计算属性求新值，而仅仅是把 dirty 设置为\n                      true，再执行 trigger(computed, \"set\" ,\n                      'value')，去通知执行 plusOne\n                      依赖的组件渲染副作用函数，即触发组件的重新渲染。\n                    </p>\n                    <p data-nodeid=\"4027\">\n                      在组件重新渲染的时候，会再次访问 plusOne，我们发现这个时候\n                      dirty 为 true，然后会再次执行 computed\n                      getter，此时才会执行 count.value + 1\n                      求得新值。这就是虽然组件没有直接访问 count，但是当我们修改\n                      count 的值的时候，组件仍然会重新渲染的原因。\n                    </p>\n                    <p data-nodeid=\"4028\">\n                      为了更加直观展示上述过程，我画了一张图：\n                    </p>\n                    <p data-nodeid=\"4029\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/3C/6A/Ciqc1F8nv6SAMiYhAAJ4vcrA7pg591.png\"\n                        alt=\"1.png\"\n                        data-nodeid=\"4134\"\n                      />\n                    </p>\n                    <p data-nodeid=\"4030\">\n                      通过以上分析，我们可以看出 computed 计算属性有两个特点：\n                    </p>\n                    <ol data-nodeid=\"4031\">\n                      <li data-nodeid=\"4032\">\n                        <p data-nodeid=\"4033\">\n                          <strong data-nodeid=\"4140\">延时计算</strong\n                          >，只有当我们访问计算属性的时候，它才会真正运行\n                          computed getter 函数计算；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"4034\">\n                        <p data-nodeid=\"4035\">\n                          <strong data-nodeid=\"4145\">缓存</strong\n                          >，它的内部会缓存上次的计算结果 value，而且只有 dirty\n                          为 true 时才会重新计算。如果访问计算属性时 dirty 为\n                          false，那么直接返回这个 value。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"4036\">\n                      现在，我们就可以回答开头提的问题了。和单纯使用普通函数相比，计算属性的优势是：<strong\n                        data-nodeid=\"4155\"\n                        >只要依赖不变化</strong\n                      >，<strong data-nodeid=\"4156\"\n                        >就可以使用缓存的 value\n                        而不用每次在渲染组件的时候都执行函数去计算</strong\n                      >，这是典型的空间换时间的优化思想。\n                    </p>\n                    <h4 data-nodeid=\"4037\">嵌套计算属性</h4>\n                    <p data-nodeid=\"4038\">\n                      计算属性也支持嵌套，我们可以针对上述例子做个小修改，即不在渲染函数中访问\n                      plusOne，而在另一个计算属性中访问：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> plusOne = computed(() =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> count.value + <span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> plusTwo = computed(() =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> plusOne.value + <span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\">console.log(plusTwo.value)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4040\">\n                      从代码中可以看到，当我们访问 plusTwo\n                      的时候，过程和前面都差不多，同样也是两个依赖收集的过程。对于\n                      plusOne 来说，它收集的依赖是 plusTwo 内部的 runner\n                      函数；对于 count 来说，它收集的依赖是 plusOne 内部的\n                      runner 函数。\n                    </p>\n                    <p data-nodeid=\"4041\">\n                      接着当我们修改 count 的值时，它会派发通知，先运行 plusOne\n                      内部的 scheduler 函数，把 plusOne 内部的 dirty 变为\n                      true，然后执行 trigger 函数再次派发通知，接着运行 plusTwo\n                      内部的 scheduler 函数，把 plusTwo 内部的 dirty 设置为\n                      true。\n                    </p>\n                    <p data-nodeid=\"4042\">\n                      然后当我们再次访问 plusTwo 的值时，发现 dirty 为\n                      true，就会执行 plusTwo 的 computed getter 函数去执行\n                      plusOne.value + 1，进而执行 plusOne 的 computed gette 即\n                      count.value + 1 + 1，求得最终新值 2。\n                    </p>\n                    <p data-nodeid=\"4043\">\n                      得益于 computed\n                      这种巧妙的设计，无论嵌套多少层计算属性都可以正常工作。\n                    </p>\n                    <h4 data-nodeid=\"4044\">计算属性的执行顺序</h4>\n                    <p data-nodeid=\"4045\">\n                      我们曾提到计算属性内部创建副作用函数的时候会配置 computed\n                      为 true，标识这是一个 computed effect，用于在 trigger\n                      阶段的优先级排序。我们来回顾一下 trigger 函数执行 effects\n                      的过程：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> add = (effectsToAdd) =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (effectsToAdd) { \n</div></li><li><div class=\"code-word\">    effectsToAdd.forEach(effect =&gt; { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (effect !== activeEffect || !shouldTrack) { \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (effect.options.computed) { \n</div></li><li><div class=\"code-word\">          computedRunners.add(effect) \n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">          effects.add(effect) \n</div></li><li><div class=\"code-word\">        } \n</div></li><li><div class=\"code-word\">      } \n</div></li><li><div class=\"code-word\">    }) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> run = (effect) =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (effect.options.scheduler) { \n</div></li><li><div class=\"code-word\">    effect.options.scheduler(effect) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">    effect() \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\">computedRunners.forEach(run) \n</div></li><li><div class=\"code-word\">effects.forEach(run)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4047\">\n                      在上一节课分析 trigger\n                      函数的时候，为了方便你理解主干逻辑，我省略了\n                      computedRunners 的分支逻辑。实际上，在添加待运行的 effects\n                      的时候，我们会判断每一个 effect 是不是一个 computed\n                      effect，如果是的话会添加到 computedRunners\n                      中，在后面运行的时候会优先执行\n                      computedRunners，然后再执行普通的 effects。\n                    </p>\n                    <p data-nodeid=\"4048\">\n                      那么为什么要这么设计呢？其实是考虑到了一些特殊场景，我们通过一个示例来说明：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { ref, computed } from <span class=\"hljs-string\">'vue'</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { effect } from <span class=\"hljs-string\">'@vue/reactivity'</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> plusOne = computed(() =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> count.value + <span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\">effect(() =&gt; { \n</div></li><li><div class=\"code-word\">  console.log(plusOne.value + count.value) \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">plus</span><span class=\"hljs-params\">()</span> </span>{ \n</div></li><li><div class=\"code-word\">  count.value++ \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\">plus()\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4050\">这个示例运行后的结果输出：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-number\">3</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-number\">3</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4052\">\n                      在执行 effect 函数时运行 console.log(plusOne.value +\n                      count.value)，所以第一次输出 1，此时 count.value 是\n                      0，plusOne.value 是 1。\n                    </p>\n                    <p data-nodeid=\"4053\">\n                      后面连续输出两次 3 是因为， plusOne 和 count\n                      的依赖都是这个 effect 函数，所以当我们执行 plus 函数修改\n                      count 的值时，会触发并执行这个 effect 函数，因为 plusOne\n                      的 runner 也是 count 的依赖，count 值修改也会执行 plusOne\n                      的 runner，也就会再次执行 plusOne 的依赖即 effect\n                      函数，因此会输出两次。\n                    </p>\n                    <p data-nodeid=\"4054\">\n                      那么为什么两次都输出 3 呢？这就跟先执行 computed runner\n                      有关。首先，由于 plusOne 的 runner 和 effect 都是 count\n                      的依赖，当我们修改 count 值的时候， plusOne 的 runner 和\n                      effect 都会执行，那么此时执行顺序就很重要了。\n                    </p>\n                    <p data-nodeid=\"6913\" class=\"\">\n                      这里先执行 plusOne 的 runner，把 plusOne 的 dirty 设置为\n                      true，然后通知它的依赖 effect 执行 plusOne.value +\n                      count.value。这个时候，由于 dirty 为 true，就会再次执行\n                      plusOne 的 getter 计算新值，拿到了新值 2， 再加上 1 就得到\n                      3。执行完 plusOne 的 runner 以及依赖更新之后，再去执行\n                      count 的普通effect 依赖，从而去执行 plusOne.value +\n                      count.value，这个时候 plusOne dirty 为 false，\n                      直接返回上次的计算结果 2，然后再加 1 就又得到 3。\n                    </p>\n\n                    <p data-nodeid=\"4056\">\n                      如果我们把 computed runner 和 effect\n                      的执行顺序换一下会怎样呢？我来告诉你，会输出如下结果：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-number\">2</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-number\">3</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"4058\">\n                      第一次输出 1\n                      很好理解，因为流程是一样的。第二次为什么会输出 2\n                      呢？我们来分析一下，当我们执行 plus 函数修改 count\n                      的值时，会触发 plusOne 的 runner 和 effect\n                      的执行，这一次我们先让 effect 执行 plusOne.value +\n                      count.value，那么就会访问 plusOne.value，但由于 plusOne 的\n                      runner 还没执行，所以此时 dirty 为\n                      false，得到的值还是上一次的计算结果 1，然后再加 1 得到 2。\n                    </p>\n                    <p data-nodeid=\"4059\" class=\"\">\n                      接着再执行 plusOne 的 runner，把 plusOne 的 dirty 设置为\n                      true，然后通知它的依赖 effect 执行 plusOne.value +\n                      count.value，这个时候由于 dirty 为 true，就会再次执行\n                      plusOne 的 getter 计算新值，拿到了 2，然后再加上 1 就得到\n                      3。\n                    </p>\n                    <p data-nodeid=\"4060\">\n                      知道原因后，我们再回过头看例子。因为 effect 函数依赖了\n                      plusOne 和 count，所以 plusOne\n                      先计算会更合理，这就是为什么我们需要让 computed runner\n                      的执行优先于普通的 effect 函数。\n                    </p>\n                    <h3 data-nodeid=\"4061\">总结</h3>\n                    <p data-nodeid=\"4062\">\n                      好的，到这里我们这一节的学习就结束啦，我希望通过学习，你能理解计算属性的工作机制，能搞明白计算属性嵌套场景代码的执行顺序，知道计算属性的两个特点——延时计算和缓存，也希望你能够在组件的开发中合理使用计算属性。\n                    </p>\n                    <p data-nodeid=\"4063\">\n                      最后，给你留一道思考题目，computed\n                      函数返回的对象实际上劫持的是 value 属性的 getter 和\n                      setter，但为什么我们在组件的模板中访问一个计算属性变量，不用手动在后面加\n                      .value 呢？欢迎你在留言区与我分享。\n                    </p>\n                    <blockquote data-nodeid=\"4064\">\n                      <p data-nodeid=\"4065\" class=\"\">\n                        <strong data-nodeid=\"4184\"\n                          >本节课的相关代码在源代码中的位置如下：</strong\n                        ><br />\n                        packages/reactivity/src/computed.ts\n                      </p>\n                    </blockquote>\n            "}