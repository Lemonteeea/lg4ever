{"title":"07 | IPv6 协议：Tunnel 技术是什么？","context":"\n                    <p data-nodeid=\"175776\">\n                      IPv4 用 32 位整数描述地址，最多只能支持 43\n                      亿设备，显然是不够用的，这也被称作 IP 地址耗尽问题。\n                    </p>\n                    <p data-nodeid=\"175777\">\n                      为了解决这个问题，有一种可行的方法是<strong\n                        data-nodeid=\"175895\"\n                        >拆分子网</strong\n                      >。拆分子网，会带来很多问题，比如说内外网数据交互，需要网络地址转换协议（NAT\n                      协议），增加传输成本。再比如说，多级网络会增加数据的路由和传输链路，降低网络的速度。理想的状态当然是所有设备在一个网络中，互相可以通过地址访问。\n                    </p>\n                    <p data-nodeid=\"175778\">\n                      为了解决这个问题，1998 年互联网工程工作小组推出了全新款的\n                      IP 协议——IPv6 协议。但是目前 IPv6 的普及程度还不够高，2019\n                      年据中国互联网络信息中心（CNNIC）统计，IPv6\n                      协议目前在我国普及率为 60%，已经位居世界首位。\n                    </p>\n                    <p data-nodeid=\"176769\" class=\"\">\n                      既然不能做到完全普及，也就引出了<strong\n                        data-nodeid=\"176775\"\n                        >本讲关联的一道面试题目：什么是 Tunnel 技术</strong\n                      >？下面请你带着这个问题，开启今天的学习吧！\n                    </p>\n\n                    <h3 data-nodeid=\"175780\">IPv4 和 IPv6 相似点</h3>\n                    <p data-nodeid=\"175781\">\n                      IPv6 的工作原理和 IPv4\n                      类似，分成切片（Segmentation）、增加封包头、路由（寻址）这样几个阶段去工作。IPv6\n                      同样接收上方主机到主机（Host-to-Host）协议传递来的数据，比如一个\n                      TCP 段（Segment），然后将 TCP 段再次切片做成一个个的 IPv6\n                      封包（Datagram or\n                      Packet），再调用底层局域网能力（数据链路层）传输数据。具体的过程如下图所示：\n                    </p>\n                    <p data-nodeid=\"177438\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/0B/CioPOWCH4u-AWVEAAAH_xR5D6lU716.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"177441\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"175784\">\n                      <strong data-nodeid=\"175915\"\n                        >作为网络层协议的\n                        IPv6，最核心的能力是确保数据可以从发送主机到达接收主机</strong\n                      >。因此，和 IPv4\n                      类似，IPv6同样需要定义地址的格式，以及路由算法如何工作。\n                    </p>\n                    <h3 data-nodeid=\"175785\">IPv6 地址</h3>\n                    <p data-nodeid=\"175786\">\n                      接下来我们重点说说地址格式的区别。\n                    </p>\n                    <p data-nodeid=\"175787\">\n                      IPv4 的地址是 4 个 8 位（octet），总共 32 位。 IPv6\n                      的地址是 8 个 16 位（hextet），总共 128\n                      位。从这个设计来看，IPv6 可以支持的地址数量是 IPv4\n                      的很多倍。就算将 IPv6\n                      的地址分给每个人，每个人拥有的地址数量，依旧是今天总地址数量的很多倍。\n                    </p>\n                    <p data-nodeid=\"175788\">\n                      格式上，IPv4 的地址用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175920\"\n                        >.</code\n                      >分割，如<code data-backticks=\"1\" data-nodeid=\"175922\"\n                        >103.28.7.35</code\n                      >。每一个是 8 位，用 0-255 的数字表示。\n                    </p>\n                    <p data-nodeid=\"175789\">\n                      IPv6 的地址用<code data-backticks=\"1\" data-nodeid=\"175925\"\n                        >:</code\n                      >分割，如<code data-backticks=\"1\" data-nodeid=\"175927\"\n                        >0123:4567:89ab:cdef:0123:4567:89ab:cdef</code\n                      >，总共 8 个 16 位的数字，通常用 16 进制表示。\n                    </p>\n                    <p data-nodeid=\"175790\">\n                      #图片需要重绘，并参考下方中英翻译，在图中标出对应中文\n                    </p>\n                    <ul data-nodeid=\"175791\">\n                      <li data-nodeid=\"175792\">\n                        <p data-nodeid=\"175793\">\n                          Hexadecimal notation：十六进制表示\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175794\">\n                        <p data-nodeid=\"175795\">Quartet：16 位</p>\n                      </li>\n                      <li data-nodeid=\"175796\">\n                        <p data-nodeid=\"175797\">Most significant：最高有效位</p>\n                      </li>\n                      <li data-nodeid=\"175798\">\n                        <p data-nodeid=\"175799\">Binary notation：二进制表示</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"178096\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/0B/CioPOWCH4wGAT3bUAALH_YQ0Q-U502.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"178099\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"175802\">\n                      上图中的地址是一个 IPv6\n                      地址的完全态，其实也有简写的方式。比如:\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">0123</span>:<span class=\"hljs-number\">4567</span>:<span class=\"hljs-number\">0000</span>:<span class=\"hljs-number\">0000</span>:<span class=\"hljs-number\">0123</span>:<span class=\"hljs-number\">4567</span>:<span class=\"hljs-number\">0000</span>:cdef\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"175804\">\n                      可以省略前 64 字节的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175942\"\n                        >0000:0000</code\n                      >简写为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">0123</span>:<span class=\"hljs-number\">4567</span>::<span class=\"hljs-number\">0123</span>:<span class=\"hljs-number\">4567</span>:<span class=\"hljs-number\">0000</span>:cdef\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"175806\">\n                      <code data-backticks=\"1\" data-nodeid=\"175944\">::</code\n                      >只能出现一次，相当于省略了若干组<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175946\"\n                        >0000</code\n                      >。比如说<code data-backticks=\"1\" data-nodeid=\"175948\"\n                        >1111::2222</code\n                      >相当于中间省略了 6 组<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175950\"\n                        >0000</code\n                      >。为什么不能出现两个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175952\"\n                        >::</code\n                      >呢？因为如果有两个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175954\"\n                        >::</code\n                      >，就会对省略的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175956\"\n                        >0000</code\n                      >的位置产生歧义。比如说<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175958\"\n                        >1111::2222:3333</code\n                      >，你就不知道究竟<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175960\"\n                        >0000</code\n                      >在<code data-backticks=\"1\" data-nodeid=\"175962\"\n                        >1111::2222</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"175964\"\n                        >2222::3333</code\n                      >是怎么分布的。\n                    </p>\n                    <p data-nodeid=\"175807\">\n                      开头的 0 也可以简写，就变成如下的样子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">123</span>:<span class=\"hljs-number\">4567</span>::<span class=\"hljs-number\">123</span>:<span class=\"hljs-number\">4567</span>:<span class=\"hljs-number\">0</span>:cdef\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"175809\">\n                      还有一种情况我们想要后面部分都填<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175968\"\n                        >0</code\n                      >，比如说<code data-backticks=\"1\" data-nodeid=\"175970\"\n                        >3c4d::/16</code\n                      >，这个代表只有前<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175972\"\n                        >16</code\n                      >位有数据，后面是<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175974\"\n                        >0</code\n                      >；<code data-backticks=\"1\" data-nodeid=\"175976\"\n                        >1234:5878:abcd/64</code\n                      >代表只有左边<code data-backticks=\"1\" data-nodeid=\"175978\"\n                        >64</code\n                      >位有数据，后面是 0；再比如<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"175980\"\n                        >ff00/8</code\n                      >，只有左边 8 位是有数据的。\n                    </p>\n                    <h3 data-nodeid=\"175810\">IPv6 的寻址</h3>\n                    <p data-nodeid=\"175811\">\n                      接下来我们讨论下寻址，和 IPv4\n                      相同，寻址的目的是找到设备，以及规划到设备途经的路径。和\n                      IPv4 相同，IPv6寻址最核心的内容就是要对网络进行划分。IPv6\n                      地址很充裕，因此对网络的划分和 IPv4 有很显著的差异。\n                    </p>\n                    <p data-nodeid=\"175812\">IPv6 的寻址分成了几种类型：</p>\n                    <ul data-nodeid=\"175813\">\n                      <li data-nodeid=\"175814\">\n                        <p data-nodeid=\"175815\">\n                          全局单播寻址（和 IPv4\n                          地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是\n                          1 对 1）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175816\">\n                        <p data-nodeid=\"175817\">\n                          本地单播（类似 IPv4\n                          里的一个内部网络，要求地址必须以<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"175987\"\n                            >fe80</code\n                          >开头，类似我们 IPv4 中<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"175989\"\n                            >127</code\n                          >开头的地址）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175818\">\n                        <p data-nodeid=\"175819\">\n                          分组多播（Group\n                          Multicast），类似今天我们说的广播，将消息发送给多个接收者；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175820\">\n                        <p data-nodeid=\"175821\">\n                          任意播（Anycast），这个方式比较特殊，接下来我们会详细讲解。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"180687\" class=\"\">全局单播</h4>\n\n                    <p data-nodeid=\"181329\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/03/Cgp9HWCH4w-AEinAAAHIfeF4_II848.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"181332\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"175826\">\n                      全局单播，就是将消息从一个设备传到另一个设备，这和 IPv4\n                      发送/接收消息大同小异。而全局单播地址，目标就是定位网络中的设备，这个地址和\n                      IPv4 的地址作用相同，只不过格式略有差异。<strong\n                        data-nodeid=\"176009\"\n                        >总的来说，IPv6\n                        地址太多，因此不再需要子网掩码，而是直接将 IPv6\n                        的地址分区即可</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"175827\">\n                      在实现全局单播时，IPv6 地址通常分成 3 个部分：\n                    </p>\n                    <ul data-nodeid=\"175828\">\n                      <li data-nodeid=\"175829\">\n                        <p data-nodeid=\"175830\">\n                          站点前缀（Site Prefix）48bit，一般是由 ISP（Internet\n                          Service Providor，运营商）或者RIR（Regional Internet\n                          Registry， 地区性互联网注册机构），RIR 将 IP\n                          地址分配给运营商；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175831\">\n                        <p data-nodeid=\"175832\">\n                          子网号（Subnet ID），16bit，用于站点内部区分子网；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175833\">\n                        <p data-nodeid=\"175834\">\n                          接口号（Interface ID）， 64bit，用于站点内部区分设备。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"175835\">\n                      因此 IPv6\n                      也是一个树状结构，站点前缀需要一定资质，子网号和接口号内部定义。IPv6\n                      的寻址过程就是先通过站点前缀找到站点，然后追踪子网，再找到接口（也就是设备的网卡）。\n                    </p>\n                    <p data-nodeid=\"175836\">\n                      从上面全局单播的分区，我们可以看出，IPv6\n                      分给站点的地址非常多。一个站点，有 16bit 的子网，相当于\n                      65535 个子网；每个子网中，还可以用 64 位整数表示设备。\n                    </p>\n                    <h4 data-nodeid=\"183848\" class=\"\">本地单播</h4>\n\n                    <p data-nodeid=\"175838\">\n                      理论上，虽然 IPv6\n                      可以将所有的设备都连入一个网络。但在实际场景中，很多公司还是需要一个内部网络的。这种情况在\n                      IPv6 的设计中属于局域网络。\n                    </p>\n                    <p data-nodeid=\"175839\">\n                      在局域网络中，实现设备到设备的通信，就是本地单播。IPv6\n                      的本地单播地址组成如下图所示：\n                    </p>\n                    <p data-nodeid=\"184472\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3C/03/Cgp9HWCH4x6AJJxNAAEMhuOKNmY768.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"184475\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"175842\">\n                      这种协议比较简单，本地单播地址必须以<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"176029\"\n                        >fe80</code\n                      >开头，后面 64 位的 0，然后接上 54 位的设备编号。上图中的\n                      Interface 可以理解成网络接口，其实就是网卡。\n                    </p>\n                    <h4 data-nodeid=\"186935\" class=\"\">分组多播</h4>\n\n                    <p data-nodeid=\"175844\">\n                      有时候，我们需要实现广播。所谓广播，就是将消息同时发送给多个接收者。\n                    </p>\n                    <p data-nodeid=\"175845\">\n                      IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个\n                      1 开头，也就是<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"176037\"\n                        >ff00</code\n                      >开头，后面会跟上一个分组的编号时，就是在进行分组多播。\n                    </p>\n                    <p data-nodeid=\"175846\">\n                      这个时候，我们需要一个广播设备，在这个设备中已经定义了这些分组编号，并且拥有分组下所有设备的清单，这个广播设备会帮助我们将消息发送给对应分组下的所有设备。\n                    </p>\n                    <h4 data-nodeid=\"189372\" class=\"\">任意播（Anycast）</h4>\n\n                    <p data-nodeid=\"175848\">\n                      任意播，本质是将消息发送给多个接收方，并选择一条最优的路径。这样说有点抽象，接下来我具体解释一下。\n                    </p>\n                    <p data-nodeid=\"175849\">\n                      比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。当一个客户端想要获取时间，就可以将请求发送到这个任播地址。客户端的请求扩散出去后，可能会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。这个时候，客户端就使用它第一次收到的授时信息修正自己的时间。\n                    </p>\n                    <h3 data-nodeid=\"189976\">IPv6 和 IPv4 的兼容</h3>\n\n                    <p data-nodeid=\"175852\">\n                      目前 IPv6 还没有完全普及，大部分知名的网站都是同时支持\n                      IPv6 和 IPv4。这个时候我们可以分成 2 种情况讨论：\n                    </p>\n                    <ol data-nodeid=\"175853\">\n                      <li data-nodeid=\"175854\">\n                        <p data-nodeid=\"175855\">\n                          一个 IPv4 的网络和一个 IPv6 的网络通信；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175856\">\n                        <p data-nodeid=\"175857\">\n                          一个 IPv6 的网络和一个 IPv6\n                          的网络通信，但是中间需要经过一个 IPv4 的网络。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"175858\">下面我们具体分析一下。</p>\n                    <p data-nodeid=\"175859\">\n                      <strong data-nodeid=\"176054\"\n                        >情况 1：IPv4 网络和 IPv6 网络通信</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"175860\">\n                      例如一个 IPv6 的客户端，想要访问 IPv4\n                      的服务器，步骤如下图所示：\n                    </p>\n                    <p data-nodeid=\"190578\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/0C/CioPOWCH4y-AUMRWAAMbF03aDqY454.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"190581\"\n                      />\n                    </p>\n\n                    <ol data-nodeid=\"175863\">\n                      <li data-nodeid=\"175864\">\n                        <p data-nodeid=\"175865\">\n                          客户端通过 DNS64 服务器查询 AAAA 记录。DNS64\n                          是国际互联网工程任务组（IETF）提供的一种解决 IPv4 和\n                          IPv6 兼容问题的 DNS 服务。这个 DNS 查询服务会把 IPv4\n                          地址和 IPv6 地址同时返回。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175866\">\n                        <p data-nodeid=\"175867\">\n                          DNS64 服务器返回含 IPv4 地址的 AAAA 记录。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175868\">\n                        <p data-nodeid=\"175869\">\n                          客户端将对应的 IPv4 地址请求发送给一个 NAT64 路由器\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175870\">\n                        <p data-nodeid=\"175871\">\n                          由这个 NAT64 路由器将 IPv6 地址转换为 IPv4\n                          地址，从而访问 IPv4 网络，并收集结果。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"175872\">\n                        <p data-nodeid=\"175873\">消息返回到客户端。</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"175874\">\n                      <strong data-nodeid=\"176070\"\n                        >情况 2：两个 IPv6 网络被 IPv4 隔离</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"175875\">\n                      这种情况在普及 IPv6 的过程中比较常见，IPv6\n                      的网络一开始是一个个孤岛，IPv6\n                      网络需要通信，就需要一些特别的手段。\n                    </p>\n                    <p data-nodeid=\"175876\">\n                      不知道你有没有联想到坐火车穿越隧道的感觉，连接两个孤岛\n                      IPv6 网络，其实就是在 IPv4\n                      网络中建立一条隧道。如下图所示：\n                    </p>\n                    <p data-nodeid=\"191174\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3C/03/Cgp9HWCH4ziAD-hYAAMdJ6IgvWE780.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"191177\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"175879\">\n                      <strong data-nodeid=\"176083\"\n                        >隧道的本质就是在两个 IPv6\n                        的网络出口网关处，实现一段地址转换的程序</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"175880\">总结</h3>\n                    <p data-nodeid=\"175881\">\n                      总结下，<strong data-nodeid=\"176090\"\n                        >IPv6 解决的是地址耗尽的问题</strong\n                      >。因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等。\n                    </p>\n                    <p data-nodeid=\"175882\">\n                      除了本讲介绍的内容，下一讲你还会从局域网络中看到更多对 NAT\n                      技术的解读、对路由器的作用的探讨。随着 IPv6\n                      彻底普及，你可以想象一下，运营商可以给到每个家庭一大批固定的\n                      IP\n                      地址，发布网页似乎可以利用家庭服务器……总之，林䭽也不知道最终会发生什么，我也对未来充满了期待，让我们拭目以待吧。\n                    </p>\n                    <p data-nodeid=\"175883\">\n                      那么，通过这一讲的学习，你可以尝试回答本讲关联的面试题目：Tunnel\n                      技术是什么了吗？\n                    </p>\n                    <p data-nodeid=\"175884\">\n                      【<strong data-nodeid=\"176098\">解析</strong>】Tunnel\n                      就是隧道，这和现实中的隧道是很相似的。隧道不是只有一辆车通过，而是每天都有大量的车辆来来往往。两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。隧道是两个网络间用程序定义的一种通道。具体来说，如果两个\n                      IPv6 网络被 IPv4 分隔开，那么两个 IPv6 网络的出口处（和\n                      IPv4\n                      网络的网关处）就可以用程序（或硬件）实现一个隧道，方便两个网络中设备的通信。\n                    </p>\n                    <h3 data-nodeid=\"175885\">思考题</h3>\n                    <p data-nodeid=\"175886\">\n                      <strong data-nodeid=\"176104\"\n                        >最后，我再给你出一道需要查资料的思考题：请你总结下 IPv6\n                        和 IPv4 究竟有哪些区别</strong\n                      >？\n                    </p>\n                    <p data-nodeid=\"175887\">\n                      我建议你拿出几分钟的时间，把这两者的区别写在留言区。这个输出的过程不仅能够帮助你产生更多的思考，也是构建知识体系的根基。如果你对本次课程有什么建议和疑问，可以在评论区留言。如果你有所收获，也可以推荐给你的朋友。\n                    </p>\n                    <p data-nodeid=\"175888\">\n                      这一讲就到这里。发现求知的乐趣，我是林䭽，感谢你学习本次课程。下一讲我们将学习“08\n                      | 局域网：NAT 是如何工作的？”再见！\n                    </p>\n            "}