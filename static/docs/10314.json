{"title":"13 | ReactDOM.render 是如何串联渲染链路的？（上）","context":"\n                    <p data-nodeid=\"1277\" class=\"\">\n                      由于 ReactDOM.render\n                      的内容比较多，所以这里拆分了上中下三讲来讲解。\n                    </p>\n                    <p data-nodeid=\"1278\">\n                      在上一讲，我们站在宏观角度对 Fiber\n                      的架构分层和迭代动机有了充分的把握。从本讲开始，我们将以首次渲染为切入点，拆解\n                      Fiber 架构下 ReactDOM.render\n                      所触发的渲染链路，结合源码理解整个链路中所涉及的初始化、render\n                      和 commit 等过程。\n                    </p>\n                    <h3 data-nodeid=\"1279\">ReactDOM.render 调用栈的逻辑分层</h3>\n                    <p data-nodeid=\"1280\">\n                      开篇先给到你一个简单的 React AppDemo：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React from \"react\";\n</div></li><li><div class=\"code-word\">import ReactDOM from \"react-dom\";\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">function App() {\n</div></li><li><div class=\"code-word\">    return (\n</div></li><li><div class=\"code-word\">      &lt;div className=\"App\"&gt;\n</div></li><li><div class=\"code-word\">        &lt;div className=\"container\"&gt;\n</div></li><li><div class=\"code-word\">          &lt;h1&gt;我是标题&lt;/h1&gt;\n</div></li><li><div class=\"code-word\">          &lt;p&gt;我是第一段话&lt;/p&gt;\n</div></li><li><div class=\"code-word\">          &lt;p&gt;我是第二段话&lt;/p&gt;\n</div></li><li><div class=\"code-word\">        &lt;/div&gt;\n</div></li><li><div class=\"code-word\">      &lt;/div&gt;\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">const rootElement = document.getElementById(\"root\");\n</div></li><li><div class=\"code-word\">ReactDOM.render(&lt;App /&gt;, rootElement);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1282\">\n                      Demo 启动后，渲染出的界面如下图所示：\n                    </p>\n                    <p data-nodeid=\"1283\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmEOAGbJ5AAAxGM0SPWA261.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"1379\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1284\">\n                      现在请你打开 Chrome 的 Performance\n                      面板，点击下图红色圈圈所圈住的这个“记录”按钮：\n                    </p>\n                    <p data-nodeid=\"1285\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmEuALVycAAEENjoXJ6E407.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"1383\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1286\">\n                      然后重新访问 Demo\n                      页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图：\n                    </p>\n                    <p data-nodeid=\"1287\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmFKAFeHBAAQn6ZuFPrI619.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"1387\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1288\">\n                      放大该图，定位“src/index.js”这个文件路径，我们就可以找到\n                      ReactDOM.render 方法对应的调用栈，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1289\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmFmAXkYlAAI2ONTKc9s081.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1391\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1290\">\n                      从图中你可以看到，ReactDOM.render\n                      方法对应的调用栈非常深，中间涉及的函数量也比较大。如果这张图使你心里发虚，请先不要急于撤退——分析调用栈只是我们理解渲染链路的一个手段，我们的目的是借此提取关键逻辑，而非理解调用栈中的每一个方法。就这张图来说，你首先需要把握的，就是整个调用链路中所包含的三个阶段：\n                    </p>\n                    <p data-nodeid=\"1291\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmGKAFb5NAAItD2ouVoc061.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"1395\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1292\">\n                      图中 scheduleUpdateOnFiber 方法的作用是调度更新，在由\n                      ReactDOM.render 发起的首屏渲染这个场景下，它触发的就是\n                      performSyncWorkOnRoot。performSyncWorkOnRoot\n                      开启的正是我们反复强调的\n                      <strong data-nodeid=\"1405\">render 阶段</strong>；而\n                      commitRoot 方法开启的则是真实 DOM 的渲染过程（<strong\n                        data-nodeid=\"1406\"\n                        >commit 阶段</strong\n                      >）。因此以scheduleUpdateOnFiber 和 commitRoot\n                      两个方法为界，我们可以大致把 ReactDOM.render\n                      的调用栈划分为三个阶段：\n                    </p>\n                    <ol data-nodeid=\"1293\">\n                      <li data-nodeid=\"1294\">\n                        <p data-nodeid=\"1295\">初始化阶段</p>\n                      </li>\n                      <li data-nodeid=\"1296\">\n                        <p data-nodeid=\"1297\">render 阶段</p>\n                      </li>\n                      <li data-nodeid=\"1298\">\n                        <p data-nodeid=\"1299\">commit 阶段</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1300\">\n                      接下来，我们就一起来看看这三个阶段分别做了哪些事情。\n                    </p>\n                    <blockquote data-nodeid=\"1301\">\n                      <p data-nodeid=\"1302\">\n                        注：渲染链路串讲已被拆分为 3\n                        个课时，本课时讲解的是初始化阶段。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"1303\">\n                      拆解 ReactDOM.render 调用栈——初始化阶段\n                    </h3>\n                    <p data-nodeid=\"1304\">\n                      首先我们提取出初始化过程中涉及的调用栈大图：\n                    </p>\n                    <p data-nodeid=\"1305\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmGqAU-42AABcbqaOzFc800.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"1416\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1306\">\n                      图中的方法虽然看上去又多又杂，但做的事情清清爽爽，那就是<strong\n                        data-nodeid=\"1422\"\n                        >完成 Fiber 树中基本实体的创建</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1307\">\n                      什么是基本实体？基本实体有哪些？问题的答案藏在源码里，这里我为你提取了源码中的关键逻辑，首先是\n                      legacyRenderSubtreeIntoContainer 方法。在 ReactDOM.render\n                      函数体中，以下面代码所示的姿势调用了它：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> legacyRenderSubtreeIntoContainer(<span class=\"hljs-keyword\">null</span>, element, container, <span class=\"hljs-keyword\">false</span>, callback);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1309\">\n                      而 legacyRenderSubtreeIntoContainer\n                      的关键逻辑如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">legacyRenderSubtreeIntoContainer</span><span class=\"hljs-params\">(parentComponent, children, container, forceHydrate, callback)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// container 对应的是我们传入的真实 DOM 对象</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> root = container._reactRootContainer;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化 fiberRoot 对象</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> fiberRoot;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!root) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span>\n</div></li><li><div class=\"code-word\">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span>\n</div></li><li><div class=\"code-word\">    fiberRoot = root._internalRoot;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (typeof callback === <span class=\"hljs-string\">'function'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">var</span> originalCallback = callback;\n</div></li><li><div class=\"code-word\">      callback = function () {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> instance = getPublicRootInstance(fiberRoot);\n</div></li><li><div class=\"code-word\">        originalCallback.call(instance);\n</div></li><li><div class=\"code-word\">      };\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-comment\">// Initial mount should not be batched.</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 进入 unbatchedUpdates 方法</span>\n</div></li><li><div class=\"code-word\">    unbatchedUpdates(function () {\n</div></li><li><div class=\"code-word\">      updateContainer(children, fiberRoot, parentComponent, callback);\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span>\n</div></li><li><div class=\"code-word\">    fiberRoot = root._internalRoot;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (typeof callback === <span class=\"hljs-string\">'function'</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">var</span> _originalCallback = callback;\n</div></li><li><div class=\"code-word\">      callback = function () {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">var</span> instance = getPublicRootInstance(fiberRoot);\n</div></li><li><div class=\"code-word\">        _originalCallback.call(instance);\n</div></li><li><div class=\"code-word\">      };\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-comment\">// Update</span>\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    updateContainer(children, fiberRoot, parentComponent, callback);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> getPublicRootInstance(fiberRoot);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1311\">\n                      这里我为你总结一下首次渲染过程中\n                      legacyRenderSubtreeIntoContainer 方法的主要逻辑链路：\n                    </p>\n                    <p data-nodeid=\"1312\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/70/03/CgqCHl-3mfWABLi5AADUzMV7iHA320.png\"\n                        alt=\"Lark20201120-182606.png\"\n                        data-nodeid=\"1428\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1313\">\n                      在这个流程中，你需要关注到 fiberRoot 这个对象。fiberRoot\n                      到底是什么呢？这里我将运行时的 root 和 fiberRoot\n                      为你截取出来，其中 root 对象的结构如下图所示：\n                    </p>\n                    <p data-nodeid=\"1314\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmH6AKzPPAADcEbfK6K4199.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"1432\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1315\">\n                      可以看出，root\n                      对象（container._reactRootContainer）上有一个\n                      _internalRoot 属性，这个 _internalRoot 也就是\n                      fiberRoot。fiberRoot 的本质是一个 FiberRootNode\n                      对象，其中包含一个 current\n                      属性，该属性同样需要划重点。这里我为你高亮出 current\n                      属性的部分内容：\n                    </p>\n                    <p data-nodeid=\"1316\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmISANlmfAADLqX8jue0154.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"1442\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1317\">\n                      或许你会对 current\n                      对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get\n                      到“current 对象是一个 FiberNode 实例”这一点，<strong\n                        data-nodeid=\"1452\"\n                        >而 FiberNode，正是 Fiber 节点对应的对象类型</strong\n                      >。current 对象是一个 Fiber 节点，不仅如此，它还是<strong\n                        data-nodeid=\"1453\"\n                        >当前 Fiber 树的头部节点</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1318\">\n                      考虑到 current 属性对应的 FiberNode\n                      节点，在调用栈中实际是由 createHostRootFiber\n                      方法创建的，React 源码中也有多处以 rootFiber 代指 current\n                      对象，因此下文中我们将以 rootFiber 指代 current 对象。\n                    </p>\n                    <p data-nodeid=\"1319\">\n                      读到这里，你脑海中应该不难形成一个这样的指向关系：\n                    </p>\n                    <p data-nodeid=\"1320\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6F/F8/Ciqc1F-3mh-AZrlvAABgy8S1u44402.png\"\n                        alt=\"Lark20201120-182610.png\"\n                        data-nodeid=\"1458\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1321\">\n                      其中，fiberRoot 的关联对象是真实 DOM 的容器节点；而\n                      rootFiber 则作为虚拟 DOM 的根节点存在。<strong\n                        data-nodeid=\"1464\"\n                        >这两个节点，将是后续整棵 Fiber 树构建的起点</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1322\">\n                      接下来，fiberRoot 将和 ReactDOM.render\n                      方法的其他入参一起，被传入 updateContainer\n                      方法，从而形成一个回调。这个回调，正是接下来要调用的\n                      unbatchedUpdates 方法的入参。我们一起看看 unbatchedUpdates\n                      做了什么，下面代码是对 unbatchedUpdates 主体逻辑的提取：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">unbatchedUpdates</span><span class=\"hljs-params\">(fn, a)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里是对上下文的处理，不必纠结</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> prevExecutionContext = executionContext;\n</div></li><li><div class=\"code-word\">  executionContext &amp;= ~BatchedContext;\n</div></li><li><div class=\"code-word\">  executionContext |= LegacyUnbatchedContext;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> fn(a);\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">finally</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// finally 逻辑里是对回调队列的处理，此处不用太关注</span>\n</div></li><li><div class=\"code-word\">    executionContext = prevExecutionContext;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (executionContext === NoContext) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// Flush the immediate callbacks that were scheduled during this batch</span>\n</div></li><li><div class=\"code-word\">      resetRenderTimer();\n</div></li><li><div class=\"code-word\">      flushSyncCallbackQueue();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1324\">\n                      在 unbatchedUpdates 函数体里，当下你只需要 Get\n                      到一个信息：它直接调用了传入的回调 fn。而在当前链路中，fn\n                      是什么呢？<strong data-nodeid=\"1471\"\n                        >fn 是一个针对 updateContainer 的调用</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">unbatchedUpdates(function () {\n</div></li><li><div class=\"code-word\">  updateContainer(children, fiberRoot, parentComponent, callback);\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1326\">\n                      接下来我们很有必要去看看 updateContainer\n                      里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">updateContainer</span><span class=\"hljs-params\">(element, container, parentComponent, callback)</span> </span>{\n</div></li><li><div class=\"code-word\">  ......\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这是一个 event 相关的入参，此处不必关注</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> eventTime = requestEventTime();\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  ......\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这是一个比较关键的入参，lane 表示优先级</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> lane = requestUpdateLane(current$<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> update = createUpdate(eventTime, lane); \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// update 的 payload 对应的是一个 React 元素</span>\n</div></li><li><div class=\"code-word\">  update.payload = {\n</div></li><li><div class=\"code-word\">    element: element\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span>\n</div></li><li><div class=\"code-word\">  callback = callback === undefined ? <span class=\"hljs-keyword\">null</span> : callback;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (callback !== <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (typeof callback !== <span class=\"hljs-string\">'function'</span>) {\n</div></li><li><div class=\"code-word\">        error(<span class=\"hljs-string\">'render(...): Expected the last optional \\`callback\\` argument to be a '</span> + <span class=\"hljs-string\">'function. Instead received: %s.'</span>, callback);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    update.callback = callback;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 将 update 入队</span>\n</div></li><li><div class=\"code-word\">  enqueueUpdate(current$<span class=\"hljs-number\">1</span>, update);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 调度 fiberRoot </span>\n</div></li><li><div class=\"code-word\">  scheduleUpdateOnFiber(current$<span class=\"hljs-number\">1</span>, lane, eventTime);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 返回当前节点（fiberRoot）的优先级</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> lane;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1328\">\n                      updateContainer\n                      的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：\n                    </p>\n                    <ol data-nodeid=\"1329\">\n                      <li data-nodeid=\"1330\">\n                        <p data-nodeid=\"1331\">\n                          请求当前 Fiber 节点的 lane（优先级）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1332\">\n                        <p data-nodeid=\"1333\">\n                          结合 lane（优先级），创建当前 Fiber 节点的 update\n                          对象，并将其入队；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1334\">\n                        <p data-nodeid=\"1335\">调度当前节点（rootFiber）。</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1336\">\n                      函数体中的 scheduleWork 其实就是\n                      scheduleUpdateOnFiber，scheduleUpdateOnFiber\n                      函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是<strong\n                        data-nodeid=\"1482\"\n                        >在 ReactDOM.render\n                        发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的</strong\n                      >。我们可以尝试在 Source\n                      面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：\n                    </p>\n                    <p data-nodeid=\"1337\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmJGATpFIAAPP-sFYf70749.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"1485\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1338\">\n                      performSyncWorkOnRoot直译过来就是“执行根节点的同步任务”，<strong\n                        data-nodeid=\"1491\"\n                        >这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程</strong\n                      >。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。\n                    </p>\n                    <p data-nodeid=\"1339\">\n                      前面我们曾经提到过，performSyncWorkOnRoot 是 render\n                      阶段的起点，render 阶段的任务就是完成 Fiber\n                      树的构建，它是整个渲染链路中最核心的一环。在异步渲染的模式下，render\n                      阶段应该是一个可打断的异步过程（下一讲我们就将针对 render\n                      过程作详细的逻辑拆解）。\n                    </p>\n                    <p data-nodeid=\"1340\">\n                      而现在，我相信你心里更多的疑惑在于：<strong\n                        data-nodeid=\"1498\"\n                        >都说 Fiber 架构带来的异步渲染是 React 16\n                        的亮点，为什么分析到现在，竟然发现 ReactDOM.render\n                        触发的首次渲染是个同步过程呢</strong\n                      >？\n                    </p>\n                    <h3 data-nodeid=\"1341\">\n                      同步的 ReactDOM.render，异步的 ReactDOM.createRoot\n                    </h3>\n                    <p data-nodeid=\"1342\">\n                      其实在 React 16，包括近期发布的 React 17 小版本中，React\n                      都有以下 3 种启动方式：\n                    </p>\n                    <p data-nodeid=\"1343\">\n                      <strong data-nodeid=\"1516\">legacy 模式</strong>：<br />\n                      <code data-backticks=\"1\" data-nodeid=\"1506\"\n                        >ReactDOM.render(&lt;App /&gt;, rootNode)</code\n                      >。这是当前 React App\n                      使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能。<br />\n                      <strong data-nodeid=\"1517\">blocking 模式</strong>：<br />\n                      <code data-backticks=\"1\" data-nodeid=\"1514\"\n                        >ReactDOM.createBlockingRoot(rootNode).render(&lt;App\n                        /&gt;)</code\n                      >。目前正在实验中，作为迁移到 concurrent\n                      模式的第一个步骤。\n                    </p>\n                    <p data-nodeid=\"1344\">\n                      <strong data-nodeid=\"1525\">concurrent 模式</strong\n                      >：<br />\n                      <code data-backticks=\"1\" data-nodeid=\"1523\"\n                        >ReactDOM.createRoot(rootNode).render(&lt;App\n                        /&gt;)</code\n                      >。目前在实验中，未来稳定之后，打算作为 React\n                      的默认开发模式，这个模式开启了所有的新功能。\n                    </p>\n                    <p data-nodeid=\"1345\">\n                      在这 3 种模式中，<strong data-nodeid=\"1535\"\n                        >我们常用的 ReactDOM.render 对应的是 legacy\n                        模式，它实际触发的仍然是同步的渲染链路</strong\n                      >。blocking 模式可以理解为 legacy 和 concurrent\n                      之间的一个过渡形态，之所以会有这个模式，是因为 React\n                      官方希望能够提供<a\n                        href=\"https://zh-hans.reactjs.org/docs/faq-versioning.html#commitment-to-stability\"\n                        data-nodeid=\"1533\"\n                        >渐进的迁移策略</a\n                      >，帮助我们更加顺滑地过渡到 Concurrent 模式。blocking\n                      在实际应用中是比较低频的一个模式，了解即可。\n                    </p>\n                    <p data-nodeid=\"1346\">\n                      按照官方的说法，“<strong data-nodeid=\"1541\"\n                        >长远来看，模式的数量会收敛，不用考虑不同的模式</strong\n                      >，但就目前而言，模式是一项重要的迁移策略，让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移”。由此可以看出，Concurrent\n                      模式确实是 React 的终极目标，也是其创作团队使用 Fiber\n                      架构重写核心算法的动机所在。\n                    </p>\n                    <h3 data-nodeid=\"1347\">\n                      拓展：关于异步模式下的首次渲染链路\n                    </h3>\n                    <p data-nodeid=\"1348\">\n                      当下，如果想要开启异步渲染，我们需要调用\n                      <code data-backticks=\"1\" data-nodeid=\"1544\"\n                        >ReactDOM.createRoot</code\n                      >方法来启动应用，那<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1546\"\n                        >ReactDOM.createRoot</code\n                      >开启的渲染链路与 ReactDOM.render 有何不同呢？\n                    </p>\n                    <p data-nodeid=\"1349\">\n                      这里我修改一下调用方式，给你展示一下调用栈。由于本讲的源码取材于\n                      React 17.0.0 版本，在这个版本中，createRoot 仍然是一个\n                      unstable 的方法。因此实际调用的 API\n                      应该是“unstable_createRoot”：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">ReactDOM.unstable_createRoot(rootElement).render(&lt;App /&gt;);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1351\">\n                      Concurrent\n                      模式开启后，首次渲染的调用栈变成了如下图所示的样子：\n                    </p>\n                    <p data-nodeid=\"1352\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmJyAbYZNAAFI67qKm98019.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"1554\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1353\">\n                      乍一看，好像和 ReactDOM.render 差别很大，其实不然。图中\n                      createRoot\n                      所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1354\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmKKAF0ODAADhhdYWzo0441.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"1558\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1355\">我们拉近一点来看，如下图所示：</p>\n                    <p data-nodeid=\"1356\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/70/75/CgqCHl-7GiaAUY_zAAxz8mfEvT0309.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"1562\"\n                      /><br />\n                      你会发现这地方也调用了一个\n                      render。再顺着这个调用往下看，发现有大量的熟悉面孔：updateContainer、requestUpdateLane、createUpdate、scheduleUpdateOnFiber......这些函数在\n                      ReactDOM.render 的调用栈中也出现过。\n                    </p>\n                    <p data-nodeid=\"1357\">\n                      其实，当前你看到的这个 render 调用链路，和 ReactDOM.render\n                      的调用链路是非常相似的，主要的区别在 scheduleUpdateOnFiber\n                      的这个判断里：\n                    </p>\n                    <p data-nodeid=\"1358\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmMKAJFKYAAMfoIVWxeM650.png\"\n                        alt=\"image.png\"\n                        data-nodeid=\"1568\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1359\">\n                      在异步渲染模式下，由于请求到的 lane 不再是\n                      SyncLane（同步优先级），故不会再走到 performSyncWorkOnRoot\n                      这个调用，而是会转而执行 else 中调度相关的逻辑。\n                    </p>\n                    <p data-nodeid=\"1360\">\n                      这里有个点要给你点出来——React\n                      是如何知道当前处于哪个模式的呢？我们可以以\n                      requestUpdateLane 函数为例，下面是它局部的代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">requestUpdateLane</span><span class=\"hljs-params\">(fiber)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取 mode 属性</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> mode = fiber.mode;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 结合 mode 属性判断当前的</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> ((mode &amp; BlockingMode) === NoMode) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> SyncLane;\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> ((mode &amp; ConcurrentMode) === NoMode) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> getCurrentPriorityLevel() === ImmediatePriority$<span class=\"hljs-number\">1</span> ? SyncLane : SyncBatchedLane;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  ......\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> lane;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1362\">\n                      上面代码中需要注意 fiber节点上的 mode 属性：<strong\n                        data-nodeid=\"1576\"\n                        >React 将会通过修改 mode\n                        属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1363\">\n                      因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及\n                      初始化 → render → commit 这 3 个步骤），而是 mode\n                      属性的差异。mode\n                      属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的。\n                    </p>\n                    <p data-nodeid=\"1364\">\n                      关于异步挂载/更新的实现细节，我们将在后续的第 16 讲“Fiber\n                      架构实现原理与编码形态”中详细探讨。\n                    </p>\n                    <h3 data-nodeid=\"1365\">Fiber 架构一定是异步渲染吗？</h3>\n                    <p data-nodeid=\"1366\">\n                      之前我曾经被读者朋友问到过这样的问题：<strong\n                        data-nodeid=\"1585\"\n                        >React 16 如果没有开启 Concurrent 模式，那它还能叫 Fiber\n                        架构吗</strong\n                      >？\n                    </p>\n                    <p data-nodeid=\"1367\">\n                      这个问题很有意思，从动机上来看，Fiber\n                      架构的设计确实主要是为了 Concurrent\n                      而存在。但经过了本讲紧贴源码的讲解，相信你也能够看出，在\n                      React 16，包括已发布的 React 17 版本中，不管是否是\n                      Concurrent，整个数据结构层面的设计、包括贯穿整个渲染链路的处理逻辑，已经完全用\n                      Fiber 重构了一遍。站在这个角度来看，Fiber 架构在 React\n                      中并不能够和异步渲染画严格的等号，它是一种<strong\n                        data-nodeid=\"1591\"\n                        >同时兼容了同步渲染与异步渲染的设计</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"1368\">总结</h3>\n                    <p data-nodeid=\"1369\">\n                      从本讲开始，我们以 ReactDOM.render\n                      所触发的首次渲染为切入点，试图串联 React Fiber\n                      架构下完整的工作链路，本讲为整个源码链路分析的前半部分。\n                    </p>\n                    <p data-nodeid=\"1370\">\n                      正所谓“磨刀不误砍柴工”。虽然当前的进度条只推到了初始化这个位置，但在这部分的分析过程中，相信你已经对Fiber\n                      树的初始形态、Fiber\n                      根节点的创建过程建立了感性的认知，同时把握住了\n                      ReactDOM.render 同步渲染的过程特征，理解了 React\n                      当下共存的3种渲染方式。在此基础上，我们再去理解 render\n                      过程，就会轻松得多。\n                    </p>\n                    <p data-nodeid=\"1371\" class=\"te-preview-highlight\">\n                      整个初始化的工作过程都是在为后续的 render\n                      阶段做准备。现在，我们的 Fiber Tree\n                      还处在只有根节点的起始状态。接下来，我们就要进入到最最关键的\n                      render\n                      阶段里去，一起去看看这棵树是怎么一点点丰满起来的，加油！\n                    </p>\n            "}