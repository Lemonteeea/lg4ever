{"title":"07 | 并查集：如何利用两行代码写并查集？","context":"\n                    <p data-nodeid=\"35077\" class=\"\">\n                      <strong data-nodeid=\"35440\">并查集</strong\n                      >是一种树型的数据结构，用于处理一些<strong\n                        data-nodeid=\"35441\"\n                        >不交集（Disjoint Sets）的合并及查询问题</strong\n                      >。通常会用到两种操作。\n                    </p>\n                    <ul data-nodeid=\"35078\">\n                      <li data-nodeid=\"35079\">\n                        <p data-nodeid=\"35080\">\n                          Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35081\">\n                        <p data-nodeid=\"35082\">\n                          Union：将两个子集合并成同一个集合。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35083\">\n                      因此，这种数据结构称为<strong data-nodeid=\"35449\"\n                        >并查集</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"35084\">\n                      在工程中，<strong data-nodeid=\"35455\"\n                        >并查集往往较多用于数据清理分类等操作</strong\n                      >，并且能够以 O(N)\n                      的时间复杂度处理较大的数据量，出现在大厂的面试题中也就不奇怪了。\n                    </p>\n                    <p data-nodeid=\"35085\">学完这一讲，你将会收获：</p>\n                    <ul data-nodeid=\"35086\">\n                      <li data-nodeid=\"35087\">\n                        <p data-nodeid=\"35088\">并查集的模板代码</p>\n                      </li>\n                      <li data-nodeid=\"35089\">\n                        <p data-nodeid=\"35090\">\n                          如何利用并查集解决<strong data-nodeid=\"35463\"\n                            >连通域</strong\n                          >问题\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35091\">\n                        <p data-nodeid=\"35092\">如何利用虚拟点与虚拟边</p>\n                      </li>\n                      <li data-nodeid=\"35093\">\n                        <p data-nodeid=\"35094\">如何利用路径压缩的技巧</p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"35095\">并查集基础</h3>\n                    <p data-nodeid=\"35096\">\n                      首先来看一下并查集要解决的问题，主要有两个。\n                    </p>\n                    <ul data-nodeid=\"35097\">\n                      <li data-nodeid=\"35098\">\n                        <p data-nodeid=\"35099\">\n                          Find：查询 item 属于<strong data-nodeid=\"35472\"\n                            >哪个集合</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35100\">\n                        <p data-nodeid=\"35101\">\n                          Union：将两个集合<strong data-nodeid=\"35477\"\n                            >进行合并</strong\n                          >\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35102\">\n                      我们以一个有趣的问题展开。在《倚天屠龙记》这部武侠小说中，有很多帮派，比如：\n                    </p>\n                    <p data-nodeid=\"35103\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZN2AGezPAABjCi7FK4I525.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"35481\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35104\">\n                      其中张无忌、谢逊、韦一笑属于明教，而张三丰、莫声谷、宋远桥属于武当派。\n                    </p>\n                    <h4 data-nodeid=\"35105\">方法 1</h4>\n                    <p data-nodeid=\"35106\">\n                      我们首先设计这样一种方案：采用数组/哈希的方法，记录每个人所在的门派。伪代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 伪代码</span>\n</div></li><li><div class=\"code-word\">Map&lt;String, String&gt; = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n</div></li><li><div class=\"code-word\">H[<span class=\"hljs-string\">\"谢逊\"</span>] = <span class=\"hljs-string\">\"明教\"</span>\n</div></li><li><div class=\"code-word\">H[<span class=\"hljs-string\">\"张无忌\"</span>] = <span class=\"hljs-string\">\"明教\"</span>\n</div></li><li><div class=\"code-word\">H[<span class=\"hljs-string\">\"韦一笑\"</span>] = <span class=\"hljs-string\">\"明教\"</span>\n</div></li><li><div class=\"code-word\">H[<span class=\"hljs-string\">\"莫声谷\"</span>] = <span class=\"hljs-string\">\"武当\"</span>\n</div></li><li><div class=\"code-word\">H[<span class=\"hljs-string\">\"张三丰\"</span>] = <span class=\"hljs-string\">\"武当\"</span>\n</div></li><li><div class=\"code-word\">H[<span class=\"hljs-string\">\"宋远桥\"</span>] = <span class=\"hljs-string\">\"武当\"</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35108\">那么就可以这样查询：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">String <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(String person)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> H.get(person);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35110\">\n                      至此，我们已经完成一个功能了。时间复杂度也很低，可以达到\n                      O(1)。\n                    </p>\n                    <p data-nodeid=\"35111\">\n                      那我们再看一下合并。假设某一天，张三丰要闭关修炼，决定将武当派暂时交给张无忌代管理，为了方便管理两个帮派，张无忌号令明教的人前往武当派。那么此时就需要进行一个合并\n                      Union 操作，也就是将所有“明教”的人归入“武当”。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(String A, String B)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (item : H) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> item.value == <span class=\"hljs-string\">\"明教\"</span>:\n</div></li><li><div class=\"code-word\">      item.value = <span class=\"hljs-string\">\"武当\"</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35113\">\n                      但是如此一来，整个时间复杂度就上去了，Union\n                      的时候，时间复杂度变成 O(N)。如果 Union\n                      操作很频繁，那么这种算法就变得不可接受。\n                    </p>\n                    <h4 data-nodeid=\"35114\">方法 2</h4>\n                    <p data-nodeid=\"35115\">\n                      在这里我们换一种思路，看看能不能解决 Union\n                      复杂度过高的问题。采用江湖中通常的做法，认帮主！当帮主一样的时候，就认为我们是一个帮派的。\n                    </p>\n                    <p data-nodeid=\"35116\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZOaADgCUAABGlTOU4Ak099.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"35493\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35117\">\n                      每个人都指向自己的大哥，帮主最牛，指向帮主自己。那么要进行\n                      Union 操作的时候。直接修改指针就可以了。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(String A, String B)</span> </span>{\n</div></li><li><div class=\"code-word\">  String A帮主 = Find(A);\n</div></li><li><div class=\"code-word\">  String B帮主 = Find(B);\n</div></li><li><div class=\"code-word\">  H.put(A帮主, B帮主); <span class=\"hljs-comment\">// 成功将A所在帮派归入B帮派</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35119\">\n                      在 Union 的最后，我们只需要将 A 帮主指向 B\n                      帮主就可以了。比如，将明教与武当合并，如下图所示：\n                    </p>\n                    <p data-nodeid=\"35120\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZO6APF37AABG3_a_Q6c057.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"35498\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35121\">\n                      我们再看一下 Find 函数，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 返回A的帮主</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">String <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(String A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (A != H.get(A)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果我还有大哥，那么就顺着大哥一路往上找</span>\n</div></li><li><div class=\"code-word\">    A = H.get(A);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 最终找到了帮主</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> A;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35123\">\n                      虽然这种办法在 Union 时比较方便，但是在 Find\n                      时却容易引入较高的复杂度。下面我们一起来看一下为什么 Find\n                      起来比较麻烦：\n                    </p>\n                    <p data-nodeid=\"35124\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZQSANG0HAAUZirp5p1k748.gif\"\n                        alt=\"1 (1).gif\"\n                        data-nodeid=\"35503\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35125\">\n                      在这种情况下，Find 查询时，总是会查询很多次\n                      O(N)。也就是说，Union 的时间复杂度较低的时候，Find\n                      的时间复杂度又上升了。\n                    </p>\n                    <p data-nodeid=\"35126\">\n                      那么，有没有更好一点的办法呢？能让 Union 和 Find\n                      的时间复杂度都低一点。\n                    </p>\n                    <h4 data-nodeid=\"35127\">路径压缩</h4>\n                    <p data-nodeid=\"35128\">\n                      办法还是有的，就叫<strong data-nodeid=\"35512\"\n                        >路径压缩</strong\n                      >，我们发现，在方法 2 中，如果能将层级结构“拍扁”，那么\n                      Find 和 Union 的时间复杂度都会特别低。\n                    </p>\n                    <p data-nodeid=\"35129\">\n                      因此，我们还需要在 Find\n                      函数里面做一些手脚。当我们找到一帮主之后，就把这条路径上的所有人的大哥都改成帮主。代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">String <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(String A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// start记为出发点</span>\n</div></li><li><div class=\"code-word\">  String start = A;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (A != H.get(A)) {\n</div></li><li><div class=\"code-word\">    A = H.get(A);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 此时A是帮主</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 我们再从出发点开始，把每个人的大哥改成帮主</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 路径压缩的关键代码</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (H.get(start) != A) {\n</div></li><li><div class=\"code-word\">    String next = H.get(start);\n</div></li><li><div class=\"code-word\">    H.put(start, A);\n</div></li><li><div class=\"code-word\">    start = next;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> A;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35131\">\n                      再看这个例子：经过合并，成立糖葫芦帮之后。如下图所示：\n                    </p>\n                    <p data-nodeid=\"35132\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/23/F4/CioPOWBX_4mAPpHfAABECA7Vc3g627.png\"\n                        alt=\"image.png\"\n                        data-nodeid=\"35517\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35133\">\n                      如果一旦执行\n                      Find(\"韦一笑\")，那么糖葫芦帮派就会变成大饼帮派。\n                    </p>\n                    <p data-nodeid=\"35134\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZgaAOFDCAABeZqcuW0s773.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"35525\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35135\">\n                      所有人的帮主都会指向张三丰。也就是说，除了第一次 Find\n                      复杂度为 O(N)，后面的查询复杂度都是\n                      O(1)。至此，我们已经讲清楚带路径压缩的并查集的原理。接下来我们看代码如何实现。\n                    </p>\n                    <h3 data-nodeid=\"35136\">并查集模板</h3>\n                    <p data-nodeid=\"35137\">\n                      前面使用的都是比较形式化的语言和伪代码。接下来我们看一下具体如何实现并查集。这里我<strong\n                        data-nodeid=\"35533\"\n                        >以整数替换前面的人名</strong\n                      >，操作起来更加方便。\n                    </p>\n                    <h4 data-nodeid=\"35138\">初始化</h4>\n                    <p data-nodeid=\"35139\">\n                      首先假设有 N 个整数，范围为 [0,\n                      N)。那么记录每个人的信息，就需要一个长度为 N 的数组。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> F[N]; <span class=\"hljs-comment\">// 记录每个人的大哥是谁</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35141\">\n                      在初始化的时候，每个人都是自成一派。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">  F[i] = i;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"35143\">查询</h4>\n                    <p data-nodeid=\"35144\">\n                      根据前面所讲，可以得到查询操作的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 查找根结点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> b = x;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (F[x] != x) {\n</div></li><li><div class=\"code-word\">    x = F[x];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 路径压缩的实现</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 将路径上的每个点指向根结点x</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (F[b] != x) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> p = F[b];\n</div></li><li><div class=\"code-word\">    F[b] = x;\n</div></li><li><div class=\"code-word\">    b = p;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"35146\">合并</h4>\n                    <p data-nodeid=\"35147\">\n                      完成查询操作，我们就要把两个集合进行合并，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{\n</div></li><li><div class=\"code-word\">  F[find(x)] = find(y);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35149\">\n                      这两个函数的代码还是显得有点长，并且不太容易记。我在刷题和面试时，更喜欢，或者说常用一份精简过的代码。下面我将分享给你。\n                    </p>\n                    <h4 data-nodeid=\"35150\">两行代码</h4>\n                    <p data-nodeid=\"35151\">\n                      这里我整理了：<strong data-nodeid=\"35553\">两行</strong\n                      >并查集核心代码模板（用 C 语言实现，<strong\n                        data-nodeid=\"35554\"\n                        >方便记忆）：</strong\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"c++\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> F[N];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\"> <span class=\"hljs-keyword\">return</span> x == F[x] ? x : F[x] = Find(F[x]); <span class=\"hljs-comment\">// &lt;-- 1. 查找</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{\n</div></li><li><div class=\"code-word\">  F[<span class=\"hljs-built_in\">find</span>(x)] = <span class=\"hljs-built_in\">find</span>(y); <span class=\"hljs-comment\">// &lt;- 2. 合并</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35153\">\n                      注：根据不同的语言，你可能需要修改不同的 Find 函数。\n                    </p>\n                    <h4 data-nodeid=\"35154\">两个功能</h4>\n                    <p data-nodeid=\"35155\">\n                      当真正使用并查集的时候，面试官可能会问你两个问题：\n                    </p>\n                    <ul data-nodeid=\"35156\">\n                      <li data-nodeid=\"35157\">\n                        <p data-nodeid=\"35158\">有多少个集合？</p>\n                      </li>\n                      <li data-nodeid=\"35159\">\n                        <p data-nodeid=\"35160\">每个集合里面有多少个元素？</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35161\">下面我们依次回答这两个问题。</p>\n                    <p data-nodeid=\"35162\">\n                      <strong data-nodeid=\"35569\">1</strong>.\n                      <strong data-nodeid=\"35570\">集合数目</strong>：在执行 Find\n                      的时候，集合个数不可能有变化。如果发生变化，只可能发生在两个集合合并的时候。\n                    </p>\n                    <p data-nodeid=\"35163\">再来具体看一下初始化和合并操作。</p>\n                    <ul data-nodeid=\"35164\">\n                      <li data-nodeid=\"35165\">\n                        <p data-nodeid=\"35166\">\n                          初始化：在并查集开始初始化的时候，一共有 N\n                          个元素，那么一开始集合个数为 N。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35167\">\n                        <p data-nodeid=\"35168\">\n                          合并：合并的时候，需要查看合并的两个集合是不是同一个，如果不是，那么集合个数减\n                          1。<br />\n                          <strong data-nodeid=\"35583\">2</strong>.\n                          <strong data-nodeid=\"35584\"\n                            >每个集合中元素的个数</strong\n                          >：在执行 Find\n                          的时候，每个集合中元素的个数不可能发生变化。如果发生变化，只可能是两个集合合并的时候。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35169\">\n                      下面我们具体看一下初始化和合并操作。\n                    </p>\n                    <ul data-nodeid=\"35170\">\n                      <li data-nodeid=\"35171\">\n                        <p data-nodeid=\"35172\">\n                          初始化：在并查集开始初始化的时候，每个元素都属于独立的元素，那么一开始每个集合里面的个数都是\n                          1。如果我们用 Count[]\n                          数组记录每个元素的个数，那么一开始初始化 Count[] = 1。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35173\">\n                        <p data-nodeid=\"35174\">\n                          合并：当 A 集合要合并到 B 集合里面的时候，可以认为 A\n                          集合里面所有的元素都变成 B 集合里面的元素。当然是 B\n                          集合里面的个数增加了，那么 Count[Find(B)] + =\n                          Count[Find(A)]。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35175\">\n                      <strong data-nodeid=\"35622\">注意</strong\n                      >：在记录集合中元素个数的时候，<strong data-nodeid=\"35623\"\n                        >只有根结点的信息是准确的</strong\n                      >。当查询结点i所属集合的信息时，只能使用\n                      Count[Find(i)]，而不能使用 Count[i]。因为如果要保证每个点\n                      Count[i]\n                      的信息都是准确的，那么每次合并的时候，整个集合中的元素的信息都要更新，这样时间复杂度就很高了，Union\n                      操作的时间复杂度就不再是O(lgN)，而变成O(N)。\n                    </p>\n                    <p data-nodeid=\"35176\">\n                      为了方便你刷题和应对面试，这里我给出了并查集的完整代码，你可以作为参考。\n                    </p>\n                    <h4 data-nodeid=\"35177\">完整 Java 代码</h4>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 并查集数组</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 记录并查集中集合的个数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 记录集合中点的个数，比如要知道i所在集合的点有多少个: C[Find(i)]</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 注意：这里不能直接使用C[i]</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 因为只有根结点的统计才是正确的</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] Cnt = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 并查集的初始化</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">  F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];\n</div></li><li><div class=\"code-word\">  Cnt = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\n</div></li><li><div class=\"code-word\">    F[i] = i;\n</div></li><li><div class=\"code-word\">    Cnt[i] = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  count = n;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (x == F[x]) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  F[x] = Find(F[x]);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> F[x];\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> xpar = Find(x);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> ypar = Find(y);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 将x所在集合，合并到y所在集合</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (xpar != ypar) {\n</div></li><li><div class=\"code-word\">    F[xpar] = ypar;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// y集合里面的个数要增加</span>\n</div></li><li><div class=\"code-word\">    Cnt[ypar] += Cnt[xpar];\n</div></li><li><div class=\"code-word\">    count--;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Size</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> Cnt[Find(i)];\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35179\">\n                      注：这里是以<strong data-nodeid=\"35635\">整数</strong\n                      >和<strong data-nodeid=\"35636\">数组</strong\n                      >为例。如果关键字是\n                      String，也可以使用哈希表将字符串映射到整数再进行并查集的操作。\n                    </p>\n                    <blockquote data-nodeid=\"35180\">\n                      <p data-nodeid=\"35181\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35640\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35644\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35648\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35182\">\n                      <strong data-nodeid=\"35653\">复杂度分析</strong\n                      >：并查集的初始化时间复杂度为 O(N)，而 Find 和 Union\n                      的操作时间复杂度都是 O(lgN)，其中 N\n                      为点的总数。这里只使用了长度为 N 的数组，所以空间复杂度为\n                      O(2N)。\n                    </p>\n                    <h4 data-nodeid=\"35183\">例 1：最小生成树</h4>\n                    <p data-nodeid=\"35184\">\n                      【<strong data-nodeid=\"35660\">题目</strong\n                      >】给定一个图的点集，边集和权重，返回构建最小生成树的代价。\n                    </p>\n                    <p data-nodeid=\"35185\">\n                      输入：N = 2， conn = [[1, 2, 37], [2, 1, 17], [1, 2, 68]]\n                    </p>\n                    <p data-nodeid=\"35186\">输出：17</p>\n                    <p data-nodeid=\"35187\">\n                      <strong data-nodeid=\"35687\">解释</strong>：图中只有两个点\n                      [1, 2]，当然是选择最小连接 [2, 1, 17]\n                    </p>\n                    <p data-nodeid=\"35188\">\n                      【<strong data-nodeid=\"35701\">分析</strong>】利用并查集 +\n                      贪心算法，可以生成一个图的<strong data-nodeid=\"35703\"\n                        >最小生成树，<strong data-nodeid=\"35702\"\n                          >这种方法也被称为</strong\n                        >\n                        Kruskal 算法</strong\n                      >。并查集可以用来将两个点进行 Union，不过在并查集的 Union\n                      代码中，并没有权重这一项，那我们该怎么办呢？\n                    </p>\n                    <p data-nodeid=\"35189\">\n                      在 Union\n                      的时候，就直接根据边的权重来排序，然后再处理，这不就是经典的\n                      <strong data-nodeid=\"35709\">Kruskal 算法</strong>。\n                    </p>\n                    <p data-nodeid=\"35190\">\n                      这里我们可以讲一下最小生成树的思路：\n                    </p>\n                    <ul data-nodeid=\"35191\">\n                      <li data-nodeid=\"35192\">\n                        <p data-nodeid=\"35193\">首先初始化并查集</p>\n                      </li>\n                      <li data-nodeid=\"35194\">\n                        <p data-nodeid=\"35195\">\n                          将边集<strong data-nodeid=\"35716\"\n                            >按照权重排序</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35196\">\n                        <p data-nodeid=\"35197\">\n                          利用边集将不同的两点进行 Union\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35198\">\n                        <p data-nodeid=\"35199\">\n                          将不同的集合进行 Union\n                          时需要加上新加入的边的代价（即边的权重）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35200\">\n                      【<strong data-nodeid=\"35724\">代码</strong\n                      >】这里我们可以写出经典的 Kruskal\n                      算法，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">long</span> cost = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里直接申请了足够多的内存</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 并查集初始化</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 注意点的编号是从1~n</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">    F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n+<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= n; i++) {\n</div></li><li><div class=\"code-word\">      F[i] = i;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    cost = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (x == F[x]) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    F[x] = Find(F[x]);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> F[x];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 在合并的时候，需要加上代价</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y, <span class=\"hljs-keyword\">int</span> pay)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (Find(x) != Find(y)) cost += pay;\n</div></li><li><div class=\"code-word\">    F[Find(x)] = Find(y);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 一共有n个点，编号从1~n</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// conn表示输入的边的集合</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 每一项是一个三元组[点a, 点b, 需要费用c]</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">Kruskal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> m, <span class=\"hljs-keyword\">int</span>[][] conn)</span> </span>{\n</div></li><li><div class=\"code-word\">    Init(n);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 边集的排序</span>\n</div></li><li><div class=\"code-word\">    Arrays.sort(conn, <span class=\"hljs-number\">0</span>, m, <span class=\"hljs-keyword\">new</span> Comparator&lt;<span class=\"hljs-keyword\">int</span>[]&gt;() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] b)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> a[<span class=\"hljs-number\">2</span>] - b[<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 顺次将边集添加到集合中</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++) {\n</div></li><li><div class=\"code-word\">      Union(conn[i][<span class=\"hljs-number\">0</span>], conn[i][<span class=\"hljs-number\">1</span>], conn[i][<span class=\"hljs-number\">2</span>]);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> cost;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n\n                    <blockquote data-nodeid=\"35202\">\n                      <p data-nodeid=\"35203\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35728\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35732\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35736\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35204\">\n                      <strong data-nodeid=\"35741\">复杂度分析</strong\n                      >：程序主要分为两块，一部分为边集 E 的排序，复杂度为\n                      O(ElgE)；另外一部分为每条边的 Union 操作，复杂度为\n                      O(ElgN)。在大部分时候，边的数目往往比点的数目要多，因此时间复杂度为\n                      O(ElgE)。\n                    </p>\n                    <p data-nodeid=\"35205\">\n                      【<strong data-nodeid=\"35747\">小结</strong>】本质上\n                      Kruskal 算法就是并查集算法 + 贪心算法。使用 Kruskal\n                      算法有一个很重要的前提——题目是假设输入边能将所有的点加到一个连通域中，也就是保证最后必然能够生成一棵树。\n                    </p>\n                    <p data-nodeid=\"35206\">\n                      这里给你留一道练习题，你可以利用它检验和巩固自己的学习成果。\n                    </p>\n                    <p data-nodeid=\"35207\">\n                      <strong data-nodeid=\"35755\">练习题 1</strong\n                      >：给定点集和边集，求最小生成树的代价，如果最后不能生成最小生成树，那么返回MAX_INT。\n                    </p>\n                    <blockquote data-nodeid=\"35208\">\n                      <p data-nodeid=\"35209\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35759\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35763\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35767\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35210\">\n                      接下来我们一起看一下关于并查集的其他考察形式与考点。\n                    </p>\n                    <h3 data-nodeid=\"35211\">连通域的数目</h3>\n                    <p data-nodeid=\"35212\">\n                      我们可以把最小生成树当成一个连通域，只不过需要用最小的代价来生成这么一个连通域。除了求解最小生成树，并查集的另外一个常见的用途是求解连通域的数目。在<strong\n                        data-nodeid=\"35775\"\n                        >微软和 EMC</strong\n                      >\n                      的面试中都出现过，但是可能会通过两种方式给出图的结构，比如：\n                    </p>\n                    <ul data-nodeid=\"35213\">\n                      <li data-nodeid=\"35214\">\n                        <p data-nodeid=\"35215\">\n                          点集和边集，告诉你有哪些点，以及哪些边；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35216\">\n                        <p data-nodeid=\"35217\">矩阵表示。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35218\">\n                      不管是通过哪一种图表示，利用<strong data-nodeid=\"35783\"\n                        >并查集解决连通域数目的步骤都是以下两步</strong\n                      >：\n                    </p>\n                    <ol data-nodeid=\"35219\">\n                      <li data-nodeid=\"35220\">\n                        <p data-nodeid=\"35221\">用 F[] 数组和点集进行初始化</p>\n                      </li>\n                      <li data-nodeid=\"35222\">\n                        <p data-nodeid=\"35223\">利用边集进行 Union</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"35224\">最后的集合数目就是连通域的数目。</p>\n                    <p data-nodeid=\"35225\">\n                      利用本讲前面学过的模板和思路，相信你已经可以解决面试中的高频出现的算法题了。\n                    </p>\n                    <h4 data-nodeid=\"35226\">例 2：帮派的数目</h4>\n                    <p data-nodeid=\"35227\">\n                      【<strong data-nodeid=\"35803\">题目</strong>】江湖上有 N\n                      个人，编号从 [1 ~\n                      N]，现在只能告诉你，其中两人是一个帮派的，请你输出帮派的数目。\n                    </p>\n                    <p data-nodeid=\"35228\">输入：N = 4, [[1, 2], [2,3]]</p>\n                    <p data-nodeid=\"35229\">输出：2</p>\n                    <p data-nodeid=\"35230\">\n                      <strong data-nodeid=\"35827\">解释</strong>：一共有 4\n                      个人，[1,2, 3] 成为一个帮派，[4]\n                      独自成为一个帮派，那么一共有 2 个帮派。\n                    </p>\n                    <p data-nodeid=\"35231\">\n                      【<strong data-nodeid=\"35833\">分析</strong\n                      >】在一开始，你可以认为他们都是独自成为一个帮派，当告诉你每两个人是一个帮派时，相当于要把这两个人合并到一个集合中。问题是一共有多少个帮派，显然这就是一个非常标准的并查集的问题了。我们可以直接套用前面所讲的并查集的模板进行求解。\n                    </p>\n                    <p data-nodeid=\"35232\">\n                      【<strong data-nodeid=\"35839\">代码</strong\n                      >】直接利用并查集的代码模板，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">  F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n + <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= n; i++) {\n</div></li><li><div class=\"code-word\">    F[i] = i;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  count = n;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (x == F[x]) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  F[x] = Find(F[x]);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> F[x];\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (Find(x) != Find(y))\n</div></li><li><div class=\"code-word\">    count--;\n</div></li><li><div class=\"code-word\">  F[Find(x)] = Find(y);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">findGangNumber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span>[][] conn)</span> </span>{\n</div></li><li><div class=\"code-word\">  Init(n);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> m = conn.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++) {\n</div></li><li><div class=\"code-word\">    Union(conn[i][<span class=\"hljs-number\">0</span>], conn[i][<span class=\"hljs-number\">1</span>]);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 帮派里面帮主的个数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> count;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"35234\">\n                      <p data-nodeid=\"35235\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35843\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35847\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35851\"\n                          >Python</a\n                        ><br />\n                        <strong data-nodeid=\"35857\">复杂度分析</strong\n                        >：整个算法的时间复杂度为 O(mlogN) ，这里 n\n                        表示人的数目，而 m 表示两两成对的输入数目。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35236\">\n                      【<strong data-nodeid=\"35863\">小结</strong\n                      >】在这里我们直接利用并查集的模板搞定了一道题目。\n                    </p>\n                    <p data-nodeid=\"35237\">\n                      <strong data-nodeid=\"35868\">延伸</strong\n                      >：如果将这里的每个点都当成一个“图”结构中的一个点，将两两成对的输入当成“图”结构中的边。那么问题就变成了求解图的连通域个数。\n                    </p>\n                    <p data-nodeid=\"35238\">\n                      下面我们一起来看一下这个曾经在<strong data-nodeid=\"35874\"\n                        >微软</strong\n                      >的电面中出现的 2 道题目。\n                    </p>\n                    <p data-nodeid=\"35239\">\n                      <strong data-nodeid=\"35887\">练习题 2</strong\n                      >：给定一个黑白图像，其中白色像素用 '1' 表示，黑色像素用\n                      '0'\n                      表示。如果把上下左右相邻的白色像素看成一个连通域，给定一幅图（用矩阵表示），请问图中有几个连通域。\n                    </p>\n                    <p data-nodeid=\"35240\">\n                      输入：A = [['1', '1', '0'], ['0', '1', '0']]\n                    </p>\n                    <p data-nodeid=\"35241\">输出：1</p>\n                    <p data-nodeid=\"35242\">\n                      <strong data-nodeid=\"35927\">解释</strong>：图中所有的 '1'\n                      都是连在一起的，所以只有一个连通域。\n                    </p>\n                    <blockquote data-nodeid=\"35243\">\n                      <p data-nodeid=\"35244\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35931\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35935\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35939\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35245\">\n                      <strong data-nodeid=\"35951\">练习题 3</strong\n                      >：给定一个图（不是图像）的矩阵，A[i][j] = 1 表示点 i 与点\n                      j 相连，求这个图里面连通域的数目。\n                    </p>\n                    <p data-nodeid=\"35246\">\n                      输入：A = [[1,0,0],[0,1,0],[0,0,1]]\n                    </p>\n                    <p data-nodeid=\"35247\">输出：3</p>\n                    <p data-nodeid=\"35248\">\n                      <strong data-nodeid=\"35975\">解释</strong>：[0, 1, 2]\n                      三个点中，每个点都不与其他点相连，所以连通域有 3 个。\n                    </p>\n                    <blockquote data-nodeid=\"35249\">\n                      <p data-nodeid=\"35250\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35979\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35983\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"35987\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"35251\">例 3: 换工位</h4>\n                    <p data-nodeid=\"35252\">\n                      【<strong data-nodeid=\"36019\">题目</strong\n                      >】因为要实施结对编程，想让两个员工的工位挨在一起：要求\n                      [0,1] 员工坐在一起，[2, 3]\n                      员工坐在一起，以此类推。不过挨着具体坐的位置并不重要，只要能挨在一起就可以了。比如\n                      [0, 1, 3, 2] 与 [2, 3, 1, 0]\n                      都是满足要求的。现在给定一个数组\n                      A[]，求换工位的最少次数，尽量让两个员工坐在一起。（给定 N\n                      个员工，他们的编号总是 [0~N-1] ，并且 N 总是偶数）。\n                    </p>\n                    <p data-nodeid=\"35253\">输入：A[] = [0, 3, 2, 1]</p>\n                    <p data-nodeid=\"35254\">输出：1</p>\n                    <p data-nodeid=\"35255\">\n                      <strong data-nodeid=\"36032\">解释</strong>：只需要换 1\n                      次就可以了，比如，将 0 号员工与 2 号员工交换。\n                    </p>\n                    <p data-nodeid=\"35256\">\n                      【<strong data-nodeid=\"36038\">分析</strong\n                      >】初看这道题的时候，没有什么思路，那么我们进行一下模拟，看看能不能发现什么规律。\n                    </p>\n                    <p data-nodeid=\"35257\">\n                      <strong data-nodeid=\"36046\">1</strong>.\n                      <strong data-nodeid=\"36047\">模拟</strong>\n                    </p>\n                    <p data-nodeid=\"35258\">\n                      当 N = 2 时，无论是 [0, 1] 还是 [1, 0]\n                      这两种排列都满足要求，因为我们总是想让 [0, 1]\n                      这两个员工坐在一起，而只有两个员工时，他们总是挨在一起的。假设结对成功的两个人坐在一起的时候，就像做在链条上的环一样。\n                    </p>\n                    <p data-nodeid=\"35259\">\n                      由于 N 必须为偶数，所以接下来我们看一下 N = 4\n                      时的情况。比如 A = [0, 3, 2, 1]，此时 4\n                      个人都没有结对成功，相当于两个环还扣一起。\n                    </p>\n                    <p data-nodeid=\"35260\">\n                      这时我们只需要交换 0, 2 形成\n                      [2,3,0,1]，如果按配对划分，那就是 [2, 3] 和 [0,\n                      1]。结对成功之后，这两个环就可以拆开了。操作如下图所示：\n                    </p>\n                    <p data-nodeid=\"35261\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZpeADOaKAADoS6Y44b0977.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"36081\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35262\">\n                      通过这个示例，还可以发现，如果不经过交换，虽然 [3, 2]\n                      这两个员工已经坐在一起了，但是不操作，那么 0 号员工和 1\n                      号员工是无法结对编程的。\n                    </p>\n                    <p data-nodeid=\"35263\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZqCAfrFNAACU4aaiqjc231.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"36089\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35264\">\n                      因此，我们可以得到<strong data-nodeid=\"36111\"\n                        >结论\n                        1：结对的时候，数组中只能偶数下标与奇数下标配比</strong\n                      >。比如 A[0] 与 A[1]\n                      结对。不能奇数下标与偶数下标结对，比如 A[1] 与 A[2] 结对。\n                    </p>\n                    <p data-nodeid=\"35265\">\n                      接下来我们再看一下 N = 6 的情况， 比如 A = [0, 2, 3, 5, 1,\n                      4]：我们在执行交换的时候，可以这样操作：\n                    </p>\n                    <p data-nodeid=\"35266\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZqqADNgZAAU5MW4PWoI242.gif\"\n                        alt=\"2 (1).gif\"\n                        data-nodeid=\"36119\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35267\">\n                      所以成功切分出三个配对集合 [0, 1], [3, 2], [5, 4]，需要 2\n                      步。\n                    </p>\n                    <p data-nodeid=\"35268\">\n                      <strong data-nodeid=\"36140\">2</strong>.\n                      <strong data-nodeid=\"36141\">规律</strong>\n                    </p>\n                    <p data-nodeid=\"35269\">\n                      通过前面的模拟，我们还需要进一步的总结规律。将里面没有成功结对的序列看成一条锁链。并且拆分出结对成功的两个元素，独立位于一个环中，并不与别人相扣在一起。\n                    </p>\n                    <p data-nodeid=\"35270\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZrSALzFBAADhm_fwnRk393.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"36145\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35271\">\n                      每 1\n                      次操作，交换两个元素，就相当于从锁链中成功拆一个环下来。\n                    </p>\n                    <p data-nodeid=\"35272\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZryASSNEAAEb64nhdKE214.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"36149\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35273\">\n                      那么，我们可以得到<strong data-nodeid=\"36155\"\n                        >结论 2：有 2x 个元素，也就是 x 个环的锁链，就需要 x-1\n                        次操作</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"35274\">\n                      至此，我们就将题目成功变成了：给定一个数组，需要找到里面有几条锁链。比如给定数组\n                      A = [6, 4, 5, 2, 3, 7, 0, 1]。\n                    </p>\n                    <p data-nodeid=\"35275\">\n                      此时应该可以分出两条锁链来，如下图所示：\n                    </p>\n                    <p data-nodeid=\"35276\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZsWAPW0xAADZQU20JEU856.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"36164\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35277\">\n                      我们再看每个锁链中的环的数目就可以得到最少操作次数。比如这里的\n                      A[] 数组有 2 条锁链，需要的操作次数是 (3 - 1) + (1-1) =\n                      2。也就是最少操作 2 次。\n                    </p>\n                    <p data-nodeid=\"35278\">\n                      那么现在问题的关键就是，如何才能通过数组得到锁链呢？这里我们还发现一个有趣的<strong\n                        data-nodeid=\"36174\"\n                        >结论 3：本就结对的两个员工必然在同一个链条中</strong\n                      >。比如 6 和 5 在没有结对的情况下，也必然在同一条锁链中。\n                    </p>\n                    <p data-nodeid=\"35279\">\n                      <strong data-nodeid=\"36182\">3</strong>.\n                      <strong data-nodeid=\"36183\">匹配</strong>\n                    </p>\n                    <p data-nodeid=\"35280\">\n                      如果将锁链当成集合，就可以对应到并查集了。这里再细化一下：\n                    </p>\n                    <ul data-nodeid=\"35281\">\n                      <li data-nodeid=\"35282\">\n                        <p data-nodeid=\"35283\">\n                          通过结论 3，我们应该将一个偶数 x 以及和它配对的数 x+1\n                          先放到同一个集合中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35284\">\n                        <p data-nodeid=\"35285\">\n                          偶数下标 A[i]，需要与 A[i+1] 进行\n                          Union，完成放到同一个锁链的操作。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35286\">\n                      虽然最后我们可以通过去数锁链中环的个数，再通过结论 2\n                      得到答案。但是如果你能想到拆环的次数，实际上就是不同集合\n                      Union 的次数。那么求解的时候，只需要在并查集模板的基础上对\n                      Union 稍做更改就可以了。\n                    </p>\n                    <p data-nodeid=\"35287\">\n                      <strong data-nodeid=\"36203\">4</strong>.\n                      <strong data-nodeid=\"36204\">边界</strong>\n                    </p>\n                    <p data-nodeid=\"35288\">\n                      注意处理空数组，注意结对的时候，要满足结论 1。\n                    </p>\n                    <p data-nodeid=\"35289\">\n                      【<strong data-nodeid=\"36215\">画图</strong\n                      >】接下来我们画图演示一下使用并查集的过程。这里我们以数组\n                      A = [6, 4, 5, 2, 3, 7, 0, 1] 为例。\n                    </p>\n                    <p data-nodeid=\"35290\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZteAaZlrABz3L57gQK4855.gif\"\n                        alt=\"3.gif\"\n                        data-nodeid=\"36218\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35291\">\n                      我们发现，不同集合的合并次数一共为 2 次，所以只需要 2\n                      次操作就可以完成结对编程的要求。\n                    </p>\n                    <p data-nodeid=\"35292\">\n                      【<strong data-nodeid=\"36225\">代码</strong\n                      >】接下来我们可以写一下代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> unionCount = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">  F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意这里在初始化的时候</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// [0, 1]需要处在一个集合里面</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 无论他们在数组里面是不是相邻</span>\n</div></li><li><div class=\"code-word\">    F[i] = i - (i &amp; <span class=\"hljs-number\">0x01</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (x == F[x]) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  F[x] = Find(F[x]);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> F[x];\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (Find(x) != Find(y)) {\n</div></li><li><div class=\"code-word\">    unionCount++;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  F[Find(x)] = Find(y);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minSwapsCouples</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  Init(N);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i += <span class=\"hljs-number\">2</span>) {\n</div></li><li><div class=\"code-word\">    Union(A[i], A[i + <span class=\"hljs-number\">1</span>]);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> unionCount;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"35294\">\n                      <p data-nodeid=\"35295\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36229\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36233\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36237\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35296\">\n                      <strong data-nodeid=\"36242\">复杂度分析</strong>：一共有\n                      N/2 对元素要合并，每次合并的时间复杂度为\n                      O(lgN)。所以时间复杂度为 O(NlgN)。\n                    </p>\n                    <p data-nodeid=\"35297\">\n                      【<strong data-nodeid=\"36248\">小结</strong\n                      >】在这里，我们学习了将锁链处理成一个连通域，并且巧妙地通过求解合并次数解决了最小操作次数。\n                    </p>\n                    <p data-nodeid=\"35298\">\n                      我认为这道题目最核心的考点是分析出<strong\n                        data-nodeid=\"36258\"\n                        >结论 2</strong\n                      >：<strong data-nodeid=\"36259\"\n                        >有 2x 个元素，也就是 x 个环的锁链，就需要 x-1\n                        次操作</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"35299\">\n                      一旦得到了每条锁链中的操作次数，然后利用并查集的模板，这道题目就解决了。我再给你留道练习题，希望你可以尝试做一下。\n                    </p>\n                    <p data-nodeid=\"35300\">\n                      <strong data-nodeid=\"36265\">练习题 4</strong\n                      >：给定一个单词数组，如果两个单词相等，或者说其中一个单词\n                      A 经过一次字符交换，可以得到单词 B，那么我们说单词 {A, B}\n                      是同构的。请问单词数组中，一共有多少组这样的同构集合？\n                    </p>\n                    <p data-nodeid=\"35301\">\n                      输入：{\"AB\", \"BA\", \"AB\", \"BC\", \"CD\"}\n                    </p>\n                    <p data-nodeid=\"35302\">输出：3</p>\n                    <p data-nodeid=\"35303\">\n                      <strong data-nodeid=\"36312\">解释</strong\n                      >：一共有三组同构集合，{\"AB\", \"BA\", \"AB\"}, {\"BC\"}, {\"CD\"}\n                    </p>\n                    <blockquote data-nodeid=\"35304\">\n                      <p data-nodeid=\"35305\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36316\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36320\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36324\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35306\">\n                      接下来我们讲解并查集的进一步运用。\n                    </p>\n                    <h3 data-nodeid=\"35307\">虚拟点与虚拟边</h3>\n                    <p data-nodeid=\"35308\">\n                      在求解连通域的过程中，我们经常利用现有的点与现有的边进行并查集的初始化与合并。\n                    </p>\n                    <p data-nodeid=\"35309\">\n                      但是在有些题目中，需要加入一些<strong data-nodeid=\"36333\"\n                        >虚拟的边和虚拟的点</strong\n                      >到并查集的点集与边集中。通过这种方式可以极大地方便我们使用并查集。\n                    </p>\n                    <h4 data-nodeid=\"35310\">例 4: 替换字母</h4>\n                    <p data-nodeid=\"35311\">\n                      【<strong data-nodeid=\"36360\">题目</strong>】给你一个矩阵\n                      A，里面只包含字母 ‘O’ 和 'X'，如果一个 'O'\n                      上下左右四周都被 'X' 包围，那么这个 'O' 会被替换成\n                      'X'。请你写程序处理一下这个过程。\n                    </p>\n                    <p data-nodeid=\"35312\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZumAF_CYAAA1NGN0dU0625.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"36363\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35313\">\n                      <strong data-nodeid=\"36387\">解释</strong>：由于中心的 'O'\n                      四周都被包围，所以需要被换成 'X'，而第 A[0][0] = 'O'\n                      靠着边，所以不能被替换。\n                    </p>\n                    <p data-nodeid=\"35314\">\n                      【<strong data-nodeid=\"36397\">分析</strong\n                      >】这道题目曾经在<strong data-nodeid=\"36398\">微软</strong\n                      >的面试中出现过。看起来就是一个连通域的问题，所以可以使用并查集来处理。思路如下：\n                    </p>\n                    <ul data-nodeid=\"35315\">\n                      <li data-nodeid=\"35316\">\n                        <p data-nodeid=\"35317\">\n                          首先用并查集标记所有 'O' 的连通域；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35318\">\n                        <p data-nodeid=\"35319\">\n                          将所有在边上的 'O' 的“帮主”放到 set 集合中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35320\">\n                        <p data-nodeid=\"35321\">\n                          遍历每个 'O' 的“帮主”，看看是不是在 set\n                          集合中，如果在，那么这个 'O' 不能替换。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35322\">\n                      可以发现，有一步操作可以优化：将所有在边上的 'O'\n                      的“帮主”放到 set 集合中，有两种办法：\n                    </p>\n                    <ul data-nodeid=\"35323\">\n                      <li data-nodeid=\"35324\">\n                        <p data-nodeid=\"35325\">\n                          随便选择边上的一个点，作为所有边上点的“帮主”；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35326\">\n                        <p data-nodeid=\"35327\">\n                          选一个虚拟的点，作为所有边上的点的“帮主”。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35328\">\n                      你可以根据自己的喜好任选其一，这里我用第 2\n                      种“虚拟点”的办法。下面就可以直接套用模板了。\n                    </p>\n                    <p data-nodeid=\"35329\">\n                      【<strong data-nodeid=\"36431\">代码</strong\n                      >】采用虚拟点的并查集的代码实现如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[][] dir = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>}};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">  F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\n</div></li><li><div class=\"code-word\">    F[i] = i;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (x == F[x]) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  F[x] = Find(F[x]);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> F[x];\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{ F[Find(x)] = Find(y); }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">solve</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[][] A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (A == <span class=\"hljs-keyword\">null</span> || A[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> R = A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> C = A[<span class=\"hljs-number\">0</span>].length;\n</div></li><li><div class=\"code-word\">  Init(R * C + <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 我们将vNode设置为R * C</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这是一个在矩阵中不存在的点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> vNode = R * C;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; R; r++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; C; c++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (A[r][c] == <span class=\"hljs-string\">'O'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果是边上的点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (r == <span class=\"hljs-number\">0</span> || r == R - <span class=\"hljs-number\">1</span> || c == <span class=\"hljs-number\">0</span> || c == C - <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 那么将其与vNode进行Union</span>\n</div></li><li><div class=\"code-word\">          Union(r * C + c, vNode);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 将其与四面的点进行Union</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-number\">0</span>; d &lt; <span class=\"hljs-number\">2</span>; d++) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nr = r + dir[d][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> nc = c + dir[d][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">if</span> (!(nr &lt; <span class=\"hljs-number\">0</span> || nr &gt;= R || nc &lt; <span class=\"hljs-number\">0</span> || nc &gt;= C)) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (A[nr][nc] == <span class=\"hljs-string\">'O'</span>) {\n</div></li><li><div class=\"code-word\">              Union(r * C + c, nr * C + nc);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 查看是不是和vNode一个集合，如果不是就要修改成'X'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = <span class=\"hljs-number\">0</span>; r &lt; R; r++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> c = <span class=\"hljs-number\">0</span>; c &lt; C; c++) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (A[r][c] == <span class=\"hljs-string\">'O'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (Find(r * C + c) != Find(vNode)) {\n</div></li><li><div class=\"code-word\">          A[r][c] = <span class=\"hljs-string\">'X'</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"35331\">\n                      <p data-nodeid=\"35332\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36435\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36439\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36443\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35333\">\n                      <strong data-nodeid=\"36452\">复杂度分析</strong\n                      >：由于每个点只遍历两遍。<strong data-nodeid=\"36453\"\n                        >所有点的数目为 N</strong\n                      >，所以时间复杂度为\n                      O(NlgN)，此外，每个点都记录了所在集合，所以空间复杂度为\n                      O(N)。\n                    </p>\n                    <p data-nodeid=\"35334\">\n                      【<strong data-nodeid=\"36459\">小结</strong\n                      >】在这里我们学习了一种新的处理技巧，那就是利用并查集 +\n                      虚拟结点，将原本不在一起的结点，统一放到了一个虚拟集合中。\n                    </p>\n                    <p data-nodeid=\"35335\">\n                      所以解决这道题目的考点我们可以总结如下：\n                    </p>\n                    <p data-nodeid=\"35336\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZvmACQxmAAC2H_g_eZk099.png\"\n                        alt=\"Drawing 15.png\"\n                        data-nodeid=\"36463\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35337\">\n                      在面试中，如果你有了并查集的模板，再加上虚拟点的思路，那么快速解决这类问题就轻而易举了。\n                    </p>\n                    <h4 data-nodeid=\"35338\">例 5：上网的最小费用</h4>\n                    <p data-nodeid=\"35339\">\n                      【<strong data-nodeid=\"36481\">题目</strong\n                      >】园区里面有很多大楼，编号从 1~N。第 i\n                      大楼可以自己花钱买路由器上网，费用为\n                      cost[i-1]，也可以从别的大楼拉一根网线来上网，比如大楼 a\n                      和大楼 b 之间拉网线的费用为 c，表示为一条边 [a, b,\n                      c]。输入为每个大楼自己买路由器和拉网线的费用，请问，让所有大楼都能够上网的最小费用是多少？上网具有联通性，只要与能够上网的大楼连通，即可上网。\n                    </p>\n                    <p data-nodeid=\"35340\">\n                      输入：cost = [1, 2, 3], edges = [[1,2,100], [2,3,3]]\n                    </p>\n                    <p data-nodeid=\"35341\">输出：6</p>\n                    <p data-nodeid=\"35342\">\n                      <strong data-nodeid=\"36509\">解释</strong>：最优方案是 1\n                      号大楼买路由器 cost[0] = 1，2 号楼买路由器 cost[1] =\n                      2，然后和 3 号楼之间可拉一根网线，费用为 3，所以一共花费 6\n                      元。如图（红色部分标记为费用 ）：\n                    </p>\n                    <p data-nodeid=\"35343\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZwOAOXuWAABVP6uBCvA003.png\"\n                        alt=\"Drawing 16.png\"\n                        data-nodeid=\"36512\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35344\">\n                      【<strong data-nodeid=\"36526\">分析</strong\n                      >】这是一道<strong data-nodeid=\"36527\">头条</strong\n                      >面试中出现过的题目。首先如果不考虑自己买路由器的情况，只依赖给定的边集构建这个图，且要求最小费用，这道题目就和最小生成树一模一样了。可是，这里与最小生成树不一样的地方在于：第\n                      i 大楼可以自己花钱买路由器上网，费用为 cost[i-1]。\n                    </p>\n                    <p data-nodeid=\"35345\">\n                      在最小生成树里面，可是没有说“自己买路由”这个操作。那怎么办？我们有什么方法可以转化一下吗？\n                    </p>\n                    <p data-nodeid=\"35346\">\n                      可以采用加入虚拟点的方法。首先假设有一个结点 0\n                      已经自己买了路由器，花费为 0\n                      元。而其他结点要自己买路由器，本质等价于与结点 0\n                      进行联通。只不过这个网线的费用，就是你自己买路由器的费用。\n                    </p>\n                    <p data-nodeid=\"35347\">\n                      比如，给定 3 个点，分别自己买路由器的费用为 [1, 2,\n                      3]。那么我们可以把图变成下图这样子：\n                    </p>\n                    <p data-nodeid=\"35348\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZwyAA5MpAABxWS4ICiA231.png\"\n                        alt=\"Drawing 17.png\"\n                        data-nodeid=\"36537\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35349\">\n                      也就是说，我们添加了一个虚拟结点 0，然后也添加了 3\n                      条虚拟边。这里虚拟的元素我们都用绿色表示。\n                    </p>\n                    <p data-nodeid=\"35350\">\n                      如果最后生成的连通图里面把 0~3\n                      这四个点都包含进去，那么所有的大楼肯定都是可以上网的。此时最小代价问题就可以用最小生成树的方法来解决了。\n                    </p>\n                    <p data-nodeid=\"35351\">\n                      【<strong data-nodeid=\"36547\">代码</strong\n                      >】到这里，相信你已经知道可以怎么写代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> totalCost = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 注意，编号是从1 ~ n</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">    F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n + <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= n; i++) {\n</div></li><li><div class=\"code-word\">      F[i] = i;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    totalCost = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (x == F[x]) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    F[x] = Find(F[x]);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> F[x];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y, <span class=\"hljs-keyword\">int</span> pay)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (Find(x) != Find(y)) {\n</div></li><li><div class=\"code-word\">      totalCost += pay;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    F[Find(x)] = Find(y);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// N 表示结点数目</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// cost[i-1]表示结点i自己买路由器的代价</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// es[x] = [a, b, c]表示大楼a,b之间拉网线的费用</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 输出所有大楼通网的最小费用</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minCostToSupplyWater</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> N, <span class=\"hljs-keyword\">int</span>[] cost, <span class=\"hljs-keyword\">int</span>[][] es)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 初始化并查集</span>\n</div></li><li><div class=\"code-word\">    Init(N);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 每个结点都要自己买路由器，那么我们可以认为这样</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 0号楼已经有网络了，可以用0费用上网</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// i号楼与0号楼拉网线，需要的费用是cost[i-1]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 那么这里就多了N条边</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[][] conn = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[es.length + N][<span class=\"hljs-number\">3</span>];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; es.length; i++) {\n</div></li><li><div class=\"code-word\">      conn[i][<span class=\"hljs-number\">0</span>] = es[i][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">      conn[i][<span class=\"hljs-number\">1</span>] = es[i][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">      conn[i][<span class=\"hljs-number\">2</span>] = es[i][<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> to = es.length;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= N; i++) {\n</div></li><li><div class=\"code-word\">      conn[to][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      conn[to][<span class=\"hljs-number\">1</span>] = i;\n</div></li><li><div class=\"code-word\">      conn[to][<span class=\"hljs-number\">2</span>] = cost[i - <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">      to++;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 接下来采用Krukal最小生成树算法</span>\n</div></li><li><div class=\"code-word\">    Arrays.sort(conn, <span class=\"hljs-keyword\">new</span> Comparator&lt;<span class=\"hljs-keyword\">int</span>[]&gt;() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] b)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> a[<span class=\"hljs-number\">2</span>] - b[<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; conn.length; i++) {\n</div></li><li><div class=\"code-word\">      Union(conn[i][<span class=\"hljs-number\">0</span>], conn[i][<span class=\"hljs-number\">1</span>], conn[i][<span class=\"hljs-number\">2</span>]);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> totalCost;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"35353\">\n                      <p data-nodeid=\"35354\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36551\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36555\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36559\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35355\">\n                      <strong data-nodeid=\"36564\">复杂度分析</strong>： 一共有 N\n                      个点，M 条边，N 个点进行 Find/Union 的时间复杂度为\n                      O(lgN)，所以总的时间复杂度为 M(lgN)。\n                    </p>\n                    <p data-nodeid=\"35356\">\n                      【<strong data-nodeid=\"36570\">小结</strong\n                      >】接下来我们从面试官的角度看一下，这道题的考点是什么：\n                    </p>\n                    <ul data-nodeid=\"35357\">\n                      <li data-nodeid=\"35358\">\n                        <p data-nodeid=\"35359\">\n                          将特殊条件转化为一般的条件，通过引入一些虚拟点，虚拟边来实现\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35360\">\n                        <p data-nodeid=\"35361\">并查集的模板代码</p>\n                      </li>\n                      <li data-nodeid=\"35362\">\n                        <p data-nodeid=\"35363\">最小生成树的 Kruskal 算法</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35364\">\n                      如果在面试中抓住了这 3\n                      个点，就很容易击破这道算法题。接下来我们看一下并查集的另外一个的考点。\n                    </p>\n                    <h3 data-nodeid=\"35365\">路径压缩</h3>\n                    <p data-nodeid=\"35366\">\n                      并查集除了前面提到了考点之外，还有一个比较不容易出现的考点。那就是关于路径压缩的考点。\n                    </p>\n                    <p data-nodeid=\"35367\">\n                      处理这种题时，需要利用路径压缩同时将节点之间的信息进行层层压缩和汇总。求解过程还是很有趣的。下面让我们通过一个例题学习一下这个知识点。\n                    </p>\n                    <h4 data-nodeid=\"35368\">例 6: 倍数关系</h4>\n                    <p data-nodeid=\"35369\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZx2AJlAhAAB9L5EmBj8559.png\"\n                        alt=\"Drawing 26.png\"\n                        data-nodeid=\"36581\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35370\">\n                      【<strong data-nodeid=\"36587\">分析</strong\n                      >】那么首先我们进行一下模拟。\n                    </p>\n                    <p data-nodeid=\"35371\">\n                      <strong data-nodeid=\"36595\">1</strong>.\n                      <strong data-nodeid=\"36596\">模拟</strong>\n                    </p>\n                    <p data-nodeid=\"35372\">\n                      变量之间的除法关系，我们需要记录一个链式信息。如果将除法当成一个有向边，然后变量与变量之间的除法就可以看成图结构。比如：<br />\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZziAOXBLAAAF8Wyu_as055.png\"\n                        alt=\"Drawing 30.png\"\n                        data-nodeid=\"36601\"\n                      /><br />\n                      可以表示为下图：\n                    </p>\n                    <p data-nodeid=\"35373\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ0OAaHLpAABvAPNQMEI372.png\"\n                        alt=\"Drawing 31.png\"\n                        data-nodeid=\"36606\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35374\">\n                      如果我们将上图进行压缩，那么可以得到下图：\n                    </p>\n                    <p data-nodeid=\"35375\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ02AEcbFAABhq26WhTE347.png\"\n                        alt=\"Drawing 32.png\"\n                        data-nodeid=\"36610\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35376\">\n                      经过压缩之后，可以发现这几个元素之间的关系就变成了下面这个样子：\n                    </p>\n                    <ul data-nodeid=\"35377\">\n                      <li data-nodeid=\"35378\">\n                        <p data-nodeid=\"35379\">a = 8 * c</p>\n                      </li>\n                      <li data-nodeid=\"35380\">\n                        <p data-nodeid=\"35381\">c = 1 * c</p>\n                      </li>\n                      <li data-nodeid=\"35382\">\n                        <p data-nodeid=\"35383\">b = 4 * c</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35384\">\n                      此时，可以得到任意两个变量之间的比值。实际上，这几个数也可以以\n                      a 元素为根，如下图所示：\n                    </p>\n                    <p data-nodeid=\"35385\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ1qASIekAAC-iYLl5-E217.png\"\n                        alt=\"Drawing 33.png\"\n                        data-nodeid=\"36624\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35386\">几个元素之间的关系就是这样：</p>\n                    <ul data-nodeid=\"35387\">\n                      <li data-nodeid=\"35388\">\n                        <p data-nodeid=\"35389\">b = 0.5 * a</p>\n                      </li>\n                      <li data-nodeid=\"35390\">\n                        <p data-nodeid=\"35391\">a = 1 * a</p>\n                      </li>\n                      <li data-nodeid=\"35392\">\n                        <p data-nodeid=\"35393\">c = 0.125 * a</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35394\">\n                      此时，我们可以得到任意两个变量之间的比值。\n                    </p>\n                    <p data-nodeid=\"35395\">\n                      <strong data-nodeid=\"36643\">2</strong>.\n                      <strong data-nodeid=\"36644\">规律</strong>\n                    </p>\n                    <p data-nodeid=\"35396\">\n                      在这里，可以通过模拟找到一个<strong data-nodeid=\"36650\"\n                        >规律：只要是相连通的几个元素，可以选择任意一个结点做根结点。连通性好办，重点是：需要记录元素与根元素的比例</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"35397\">\n                      并且我们发现其实哪个点做根结点都一样。但是比例关系怎么办？再回看一下模拟的过程，可以发现：<strong\n                        data-nodeid=\"36656\"\n                        >比例关系就是顺着图中，有向边的方向乘过去即可</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"35398\">这里我们画图表示如下：</p>\n                    <p data-nodeid=\"35399\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ2WAYuNmAADbi_WkYTo775.png\"\n                        alt=\"Drawing 34.png\"\n                        data-nodeid=\"36660\"\n                      />\n                    </p>\n                    <p data-nodeid=\"35400\">\n                      也就是说，在压缩的时候，需要把路径上边的权重依次乘起来。\n                    </p>\n                    <p data-nodeid=\"35401\">\n                      <strong data-nodeid=\"36669\">3</strong>.\n                      <strong data-nodeid=\"36670\">匹配</strong>\n                    </p>\n                    <p data-nodeid=\"35402\">\n                      通过前面的一番分析，可以发现题目具有两个特点：\n                    </p>\n                    <ul data-nodeid=\"35403\">\n                      <li data-nodeid=\"35404\">\n                        <p data-nodeid=\"35405\">连通性</p>\n                      </li>\n                      <li data-nodeid=\"35406\">\n                        <p data-nodeid=\"35407\">路径压缩性</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35408\">\n                      能匹配到这两个特点的算法刚好是今天所讲的并查集。\n                    </p>\n                    <p data-nodeid=\"35409\">\n                      <strong data-nodeid=\"36682\">4</strong>.\n                      <strong data-nodeid=\"36683\">边界</strong>\n                    </p>\n                    <p data-nodeid=\"35410\">\n                      <strong data-nodeid=\"36692\">面试官提醒</strong>：<strong\n                        data-nodeid=\"36693\"\n                        >由于涉及除法，在面试中，你一定要主动提出是否可能存在除\n                        0\n                        的情况。如果给定的输入里面可能有，那么一定要记得处理</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"35411\">\n                      【<strong data-nodeid=\"36699\">代码</strong\n                      >】我们已经有了并查集的代码，那么处理路径压缩，应该也不是什么问题，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 小技巧：</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 记录字符串与整数的映射</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 将字符串映射成整数之后，在操作并查集的数组的时候</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 我们就可以使用整数组，速度也更快。</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addToMap</span><span class=\"hljs-params\">(String key, Map&lt;String, Integer&gt; H)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> id = H.size();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!H.containsKey(key)) {\n</div></li><li><div class=\"code-word\">    H.put(key, id);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 并查集的数组 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] F = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 结点与其父结点的比例关系，我们总是用子结点除以父结点</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 当 a / c = 8时，并且当前 a的父结点就是c</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 那么 C[a] = 8</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 当并查集的结构调整之后，a的父结点变成了d</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 并且a/d=16，那么此时C[a] = 16</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">double</span>[] C = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>{\n</div></li><li><div class=\"code-word\">  F = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];\n</div></li><li><div class=\"code-word\">  C = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">double</span>[n];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\n</div></li><li><div class=\"code-word\">    F[i] = i;\n</div></li><li><div class=\"code-word\">    C[i] = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> b = x;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// base用来保存从x -&gt; .... root</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这条路径上所有的乘积</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 最后保证可以得到</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// x = base * root</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">double</span> base = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (x != F[x]) {\n</div></li><li><div class=\"code-word\">    base *= C[x];\n</div></li><li><div class=\"code-word\">    x = F[x];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里x就是root</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// base x -&gt; root的映射值</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 把路径上的其他值一并压缩</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> root = x;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (F[b] != root) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 修改值上的变化</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">double</span> next = base / C[b];\n</div></li><li><div class=\"code-word\">    C[b] = base;\n</div></li><li><div class=\"code-word\">    base = next;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> par = F[b];\n</div></li><li><div class=\"code-word\">    F[b] = root;\n</div></li><li><div class=\"code-word\">    b = par;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> root;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> T, <span class=\"hljs-keyword\">int</span> D, <span class=\"hljs-keyword\">double</span> v)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// T / D = v;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 给定的输入表示 T = v * D;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 那么找到T的root</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> tpar = Find(T);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// T = C[T] * par</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> dpar = Find(D);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// D = C[D] * dpar;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// T = v * D = v * C[D] * dpar = C[T] * tpar;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果我们要让tpar 指向dpar</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// tpar = v * C[D] * dpar / C[T]</span>\n</div></li><li><div class=\"code-word\">  F[tpar] = dpar;\n</div></li><li><div class=\"code-word\">  C[tpar] = v * C[D] / C[T];\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations,\n</div></li><li><div class=\"code-word\">                       <span class=\"hljs-keyword\">double</span>[] values,\n</div></li><li><div class=\"code-word\">                       List&lt;List&lt;String&gt;&gt; queries) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 为了方便后面操作，我们把所有的字符串都映射成整数</span>\n</div></li><li><div class=\"code-word\">  Map&lt;String, Integer&gt; H = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (List&lt;String&gt; l : equations) {\n</div></li><li><div class=\"code-word\">    String t = l.get(<span class=\"hljs-number\">0</span>), d = l.get(<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    addToMap(t, H);\n</div></li><li><div class=\"code-word\">    addToMap(d, H);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化并查集</span>\n</div></li><li><div class=\"code-word\">  Init(H.size());\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 开始执行Union操作</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; equations.size(); i++) {\n</div></li><li><div class=\"code-word\">    List&lt;String&gt; l = equations.get(i);\n</div></li><li><div class=\"code-word\">    Union(H.get(l.get(<span class=\"hljs-number\">0</span>)), H.get(l.get(<span class=\"hljs-number\">1</span>)), values[i]);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 在进行query之前，对所有的点执行Find操作。让后面的query</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 的Find操作时间复杂度为O(1)</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; H.size(); i++) {\n</div></li><li><div class=\"code-word\">    Find(i);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">double</span>[] ans = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">double</span>[queries.size()];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; queries.size(); i++) {\n</div></li><li><div class=\"code-word\">    List&lt;String&gt; l = queries.get(i);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> tidx = H.containsKey(l.get(<span class=\"hljs-number\">0</span>)) ? H.get(l.get(<span class=\"hljs-number\">0</span>)) : -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> didx = H.containsKey(l.get(<span class=\"hljs-number\">1</span>)) ? H.get(l.get(<span class=\"hljs-number\">1</span>)) : -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果变量不存在，那么比例关系照题意设置为-1</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (tidx == -<span class=\"hljs-number\">1</span> || didx == -<span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      ans[i] = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">int</span> troot = Find(tidx);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">int</span> droot = Find(didx);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果两个变量从来没有过交集 </span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (troot != droot) {\n</div></li><li><div class=\"code-word\">        ans[i] = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        ans[i] = C[tidx] / C[didx];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"35413\">\n                      <p data-nodeid=\"35414\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36703\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36707\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"36711\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"35415\">\n                      <strong data-nodeid=\"36716\">复杂度分析</strong>：假设有 N\n                      个变量，构建并查集的时间复杂度为 O (NlgN)，如果有 M 个\n                      Query，每次在询问为 O(1)，所以总的时间复杂度为\n                      max(O(NlgN),M)。\n                    </p>\n                    <p data-nodeid=\"35416\">\n                      【<strong data-nodeid=\"36722\">小结</strong\n                      >】如果要解决这道题，那么需要注意掌握以下三点。\n                    </p>\n                    <ul data-nodeid=\"35417\">\n                      <li data-nodeid=\"35418\">\n                        <p data-nodeid=\"35419\">\n                          连通域里面的所有变量都统一用一个变量表示倍数关系，那么任意的两个变量就可以直接询问倍数关系。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35420\">\n                        <p data-nodeid=\"35421\">\n                          倍数关系具有传递性，即：<br />\n                          <img\n                            src=\"https://uploader.shimo.im/f/LbdIya2siEFX52pW.png!thumbnail?fileGuid=xxQTRXtVcqtHK6j8\"\n                            alt=\"图片\"\n                            data-nodeid=\"36728\"\n                          /><br />\n                          这是我们进行路径压缩的关键。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"35422\">\n                        <p data-nodeid=\"35423\">\n                          Union 操作时，注意变量倍数关系的调整。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"35424\">\n                      如果想到了这些，再加上我介绍的并查集的代码模板，那么解决这道面试题也就没什么难度了。以后在面试中，你如果发现题目具有<strong\n                        data-nodeid=\"36737\"\n                        >传递性</strong\n                      >的特点，就可以使用并查集进行求解。\n                    </p>\n                    <h3 data-nodeid=\"35425\">总结</h3>\n                    <p data-nodeid=\"35426\" class=\"\">\n                      在本讲中，我介绍了并查集面试时常见的考察点，并且给出了并查集的代码模板。最后我还给你准备了并查集的知识树，面试中并查集相关的问题基本上逃不出这个圈。希望你可以尝试自己对本讲的内容进行梳理，然后再对照下图查缺补漏。\n                    </p>\n                    <p data-nodeid=\"35427\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ5KACZb3AAEzzay3PAM503.png\"\n                        alt=\"Drawing 38.png\"\n                        data-nodeid=\"36742\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"35428\">思考题</h3>\n                    <p data-nodeid=\"35429\">\n                      如果我们把例 5\n                      的变量看成图上的点，变量与变量之间的关系看成是边。一旦构建好了并查集，在\n                      Query 的时候，就可以 O(1)\n                      的时间查询到两个变量之间的代价。那么为什么在图算法中，我们需要用\n                      Floyd 算法求解图中两个点之间的最短路径？\n                    </p>\n                    <p data-nodeid=\"35430\">\n                      希望你可以把思考写在留言区，我们一起讨论，如果看到有趣的想法，我也会做成加餐和大家分享。：）\n                    </p>\n                    <p data-nodeid=\"35431\" class=\"\">\n                      到这里，我们就要与并查集说再见了，接下来我们一起学习\n                      08｜排序：如何利用合并与快排的小技巧，解决算法难题。记得按时来探险。\n                    </p>\n            "}