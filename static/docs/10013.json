{"title":"10 | 掌握前端框架模板引擎的实现原理","context":"\n                    <p data-nodeid=\"68536\">\n                      如今说起前端开发，基本上都离不开前端框架。随着前端技术不断迭代，前端框架相关的文档和社区日益完善，前端入门也越来越简单了。我们可以快速上手一些工具和框架，但常常会忽略其中的设计和原理。\n                    </p>\n                    <p data-nodeid=\"68537\">\n                      对框架和工具的了解不够深入，会导致我们在遇到一些偏门的问题时容易找不到方向，也不利于个人的知识领域扩展，不能很好地进行技术选型。\n                    </p>\n                    <p data-nodeid=\"68538\">\n                      今天，我会带你了解前端框架为什么会这么热门，以及介绍前端框架的核心能力——模板引擎的实现原理。在讲解的过程中，一些代码会以\n                      Vue.js 作为示例。\n                    </p>\n                    <p data-nodeid=\"68539\">\n                      我们先来看一下，为什么要使用前端框架。\n                    </p>\n                    <h3 data-nodeid=\"68540\">为什么要使用前端框架</h3>\n                    <p data-nodeid=\"68541\">\n                      一个工具被大多数人使用、成为热门，离不开相关技术发展的历史进程。了解这些工具和框架出现的原因，我们可以及时掌握技术的发展方向，保持对技术的敏感度、更新自身的认知，这些都会成为我们自身的竞争力。\n                    </p>\n                    <p data-nodeid=\"68542\">\n                      前端框架也一样。在前端框架出现之前，jQuery\n                      也是前端开发必备的工具库，大多数项目中都会使用。短短几年间，前端开发却变得无法离开前端框架，这中间到底发生了什么呢？\n                    </p>\n                    <h4 data-nodeid=\"68543\">前端的飞速发展</h4>\n                    <p data-nodeid=\"68544\">\n                      曾几何时，一提到前端，大家都会想到 jQuery。那是 jQuery\n                      一把梭的年代，不管前端后台都会用 jQuery\n                      完成页面开发。那时候前端开发的工作倾向于切图和重构，重页面样式而轻逻辑，工作内容常常是拼接\n                      JSP 模板、拼 PHP 模板以及调节浏览器兼容。\n                    </p>\n                    <p data-nodeid=\"68545\">\n                      为什么 jQuery 那么热门呢？除了超方便的 Sizzle\n                      引擎元素选择器、简单易用的异步请求库\n                      ajax，还有链式调用的编程方式使得代码如行云流水般流畅。jQuery\n                      提供的便捷几乎满足了当时前端的大部分工作（所以说 jQuery\n                      一把梭不是毫无道理的）。\n                    </p>\n                    <p data-nodeid=\"68546\">\n                      接下来短短的几年时间，前端经历了特别多的改变。随着 Node.js\n                      的出现、NPM\n                      包管理的完善，再加上热闹的开源社区，前端领域获得了千千万万开发者的支援。从页面开发到工具库开发、框架开发、脚本开发、到服务端开发，单线程的\n                      JavaScript\n                      正在不断进行自我革新，从而将领域不断拓宽，形成了如今你所能看到的、获得赋能的前端。\n                    </p>\n                    <p data-nodeid=\"68547\">\n                      那么，是什么原因导致了 jQuery\n                      被逐渐冷落，前端框架站上了舞台中央呢？其中的原因有很多，包括业务场景的进化、技术的更新迭代，比如前端应用逐渐复杂、单页应用的出现、前端模块化等。\n                    </p>\n                    <h4 data-nodeid=\"68548\">前端框架的出现</h4>\n                    <p data-nodeid=\"68549\">\n                      前面第 8\n                      讲中，我们知道了浏览器是如何渲染页面的。从用户的角度来看，浏览器生成了最终的渲染树，并通过光栅化来将页面显示在屏幕上，页面渲染的工作就完成了。\n                    </p>\n                    <p data-nodeid=\"68550\">\n                      实际上，浏览器页面更多的不只是静态页面的渲染，还包括点击、拖拽等事件操作以及接口请求、数据渲染到页面等动态的交互逻辑，因此我们还常常需要更新页面的内容。\n                    </p>\n                    <p data-nodeid=\"68551\">\n                      要理解前端框架为什么如此重要，需要先看看在框架出现前，前端开发是如何实现和用户进行交互的。\n                    </p>\n                    <p data-nodeid=\"68552\">\n                      这个过程跟上一讲事件驱动的内容很相似，以一个常见的表单提交作为例子，会包括编写静态页面、给对应的元素绑定对应的事件、事件触发时更新页面内容等步骤，这是最简单的页面交互。\n                    </p>\n                    <p data-nodeid=\"68553\">\n                      对于更新页面内容这个步骤，如果我们页面中有很多的内容需要更新，光拼接字符串我们可能就有一大堆代码。\n                    </p>\n                    <blockquote data-nodeid=\"68554\">\n                      <p data-nodeid=\"68555\">\n                        以下的例子，为了不占用大量的篇幅，使用了\n                        jQuery，否则代码量会更多。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"68556\">\n                      举个例子，抢答活动中常常会出现题目和多个答案进行选择，我们现在需要开发一个管理端，对这些抢答卡片进行管理。假设一个问题会包括两个答案，我们可以通过新增卡片的方式来添加一套问答，编辑卡片的过程包括这些步骤。\n                    </p>\n                    <p data-nodeid=\"69931\" class=\"\">\n                      <strong data-nodeid=\"69937\">1</strong>.\n                      新增一个卡片时，通过插入 DOM 节点的方式添加卡片样式。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 用来新增一个卡片，卡片内需要填写一些内容</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">addCard</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取一个id为the-dom的元素</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> body = $(<span class=\"hljs-string\">\"#the-dom\"</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 从该元素内获取class为the-class的元素</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> addDom = body.find(<span class=\"hljs-string\">\".the-class\"</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 在the-class元素前方插入一个div</span>\n</div></li><li><div class=\"code-word\">  addDom.before(<span class=\"hljs-string\">'&lt;div class=\"col-lg-4\" data-index=\"'</span> + index + <span class=\"hljs-string\">'\"&gt;&lt;/div&gt;'</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 同时保存下来该DOM节点，方便更新内容</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> theDom = body.find(<span class=\"hljs-string\">'[data-index=\"'</span> + index + <span class=\"hljs-string\">'\"]'</span>);\n</div></li><li><div class=\"code-word\">  theDom.innerHTML(\n</div></li><li><div class=\"code-word\">    \\`&lt;input type=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"form-control question\"</span> placeholder=<span class=\"hljs-string\">\"你的问题\"</span>&gt;\n</div></li><li><div class=\"code-word\">         &lt;input type=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"form-control option-a\"</span> placeholder=<span class=\"hljs-string\">\"回答1\"</span>&gt;\n</div></li><li><div class=\"code-word\">         &lt;input type=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"form-control option-b\"</span> placeholder=<span class=\"hljs-string\">\"回答2\"</span>&gt;\n</div></li><li><div class=\"code-word\">        \\`\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 做完上面这堆之后index自增</span>\n</div></li><li><div class=\"code-word\">  index++;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> theDom;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"70496\" class=\"\">\n                      <strong data-nodeid=\"70502\">2</strong>.\n                      卡片内编辑题目和答案时，会有字数限制（使用 jQuery\n                      对输入框的输入事件进行监听，并限制输入内容）。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// theDom使用上面代码保存下来的引用</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 问题绑定值</span>\n</div></li><li><div class=\"code-word\">theDom\n</div></li><li><div class=\"code-word\">  .on(<span class=\"hljs-string\">\"keyup\"</span>, <span class=\"hljs-string\">\".question\"</span>, function (ev) {\n</div></li><li><div class=\"code-word\">    ev.target.value = ev.target.value.substr(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>);\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 答案a绑定值</span>\n</div></li><li><div class=\"code-word\">  .on(<span class=\"hljs-string\">\"keyup\"</span>, <span class=\"hljs-string\">\".option-a\"</span>, function (ev) {\n</div></li><li><div class=\"code-word\">    ev.target.value = ev.target.value.substr(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>);\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 答案b绑定值</span>\n</div></li><li><div class=\"code-word\">  .on(<span class=\"hljs-string\">\"keyup\"</span>, <span class=\"hljs-string\">\".option-b\"</span>, function (ev) {\n</div></li><li><div class=\"code-word\">    ev.target.value = ev.target.value.substr(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>);\n</div></li><li><div class=\"code-word\">  });\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"71065\" class=\"te-preview-highlight\">\n                      <strong data-nodeid=\"71071\">3</strong>.\n                      获取输入框内的内容（使用 jQuery\n                      选择元素并获取内容），用于提交到后台。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取卡片的输入值</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// theDom 使用上面代码保存下来的引用</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">getCardValue</span><span class=\"hljs-params\">(index)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> body = $(<span class=\"hljs-string\">\"#the-dom\"</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> theDom = body.find(<span class=\"hljs-string\">'[data-index=\"'</span> + index + <span class=\"hljs-string\">'\"]'</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> questionName = theDom.find(<span class=\"hljs-string\">\".question\"</span>).val();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> optionA = theDom.find(<span class=\"hljs-string\">\".option-a\"</span>).val();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> optionB = theDom.find(<span class=\"hljs-string\">\".option-b\"</span>).val();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> { questionName, optionA, optionB };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"68569\">\n                      可以看到，仅是实现一个问答卡片的编辑就需要编写不少的代码，大多数代码内容都是为了拼接\n                      HTML 内容、获取 DOM 节点、操作 DOM 节点。<br />\n                      这些代码逻辑，如果我们使用 Vue 来实现，只需要这么写：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  &lt;div v-for=\"card in cards\"&gt;\n</div></li><li><div class=\"code-word\">    &lt;input\n</div></li><li><div class=\"code-word\">      type=\"text\"\n</div></li><li><div class=\"code-word\">      class=\"form-control question\"\n</div></li><li><div class=\"code-word\">      v-model=\"card.questionName\"\n</div></li><li><div class=\"code-word\">      placeholder=\"你的问题\"\n</div></li><li><div class=\"code-word\">    /&gt;\n</div></li><li><div class=\"code-word\">    &lt;input\n</div></li><li><div class=\"code-word\">      type=\"text\"\n</div></li><li><div class=\"code-word\">      class=\"form-control option-a\"\n</div></li><li><div class=\"code-word\">      v-model=\"card.optionA\"\n</div></li><li><div class=\"code-word\">      placeholder=\"回答1\"\n</div></li><li><div class=\"code-word\">    /&gt;\n</div></li><li><div class=\"code-word\">    &lt;input\n</div></li><li><div class=\"code-word\">      type=\"text\"\n</div></li><li><div class=\"code-word\">      class=\"form-control option-b\"\n</div></li><li><div class=\"code-word\">      v-model=\"card.optionB\"\n</div></li><li><div class=\"code-word\">      placeholder=\"回答2\"\n</div></li><li><div class=\"code-word\">    /&gt;\n</div></li><li><div class=\"code-word\">  &lt;/div&gt;\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\">&lt;script&gt;\n</div></li><li><div class=\"code-word\">  export default {\n</div></li><li><div class=\"code-word\">    name: \"Cards\",\n</div></li><li><div class=\"code-word\">    data() {\n</div></li><li><div class=\"code-word\">      return {\n</div></li><li><div class=\"code-word\">        cards: [],\n</div></li><li><div class=\"code-word\">      };\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    methods: {\n</div></li><li><div class=\"code-word\">      // 添加一个卡片\n</div></li><li><div class=\"code-word\">      addCard() {\n</div></li><li><div class=\"code-word\">        this.cards.push({\n</div></li><li><div class=\"code-word\">          questionName: \"\",\n</div></li><li><div class=\"code-word\">          optionA: \"\",\n</div></li><li><div class=\"code-word\">          optionB: \"\",\n</div></li><li><div class=\"code-word\">        });\n</div></li><li><div class=\"code-word\">      },\n</div></li><li><div class=\"code-word\">      // 获取卡片的输入值\n</div></li><li><div class=\"code-word\">      getCardValue(index) {\n</div></li><li><div class=\"code-word\">        return this.cards[index];\n</div></li><li><div class=\"code-word\">      },\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">&lt;/script&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"68571\">\n                      可见，前端框架提供了便利的数据绑定、界面更新、事件监听等\n                      API，我们不需要再手动更新前端页面的内容、维护一大堆的 HTML\n                      和变量拼接的动态内容了。<br />\n                      使用前端框架对开发效率有很大的提升，同时也在一定程度上避免了代码可读性、可维护性等问题。这也是为什么前端框架这么热门，大家都会使用它来进行开发的原因。\n                    </p>\n                    <p data-nodeid=\"68572\">\n                      那么，前端框架是怎么做到这些的呢？要实现这些能力，离不开其中的模板引擎。\n                    </p>\n                    <h3 data-nodeid=\"68573\">前端框架的核心——模板引擎</h3>\n                    <p data-nodeid=\"68574\">\n                      当用户对页面进行操作、页面内容更新，我们需要实现的功能流程包括：\n                    </p>\n                    <ol data-nodeid=\"68575\">\n                      <li data-nodeid=\"68576\">\n                        <p data-nodeid=\"68577\">监听操作；</p>\n                      </li>\n                      <li data-nodeid=\"68578\">\n                        <p data-nodeid=\"68579\">获取数据变量；</p>\n                      </li>\n                      <li data-nodeid=\"68580\">\n                        <p data-nodeid=\"68581\">\n                          使用数据变量拼接成 HTML 模板；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68582\">\n                        <p data-nodeid=\"68583\">\n                          将 HTML 内容塞到页面对应的地方；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68584\">\n                        <p data-nodeid=\"68585\">\n                          将 HTML 片段内需要监听的点击等事件进行绑定。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"68586\">\n                      可以看到，实现逻辑会比较复杂和烦琐。\n                    </p>\n                    <p data-nodeid=\"68587\">如果使用前端框架，我们可以：</p>\n                    <ul data-nodeid=\"68588\">\n                      <li data-nodeid=\"68589\">\n                        <p data-nodeid=\"68590\">\n                          使用将数据变量绑定到 HTML\n                          模板的方式，来控制展示的内容；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68591\">\n                        <p data-nodeid=\"68592\">\n                          配合一些条件判断、条件循环等逻辑，控制交互的具体逻辑；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68593\">\n                        <p data-nodeid=\"68594\">\n                          通过改变数据变量，框架会自动更新页面内容。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"68595\">\n                      这样，我们可以快速高效地完成功能开发，代码的可读性和维护性都远胜于纯手工实现。\n                    </p>\n                    <p data-nodeid=\"68596\">\n                      如果使用数据驱动的方式，还可以通过让逻辑与 UI\n                      解耦的方式，提升代码的可维护性。其中的数据绑定、事件绑定等功能，前端框架是依赖模板引擎的方式来实现的。\n                    </p>\n                    <p data-nodeid=\"68597\">\n                      以 Vue 为例子，对于开发者编写的 Vue 代码，Vue\n                      会将其进行以下处理从而渲染到页面中：\n                    </p>\n                    <ol data-nodeid=\"68598\">\n                      <li data-nodeid=\"68599\">\n                        <p data-nodeid=\"68600\">解析语法生成 AST 对象；</p>\n                      </li>\n                      <li data-nodeid=\"68601\">\n                        <p data-nodeid=\"68602\">\n                          根据生成的 AST 对象，完成<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68729\"\n                            >data</code\n                          >数据初始化；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68603\">\n                        <p data-nodeid=\"68604\">\n                          根据 AST 对象和<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68732\"\n                            >data</code\n                          >数据绑定情况，生成虚拟 DOM 对象；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68605\">\n                        <p data-nodeid=\"68606\">\n                          将虚拟 DOM 对象生成真正的 DOM\n                          元素插入到页面中，此时页面会被渲染。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"68607\">\n                      模板引擎将模板语法进行解析，分别生成 HTML DOM，使用像 HTML\n                      拼接的方式（在对应的位置绑定变量、指令解析获取拼接逻辑等等），同时配合事件的管理、虚拟\n                      DOM 的设计，可以最大化地提升页面的性能。\n                    </p>\n                    <p data-nodeid=\"68608\">\n                      这些便是模板引擎主要的工作，我们来分别看一下。\n                    </p>\n                    <h4 data-nodeid=\"68609\">解析语法生成 AST 对象</h4>\n                    <p data-nodeid=\"68610\">\n                      抽象语法树（Abstract Syntax Tree）也称为 AST\n                      语法树，指的是源代码语法所对应的树状结构。其实我们的 DOM\n                      结构树，也是 AST 的一种，浏览器会对 HTML DOM\n                      进行语法解析、并生成最终的页面。\n                    </p>\n                    <p data-nodeid=\"68611\">\n                      生成 AST 的过程涉及编译器的原理，一般经过以下过程。\n                    </p>\n                    <ol data-nodeid=\"68612\">\n                      <li data-nodeid=\"68613\">\n                        <p data-nodeid=\"68614\">\n                          语法分析。模板引擎需要在这个过程中识别出特定的语法，比如<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68741\"\n                            >v-if</code\n                          >/<code data-backticks=\"1\" data-nodeid=\"68743\"\n                            >v-for</code\n                          >这样的指令，或是<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68745\"\n                            >&lt;MyCustomComponent&gt;</code\n                          >这样的自定义 DOM 标签，还有<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68747\"\n                            >@click</code\n                          >/<code data-backticks=\"1\" data-nodeid=\"68749\"\n                            >:props</code\n                          >这样的简化绑定语法等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68615\">\n                        <p data-nodeid=\"68616\">\n                          语义分析。这个过程会审查源程序有无语义错误，为代码生成阶段收集类型信息，一般类型检查也会在这个过程中进行。例如我们绑定了某个不存在的变量或者事件，又或者是使用了某个未定义的自定义组件等，都会在这个阶段进行报错提示。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68617\">\n                        <p data-nodeid=\"68618\">生成 AST 对象。</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"68619\">\n                      以 Vue 为例，生成 AST 的过程包括 HTML\n                      模板解析、元素检查和预处理：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> *  将HTML编译成AST对象\n</div></li><li><div class=\"code-word\"> *  该代码片段基于Vue2.x版本\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">parse</span><span class=\"hljs-params\">(\n</span></span></div></li><li><div class=\"code-word\">  template: string,\n</div></li><li><div class=\"code-word\">  options: CompilerOptions\n</div></li><li><div class=\"code-word\">): ASTElement | <span class=\"hljs-keyword\">void</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 返回AST对象</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 篇幅原因，一些前置定义省略</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 此处开始解析HTML模板</span>\n</div></li><li><div class=\"code-word\">  parseHTML(template, {\n</div></li><li><div class=\"code-word\">    expectHTML: options.expectHTML,\n</div></li><li><div class=\"code-word\">    isUnaryTag: options.isUnaryTag,\n</div></li><li><div class=\"code-word\">    shouldDecodeNewlines: options.shouldDecodeNewlines,\n</div></li><li><div class=\"code-word\">    start(tag, attrs, unary) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 一些前置检查和设置、兼容处理此处省略</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 此处定义了初始化的元素AST对象</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> element: ASTElement = {\n</div></li><li><div class=\"code-word\">        type: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\">        tag,\n</div></li><li><div class=\"code-word\">        attrsList: attrs,\n</div></li><li><div class=\"code-word\">        attrsMap: makeAttrsMap(attrs),\n</div></li><li><div class=\"code-word\">        parent: currentParent,\n</div></li><li><div class=\"code-word\">        children: [],\n</div></li><li><div class=\"code-word\">      };\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 检查元素标签是否合法（不是保留命名）</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (isForbiddenTag(element) &amp;&amp; !isServerRendering()) {\n</div></li><li><div class=\"code-word\">        element.forbidden = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">        process.env.NODE_ENV !== <span class=\"hljs-string\">\"production\"</span> &amp;&amp;\n</div></li><li><div class=\"code-word\">          warn(\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-string\">\"Templates should only be responsible for mapping the state to the \"</span> +\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-string\">\"UI. Avoid placing tags with side-effects in your templates, such as \"</span> +\n</div></li><li><div class=\"code-word\">              \\`&lt;${tag}&gt;\\` +\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-string\">\", as they will not be parsed.\"</span>\n</div></li><li><div class=\"code-word\">          );\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 执行一些前置的元素预处理</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i &lt; preTransforms.length; i++) {\n</div></li><li><div class=\"code-word\">        preTransforms[i](element, options);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 是否原生元素</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (inVPre) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 处理元素的一些属性</span>\n</div></li><li><div class=\"code-word\">        processRawAttrs(element);\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 处理指令，此处包括v-for/v-if/v-once/key等等</span>\n</div></li><li><div class=\"code-word\">        processFor(element);\n</div></li><li><div class=\"code-word\">        processIf(element);\n</div></li><li><div class=\"code-word\">        processOnce(element);\n</div></li><li><div class=\"code-word\">        processKey(element); <span class=\"hljs-comment\">// 删除结构属性</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 确定这是否是一个简单的元素</span>\n</div></li><li><div class=\"code-word\">        element.plain = !element.key &amp;&amp; !attrs.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 处理ref/slot/component等属性</span>\n</div></li><li><div class=\"code-word\">        processRef(element);\n</div></li><li><div class=\"code-word\">        processSlot(element);\n</div></li><li><div class=\"code-word\">        processComponent(element);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i &lt; transforms.length; i++) {\n</div></li><li><div class=\"code-word\">          transforms[i](element, options);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        processAttrs(element);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 后面还有一些父子节点等处理，此处省略</span>\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 其他省略</span>\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> root;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"68621\">\n                      到这里，Vue 将开发者的模板代码解析成 AST\n                      对象，我们来看看这样的 AST 对象是怎样生成 DOM 元素的。\n                    </p>\n                    <h4 data-nodeid=\"68622\">AST 对象生成 DOM 元素</h4>\n                    <p data-nodeid=\"68623\">\n                      前面提到，在编译解析和渲染过程中，模板引擎会识别和解析模板语法语义、生成\n                      AST 对象，最后根据 AST 对象会生成最终的 DOM 元素。\n                    </p>\n                    <p data-nodeid=\"68624\">\n                      举个例子，我们写了以下这么一段 HTML 模板：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;div&gt;\n</div></li><li><div class=\"code-word\">  &lt;a&gt;123&lt;/a&gt;\n</div></li><li><div class=\"code-word\">  &lt;p&gt;456&lt;span&gt;789&lt;/span&gt;&lt;/p&gt;\n</div></li><li><div class=\"code-word\">&lt;/div&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"68626\">\n                      模板引擎可以在语法分析、语义分析等步骤后，得到这样的一个\n                      AST 对象：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">thisDiv = {\n</div></li><li><div class=\"code-word\">  dom: {\n</div></li><li><div class=\"code-word\">    type: <span class=\"hljs-string\">\"dom\"</span>,\n</div></li><li><div class=\"code-word\">    ele: <span class=\"hljs-string\">\"div\"</span>,\n</div></li><li><div class=\"code-word\">    nodeIndex: <span class=\"hljs-number\">0</span>,\n</div></li><li><div class=\"code-word\">    children: [\n</div></li><li><div class=\"code-word\">      {\n</div></li><li><div class=\"code-word\">        type: <span class=\"hljs-string\">\"dom\"</span>,\n</div></li><li><div class=\"code-word\">        ele: <span class=\"hljs-string\">\"a\"</span>,\n</div></li><li><div class=\"code-word\">        nodeIndex: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\">        children: [{ type: <span class=\"hljs-string\">\"text\"</span>, value: <span class=\"hljs-string\">\"123\"</span> }],\n</div></li><li><div class=\"code-word\">      },\n</div></li><li><div class=\"code-word\">      {\n</div></li><li><div class=\"code-word\">        type: <span class=\"hljs-string\">\"dom\"</span>,\n</div></li><li><div class=\"code-word\">        ele: <span class=\"hljs-string\">\"p\"</span>,\n</div></li><li><div class=\"code-word\">        nodeIndex: <span class=\"hljs-number\">2</span>,\n</div></li><li><div class=\"code-word\">        children: [\n</div></li><li><div class=\"code-word\">          { type: <span class=\"hljs-string\">\"text\"</span>, value: <span class=\"hljs-string\">\"456\"</span> },\n</div></li><li><div class=\"code-word\">          {\n</div></li><li><div class=\"code-word\">            type: <span class=\"hljs-string\">\"dom\"</span>,\n</div></li><li><div class=\"code-word\">            ele: <span class=\"hljs-string\">\"span\"</span>,\n</div></li><li><div class=\"code-word\">            nodeIndex: <span class=\"hljs-number\">3</span>,\n</div></li><li><div class=\"code-word\">            children: [{ type: <span class=\"hljs-string\">\"text\"</span>, value: <span class=\"hljs-string\">\"789\"</span> }],\n</div></li><li><div class=\"code-word\">          },\n</div></li><li><div class=\"code-word\">        ],\n</div></li><li><div class=\"code-word\">      },\n</div></li><li><div class=\"code-word\">    ],\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"68628\">\n                      这个 AST 对象维护我们需要的一些信息，包括 HTML 元素里：\n                    </p>\n                    <ul data-nodeid=\"68629\">\n                      <li data-nodeid=\"68630\">\n                        <p data-nodeid=\"68631\">\n                          需要绑定哪些变量（变量更新的时候需要更新该节点内容）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68632\">\n                        <p data-nodeid=\"68633\">\n                          是否有其他的逻辑需要处理（比如含有逻辑指令，如<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68762\"\n                            >v-if</code\n                          >、<code data-backticks=\"1\" data-nodeid=\"68764\"\n                            >v-for</code\n                          >等）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68634\">\n                        <p data-nodeid=\"68635\">\n                          哪些节点绑定了事件监听事件（是否匹配一些常用的事件能力支持，如<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68767\"\n                            >@click</code\n                          >）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"68636\">\n                      模板引擎会根据 AST\n                      对象生成最终的页面片段和逻辑，在这个过程中会通过添加特殊标识（例如元素\n                      ID、属性标记等）的方式来标记 DOM 节点，配合 DOM\n                      元素选择方式、事件监听方式等，在需要更新的时候可快速定位到该\n                      DOM 节点，并进行节点内容更新，从而实现页面内容的更新。\n                    </p>\n                    <p data-nodeid=\"68637\">\n                      目前来说，前端模板渲染的实现一般分为以下两种方式。\n                    </p>\n                    <ol data-nodeid=\"68638\">\n                      <li data-nodeid=\"68639\">\n                        <p data-nodeid=\"68640\">\n                          字符串模版方式：使用拼接的方式生成 DOM\n                          字符串，直接通过<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68772\"\n                            >innderHTML()</code\n                          >插入页面。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68641\">\n                        <p data-nodeid=\"68642\">\n                          节点模版方式：使用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"68775\"\n                            >createElement()</code\n                          >/<code data-backticks=\"1\" data-nodeid=\"68777\"\n                            >appendChild()</code\n                          >/<code data-backticks=\"1\" data-nodeid=\"68779\"\n                            >textContent</code\n                          >等方法动态地插入 DOM 节点。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"68643\">\n                      在使用字符串模版的时候，我们将<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"68782\"\n                        >nodeIndex</code\n                      >绑定在元素属性上，主要用于在数据更新时追寻节点进行内容更新。\n                    </p>\n                    <p data-nodeid=\"68644\">\n                      在使用节点模版的时候，我们可在创建节点时将该节点保存下来，直接用于数据更新：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">// 假设这是一个生成 DOM 的过程，包括 innerHTML 和事件监听\n</div></li><li><div class=\"code-word\">function generateDOM(astObject) {\n</div></li><li><div class=\"code-word\">  const { dom, binding = [] } = astObject;\n</div></li><li><div class=\"code-word\">  // 生成DOM，这里假装当前节点是baseDom\n</div></li><li><div class=\"code-word\">  baseDom.innerHTML = getDOMString(dom);\n</div></li><li><div class=\"code-word\">  // 对于数据绑定的，来进行监听更新吧\n</div></li><li><div class=\"code-word\">  baseDom.addEventListener(\"data:change\", (name, value) =&gt; {\n</div></li><li><div class=\"code-word\">    // 寻找匹配的数据绑定\n</div></li><li><div class=\"code-word\">    const obj = binding.find((x) =&gt; x.valueName == name);\n</div></li><li><div class=\"code-word\">    // 若找到值绑定的对应节点，则更新其值。\n</div></li><li><div class=\"code-word\">    if (obj) {\n</div></li><li><div class=\"code-word\">      baseDom.find(\\`[data-node-index=\"${obj.nodeIndex}\"]\\`).innerHTML = value;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">// 获取DOM字符串，这里简单拼成字符串\n</div></li><li><div class=\"code-word\">function getDOMString(domObj) {\n</div></li><li><div class=\"code-word\">  // 无效对象返回''\n</div></li><li><div class=\"code-word\">  if (!domObj) return \"\";\n</div></li><li><div class=\"code-word\">  const { type, children = [], nodeIndex, ele, value } = domObj;\n</div></li><li><div class=\"code-word\">  if (type == \"dom\") {\n</div></li><li><div class=\"code-word\">    // 若有子对象，递归返回生成的字符串拼接\n</div></li><li><div class=\"code-word\">    const childString = \"\";\n</div></li><li><div class=\"code-word\">    children.forEach((x) =&gt; {\n</div></li><li><div class=\"code-word\">      childString += getDOMString(x);\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    // dom对象，拼接生成对象字符串\n</div></li><li><div class=\"code-word\">    return \\`&lt;${ele} data-node-index=\"${nodeIndex}\"&gt;${childString}&lt;/${ele}&gt;\\`;\n</div></li><li><div class=\"code-word\">  } else if (type == \"text\") {\n</div></li><li><div class=\"code-word\">    // 若为textNode，返回text的值\n</div></li><li><div class=\"code-word\">    return value;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"68646\">\n                      通过上面的方式，前端框架实现了将 AST 对象生成 DOM\n                      元素，并将这些 DOM 元素渲染或更新到页面上。\n                    </p>\n                    <p data-nodeid=\"68647\">\n                      或许你会觉得疑惑：原本就是一个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"68787\"\n                        >&lt;div&gt;</code\n                      >HTML 模板，经过 AST 生成一个对象，最终还是生成一个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"68789\"\n                        >&lt;div&gt;</code\n                      >DOM 节点，看起来好像挺多余的。\n                    </p>\n                    <p data-nodeid=\"68648\">\n                      实际上，在这个过程中，模板引擎可以实现更多功能。\n                    </p>\n                    <h4 data-nodeid=\"68649\">模板引擎可以做更多</h4>\n                    <p data-nodeid=\"68650\">\n                      将 HTML 模板解析成 AST 对象，再根据 AST 对象生成 DOM\n                      节点，在这个过程中前端框架可以实现以下功能：\n                    </p>\n                    <ol data-nodeid=\"68651\">\n                      <li data-nodeid=\"68652\">\n                        <p data-nodeid=\"68653\">\n                          排除无效 DOM 元素（非自定义组件、也非默认组件的 DOM\n                          元素），在构建阶段可及时发现并进行报错；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68654\">\n                        <p data-nodeid=\"68655\">\n                          可识别出自定义组件，并渲染对应的组件；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68656\">\n                        <p data-nodeid=\"68657\">\n                          可方便地实现数据绑定、事件绑定等功能；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68658\">\n                        <p data-nodeid=\"68659\">\n                          为虚拟 DOM Diff 过程打下铺垫；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68660\">\n                        <p data-nodeid=\"68661\">HTML 转义（预防 XSS 漏洞）。</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"68662\">\n                      这里我们以第 5 点预防 XSS\n                      漏洞为例子，详细地介绍一下模板引擎是如何避免 XSS 攻击的。\n                    </p>\n                    <h4 data-nodeid=\"68663\">预防 XSS 漏洞</h4>\n                    <p data-nodeid=\"68664\">\n                      我们知道 XSS 的整个攻击过程大概为：\n                    </p>\n                    <ol data-nodeid=\"68665\">\n                      <li data-nodeid=\"68666\">\n                        <p data-nodeid=\"68667\">\n                          攻击者提交含有恶意代码的内容（比如 JavaScript 脚本）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68668\">\n                        <p data-nodeid=\"68669\">\n                          页面渲染的时候，这些内容未被过滤就被加载处理，比如获取\n                          Cookie、执行操作等；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"68670\">\n                        <p data-nodeid=\"68671\">\n                          其他用户在浏览页面的时候，就会在加载到恶意代码时受到攻击。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"68672\">\n                      要避免网站用户受到 XSS\n                      攻击，主要方法是将用户提交的内容进行过滤处理。大多数前端框架会自带\n                      HTML 转义功能，从而避免的 XSS 攻击。\n                    </p>\n                    <p data-nodeid=\"68673\">\n                      以 Vue 为例，使用默认的数据绑定方式（双大括号、<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"68807\"\n                        >v-bind</code\n                      >等）会进行 HTML 转义，将数据解释为普通文本，而非 HTML\n                      代码。\n                    </p>\n                    <p data-nodeid=\"68674\">\n                      除此预防 XSS\n                      漏洞之外，前端框架还做了一些性能、安全性等方面的优化，也提供了一些用于项目开发配套的工具，包括路由的管理、状态和数据的管理等工具。\n                    </p>\n                    <h3 data-nodeid=\"68675\">小结</h3>\n                    <p data-nodeid=\"68676\">\n                      今天我带大家了解了前端框架的出现，由于前端框架帮开发者解决了很多重复性的工作（拼接\n                      HTML 模板、DOM 元素查找、DOM\n                      元素事件监听等），极大地提升了开发者的效率，同时还提升了代码的可读性和可维护性，因此受到很多前端开发的追捧。\n                    </p>\n                    <p data-nodeid=\"68677\">\n                      除此之外，我还介绍了前端框架中模板引擎的实现原理，包括解析语法生成\n                      AST 对象、根据 AST 对象生成 DOM 元素，并对生成的 DOM\n                      元素进行标记，则可以在变量改变的时候，解析找到相应的 DOM\n                      元素进行内容的更新。\n                    </p>\n                    <p data-nodeid=\"68678\">\n                      在了解这些内容之后，我们可以在页面渲染遇到性能问题的时候，根据所使用框架的具体实现，找到可能导致页面渲染卡顿或是不流畅的原因。除此之外，在使用框架的过程中，遇到一些语法报错、XSS\n                      安全漏洞等问题的时候，也可以快速找到解决办法。\n                    </p>\n                    <p data-nodeid=\"68679\">\n                      今日思考：React.js 中的 JSX\n                      和模板引擎是什么关系？在留言区写出你的想法！\n                    </p>\n            "}