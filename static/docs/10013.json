{"title":"13 | 代码构建与 Webpack 必备技能","context":"\n                    <p data-nodeid=\"1169\" class=\"\">\n                      最初的页面开发中，前端实现一个页面只需要在一个文件里完成，包括\n                      HTML/CSS/JavaScript\n                      各种内容。后来，通常将常用的静态资源放置在\n                      CDN，并使用<code data-backticks=\"1\" data-nodeid=\"1299\"\n                        >&lt;link&gt;</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"1301\"\n                        >&lt;script&gt;</code\n                      >的 src\n                      属性引入的方式，来减少页面开发过程中的重复代码编写。\n                    </p>\n                    <p data-nodeid=\"1170\">\n                      如今前端页面的功能越来越复杂，规模也越来越大。为了提升代码的可读性、项目的可维护性，我们会将一些通用的工具和组件进行抽象，代码被有组织地按照一定规则进行划分，比如按照功能划分为页面、组件、工具库、脚本等。\n                    </p>\n                    <p data-nodeid=\"1171\">\n                      这个过程便是模块化，而 JavaScript 中的模块规范不止一种。\n                    </p>\n                    <h3 data-nodeid=\"1172\">JavaScript 模块</h3>\n                    <p data-nodeid=\"1173\">\n                      在 JavaScript 中，我们常说的模块规范包括\n                      CommonJS/AMD/UMD/ES6 Module\n                      四种。这些模块规范和定义之间的区别常常容易搞混，我们先来分别看一下。\n                    </p>\n                    <h4 data-nodeid=\"1174\">CommonJS 规范</h4>\n                    <p data-nodeid=\"1175\">\n                      CommonJS\n                      规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。\n                    </p>\n                    <p data-nodeid=\"1176\">\n                      我们来看一个 CommonJS 规范的模块示例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> beta = require(<span class=\"hljs-string\">'beta'</span>);\n</div></li><li><div class=\"code-word\">function verb {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> beta.verb();\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n</div></li><li><div class=\"code-word\">  verb: verb\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1178\">\n                      在该示例中，使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1311\"\n                        >require()</code\n                      >载入模块，使用<code data-backticks=\"1\" data-nodeid=\"1313\"\n                        >module.exports</code\n                      >输出模块 。<br />\n                      一般来说，CommonJS 有以下特点：\n                    </p>\n                    <ul data-nodeid=\"1179\">\n                      <li data-nodeid=\"1180\">\n                        <p data-nodeid=\"1181\">一个文件就是一个模块；</p>\n                      </li>\n                      <li data-nodeid=\"1182\">\n                        <p data-nodeid=\"1183\">\n                          使用<code data-backticks=\"1\" data-nodeid=\"1319\"\n                            >require()</code\n                          >载入模块，使用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"1321\"\n                            >module.exports</code\n                          >输出模块，因此各个模块间可以进行交互；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1184\">\n                        <p data-nodeid=\"1185\">不支持异步加载。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1186\">\n                      或许你已经知道，Node.js 环境使用的便是基于 CommonJS\n                      规范实现的模块系统，而如今我们提到 CommonJS\n                      规范，也基本上认为是 Node.js 系统。\n                    </p>\n                    <p data-nodeid=\"1187\">\n                      为什么浏览器环境不使用 CommonJS 规范呢？这是因为 CommonJS\n                      不支持异步加载，而前面我们也说过，浏览器环境中同步任务的执行会带来性能问题，但对于异步模块定义（AMD）来说就不存在这样的问题。\n                    </p>\n                    <h4 data-nodeid=\"1188\">AMD</h4>\n                    <p data-nodeid=\"1189\">\n                      顾名思义，异步模块定义（AMD）主要为了解决异步加载模块而提出，它通过指定模块和依赖项的方式来定义模块。\n                    </p>\n                    <p data-nodeid=\"1190\">\n                      RequireJS 便是基于 AMD\n                      的实现，我们同样可以看一个模块示例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">define(<span class=\"hljs-string\">\"alpha\"</span>, [<span class=\"hljs-string\">\"require\"</span>, <span class=\"hljs-string\">\"exports\"</span>, <span class=\"hljs-string\">\"beta\"</span>], function (\n</div></li><li><div class=\"code-word\">  require,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">exports</span>,\n</div></li><li><div class=\"code-word\">  beta\n</div></li><li><div class=\"code-word\">) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">exports</span>.verb = function () {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> beta.verb();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 或者可以这么写</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> require(<span class=\"hljs-string\">\"beta\"</span>).verb();\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1192\">\n                      在该示例中，导出 ID 为 alpha 的模块，依赖了 ID 为 beta\n                      的模块。\n                    </p>\n                    <p data-nodeid=\"1193\">\n                      现在我们知道，Node.js 环境中的模块系统基于 CommonJS\n                      规范，而浏览器环境中需要使用 AMD 实现。\n                    </p>\n                    <p data-nodeid=\"1194\">\n                      那么如果我们有一个模块，需要同时能运行在 Node.js\n                      环境和浏览器环境中，要怎么办？我们可以使用 UMD 模式。\n                    </p>\n                    <h4 data-nodeid=\"1195\">UMD</h4>\n                    <p data-nodeid=\"1196\">\n                      为了兼容 AMD 和 CommonJS\n                      的规范，通用模块定义（UMD）模式被提出，它在兼容两者的同时，也支持了传统的全局变量模式。\n                    </p>\n                    <p data-nodeid=\"1197\">我们来看一个 UMD 模式的模块示例：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">(function (root, factory) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (typeof define === <span class=\"hljs-string\">\"function\"</span> &amp;&amp; define.amd) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// AMD</span>\n</div></li><li><div class=\"code-word\">    define([<span class=\"hljs-string\">\"jquery\"</span>], factory);\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (typeof <span class=\"hljs-keyword\">exports</span> === <span class=\"hljs-string\">\"object\"</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// CommonJS</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = factory(require(<span class=\"hljs-string\">\"jquery\"</span>));\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 全局变量</span>\n</div></li><li><div class=\"code-word\">    root.returnExports = factory(root.jQuery);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">})(<span class=\"hljs-keyword\">this</span>, function ($) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1199\">\n                      可以看到，UMD\n                      模块头部通常都会有用来判断模块加载器环境的代码，并根据不同的环境提供了不同的方式进行加载。\n                    </p>\n                    <p data-nodeid=\"1200\">\n                      到这里，似乎不管是 Node.js\n                      环境还是浏览器环境，都有支持的模块规范，也有能相互兼容的模块规范了。那么，ES6\n                      模块又是什么呢？\n                    </p>\n                    <h4 data-nodeid=\"1201\">ES6 模块</h4>\n                    <p data-nodeid=\"1202\">\n                      相比于运行时进行加载的 CommonJS 规范，ES6\n                      模块化主要是为了<strong data-nodeid=\"1343\"\n                        >在编译阶段就可以确定各个模块之间的依赖关系</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1203\">\n                      我们同样来看一个 ES6 模块的示例代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// import 导入</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> BaseTask, { TaskType } from <span class=\"hljs-string\">\"./BaseTask\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// export 导出</span>\n</div></li><li><div class=\"code-word\">export { BaseTask };\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1205\">\n                      在该示例中，使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1346\"\n                        >import</code\n                      >加载模块，使用<code data-backticks=\"1\" data-nodeid=\"1348\"\n                        >export</code\n                      >输出模块。\n                    </p>\n                    <p data-nodeid=\"1206\">ES6 模块的特点如下：</p>\n                    <ul data-nodeid=\"1207\">\n                      <li data-nodeid=\"1208\">\n                        <p data-nodeid=\"1209\">\n                          使用<code data-backticks=\"1\" data-nodeid=\"1352\"\n                            >import</code\n                          >加载和<code data-backticks=\"1\" data-nodeid=\"1354\"\n                            >export</code\n                          >输出；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1210\">\n                        <p data-nodeid=\"1211\">\n                          一个模块只会加载一次（CommonJS 也是一样）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1212\">\n                        <p data-nodeid=\"1213\">\n                          导出的模块为变量引用，因此可以在内存中共享。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1214\">\n                      现在大多数前端项目中都使用 ES6 模块，由于 ES6\n                      模块化目的是编译阶段确定模块间依赖关系，因此我们需要在编译的时候使用\n                      Babel、Webpack 等方式构建依赖关系树。\n                    </p>\n                    <p data-nodeid=\"1215\">\n                      除此之外，ES6\n                      模块化在各个浏览器里的兼容性差异较大，因此同样需要进行\n                      Babal 编译以及 Webpack\n                      进行打包，这个过程我们称之为代码构建。\n                    </p>\n                    <p data-nodeid=\"1216\">\n                      我们来总结一下 CommonJS/AMD/UMD/ES6 Module\n                      这四种模块规范：\n                    </p>\n                    <ol data-nodeid=\"1217\">\n                      <li data-nodeid=\"1218\">\n                        <p data-nodeid=\"1219\">\n                          CommonJS\n                          规范定义了模块应该怎样进行编写，从而各个模块系统之间可以进行相互操作。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1220\">\n                        <p data-nodeid=\"1221\">\n                          CommonJS\n                          不支持异步加载，因此异步模块定义（AMD）主要为了解决异步加载模块而提出。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1222\">\n                        <p data-nodeid=\"1223\">\n                          通用模块定义（UMD）模式用于兼容 AMD 和 CommonJS\n                          的规范。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1224\">\n                        <p data-nodeid=\"1225\">\n                          CommonJS 规范用于运行时进行模块加载，ES6\n                          模块化可以在编译阶段确定各个模块之间的依赖关系。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1226\">\n                      下面，我们一起来看看 Webpack\n                      这个在前端项目中经常出现的工具。\n                    </p>\n                    <h3 data-nodeid=\"1227\">Webpack 工具都做了些什么</h3>\n                    <p data-nodeid=\"1228\">\n                      如今前端项目大多数都使用了模块化，而如果想要将多个文件的代码打包成最终可按照预期运行的代码，则需要使用到代码构建工具。\n                    </p>\n                    <p data-nodeid=\"1229\">\n                      不管项目代码是如何进行组织的，项目中又有多少个文件，最终浏览器依然会从\n                      HTML\n                      内容进行解析和加载，因此我们需要对项目中的代码进行构建（包括编译和打包），生成浏览器可正常解析和加载的内容。\n                    </p>\n                    <p data-nodeid=\"1230\">\n                      我们先来认识下常见的前端构建相关的工具。\n                    </p>\n                    <h4 data-nodeid=\"1231\" class=\"\">常见的前端构建工具</h4>\n                    <p data-nodeid=\"4965\">\n                      对于前端开发来说，我们会用到各式各样的构建/打包工具，比如这些。\n                    </p>\n                    <p data-nodeid=\"4966\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3F/7C/Cgp9HWCeSsSAHiJFAALlqT5qxqA460.png\"\n                        alt=\"图片2.png\"\n                        data-nodeid=\"4970\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"1234\">\n                      其中，涉及模块化代码打包的主要有\n                      Grunt/Gulp/Webpack/Rollup。很多同学会搞混这几个工具，这里我简单介绍下它们之间的区别。\n                    </p>\n                    <ol data-nodeid=\"1235\">\n                      <li data-nodeid=\"1236\">\n                        <p data-nodeid=\"1237\">\n                          Gulp/Grunt\n                          是一种能够优化前端工作流程的工具，比如自动刷新页面、combo、压缩\n                          CSS/JavaScript、编译 Less/Sass 等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1238\">\n                        <p data-nodeid=\"1239\">\n                          Webpack/Rollup 是一个 JavaScript\n                          的模块打包器，用于整合编译成最终的代码。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1240\">\n                        <p data-nodeid=\"1241\">\n                          其中，Rollup 通常用来构建库，Webpack\n                          更适合用来构建应用程序。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1242\">\n                      对于业务团队来说，进行代码的模块打包更多情况下会选择\n                      Webpack。那么，下面我们主要围绕 Webpack\n                      工具，来介绍代码模块化打包的过程。\n                    </p>\n                    <h3 data-nodeid=\"1243\">认识 Webpack</h3>\n                    <p data-nodeid=\"1244\">\n                      相信你肯定也认识\n                      Webpack，要了解一个工具，最好的方式就是从如何使用它开始熟悉。\n                    </p>\n                    <p data-nodeid=\"1245\">\n                      Webpack 的使用中有 4\n                      个核心概念：入口（entry）、输出（output）、Loader、插件（plugins），我们先来分别看看。\n                    </p>\n                    <h4 data-nodeid=\"1246\">入口（entry）</h4>\n                    <p data-nodeid=\"1247\">\n                      首先便是入口（entry），entry\n                      指向我们前端应用的第一个启动文件。例如，在 Vue 中是<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1385\"\n                        >new Vue()</code\n                      >位置所在的文件，在 Angular 中是启动<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1387\"\n                        >.bootstrap()</code\n                      >的文件，在 React 中则是<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1389\"\n                        >ReactDOM.render()</code\n                      >或者是<code data-backticks=\"1\" data-nodeid=\"1391\"\n                        >React.render()</code\n                      >的启动文件。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 将entry指向启动文件即可</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n</div></li><li><div class=\"code-word\">  entry: <span class=\"hljs-string\">\"./path/to/my/entry/file.js\"</span>,\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1249\">\n                      或许你会疑惑，入口的一个文件，又是怎样把整个前端项目中的代码关联起来，并进行打包的呢？\n                    </p>\n                    <p data-nodeid=\"3797\">\n                      实际上， Webpack 会从 entry\n                      开始，通过解析模块间的依赖关系，递归地构建出一个依赖图。我们如果在项目中使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"3800\"\n                        >webpack-bundle-analyzer</code\n                      >插件，也可以看到生成的这样一个依赖图。\n                    </p>\n                    <p data-nodeid=\"3798\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3F/85/CioPOWCeSrqACnYnABLbVfl-Zds569.png\"\n                        alt=\"图片4.png\"\n                        data-nodeid=\"3804\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"1252\">\n                      Webpack\n                      会根据依赖图来对各个模块进行整合，最终打包成一个或多个的文件，来提供给浏览器进行加载。\n                    </p>\n                    <p data-nodeid=\"1253\" class=\"\">\n                      既然有入口，那当然就有出口，Webpack\n                      中的出口由输出（output）字段来描述。\n                    </p>\n                    <h4 data-nodeid=\"1254\">输出（output）</h4>\n                    <p data-nodeid=\"1255\">\n                      输出（output）字段用于告诉 Webpack\n                      要将打包后的代码生成的文件名是什么（<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1404\"\n                        >filename</code\n                      >），以及将它们放在哪里（<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1406\"\n                        >path</code\n                      >）。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n</div></li><li><div class=\"code-word\">  output: {\n</div></li><li><div class=\"code-word\">    filename: <span class=\"hljs-string\">\"bundle.js\"</span>, <span class=\"hljs-comment\">// 编译文件的文件名，比如 main.js/bundle.js/index.js</span>\n</div></li><li><div class=\"code-word\">    path: <span class=\"hljs-string\">\"/home/proj/public/assets\"</span>, <span class=\"hljs-comment\">// 对应一个绝对路径，此路径是你希望一次性打包的目录</span>\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1257\">\n                      有了 entry 和 output，我们来看看 Webpack\n                      中间的编译过程中，是怎样用到 Loader 和 Plugins 的。\n                    </p>\n                    <h4 data-nodeid=\"1258\">Loader</h4>\n                    <p data-nodeid=\"1259\">\n                      要了解 Loader，你需要知道在 Webpack 中，每个文件(<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1411\"\n                        >.css</code\n                      >,<code data-backticks=\"1\" data-nodeid=\"1413\">.html</code\n                      >,<code data-backticks=\"1\" data-nodeid=\"1415\">.scss</code\n                      >,<code data-backticks=\"1\" data-nodeid=\"1417\">.jpg</code\n                      >等) 都会被作为模块处理。如果你看过生成的 bundle.js\n                      代码就会发现，Webpack\n                      将所有的模块打包一起，每个模块添加标记 id，通过这样一个 id\n                      去获取所需模块的代码。\n                    </p>\n                    <p data-nodeid=\"1260\">\n                      但实际上，Webpack 只理解 JavaScript，因此 Loader\n                      的作用就是把不同的模块和文件（比如\n                      HTML、CSS、JSX、Typescript 等）转换为 JavaScript 模块。\n                    </p>\n                    <p data-nodeid=\"2039\">\n                      而不同的应用场景需要不同的 Loader，比如我们经常会使用到的\n                      CSS 相关 Loader 和其他资源 Loader。\n                    </p>\n                    <p data-nodeid=\"2631\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3F/7C/Cgp9HWCeSqyAWHwvAAHProznCQc246.png\"\n                        alt=\"图片3.png\"\n                        data-nodeid=\"2635\"\n                      />\n                    </p>\n                    <p data-nodeid=\"2632\">\n                      前面我们说到，ES6 模块需要依赖 Babel 编译和 Webpack\n                      打包，而 Babel 在 Webpack 中就是使用 Loader\n                      的方式来进行编译的。\n                    </p>\n\n                    <p data-nodeid=\"1264\">\n                      babel-loader 将 ES6/ES7 语法编译生成\n                      ES5，其中部分特性还需要 babel-polyfill 支持。这是因为\n                      Babel 默认只转换新的 JavaScript 语法（比如<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1426\"\n                        >const/let</code\n                      >），但不会对新的 API（比如<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1428\"\n                        >Promise</code\n                      >）进行处理。\n                    </p>\n                    <p data-nodeid=\"1265\">\n                      Webpack 在编译过程中，支持多个 Loader\n                      通过流水线的方式进行先后编译，编译的顺序为从后往前，最终以\n                      JavaScript 模块的方式输出。\n                    </p>\n                    <p data-nodeid=\"1266\">\n                      到这里，我们知道 Webpack 以 entry 为入口，链式调用各个\n                      Loader 进行编译生成 JavaScript，最终打包放置在 output\n                      中。其中 Loader 只负责将其他非 JavaScript 模块转换成\n                      JavaScript 模块。\n                    </p>\n                    <p data-nodeid=\"1267\">\n                      那 Webpack\n                      又是怎样地对这些代码进行组织并生成文件呢？这就是插件\n                      Plugins 负责的事情。\n                    </p>\n                    <h4 data-nodeid=\"1268\">插件（plugins）</h4>\n                    <p data-nodeid=\"1269\">\n                      插件（plugins）主要负责解决 Loader\n                      无法做到的事情，它可以访问在 Webpack\n                      编译过程中的关键事件，对 Webpack\n                      内部示例的一些数据进行处理，处理完成后回调 Webpack\n                      让其继续。\n                    </p>\n                    <p data-nodeid=\"1270\">\n                      这样说或许有些抽象，我们直接来看看几个常用的插件就明白了。\n                    </p>\n                    <ul data-nodeid=\"1271\">\n                      <li data-nodeid=\"1272\">\n                        <p data-nodeid=\"1273\">\n                          HtmlwebpackPlugin：可以生成创建 HTML\n                          入口文件，也可以为 HTML 文件中引入的外部资源如\n                          script、link\n                          动态添加每次编译后的哈希值，防止引用缓存的外部文件问题。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1274\">\n                        <p data-nodeid=\"1275\">\n                          CommonsChunkPlugin：用来提取代码中的公共模块，并将这些公共模块按照预期进行打包生成独立的文件。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1276\">\n                        <p data-nodeid=\"1277\">\n                          ProvidePlugin：用来定义标识符，当遇到指定标识符的时候自动加载模块，适合引入的全局变量（比如\n                          jQuery）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1278\">\n                        <p data-nodeid=\"1279\">\n                          ExtractTextPlugin：可以将样式从 JavaScript\n                          中抽出，生成单独的 .css 样式文件。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1280\">\n                      看到这里你应该已经明白了，<strong data-nodeid=\"1445\"\n                        >插件可以用来控制最终生成的代码是如何进行组织和输出的，包括对代码的打包优化、压缩，甚至是启用模块热替换、重新定义环境中的变量，等等</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1281\">\n                      那么，现在我们已经知道 Webpack 到底对项目代码做了什么。\n                    </p>\n                    <ol data-nodeid=\"1282\">\n                      <li data-nodeid=\"1283\">\n                        <p data-nodeid=\"1284\">\n                          通过 entry 指定的入口开始，解析各个文件模块间的依赖。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1285\">\n                        <p data-nodeid=\"1286\">\n                          根据模块间的依赖关系，开始对各个模块进行编译。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1287\">\n                        <p data-nodeid=\"1288\">\n                          编译过程中，根据配置的规则对一些模块使用 Loader\n                          进行编译处理。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1289\">\n                        <p data-nodeid=\"1290\">\n                          根据插件的配置，对 Loader\n                          编译后的代码进行封装、优化、分块、压缩等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1291\">\n                        <p data-nodeid=\"1292\">\n                          最终 Webpack\n                          整合各个模块，根据依赖关系将它们打包成最终的一个或者多个文件。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1293\">\n                      这便是 Webpack 做的事情：<strong data-nodeid=\"1456\"\n                        >让前端项目中模块化的代码能最终在浏览器中进行加载、并正常地工作。</strong\n                      >\n                    </p>\n                    <h3 data-nodeid=\"1294\">小结</h3>\n                    <p data-nodeid=\"1295\">\n                      如今几乎大多数框架的代码构建工具（比如 Vue CLI、Create\n                      React App 等）底层实现都依赖\n                      Webpack。虽然这些前端框架都提供了完善的脚手架，也提供了丰富的配置功能，但如果想要对自己的项目进行更多优化，我们依然需要自己调整\n                      Webpack 配置，因此对它的掌握也是不可少的。\n                    </p>\n                    <p data-nodeid=\"1296\">\n                      对于前端来说，自动化工具的出现，大大降低了应用的开发和维护成本，也因此前端生态也日益丰富和完善。善用这些工具来解决开发过程中的痛点，是作为现代前端开发的必备技能。比如，我们可以使用\n                      Webpack 的 Loader 和插件，实现自己的 AST\n                      语法分析和代码处理过程，这也是许多前端框架在做的事情。\n                    </p>\n                    <p data-nodeid=\"1297\" class=\"\">\n                      如果你要做一个在编译时自动给 Class\n                      类加上指定装饰器的能力，你认为是应该使用 Loader 还是\n                      Plugins 呢？可以在留言区留下你的想法和实现逻辑。\n                    </p>\n            "}