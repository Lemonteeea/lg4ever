{"title":"08 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","context":"\n                    <p data-nodeid=\"34509\">\n                      在平时的开发工作中，我们经常使用侦听器帮助我们去观察某个数据的变化然后去执行一段逻辑。\n                    </p>\n                    <p data-nodeid=\"34510\">\n                      在 Vue.js 2.x 中，你可以通过 watch\n                      选项去初始化一个侦听器，称作 watcher：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> { \n</div></li><li><div class=\"code-word\">  watch: { \n</div></li><li><div class=\"code-word\">    a(newVal, oldVal) { \n</div></li><li><div class=\"code-word\">      console.log(<span class=\"hljs-string\">'new: %s,00 old: %s'</span>, newVal, oldVal) \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li></ol></code></pre>\n                    </div>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34512\">\n                      当然你也可以通过 $watch API 去创建一个侦听器：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> unwatch = vm.$watch(<span class=\"hljs-string\">'a'</span>, function(newVal, oldVal) { \n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'new: %s, old: %s'</span>, newVal, oldVal) \n</div></li><li><div class=\"code-word\">}) \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34514\">\n                      与 watch 选项不同，通过 $watch API 创建的侦听器 watcher\n                      会返回一个 unwatch 函数，你可以随时执行它来停止这个\n                      watcher 对数据的侦听，而对于 watch\n                      选项创建的侦听器，它会随着组件的销毁而停止对数据的侦听。\n                    </p>\n                    <p data-nodeid=\"34515\">\n                      在 Vue.js 3.0 中，虽然你仍可以使用 watch 选项，但针对\n                      Composition API，Vue.js 3.0 提供了 watch API\n                      来实现侦听器的效果。\n                    </p>\n                    <p data-nodeid=\"34516\">\n                      那么，接下来就随我一起来学习 watch API 吧。\n                    </p>\n                    <h3 data-nodeid=\"34517\">watch API 的用法</h3>\n                    <p data-nodeid=\"34518\">\n                      我们先来看 Vue.js 3.0 中 watch API 有哪些用法。\n                    </p>\n                    <p data-nodeid=\"39777\" class=\"\">\n                      1.watch API 可以<strong data-nodeid=\"39784\"\n                        >侦听一个 getter 函数</strong\n                      >，但是它必须返回一个响应式对象，当该响应式对象更新后，会执行对应的回调函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { reactive, watch } from <span class=\"hljs-string\">'vue'</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> state = reactive({ count: <span class=\"hljs-number\">0</span> }) \n</div></li><li><div class=\"code-word\">watch(() =&gt; state.count, (count, prevCount) =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 当 state.count 更新，会触发此回调函数 </span>\n</div></li><li><div class=\"code-word\">}) \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"40649\" class=\"\">\n                      2.watch API 也可以直接<strong data-nodeid=\"40656\"\n                        >侦听一个响应式对象</strong\n                      >，当响应式对象更新后，会执行对应的回调函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { ref, watch } from <span class=\"hljs-string\">'vue'</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>) \n</div></li><li><div class=\"code-word\">watch(count, (count, prevCount) =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 当 count.value 更新，会触发此回调函数 </span>\n</div></li><li><div class=\"code-word\">}) \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"41946\" class=\"\">\n                      3.watch API 还可以直接<strong data-nodeid=\"41953\"\n                        >侦听多个响应式对象</strong\n                      >，任意一个响应式对象更新后，就会执行对应的回调函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { ref, watch } from <span class=\"hljs-string\">'vue'</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> count2 = ref(<span class=\"hljs-number\">1</span>) \n</div></li><li><div class=\"code-word\">watch([count, count2], ([count, count2], [prevCount, prevCount2]) =&gt; { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 当 count.value 或者 count2.value 更新，会触发此回调函数 </span>\n</div></li><li><div class=\"code-word\">}) \n</div></li></ol></code></pre>\n                    </div>\n\n                    <h3 data-nodeid=\"34531\">watch API 实现原理</h3>\n                    <p data-nodeid=\"34532\">\n                      侦听器的言下之意就是，当侦听的对象或者函数发生了变化则自动执行某个回调函数，这和我们前面说过的副作用函数\n                      effect 很像， 那它的内部实现是不是依赖了 effect\n                      呢？带着这个疑问，我们来探究 watch API 的具体实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">watch</span><span class=\"hljs-params\">(source, cb, options)</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> ((process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp; !isFunction(cb)) { \n</div></li><li><div class=\"code-word\">    warn(\\`\\\\`watch(fn, options?)\\\\` signature has been moved to a separate API. \\` + \n</div></li><li><div class=\"code-word\">      \\`Use \\\\`watchEffect(fn, options?)\\\\` instead. \\\\`watch\\\\` now only \\` + \n</div></li><li><div class=\"code-word\">      \\`supports \\\\`watch(source, cb, options?) signature.\\`) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> doWatch(source, cb, options) \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">doWatch</span><span class=\"hljs-params\">(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ)</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 标准化 source </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 构造 applyCb 回调函数 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建 scheduler 时序执行函数 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建 effect 副作用函数 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 返回侦听器销毁函数 </span>\n</div></li><li><div class=\"code-word\">}    \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34534\">\n                      从代码中可以看到，watch 函数内部调用了 doWatch\n                      函数，调用前会在非生产环境下判断第二个参数 cb\n                      是不是一个函数，如果不是则会报警告以告诉用户应该使用\n                      watchEffect(fn, options) API，watchEffect API\n                      也是侦听器相关的 API，稍后我们会详细介绍。\n                    </p>\n                    <p data-nodeid=\"34535\">\n                      这个 doWatch\n                      函数很长，所以我只贴出了需要理解的部分，我用注释将这个函数的实现逻辑拆解成了几个步骤。可以看到，内部确实创建了\n                      effect\n                      副作用函数。接下来，就随我一步步看它具体做了哪些事情吧。\n                    </p>\n                    <h4 data-nodeid=\"44491\" class=\"\">标准化 source</h4>\n\n                    <p data-nodeid=\"34537\">\n                      我们先来看watch 函数的第一个参数 source。\n                    </p>\n                    <p data-nodeid=\"34538\">\n                      通过前文知道 source 可以是 getter\n                      函数，也可以是响应式对象甚至是响应式对象数组，所以我们需要标准化\n                      source，这是<strong data-nodeid=\"34651\"\n                        >标准化 source 的流程</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// source 不合法的时候会报警告 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> warnInvalidSource = (s) =&gt; { \n</div></li><li><div class=\"code-word\">  warn(\\`Invalid watch source: \\`, s, \\`A watch source can only be a getter/effect function, a ref, \\` + \n</div></li><li><div class=\"code-word\">    \\`a reactive object, or an array of these types.\\`) \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 当前组件实例 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> instance = <span class=\"hljs-function\">currentInstance \n</span></div></li><li><div class=\"code-word\">let getter \n</div></li><li><div class=\"code-word\"><span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(isArray(source)</span>) { \n</div></li><li><div class=\"code-word\">  getter = () =&gt; source.map(s =&gt; { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (isRef(s)) { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> s.value \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isReactive(s)) { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> traverse(s) \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isFunction(s)) { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> callWithErrorHandling(s, instance, <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">/* WATCH_GETTER */</span>) \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">      (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp; warnInvalidSource(s) \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  }) \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isRef(source)) { \n</div></li><li><div class=\"code-word\">  getter = () =&gt; source.value \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isReactive(source)) { \n</div></li><li><div class=\"code-word\">  getter = () =&gt; source \n</div></li><li><div class=\"code-word\">  deep = <span class=\"hljs-keyword\">true</span> \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isFunction(source)) { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (cb) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// getter with cb </span>\n</div></li><li><div class=\"code-word\">    getter = () =&gt; callWithErrorHandling(source, instance, <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">/* WATCH_GETTER */</span>) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// watchEffect 的逻辑 </span>\n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">  getter = NOOP \n</div></li><li><div class=\"code-word\">  (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp; warnInvalidSource(source) \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (cb &amp;&amp; deep) { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> baseGetter = getter \n</div></li><li><div class=\"code-word\">  getter = () =&gt; traverse(baseGetter()) \n</div></li><li><div class=\"code-word\">} \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34540\">\n                      其实，source 标准化主要是根据 source 的类型，将其变成\n                      <del data-nodeid=\"34657\">标准成</del> getter\n                      函数。具体来说：\n                    </p>\n                    <ol data-nodeid=\"34541\">\n                      <li data-nodeid=\"34542\">\n                        <p data-nodeid=\"34543\">\n                          如果 source 是 ref 对象，则创建一个访问 source.value\n                          的 getter 函数;\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34544\">\n                        <p data-nodeid=\"34545\">\n                          如果 source 是 reactive 对象，则创建一个访问 source 的\n                          getter 函数，并设置 deep 为 true（deep\n                          的作用我稍后会说）;\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34546\">\n                        <p data-nodeid=\"34547\" class=\"\">\n                          如果 source 是一个函数，则会进一步判断第二个参数 cb\n                          是否存在，对于 watch API 来说，cb\n                          是一定存在且是一个回调函数，这种情况下，getter\n                          就是一个简单的对 source 函数封装的函数。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"34548\">\n                      如果 source 不满足上述条件，则在非生产环境下报警告，提示\n                      source 类型不合法。\n                    </p>\n                    <p data-nodeid=\"34549\">\n                      我们来看一下最终标准化生成的 getter\n                      函数，它会返回一个响应式对象，在后续创建 effect runner\n                      副作用函数需要用到，每次执行 runner 就会把 getter\n                      函数返回的响应式对象作为 watcher 求值的结果，effect runner\n                      的创建流程我们后续会详细分析，这里不需要深入了解。\n                    </p>\n                    <p data-nodeid=\"34550\">\n                      最后我们来关注一下 deep 为 true\n                      的情况。此时，我们会发现生成的 getter 函数会被 traverse\n                      函数包装一层。traverse\n                      函数的实现很简单，即通过递归的方式访问 value\n                      的每一个子属性。那么，为什么要递归访问每一个子属性呢？\n                    </p>\n                    <p data-nodeid=\"34551\">\n                      其实 deep 属于 watcher 的一个配置选项，Vue.js 2.x\n                      也支持，表面含义是深度侦听，实际上是通过遍历对象的每一个子属性来实现。举个例子你就明白了：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { reactive, watch } from <span class=\"hljs-string\">'vue'</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> state = reactive({ \n</div></li><li><div class=\"code-word\">  count: { \n</div></li><li><div class=\"code-word\">    a: { \n</div></li><li><div class=\"code-word\">      b: <span class=\"hljs-number\">1</span> \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\">watch(state.count, (count, prevCount) =&gt; { \n</div></li><li><div class=\"code-word\">  console.log(count) \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\">state.count.a.b = <span class=\"hljs-number\">2</span>  \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34553\">\n                      这里，我们利用 reactive API\n                      创建了一个嵌套层级较深的响应式对象 state，然后再调用 watch\n                      API 侦听 state.count 的变化。接下来我们修改内部属性\n                      state.count.a.b 的值，你会发现 watcher\n                      的回调函数执行了，为什么会执行呢？\n                    </p>\n                    <p data-nodeid=\"34554\">\n                      学过响应式章节，我们知道只有对象属性先被访问触发了依赖收集，再去修改这个属性，才可以通知对应的依赖更新。而从上述业务代码来看，我们修改\n                      state.count.a.b 的值时并没有访问它 ，但还是触发了 watcher\n                      的回调函数。\n                    </p>\n                    <p data-nodeid=\"34555\">\n                      根本原因是，当我们执行 watch\n                      函数的时候，我们知道如果侦听的是一个 reactive\n                      对象，那么内部会设置 deep 为 true，然后执行 traverse\n                      去递归访问对象深层子属性，这个时候就会访问 state.count.a.b\n                      触发依赖收集，这里收集的依赖是 watcher 内部创建的 effect\n                      runner。因此，当我们再去修改 state.count.a.b\n                      的时候，就会通知这个 effect ，所以最终会执行 watcher\n                      的回调函数。\n                    </p>\n                    <p data-nodeid=\"34556\">\n                      当我们侦听一个通过 reactive API\n                      创建的响应式对象时，内部会执行 traverse\n                      函数，如果这个对象非常复杂，比如嵌套层级很深，那么递归\n                      traverse\n                      就会有一定的性能耗时。因此如果我们需要侦听这个复杂响应式对象内部的某个具体属性，就可以想办法减少\n                      traverse 带来的性能损耗。\n                    </p>\n                    <p data-nodeid=\"34557\">\n                      比如刚才的例子，我们就可以直接侦听 state.count.a.b\n                      的变化：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">watch(state.count.a, <span class=\"hljs-function\">(<span class=\"hljs-params\">newVal, oldVal</span>) =&gt;</span> { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">console</span>.log(newVal) \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\">state.count.a.b = <span class=\"hljs-number\">2</span> \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34559\">\n                      这样就可以减少内部执行 traverse\n                      的次数。你可能会问，直接侦听 state.count.a.b\n                      可以吗？答案是不行，因为 state.count.a.b\n                      已经是一个基础数字类型了，不符合 source\n                      要求的参数类型，所以会在非生产环境下报警告。\n                    </p>\n                    <p data-nodeid=\"34560\">\n                      那么有没有办法优化使得 traverse\n                      不执行呢？答案是可以的。我们可以侦听一个 getter 函数：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">watch(<span class=\"hljs-function\">() =&gt;</span> state.count.a.b, <span class=\"hljs-function\">(<span class=\"hljs-params\">newVal, oldVal</span>) =&gt;</span> { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">console</span>.log(newVal) \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\">state.count.a.b = <span class=\"hljs-number\">2</span> \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34562\">\n                      这样函数内部会访问并返回 state.count.a.b，一次 traverse\n                      都不会执行并且依然可以侦听到它的变化从而执行 watcher\n                      的回调函数。\n                    </p>\n                    <h4 data-nodeid=\"34563\">构造回调函数</h4>\n                    <p data-nodeid=\"34564\">\n                      处理完 watch API 第一个参数 source\n                      后，接下来处理第二个参数 cb。\n                    </p>\n                    <p data-nodeid=\"34565\">\n                      cb 是一个回调函数，它有三个参数：第一个 newValue\n                      代表新值；第二个 oldValue 代表旧值。第三个参数\n                      onInvalidate，我打算放在后面介绍。\n                    </p>\n                    <p data-nodeid=\"34566\">\n                      其实这样的 API\n                      设计非常好理解，即侦听一个值的变化，如果值变了就执行回调函数，回调函数里可以访问到新值和旧值。\n                    </p>\n                    <p data-nodeid=\"34567\">\n                      接下来我们来看一下构造回调函数的处理逻辑：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">let cleanup \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 注册无效回调函数 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> onInvalidate = (fn) =&gt; { \n</div></li><li><div class=\"code-word\">  cleanup = runner.options.onStop = () =&gt; { \n</div></li><li><div class=\"code-word\">    callWithErrorHandling(fn, instance, <span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">/* WATCH_CLEANUP */</span>) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 旧值初始值 </span>\n</div></li><li><div class=\"code-word\">let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE <span class=\"hljs-comment\">/*{}*/</span> \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 回调函数 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> applyCb = cb \n</div></li><li><div class=\"code-word\">  ? () =&gt; { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 组件销毁，则直接返回 </span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (instance &amp;&amp; instance.isUnmounted) { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 求得新值 </span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> newValue = runner() \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (deep || hasChanged(newValue, oldValue)) { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 执行清理函数 </span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (cleanup) { \n</div></li><li><div class=\"code-word\">        cleanup() \n</div></li><li><div class=\"code-word\">      } \n</div></li><li><div class=\"code-word\">      callWithAsyncErrorHandling(cb, instance, <span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">/* WATCH_CALLBACK */</span>, [ \n</div></li><li><div class=\"code-word\">        newValue, \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 第一次更改时传递旧值为 undefined </span>\n</div></li><li><div class=\"code-word\">        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, \n</div></li><li><div class=\"code-word\">        onInvalidate \n</div></li><li><div class=\"code-word\">      ]) \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 更新旧值 </span>\n</div></li><li><div class=\"code-word\">      oldValue = newValue \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  : <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span> \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34569\">\n                      onInvalidate 函数用来注册无效回调函数\n                      ，我们暂时不需要关注它，我们需要重点来看 applyCb。\n                      这个函数实际上就是对 cb\n                      做一层封装，当侦听的值发生变化时就会执行 applyCb\n                      方法，我们来分析一下它的实现。\n                    </p>\n                    <p data-nodeid=\"34570\">\n                      首先，watch API 和组件实例相关，因为通常我们会在组件的\n                      setup 函数中使用它，当组件销毁后，回调函数 cb\n                      不应该被执行而是直接返回。\n                    </p>\n                    <p data-nodeid=\"34571\">\n                      接着，执行 runner 求得新值，这里实际上就是执行前面创建的\n                      getter 函数求新值。\n                    </p>\n                    <p data-nodeid=\"34572\">\n                      最后进行判断，如果是 deep\n                      的情况或者新旧值发生了变化，则执行回调函数 cb，传入参数\n                      newValue 和\n                      oldValue。注意，第一次执行的时候旧值的初始值是空数组或者\n                      undefined。执行完回调函数 cb 后，把旧值 oldValue 再更新为\n                      newValue，这是为了下一次的比对。\n                    </p>\n                    <h4 data-nodeid=\"34573\">创建 scheduler</h4>\n                    <p data-nodeid=\"34574\">\n                      接下来我们要分析创建 scheduler 过程。\n                    </p>\n                    <p data-nodeid=\"34575\">\n                      scheduler 的作用是根据某种调度的方式去执行某种函数，在\n                      watch API\n                      中，主要影响到的是回调函数的执行方式。我们来看一下它的实现逻辑：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> invoke = (fn) =&gt; fn() \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">let scheduler \n</span></div></li><li><div class=\"code-word\"><span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(flush === <span class=\"hljs-string\">'sync'</span>)</span> { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 同步 </span>\n</div></li><li><div class=\"code-word\">  scheduler = invoke \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (flush === <span class=\"hljs-string\">'pre'</span>) { \n</div></li><li><div class=\"code-word\">  scheduler = job =&gt; { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!instance || instance.isMounted) { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 进入异步队列，组件更新前执行 </span>\n</div></li><li><div class=\"code-word\">      queueJob(job) \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果组件还没挂载，则同步执行确保在组件挂载前 </span>\n</div></li><li><div class=\"code-word\">      job() \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 进入异步队列，组件更新后执行 </span>\n</div></li><li><div class=\"code-word\">  scheduler = job =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense) \n</div></li><li><div class=\"code-word\">} \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34577\">\n                      Watch API 的参数除了 source 和 cb，还支持第三个参数\n                      options，不同的配置决定了 watcher\n                      的不同行为。前面我们也分析了 deep 为 true 的情况，除了\n                      source 为 reactive 对象时会默认把 deep 设置为\n                      true，你也可以主动传入第三个参数，把 deep 设置为 true。\n                    </p>\n                    <p data-nodeid=\"34578\">\n                      这里，scheduler 的创建逻辑受到了第三个参数 Options 中的\n                      flush 属性值的影响，不同的 flush 决定了 watcher\n                      的执行时机。\n                    </p>\n                    <ul data-nodeid=\"34579\">\n                      <li data-nodeid=\"34580\">\n                        <p data-nodeid=\"34581\">\n                          当 flush 为 sync 的时候，表示它是一个同步\n                          watcher，即当数据变化时同步执行回调函数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34582\">\n                        <p data-nodeid=\"34583\">\n                          当 flush 为 pre 的时候，回调函数通过 queueJob\n                          的方式在组件更新之前执行，如果组件还没挂载，则同步执行确保回调函数在组件挂载之前执行。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34584\">\n                        <p data-nodeid=\"34585\">\n                          如果没设置 flush，那么回调函数通过\n                          queuePostRenderEffect 的方式在组件更新之后执行。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"34586\">\n                      queueJob 和 queuePostRenderEffect\n                      在这里不是重点，所以我们放到后面介绍。总之，你现在要记住，<strong\n                        data-nodeid=\"34695\"\n                        >watcher 的回调函数是通过一定的调度方式执行的</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"34587\">创建 effect</h4>\n                    <p data-nodeid=\"34588\">\n                      前面的分析我们提到了 runner，它其实就是 watcher 内部创建的\n                      effect 函数，接下来，我们来分析它逻辑：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> runner = effect(getter, { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 延时执行 </span>\n</div></li><li><div class=\"code-word\">  lazy: <span class=\"hljs-keyword\">true</span>, \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// computed effect 可以优先于普通的 effect 先运行，比如组件渲染的 effect </span>\n</div></li><li><div class=\"code-word\">  computed: <span class=\"hljs-keyword\">true</span>, \n</div></li><li><div class=\"code-word\">  onTrack, \n</div></li><li><div class=\"code-word\">  onTrigger, \n</div></li><li><div class=\"code-word\">  scheduler: applyCb ? () =&gt; scheduler(applyCb) : scheduler \n</div></li><li><div class=\"code-word\">}) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 在组件实例中记录这个 effect </span>\n</div></li><li><div class=\"code-word\">recordInstanceBoundEffect(runner) \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 初次执行 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (applyCb) { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (immediate) { \n</div></li><li><div class=\"code-word\">    applyCb() \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 求旧值 </span>\n</div></li><li><div class=\"code-word\">    oldValue = runner() \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">else</span> { \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 没有 cb 的情况 </span>\n</div></li><li><div class=\"code-word\">  runner() \n</div></li><li><div class=\"code-word\">} \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34590\">\n                      这块代码逻辑是整个 watcher 实现的核心部分，即通过 effect\n                      API 创建一个副作用函数 runner，我们需要关注以下几点。\n                    </p>\n                    <ul data-nodeid=\"34591\">\n                      <li data-nodeid=\"34592\">\n                        <p data-nodeid=\"34593\">\n                          <strong data-nodeid=\"34703\"\n                            >runner 是一个 computed effect</strong\n                          >。因为 computed effect 可以优先于普通的\n                          effect（比如组件渲染的\n                          effect）先运行，这样就可以实现当配置 flush 为 pre\n                          的时候，watcher 的执行可以优先于组件更新。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34594\">\n                        <p data-nodeid=\"34595\">\n                          <strong data-nodeid=\"34708\">runner 执行的方式</strong\n                          >。runner 是 lazy\n                          的，它不会在创建后立刻执行。第一次手动执行 runner\n                          会执行前面的 getter\n                          函数，访问响应式数据并做依赖收集。注意，此时activeEffect\n                          就是 runner，这样在后面更新响应式数据时，就可以触发\n                          runner 执行 scheduler\n                          函数，以一种调度方式来执行回调函数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34596\">\n                        <p data-nodeid=\"34597\">\n                          <strong data-nodeid=\"34713\">runner 的返回结果</strong\n                          >。手动执行 runner 就相当于执行了前面标准化的 getter\n                          函数，getter 函数的返回值就是 watcher\n                          计算出的值，所以我们第一次执行 runner 求得的值可以作为\n                          oldValue。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"34598\">\n                        <p data-nodeid=\"34599\">\n                          <strong data-nodeid=\"34718\"\n                            >配置了 immediate 的情况</strong\n                          >。当我们配置了 immediate ，创建完 watcher 会立刻执行\n                          applyCb 函数，此时 oldValue 还是初始值，在 applyCb\n                          执行时也会执行 runner 进而执行前面的 getter\n                          函数做依赖收集，求得新值。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"34600\">返回销毁函数</h4>\n                    <p data-nodeid=\"34601\">\n                      最后，会返回侦听器销毁函数，也就是 watch API\n                      执行后返回的函数。我们可以通过调用它来停止 watcher\n                      对数据的侦听。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> () =&gt; { \n</div></li><li><div class=\"code-word\">  stop(runner) \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (instance) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 移除组件 effects 对这个 runner 的引用 </span>\n</div></li><li><div class=\"code-word\">    remove(instance.effects, runner) \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">(effect)</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (effect.active) { \n</div></li><li><div class=\"code-word\">    cleanup(effect) \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (effect.options.onStop) { \n</div></li><li><div class=\"code-word\">      effect.options.onStop() \n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">    effect.active = <span class=\"hljs-keyword\">false</span> \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">} \n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"34603\">\n                      销毁函数内部会执行 stop 方法让 runner 失活，并清理 runner\n                      的相关依赖，这样就可以停止对数据的侦听。并且，如果是在组件中注册的\n                      watcher，也会移除组件 effects 对这个 runner 的引用。\n                    </p>\n                    <p data-nodeid=\"34604\">\n                      好了，到这里我们对 watch API\n                      的分析就可以告一段落了。侦听器的内部设计很巧妙，我们可以侦听响应式数据的变化，内部创建\n                      effect runner，首次执行 runner\n                      做依赖收集，然后在数据发生变化后，以某种调度方式去执行回调函数。\n                    </p>\n                    <blockquote data-nodeid=\"34605\">\n                      <p data-nodeid=\"34606\">\n                        <strong data-nodeid=\"34729\"\n                          >本节课的相关代码在源代码中的位置如下：</strong\n                        ><br />\n                        packages/runtime-core/src/apiWatch.ts\n                      </p>\n                    </blockquote>\n            "}