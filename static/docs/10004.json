{"title":"04 | JavaScript 引擎如何执行 JavaScript 代码？","context":"\n                    <p data-nodeid=\"27241\">\n                      JavaScript 在运行过程中与其他语言有所不一样，如果你不理解\n                      JavaScript\n                      的词法环境、执行上下文等内容，很容易会在开发过程中埋下“莫名奇妙”的\n                      Bug，比如<code data-backticks=\"1\" data-nodeid=\"27243\"\n                        >this</code\n                      >指向和预期不一致、某个变量不知道为什么被改了，等等。所以今天我就跟大家聊一聊\n                      JavaScript 代码的运行过程。\n                    </p>\n\n                    <p data-nodeid=\"25732\">\n                      大家都知道，JavaScript 代码是需要在 JavaScript\n                      引擎中运行的。我们在说到 JavaScript\n                      运行的时候，常常会提到执行环境、词法环境、作用域、执行上下文、闭包等内容。这些概念看起来都差不多，却好像又不大容易区分清楚，它们分别都在描述什么呢？\n                    </p>\n                    <p data-nodeid=\"25733\">\n                      这些词语都是与 JavaScript\n                      引擎执行代码的过程有关，为了搞清楚这些概念之间的区别，我们可以回顾下\n                      JavaScript 代码运行过程中的各个阶段。\n                    </p>\n                    <h3 data-nodeid=\"28245\" class=\"\">\n                      JavaScript 代码运行的各个阶段\n                    </h3>\n\n                    <p data-nodeid=\"25735\">\n                      JavaScript\n                      是弱类型语言，在运行时才能确定变量类型。即使是如今流行的\n                      TypeScript，也只是增加了编译时（编译成\n                      JavaScript）的类型检测（对于编译器相信大家都有所了解，代码编译过程中编译器会进行词法分析、语法分析、语义分析、生成\n                      AST 等处理）。\n                    </p>\n                    <p data-nodeid=\"25736\">\n                      同样，JavaScript 引擎在执行 JavaScript\n                      代码时，也会从上到下进行词法分析、语法分析、语义分析等处理，并在代码解析完成后生成\n                      AST（抽象语法树），最终根据 AST 生成 CPU\n                      可以执行的机器码并执行。\n                    </p>\n                    <p data-nodeid=\"25737\">\n                      这个过程，我们后面统一描述为语法分析阶段。除了语法分析阶段，JavaScript\n                      引擎在执行代码时还会进行其他的处理。以 V8 引擎为例，在 V8\n                      引擎中 JavaScript 代码的运行过程主要分成三个阶段。\n                    </p>\n                    <ol data-nodeid=\"31294\">\n                      <li data-nodeid=\"31295\">\n                        <p data-nodeid=\"31296\">\n                          <strong data-nodeid=\"31305\">语法分析阶段。</strong>\n                          该阶段会对代码进行语法分析，检查是否有语法错误（SyntaxError），如果发现语法错误，会在控制台抛出异常并终止执行。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"31297\">\n                        <p data-nodeid=\"31298\">\n                          <strong data-nodeid=\"31310\">编译阶段。</strong>\n                          该阶段会进行执行上下文（Execution\n                          Context）的创建，包括创建变量对象、建立作用域链、确定\n                          this 的指向等。每进入一个不同的运行环境时，V8\n                          引擎都会创建一个新的执行上下文。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"31299\">\n                        <p data-nodeid=\"31300\" class=\"\">\n                          <strong data-nodeid=\"31315\">执行阶段。</strong>\n                          将编译阶段中创建的执行上下文压入调用栈，并成为正在运行的执行上下文，代码执行结束后，将其弹出调用栈。\n                        </p>\n                      </li>\n                    </ol>\n\n                    <p data-nodeid=\"25745\">\n                      其中，语法分析阶段属于编译器通用内容，就不再赘述。前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。\n                    </p>\n                    <blockquote data-nodeid=\"25746\">\n                      <p data-nodeid=\"25747\">\n                        关于调用栈的内容我们会在下一讲详细讲解，目前我们只需要知道\n                        JavaScript 在运行过程中会产生一个调用栈，调用栈遵循\n                        LIFO（先进后出，后进先出）原则即可。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"25748\">\n                      今天，我们重点介绍编译阶段，而编译阶段的核心便是执行上下文的创建。\n                    </p>\n                    <h3 data-nodeid=\"32322\" class=\"\">执行上下文的创建</h3>\n\n                    <p data-nodeid=\"25750\">\n                      执行上下文的创建离不开 JavaScript 的运行环境，JavaScript\n                      运行环境包括全局环境、函数环境和<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25933\"\n                        >eval</code\n                      >，其中全局环境和函数环境的创建过程如下：\n                    </p>\n                    <ol data-nodeid=\"25751\">\n                      <li data-nodeid=\"25752\">\n                        <p data-nodeid=\"25753\">\n                          第一次载入 JavaScript\n                          代码时，首先会创建一个全局环境。全局环境位于最外层，直到应用程序退出后（例如关闭浏览器和网页）才会被销毁。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25754\">\n                        <p data-nodeid=\"25755\">\n                          每个函数都有自己的运行环境，当函数被调用时，则会进入该函数的运行环境。当该环境中的代码被全部执行完毕后，该环境会被销毁。不同的函数运行环境不一样，即使是同一个函数，在被多次调用时也会创建多个不同的函数环境。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"25756\">\n                      在不同的运行环境中，变量和函数可访问的其他数据范围不同，环境的行为（比如创建和销毁）也有所区别。而每进入一个不同的运行环境时，JavaScript\n                      都会创建一个新的执行上下文，该过程包括：\n                    </p>\n                    <ul data-nodeid=\"25757\">\n                      <li data-nodeid=\"25758\">\n                        <p data-nodeid=\"25759\">建立作用域链（Scope Chain）；</p>\n                      </li>\n                      <li data-nodeid=\"25760\">\n                        <p data-nodeid=\"25761\">\n                          创建变量对象（Variable Object，简称 VO）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25762\">\n                        <p data-nodeid=\"25763\">确定 this 的指向。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25764\">\n                      由于建立作用域链过程中会涉及变量对象的概念，因此我们先来看看变量对象的创建，再看建立作用域链和确定\n                      this 的指向。\n                    </p>\n                    <h4 data-nodeid=\"33330\" class=\"\">创建变量对象</h4>\n\n                    <p data-nodeid=\"25766\">\n                      什么是变量对象呢？每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。\n                    </p>\n                    <p data-nodeid=\"25767\">\n                      而在浏览器中，全局环境的变量对象是<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25945\"\n                        >window</code\n                      >对象，因此所有的全局变量和函数都是作为<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25947\"\n                        >window</code\n                      >对象的属性和方法创建的。相应的，在 Node\n                      中全局环境的变量对象则是<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25949\"\n                        >global</code\n                      >对象。\n                    </p>\n                    <p data-nodeid=\"25768\">\n                      了解了什么是变量对象之后，我们来看下创建变量对象的过程。创建变量对象将会创建<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25952\"\n                        >arguments</code\n                      >对象（仅函数环境下），同时会检查当前上下文的函数声明和变量声明。\n                    </p>\n                    <ul data-nodeid=\"25769\">\n                      <li data-nodeid=\"25770\">\n                        <p data-nodeid=\"25771\">\n                          对于变量声明：此时会给变量分配内存，并将其初始化为<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"25955\"\n                            >undefined</code\n                          >（该过程只进行定义声明，执行阶段才执行赋值语句）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25772\">\n                        <p data-nodeid=\"25773\">\n                          对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25774\">\n                      上述变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此\n                      ES6 中引入了<code data-backticks=\"1\" data-nodeid=\"25959\"\n                        >let</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"25961\"\n                        >const</code\n                      >关键字，从而使 JavaScript 也拥有了块级作用域。\n                    </p>\n                    <p data-nodeid=\"25775\">\n                      或许你会感到疑惑，JavaScript\n                      是怎么支持块级作用域的呢？这就涉及作用域的概念。\n                    </p>\n                    <p data-nodeid=\"25776\">\n                      在各类编程语言中，作用域分为静态作用域和动态作用域。JavaScript\n                      采用的是词法作用域（Lexical\n                      Scoping），也就是静态作用域。词法作用域中的变量，在编译过程中会产生一个确定的作用域。\n                    </p>\n                    <p data-nodeid=\"25777\">\n                      到这里，或许你对会词法作用域、作用域、执行上下文、词法环境之间的关系依然感到混乱，没关系，我这就来给你梳理下。\n                    </p>\n                    <p data-nodeid=\"25778\">\n                      刚刚说到，词法作用域中的变量，在编译过程中会产生一个确定的作用域，这个作用域即当前的执行上下文，在\n                      ES5 后我们使用词法环境（Lexical\n                      Environment）替代作用域来描述该执行上下文。因此，词法环境可理解为我们常说的作用域，同样也指当前的执行上下文（注意，是当前的执行上下文）。\n                    </p>\n                    <p data-nodeid=\"25779\">\n                      在 JavaScript 中，词法环境又分为词法环境（Lexical\n                      Environment）和变量环境（Variable\n                      Environment）两种，其中：\n                    </p>\n                    <ul data-nodeid=\"25780\">\n                      <li data-nodeid=\"25781\">\n                        <p data-nodeid=\"25782\">\n                          变量环境用来记录<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"25969\"\n                            >var</code\n                          >/<code data-backticks=\"1\" data-nodeid=\"25971\"\n                            >function</code\n                          >等变量声明；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25783\">\n                        <p data-nodeid=\"25784\">\n                          词法环境是用来记录<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"25974\"\n                            >let</code\n                          >/<code data-backticks=\"1\" data-nodeid=\"25976\"\n                            >const</code\n                          >/<code data-backticks=\"1\" data-nodeid=\"25978\"\n                            >class</code\n                          >等变量声明。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25785\">\n                      也就是说，创建变量过程中会进行函数提升和变量提升，JavaScript\n                      会通过词法环境来记录函数和变量声明。通过使用两个词法环境（而不是一个）分别记录不同的变量声明内容，JavaScript\n                      实现了支持块级作用域的同时，不影响原有的变量声明和函数声明。\n                    </p>\n                    <p data-nodeid=\"25786\">\n                      这就是创建变量的过程，它属于执行上下文创建中的一环。创建变量的过程会产生作用域，作用域也被称为词法环境，那词法环境是由什么组成的呢？下面我结合作用域链的建立过程一起来进行分析。\n                    </p>\n                    <h4 data-nodeid=\"34338\" class=\"\">建立作用域链</h4>\n\n                    <p data-nodeid=\"25788\">\n                      作用域链，顾名思义，就是将各个作用域通过某种方式连接在一起。\n                    </p>\n                    <p data-nodeid=\"25789\">\n                      前面说过，作用域就是词法环境，而词法环境由两个成员组成。\n                    </p>\n                    <ul data-nodeid=\"25790\">\n                      <li data-nodeid=\"25791\">\n                        <p data-nodeid=\"25792\">\n                          环境记录（Environment\n                          Record）：用于记录自身词法环境中的变量对象。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25793\">\n                        <p data-nodeid=\"25794\">\n                          外部词法环境引用（Outer Lexical\n                          Environment）：记录外层词法环境的引用。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25795\">\n                      通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25988\"\n                        >null</code\n                      >，这便是作用域链的变量查询。\n                    </p>\n                    <p data-nodeid=\"25796\">\n                      那么，这个外部词法环境引用又是怎样指向外层呢？我们来看看\n                      JavaScript 中是如何通过外部词法环境引用来创建作用域的。\n                    </p>\n                    <p data-nodeid=\"25797\">\n                      为了方便描述，我们将 JavaScript\n                      代码运行过程分为定义期和执行期，前面提到的编译阶段则属于定义期。\n                    </p>\n                    <p data-nodeid=\"25798\">\n                      来看一个例子，我们定义了全局函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25993\"\n                        >foo</code\n                      >，并在该函数中定义了函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25995\"\n                        >bar</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\"> &nbsp;console.dir(bar);\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-function\">function <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;a = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">console.dir(foo);\n</div></li><li><div class=\"code-word\">foo();\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25800\">\n                      前面我们说到，JavaScript\n                      使用的是静态作用域，因此函数的作用域在定义期已经决定了。在上面的例子中，全局函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"25998\"\n                        >foo</code\n                      >创建了一个<code data-backticks=\"1\" data-nodeid=\"26000\"\n                        >foo</code\n                      >的<code data-backticks=\"1\" data-nodeid=\"26002\"\n                        >[[scope]]</code\n                      >属性，包含了全局<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26004\"\n                        >[[scope]]</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">foo[[scope]] = [globalContext];\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25802\">\n                      而当我们执行<code data-backticks=\"1\" data-nodeid=\"26007\"\n                        >foo()</code\n                      >时，也会分别进入<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26009\"\n                        >foo</code\n                      >函数的定义期和执行期。\n                    </p>\n                    <p data-nodeid=\"25803\">\n                      在<code data-backticks=\"1\" data-nodeid=\"26012\">foo</code\n                      >函数的定义期时，函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26014\"\n                        >bar</code\n                      >的<code data-backticks=\"1\" data-nodeid=\"26016\"\n                        >[[scope]]</code\n                      >将会包含全局<code data-backticks=\"1\" data-nodeid=\"26018\"\n                        >[[scope]]</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"26020\">foo</code\n                      >的<code data-backticks=\"1\" data-nodeid=\"26022\"\n                        >[[scope]]</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">bar[[scope]] = [fooContext, globalContext];\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25805\">\n                      运行上述代码，我们可以在控制台看到符合预期的输出：\n                    </p>\n                    <p data-nodeid=\"35346\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/37/18/Cgp9HWB1uyGAAaZIAAK9qHI3wvE362.png\"\n                        alt=\"图片2.png\"\n                        data-nodeid=\"35349\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"25808\">可以看到：</p>\n                    <ul data-nodeid=\"25809\">\n                      <li data-nodeid=\"25810\">\n                        <p data-nodeid=\"25811\">\n                          <code data-backticks=\"1\" data-nodeid=\"26032\">foo</code\n                          >的<code data-backticks=\"1\" data-nodeid=\"26034\"\n                            >[[scope]]</code\n                          >属性包含了全局<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26036\"\n                            >[[scope]]</code\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25812\">\n                        <p data-nodeid=\"25813\">\n                          <code data-backticks=\"1\" data-nodeid=\"26037\">bar</code\n                          >的<code data-backticks=\"1\" data-nodeid=\"26039\"\n                            >[[scope]]</code\n                          >将会包含全局<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26041\"\n                            >[[scope]]</code\n                          >和<code data-backticks=\"1\" data-nodeid=\"26043\"\n                            >foo</code\n                          >的<code data-backticks=\"1\" data-nodeid=\"26045\"\n                            >[[scope]]</code\n                          >\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25814\">\n                      也就是说，<strong data-nodeid=\"26051\"\n                        >JavaScript\n                        会通过外部词法环境引用来创建变量对象的一个作用域链，从而保证对执行环境有权访问的变量和函数的有序访问</strong\n                      >。除了创建作用域链之外，在这个过程中还会对创建的变量对象做一些处理。\n                    </p>\n                    <p data-nodeid=\"25815\">\n                      前面我们说过，编译阶段会进行变量对象（VO）的创建，该过程会进行函数声明和变量声明，这时候变量的值被初始化为\n                      undefined。在代码进入执行阶段之后，JavaScript\n                      会对变量进行赋值，此时变量对象会转为活动对象（Active\n                      Object，简称 AO），转换后的活动对象才可被访问，这就是 VO\n                      -&gt; AO 的过程。\n                    </p>\n                    <p data-nodeid=\"25816\">\n                      为了更好地理解这个过程，我们来看个例子，我们在<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26054\"\n                        >foo</code\n                      >函数中定义了变量<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26056\"\n                        >b</code\n                      >、函数<code data-backticks=\"1\" data-nodeid=\"26058\"\n                        >c</code\n                      >和函数表达式变量<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26060\"\n                        >d</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(a)</span> </span>{\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-function\">function <span class=\"hljs-title\">c</span><span class=\"hljs-params\">()</span> </span>{}\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">var</span> d = function() {};\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">​\n</div></li><li><div class=\"code-word\">foo(<span class=\"hljs-number\">1</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25818\">\n                      在执行<code data-backticks=\"1\" data-nodeid=\"26063\"\n                        >foo(1)</code\n                      >时，首先进入定义期，此时：\n                    </p>\n                    <ul data-nodeid=\"25819\">\n                      <li data-nodeid=\"25820\">\n                        <p data-nodeid=\"25821\">\n                          参数变量<code data-backticks=\"1\" data-nodeid=\"26066\"\n                            >a</code\n                          >的值为<code data-backticks=\"1\" data-nodeid=\"26068\"\n                            >1</code\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25822\">\n                        <p data-nodeid=\"25823\">\n                          变量<code data-backticks=\"1\" data-nodeid=\"26070\"\n                            >b</code\n                          >和<code data-backticks=\"1\" data-nodeid=\"26072\"\n                            >d</code\n                          >初始化为<code data-backticks=\"1\" data-nodeid=\"26074\"\n                            >undefined</code\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25824\">\n                        <p data-nodeid=\"25825\">\n                          函数<code data-backticks=\"1\" data-nodeid=\"26076\"\n                            >c</code\n                          >创建函数并初始化\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">AO = {\n</div></li><li><div class=\"code-word\"> &nbsp;arguments: {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;length: <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\"> &nbsp;a: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\"> &nbsp;b: undefined,\n</div></li><li><div class=\"code-word\"> &nbsp;c: <span class=\"hljs-function\">reference to function <span class=\"hljs-title\">c</span><span class=\"hljs-params\">()</span></span>{},\n</div></li><li><div class=\"code-word\"> &nbsp;d: undefined\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25827\">\n                      前面我们也有提到，进入执行期之后，会执行赋值语句进行赋值，此时变量<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26079\"\n                        >b</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"26081\">d</code\n                      >会被赋值为 2 和函数表达式：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">AO = {\n</div></li><li><div class=\"code-word\">  &nbsp;arguments: {\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;length: <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\"> &nbsp;a: <span class=\"hljs-number\">1</span>,\n</div></li><li><div class=\"code-word\"> &nbsp;b: <span class=\"hljs-number\">2</span>,\n</div></li><li><div class=\"code-word\"> &nbsp;c: <span class=\"hljs-function\">reference to function <span class=\"hljs-title\">c</span><span class=\"hljs-params\">()</span></span>{},\n</div></li><li><div class=\"code-word\"> &nbsp;d: reference to FunctionExpression <span class=\"hljs-string\">\"d\"</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25829\">这就是 VO -&gt; AO 过程。</p>\n                    <ul data-nodeid=\"25830\">\n                      <li data-nodeid=\"25831\">\n                        <p data-nodeid=\"25832\">\n                          在定义期（编译阶段）：该对象值仍为<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26085\"\n                            >undefined</code\n                          >，且处于不可访问的状态。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25833\">\n                        <p data-nodeid=\"25834\">\n                          进入执行期（执行阶段）：VO\n                          被激活，其中变量属性会进行赋值。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25835\">\n                      实际上在执行的时候，除了 VO\n                      被激活，活动对象还会添加函数执行时传入的参数和<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26089\"\n                        >arguments</code\n                      >这个特殊对象，因此 AO 和 VO 的关系可以用以下关系来表达：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">AO = VO + function parameters + arguments\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25837\">\n                      现在，我们知道作用域链是在进入代码的执行阶段时，通过外部词法环境引用来创建的。总结如下：\n                    </p>\n                    <ul data-nodeid=\"25838\">\n                      <li data-nodeid=\"25839\">\n                        <p data-nodeid=\"25840\">\n                          在编译阶段，JavaScript\n                          在创建执行上下文的时候会先创建变量对象（VO）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25841\">\n                        <p data-nodeid=\"25842\">\n                          在执行阶段，变量对象（VO）被激活为活动对象（\n                          AO），函数内部的变量对象通过外部词法环境的引用创建作用域链。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25843\">\n                      虽然 JavaScript\n                      代码的运行过程可以分为语法分析阶段、编译阶段和执行阶段，但由于在\n                      JavaScript 引擎中是通过调用栈的方式来执行 JavaScript\n                      代码的（下一讲会介绍），因此并不存在“整个 JavaScript\n                      运行过程只会在某个阶段中”这一说法，比如上面例子中<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26095\"\n                        >bar</code\n                      >函数的编译阶段，其实是在<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26097\"\n                        >foo</code\n                      >函数的执行阶段中。\n                    </p>\n                    <p data-nodeid=\"25844\">\n                      一般来说，当函数执行结束之后，执行期上下文将被销毁（作用域链和活动对象均被销毁）。但有时候我们想要保留其中一些变量对象，不想被销毁，此时就会使用到闭包。\n                    </p>\n                    <p data-nodeid=\"25845\">\n                      我们已经知道，通过作用域链，我们可以在函数内部可以直接读取外部以及全局变量，但外部环境是无法访问内部函数里的变量。比如下面的例子中，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26101\"\n                        >foo</code\n                      >函数中定义了变量<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26103\"\n                        >a</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">foo();\n</div></li><li><div class=\"code-word\">console.log(a); <span class=\"hljs-comment\">// undefined</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25847\">\n                      我们在全局环境下无法访问函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26106\"\n                        >foo</code\n                      >中的变量<code data-backticks=\"1\" data-nodeid=\"26108\"\n                        >a</code\n                      >，这是因为全局函数的作用域链里，不含有函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26110\"\n                        >foo</code\n                      >内的作用域。\n                    </p>\n                    <p data-nodeid=\"25848\">\n                      如果我们想要访问内部函数的变量，可以通过函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26113\"\n                        >foo</code\n                      >中的函数<code data-backticks=\"1\" data-nodeid=\"26115\"\n                        >bar</code\n                      >返回变量<code data-backticks=\"1\" data-nodeid=\"26117\"\n                        >a</code\n                      >，并将函数<code data-backticks=\"1\" data-nodeid=\"26119\"\n                        >bar</code\n                      >返回，这样我们在全局环境中也可以通过调用函数<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26121\"\n                        >foo</code\n                      >返回的函数<code data-backticks=\"1\" data-nodeid=\"26123\"\n                        >bar</code\n                      >，来访问变量<code data-backticks=\"1\" data-nodeid=\"26125\"\n                        >a</code\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">function <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> a;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> bar;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> b = foo();\n</div></li><li><div class=\"code-word\">console.log(b()); <span class=\"hljs-comment\">// 1</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25850\">\n                      前面我们说到，当函数执行结束之后，执行期上下文将被销毁，其中包括作用域链和激活对象。那么，在这个例子中，当<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26128\"\n                        >b()</code\n                      >执行时，<code data-backticks=\"1\" data-nodeid=\"26130\"\n                        >foo</code\n                      >函数上下文包括作用域都已经被销毁了，为什么<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26132\"\n                        >foo</code\n                      >作用域下的<code data-backticks=\"1\" data-nodeid=\"26134\"\n                        >a</code\n                      >依然可以被访问到呢？\n                    </p>\n                    <p data-nodeid=\"25851\">\n                      这是因为<code data-backticks=\"1\" data-nodeid=\"26137\"\n                        >bar</code\n                      >函数引用了<code data-backticks=\"1\" data-nodeid=\"26139\"\n                        >foo</code\n                      >函数变量对象中的值，此时即使创建<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26141\"\n                        >bar</code\n                      >函数的<code data-backticks=\"1\" data-nodeid=\"26143\"\n                        >foo</code\n                      >函数执行上下文被销毁了，但它的变量对象依然会保留在\n                      JavaScript 内存中，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26145\"\n                        >bar</code\n                      >函数依然可以通过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26147\"\n                        >bar</code\n                      >函数的作用域链找到它，并进行访问。这便是我们常说的闭包，即使创建它的上下文已经销毁，它仍然被保留在内存中。\n                    </p>\n                    <p data-nodeid=\"25852\">\n                      闭包使得我们可以从外部读取局部变量，在大多数项目中都会被使用到，常见的用途包括：\n                    </p>\n                    <ul data-nodeid=\"25853\">\n                      <li data-nodeid=\"25854\">\n                        <p data-nodeid=\"25855\">\n                          用于从外部读取其他函数内部变量的函数；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25856\">\n                        <p data-nodeid=\"25857\">可以使用闭包来模拟私有方法；</p>\n                      </li>\n                      <li data-nodeid=\"25858\">\n                        <p data-nodeid=\"25859\">\n                          让这些变量的值始终保持在内存中。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25860\">\n                      需要注意的是，我们在使用闭包的时候，需要及时清理不再使用到的变量，否则可能导致内存泄漏问题。\n                    </p>\n                    <p data-nodeid=\"25861\">\n                      相信大家现在已经掌握了作用域链的建立过程，那么作用域链的用途想必大家也已经了解，比如在函数执行过程中变量的解析：\n                    </p>\n                    <ul data-nodeid=\"25862\">\n                      <li data-nodeid=\"25863\">\n                        <p data-nodeid=\"25864\">\n                          从当前词法环境开始，沿着作用域链逐级向外层寻找环境记录，直到找到同名变量为止；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25865\">\n                        <p data-nodeid=\"25866\">\n                          找到后不再继续遍历，找不到就报错。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25867\">\n                      下面我们继续来看，执行上下文的创建过程中还会做的一件事：确定<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26158\"\n                        >this</code\n                      >的指向。\n                    </p>\n                    <h4 data-nodeid=\"38350\" class=\"te-preview-highlight\">\n                      确定 this 的指向\n                    </h4>\n\n                    <p data-nodeid=\"25869\">\n                      在 JavaScript 中，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26162\"\n                        >this</code\n                      >指向执行当前代码对象的所有者，可简单理解为<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26164\"\n                        >this</code\n                      >指向最后调用当前代码的那个对象。相信大家都很熟悉<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26166\"\n                        >this</code\n                      >，因此这里我就进行结论性的简单总结。\n                    </p>\n                    <p data-nodeid=\"25870\">\n                      根据 JavaScript 中函数的调用方式不同，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26169\"\n                        >this</code\n                      >的指向分为以下情况。\n                    </p>\n                    <p data-nodeid=\"36348\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/37/18/Cgp9HWB1uzSAQvuHAAJh7k1PAh8263.png\"\n                        alt=\"this 指向.png\"\n                        data-nodeid=\"36351\"\n                      />\n                    </p>\n\n                    <ul data-nodeid=\"25872\">\n                      <li data-nodeid=\"25873\">\n                        <p data-nodeid=\"25874\">\n                          在全局环境中，<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26175\"\n                            >this</code\n                          >指向全局对象（在浏览器中为<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26177\"\n                            >window</code\n                          >）\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25875\">\n                        <p data-nodeid=\"25876\">\n                          在函数内部，<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26180\"\n                            >this</code\n                          >的值取决于函数被调用的方式\n                        </p>\n                        <ul data-nodeid=\"25877\">\n                          <li data-nodeid=\"25878\">\n                            <p data-nodeid=\"25879\">\n                              函数作为对象的方法被调用，<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"26183\"\n                                >this</code\n                              >指向调用这个方法的对象\n                            </p>\n                          </li>\n                          <li data-nodeid=\"25880\">\n                            <p data-nodeid=\"25881\">\n                              函数用作构造函数时（使用<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"26186\"\n                                >new</code\n                              >关键字），它的<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"26188\"\n                                >this</code\n                              >被绑定到正在构造的新对象\n                            </p>\n                          </li>\n                          <li data-nodeid=\"25882\">\n                            <p data-nodeid=\"25883\">\n                              在类的构造函数中，<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"26191\"\n                                >this</code\n                              >是一个常规对象，类中所有非静态的方法都会被添加到<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"26193\"\n                                >this</code\n                              >的原型中\n                            </p>\n                          </li>\n                        </ul>\n                      </li>\n                      <li data-nodeid=\"25884\">\n                        <p data-nodeid=\"25885\">\n                          在箭头函数中，<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26196\"\n                            >this</code\n                          >指向它被创建时的环境\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25886\">\n                        <p data-nodeid=\"25887\">\n                          使用<code data-backticks=\"1\" data-nodeid=\"26199\"\n                            >apply</code\n                          >、<code data-backticks=\"1\" data-nodeid=\"26201\"\n                            >call</code\n                          >、<code data-backticks=\"1\" data-nodeid=\"26203\"\n                            >bind</code\n                          >等方式调用：根据 API\n                          不同，可切换函数执行的上下文环境，即<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"26205\"\n                            >this</code\n                          >绑定的对象\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25888\">\n                      可以看到，<code data-backticks=\"1\" data-nodeid=\"26208\"\n                        >this</code\n                      >在不同的情况下会有不同的指向，在 ES6\n                      箭头函数还没出现之前，为了能正确获取某个运行环境下<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26210\"\n                        >this</code\n                      >对象，我们常常会使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26212\"\n                        >var that = this;</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"26214\"\n                        >var self = this;</code\n                      >这样的代码将变量分配给<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26216\"\n                        >this</code\n                      >，便于使用。这种方式降低了代码可读性，因此如今这种做法不再被提倡，通过正确使用箭头函数，我们可以更好地管理作用域。\n                    </p>\n                    <p data-nodeid=\"25889\">\n                      到这里，围绕 JavaScript\n                      的编译阶段和执行阶段中执行上下文创建相关的内容已经介绍完毕。\n                    </p>\n                    <h3 data-nodeid=\"37350\" class=\"\">小结</h3>\n\n                    <p data-nodeid=\"25891\">\n                      今天我主要介绍了 JavaScript\n                      代码的运行过程，该过程分为语法分析阶段、编译阶段、执行阶段三个阶段。\n                    </p>\n                    <p data-nodeid=\"25892\">\n                      在编译阶段，JavaScript会进行执行上下文的创建，包括：\n                    </p>\n                    <ul data-nodeid=\"25893\">\n                      <li data-nodeid=\"25894\">\n                        <p data-nodeid=\"25895\">\n                          创建变量对象，进行变量声明和函数声明，此时会产生变量提升和函数提升；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25896\">\n                        <p data-nodeid=\"25897\">\n                          通过添加对外部词法环境的引用，建立作用域链，通过作用域链可以访问外部的变量对象；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25898\">\n                        <p data-nodeid=\"25899\">确定 this 的指向。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"25900\">\n                      在执行阶段，变量对象（VO）会被激活为活动对象（AO），变量会进行赋值，此时活动对象才可被访问。在执行结束之后，作用域链和活动对象均被销毁，使用闭包可使活动对象依然被保留在内存中。这就是\n                      JavaScript 代码的运行过程。\n                    </p>\n                    <p data-nodeid=\"25901\">\n                      我们前面也说过，下面这段代码中<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26227\"\n                        >bar</code\n                      >函数的编译阶段是在<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"26229\"\n                        >foo</code\n                      >函数的执行阶段中 ：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\"> &nbsp;console.dir(bar);\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\"> &nbsp;<span class=\"hljs-function\">function <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\"> &nbsp; &nbsp;a = <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">console.dir(foo);\n</div></li><li><div class=\"code-word\">foo();\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25903\">\n                      你能说出整段代码的运行过程分别是怎样的，变量对象\n                      AO/VO、作用域链、this\n                      指向在各个阶段中又会怎样表现呢？可以把你的想法写在留言区。\n                    </p>\n                    <p data-nodeid=\"25904\">\n                      其实，JavaScript 的运行过程和 EventLoop\n                      结合可以有更好的理解，关于 EventLoop\n                      我会在下一讲进行介绍，你也可以在学习之后再来结合本讲内容进行总结。\n                    </p>\n            "}