{"title":"03 | 复杂基础类型：TypeScript 与 JavaScript 有何不同？","context":"\n                    <p data-nodeid=\"1409\" class=\"\">\n                      学习完原始类型等知识点，你可能已经对 TypeScript\n                      有了基本的认知。在接下来这一讲中，我将带你接触稍微复杂一点的类型结构（比如数组、any\n                      等比较难理解的特殊类型）及其使用场景。\n                    </p>\n                    <blockquote data-nodeid=\"1410\">\n                      <p data-nodeid=\"1411\">\n                        学习建议：请使用 VS Code 新建一个 03.Basic.2.ts\n                        文件，然后尝试课程中的所有示例。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"1412\">数组</h3>\n                    <p data-nodeid=\"1413\">\n                      因为 TypeScript 的数组和元组转译为 JavaScript\n                      后都是数组，所以这里我们把数组和元组这两个类型整合到一起介绍，也方便你更好地对比学习。\n                    </p>\n                    <h4 data-nodeid=\"1414\">数组类型（Array）</h4>\n                    <p data-nodeid=\"1415\">\n                      在 TypeScript 中，我们也可以像 JavaScript\n                      一样定义数组类型，并且指定数组元素的类型。\n                    </p>\n                    <p data-nodeid=\"1416\">\n                      首先，我们可以直接使用 []\n                      的形式定义数组类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">/** 子元素是数字类型的数组 */</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> arrayOfNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/** 子元素是字符串类型的数组 */</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> arrayOfString: <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'z'</span>];\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1418\">\n                      同样，我们也可以使用 Array 泛型（在第 10\n                      讲会详细介绍泛型）定义数组类型，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">/** 子元素是数字类型的数组 */</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> arrayOfNumber: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/** 子元素是字符串类型的数组 */</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> arrayOfString: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">string</span>&gt; = [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'z'</span>];\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1420\">\n                      以上两种定义数组类型的方式虽然本质上没有任何区别，但是我更推荐使用\n                      [] 这种形式来定义。<strong data-nodeid=\"1558\"\n                        >一方面可以避免与 JSX\n                        的语法冲突，另一方面可以减少不少代码量</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1421\">\n                      如果我们明确指定了数组元素的类型，以下所有操作都将因为不符合类型约定而提示错误。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> arrayOfNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'z'</span>]; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n</div></li><li><div class=\"code-word\">arrayOfNumber[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-string\">'a'</span>; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n</div></li><li><div class=\"code-word\">arrayOfNumber.push(<span class=\"hljs-string\">'b'</span>); <span class=\"hljs-comment\">// 提示 ts(2345)</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> arrayOfString: <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n</div></li><li><div class=\"code-word\">arrayOfString[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n</div></li><li><div class=\"code-word\">arrayOfString.push(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 提示 ts(2345)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"1423\">元组类型（Tuple）</h4>\n                    <p data-nodeid=\"1424\">\n                      元组最重要的特性是可以限制数组元素的个数和类型，它特别适合用来实现多值返回。\n                    </p>\n                    <p data-nodeid=\"1425\">\n                      我们熟知的一个使用元组的场景是 React Hooks（关于 React\n                      Hooks 的简介<a\n                        href=\"https://reactjs.org/docs/hooks-intro.html?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"1565\"\n                        >请点击这里查看</a\n                      >），例如 useState 示例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useCount</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> ....;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1427\">\n                      在 JavaScript\n                      中并没有元组的概念，作为一门动态类型语言，它的优势是<strong\n                        data-nodeid=\"1572\"\n                        >天然支持多类型元素数组</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1428\">\n                      我们假设以下两个数组的元素类型如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">[state, setState]\n</div></li><li><div class=\"code-word\">[setState, state]\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1430\">\n                      从上面可以看出，state 是一个类型为 State 的对象，而\n                      setState 是一个类型为 SetState 的函数。\n                    </p>\n                    <p data-nodeid=\"1431\">\n                      <strong data-nodeid=\"1578\"\n                        >注意：这里我们用全小写表示值，首字母大写表示（TypeScript）类型。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1432\">\n                      对于 JavaScript\n                      而言，上面的数组其实长的都一样，并没有一个有效的途径可以区分彼此。\n                    </p>\n                    <p data-nodeid=\"1433\">\n                      不过，出于较好的扩展性、可读性和稳定性考虑，我们往往会更偏向于<strong\n                        data-nodeid=\"1585\"\n                        >把不同类型的值通过键值对的形式塞到一个对象中，再返回这个对象</strong\n                      >（尽管这样会增加代码量），而不是使用没有任何限制的数组。比如我们可能会使用如下的对象结构来替换数组：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  state,\n</div></li><li><div class=\"code-word\">  setState\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1435\">\n                      而 TypeScript\n                      的元组类型正好弥补了这个不足，使得定义包含固定个数元素、每个元素类型未必相同的数组成为可能。（需要注意的是，毕竟\n                      TypeScript 会转译成 JavaScript，所以 TypeScript\n                      的元组无法在运行时约束所谓的“元组”像真正的元组一样，保证元素类型、长度不可变更）。\n                    </p>\n                    <p data-nodeid=\"1436\">\n                      对于 TypeScript 而言，如下所示的两个元组类型其实并不相同：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">[State, SetState]\n</div></li><li><div class=\"code-word\">[SetState, State]\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1438\">\n                      所以添加了不同元组类型注解的数组后，在 TypeScript\n                      静态类型检测层面就变成了两个不相同的元组，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> x: [State, SetState] = [state, setState];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> y: [SetState, State] = [setState, state];\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1440\">\n                      下面我们还是使用所熟知的 React Hooks 来介绍 TypeScript\n                      元组的应用场景。\n                    </p>\n                    <p data-nodeid=\"1441\">\n                      比如 useState\n                      的返回值类型是一个元组类型，如下代码所示（以下仅是简单的例子，事实上\n                      useState 的类型定义更为复杂）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">(state: State) =&gt; [State, SetState]\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1443\">\n                      元组相较对象而言，不仅为我们实现解构赋值提供了极大便利，还减少了不少代码量，这可能也是\n                      React 官方如此设计核心 Hooks 的重要原因之一。\n                    </p>\n                    <p data-nodeid=\"1444\">\n                      但事实上，许多第三方的 Hooks\n                      往往会出于扩展性、稳定性等考虑，尤其是需要返回的值的个数超过\n                      2 个时，会更偏向于使用对象作为返回值。\n                    </p>\n                    <blockquote data-nodeid=\"1445\">\n                      <p data-nodeid=\"1446\">\n                        这里需要注意：数组类型的值只有显示添加了元组类型注解后（或者使用\n                        as const，声明为只读元组），TypeScript\n                        才会把它当作元组，否则推荐出来的类型就是普通的数组类型（第\n                        4 讲会介绍类型推断）。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1447\">\n                      相对于以上熟悉的 JavaScript\n                      一般味道的数组类型，接下来我们将介绍几种不一样且需要费点心力理解的类型——特殊类型（这是并不是\n                      TypeScript 官方的定义，这么划分是为了更好地组织知识点）。\n                    </p>\n                    <h3 data-nodeid=\"1448\">特殊类型</h3>\n                    <h4 data-nodeid=\"1449\">1. any</h4>\n                    <p data-nodeid=\"1450\">\n                      any\n                      指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式。\n                    </p>\n                    <p data-nodeid=\"1451\">\n                      我们可以对被注解为 any\n                      类型的变量进行任何操作，包括获取事实上并不存在的属性、方法，并且\n                      TypeScript 还无法检测其属性是否存在、类型是否正确。\n                    </p>\n                    <p data-nodeid=\"1452\">\n                      比如我们可以把任何类型的值赋值给 any 类型的变量，也可以把\n                      any 类型的值赋值给任意类型（除 never\n                      以外）的变量，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> anything: <span class=\"hljs-built_in\">any</span> = {};\n</div></li><li><div class=\"code-word\">anything.doAnything(); <span class=\"hljs-comment\">// 不会提示错误</span>\n</div></li><li><div class=\"code-word\">anything = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 不会提示错误</span>\n</div></li><li><div class=\"code-word\">anything = <span class=\"hljs-string\">'x'</span>; <span class=\"hljs-comment\">// 不会提示错误</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = anything;&nbsp;<span class=\"hljs-comment\">// 不会提示错误</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">string</span> = anything;&nbsp;<span class=\"hljs-comment\">// 不会提示错误</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1454\">\n                      如果我们不想花费过高的成本为复杂的数据添加类型注解，或者已经引入了缺少类型注解的第三方组件库，这时就可以把这些值全部注解为\n                      any 类型，并告诉 TypeScript 选择性地忽略静态类型检测。\n                    </p>\n                    <p data-nodeid=\"1455\">\n                      尤其是在将一个基于 JavaScript 的应用改造成 TypeScript\n                      的过程中，我们不得不借助 any 来选择性添加和忽略对某些\n                      JavaScript 模块的静态类型检测，直至逐步替换掉所有的\n                      JavaScript。\n                    </p>\n                    <p data-nodeid=\"1456\">\n                      any 类型会在对象的调用链中进行传导，即所有 any\n                      类型的任意属性的类型都是 any，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> anything: <span class=\"hljs-built_in\">any</span> = {};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> z = anything.x.y.z; <span class=\"hljs-comment\">// z 类型是 any，不会提示错误</span>\n</div></li><li><div class=\"code-word\">z(); <span class=\"hljs-comment\">// 不会提示错误</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1458\">\n                      这里我们需要明白且记住：<strong data-nodeid=\"1610\"\n                        >Any is Hell（Any 是地狱）</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1459\">\n                      从长远来看，使用 any 绝对是一个坏习惯。如果一个 TypeScript\n                      应用中充满了\n                      any，此时静态类型检测基本起不到任何作用，也就是说与直接使用\n                      JavaScript 没有任何区别。<strong data-nodeid=\"1615\"\n                        >因此，除非有充足的理由，否则我们应该尽量避免使用 any\n                        ，并且开启禁用隐式 any 的设置。</strong\n                      >\n                    </p>\n                    <h4 data-nodeid=\"1460\">2. unknown</h4>\n                    <p data-nodeid=\"1461\">\n                      unknown 是 TypeScript 3.0\n                      中添加的一个类型，它主要用来描述类型并不确定的变量。\n                    </p>\n                    <p data-nodeid=\"1462\">\n                      比如在多个 if else\n                      条件分支场景下，它可以用来接收不同条件下类型各异的返回值的临时变量，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> result: unknown;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (x) {\n</div></li><li><div class=\"code-word\">  result = x();\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (y) {\n</div></li><li><div class=\"code-word\">  result = y();\n</div></li><li><div class=\"code-word\">} ...\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1464\">\n                      在 3.0 以前的版本中，只有使用 any\n                      才能满足这种动态类型场景。\n                    </p>\n                    <p data-nodeid=\"1465\">\n                      与 any 不同的是，unknown\n                      在类型上更安全。比如我们可以将任意类型的值赋值给\n                      unknown，但 unknown 类型的值只能赋值给 unknown 或\n                      any，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> result: unknown;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = result; <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> anything: <span class=\"hljs-built_in\">any</span> = result; <span class=\"hljs-comment\">// 不会提示错误</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1467\">\n                      使用 unknown 后，TypeScript\n                      会对它做类型检测。但是，如果不缩小类型（Type\n                      Narrowing），我们对 unknown\n                      执行的任何操作都会出现如下所示错误：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> result: unknown;\n</div></li><li><div class=\"code-word\">result.toFixed(); <span class=\"hljs-comment\">// 提示 ts(2571)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1469\">\n                      <strong data-nodeid=\"1628\"\n                        >而所有的类型缩小手段对 unknown 都有效</strong\n                      >，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> result: unknown;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">'number'</span>) {\n</div></li><li><div class=\"code-word\">  result.toFixed(); <span class=\"hljs-comment\">// 此处 hover result 提示类型是 number，不会提示错误</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"1471\">3. void、undefined、null</h4>\n                    <p data-nodeid=\"1472\">\n                      考虑再三，我们还是决定把 void、undefined 和 null\n                      “三废柴”特殊类型整合到一起介绍。\n                    </p>\n                    <p data-nodeid=\"1473\">\n                      依照官方的说法，它们实际上并没有太大的用处，尤其是在本专栏中强烈推荐并要求的\n                      strict 模式下，它们是名副其实的“废柴”。\n                    </p>\n                    <p data-nodeid=\"1474\">\n                      首先我们来说一下 void\n                      类型，它仅适用于表示没有返回值的函数。即如果该函数没有返回值，那它的类型就是\n                      void。\n                    </p>\n                    <p data-nodeid=\"1475\">\n                      在 strict 模式下，声明一个 void\n                      类型的变量几乎没有任何实际用处，因为我们不能把 void\n                      类型的变量值再赋值给除了 any 和 unkown\n                      之外的任何类型变量。\n                    </p>\n                    <p data-nodeid=\"1476\">\n                      然后我们说说 undefined 类型 和 null 类型，它们是\n                      TypeScript\n                      值与类型关键字同名的唯二例外。但这并不影响它们被称为“废柴”，因为单纯声明\n                      undefined 或者 null 类型的变量也是无比鸡肋，示例如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> undeclared: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// 鸡肋</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> nullable: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 鸡肋</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1478\">\n                      undefined 的最大价值主要体现在接口类型（第 7\n                      讲会涉及）上，它表示一个可缺省、未定义的属性。\n                    </p>\n                    <p data-nodeid=\"1479\">\n                      这里分享一个稍微有点费解的设计：<strong data-nodeid=\"1642\"\n                        >我们可以把 undefined 值或类型是 undefined 的变量赋值给\n                        void 类型变量，反过来，类型是 void 但值是 undefined\n                        的变量不能赋值给 undefined 类型。</strong\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> userInfo: {\n</div></li><li><div class=\"code-word\">  id?: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">} = {};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> undeclared: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> unusable: <span class=\"hljs-built_in\">void</span> = <span class=\"hljs-literal\">undefined</span>;\n</div></li><li><div class=\"code-word\">unusable = undeclared; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">undeclared = unusable; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1481\">\n                      而 null\n                      的价值我认为主要体现在接口制定上，它表明对象或属性可能是空值。尤其是在前后端交互的接口，比如\n                      Java Restful、Graphql，任何涉及查询的属性、对象都可能是\n                      null 空对象，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> userInfo: {\n</div></li><li><div class=\"code-word\">  name: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-built_in\">string</span>\n</div></li><li><div class=\"code-word\">} = { name: <span class=\"hljs-literal\">null</span> };\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1483\">\n                      除此之外，undefined 和 null\n                      类型还具备警示意义，它们可以提醒我们针对可能操作这两种（类型）值的情况做容错处理。\n                    </p>\n                    <p data-nodeid=\"1484\">\n                      我们需要类型守卫（Type Guard，<strong data-nodeid=\"1650\"\n                        >第 11 讲会专门讲解</strong\n                      >）在操作之前判断值的类型是否支持当前的操作。类型守卫既能通过类型缩小影响\n                      TypeScript 的类型检测，也能保障 JavaScript\n                      运行时的安全性，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> userInfo: {\n</div></li><li><div class=\"code-word\">  id?: <span class=\"hljs-built_in\">number</span>;\n</div></li><li><div class=\"code-word\">  name?: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-built_in\">string</span>\n</div></li><li><div class=\"code-word\">} = { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'Captain'</span> };\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (userInfo.id !== <span class=\"hljs-literal\">undefined</span>) { <span class=\"hljs-comment\">// Type Guard</span>\n</div></li><li><div class=\"code-word\">  userInfo.id.toFixed(); <span class=\"hljs-comment\">// id 的类型缩小成 number</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"1486\">\n                      我们不建议随意使用非空断言（下面要讲的“类型断言”中会详细介绍非空断言）来排除值可能为\n                      null 或 undefined 的情况，因为这样很不安全。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">userInfo.id!.toFixed(); <span class=\"hljs-comment\">// ok，但不建议</span>\n</div></li><li><div class=\"code-word\">userInfo.name!.toLowerCase() <span class=\"hljs-comment\">// ok，但不建议</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1488\">\n                      而比非空断言更安全、类型守卫更方便的做法是使用单问号（Optional\n                      Chain）、双问号（空值合并），我们可以使用它们来保障代码的安全性，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\">userInfo.id?.toFixed(); <span class=\"hljs-comment\">// Optional Chain</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> myName = userInfo.name?? <span class=\"hljs-string\">\\`my name is <span class=\"hljs-subst\">${info.name}</span>\\`</span>; <span class=\"hljs-comment\">// 空值合并</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"1490\">4. never</h4>\n                    <p data-nodeid=\"1491\">\n                      never\n                      表示永远不会发生值的类型，这里我们举一个实际的场景进行说明。\n                    </p>\n                    <p data-nodeid=\"1492\">\n                      首先，我们定义一个统一抛出错误的函数，代码示例如下（圆括号后\n                      : + 类型注解\n                      表示函数返回值的类型，关于函数类型我们会在后续\n                      <strong data-nodeid=\"1662\"\n                        >“第 5 讲：函数类型”详细讲解</strong\n                      >）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThrowError</span>(<span class=\"hljs-params\">msg: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">never</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">Error</span>(msg);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1494\">\n                      以上函数因为永远不会有返回值，所以它的返回值类型就是\n                      never。\n                    </p>\n                    <p data-nodeid=\"1495\">\n                      同样，如果函数代码中是一个死循环，那么这个函数的返回值类型也是\n                      never，如下代码所示。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">InfiniteLoop</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">never</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {}\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1497\">\n                      never\n                      是所有类型的子类型，它可以给所有类型赋值，如下代码所示。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> Unreachable: never = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li><li><div class=\"code-word\">Unreachable = <span class=\"hljs-string\">'string'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li><li><div class=\"code-word\">Unreachable = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> num: <span class=\"hljs-built_in\">number</span> = Unreachable; <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> str: <span class=\"hljs-built_in\">string</span> = Unreachable;&nbsp;<span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> bool: <span class=\"hljs-built_in\">boolean</span> = Unreachable;&nbsp;<span class=\"hljs-comment\">// ok</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1499\">\n                      但是反过来，除了 never 自身以外，其他类型（包括 any\n                      在内的类型）都不能为 never 类型赋值。\n                    </p>\n                    <p data-nodeid=\"1500\">\n                      在恒为 false 的类型守卫条件判断下，变量的类型将缩小为\n                      never（never 是所有其他类型的子类型，所以是类型缩小为\n                      never，而不是变成\n                      never）。因此，条件判断中的相关操作始终会报无法更正的错误（我们可以把这理解为一种基于静态类型检测的\n                      Dead Code 检测机制），如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> str: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'string'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> str === <span class=\"hljs-string\">'number'</span>) {\n</div></li><li><div class=\"code-word\">  str.toLowerCase(); <span class=\"hljs-comment\">// Property 'toLowerCase' does not exist on type 'never'.ts(2339)</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1502\">\n                      基于 never 的特性，我们还可以使用 never\n                      实现一些有意思的功能。比如我们可以把 never\n                      作为接口类型下的属性类型，用来禁止写接口下特定的属性，示例代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> props: {\n</div></li><li><div class=\"code-word\">  id: <span class=\"hljs-built_in\">number</span>,\n</div></li><li><div class=\"code-word\">  name?: never\n</div></li><li><div class=\"code-word\">} = {\n</div></li><li><div class=\"code-word\">  id: <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">props.name = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// ts(2322))</span>\n</div></li><li><div class=\"code-word\">props.name = <span class=\"hljs-string\">'str'</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li><li><div class=\"code-word\">props.name = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// ts(2322)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1504\">\n                      此时，无论我们给 props.name\n                      赋什么类型的值，它都会提示类型错误，实际效果等同于 name\n                      只读 。\n                    </p>\n                    <h4 data-nodeid=\"1505\">5. object</h4>\n                    <p data-nodeid=\"1506\">\n                      object\n                      类型表示非原始类型的类型，即非&nbsp;number、string、boolean、bigint、symbol、null、undefined\n                      的类型。然而，它也是个没有什么用武之地的类型，如下所示的一个应用场景是用来表示\n                      Object.create 的类型。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\">o: object | <span class=\"hljs-literal\">null</span></span>): <span class=\"hljs-title\">any</span></span>;\n</div></li><li><div class=\"code-word\">create({}); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">create(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">create(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// ts(2345)</span>\n</div></li><li><div class=\"code-word\">create(<span class=\"hljs-string\">'string'</span>); <span class=\"hljs-comment\">// ts(2345)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"1508\">类型断言（Type Assertion）</h3>\n                    <p data-nodeid=\"1509\">\n                      TypeScript\n                      类型检测无法做到绝对智能，毕竟程序不能像人一样思考。有时会碰到我们比\n                      TypeScript 更清楚实际类型的情况，比如下面的例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> arrayNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> greaterThan2: <span class=\"hljs-built_in\">number</span> = arrayNumber.find(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> num &gt; <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 提示 ts(2322)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1511\">\n                      其中，greaterThan2 一定是一个数字（确切地讲是 3），因为\n                      arrayNumber 中明显有大于 2\n                      的成员，但静态类型对运行时的逻辑无能为力。\n                    </p>\n                    <p data-nodeid=\"1512\">\n                      在 TypeScript 看来，greaterThan2\n                      的类型既可能是数字，也可能是\n                      undefined，所以上面的示例中提示了一个 ts(2322)\n                      错误，此时我们不能把类型 undefined 分配给类型 number。\n                    </p>\n                    <p data-nodeid=\"1513\">\n                      不过，我们可以使用一种笃定的方式——<strong\n                        data-nodeid=\"1683\"\n                        >类型断言</strong\n                      >（类似仅作用在类型层面的强制类型转换）告诉 TypeScript\n                      按照我们的方式做类型检查。\n                    </p>\n                    <p data-nodeid=\"1514\">\n                      比如，我们可以使用 as 语法做类型断言，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> arrayNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> greaterThan2: <span class=\"hljs-built_in\">number</span> = arrayNumber.find(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> num &gt; <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">number</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1516\">\n                      又或者是使用尖括号 + 类型的格式做类型断言，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> arrayNumber: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> greaterThan2: <span class=\"hljs-built_in\">number</span> = &lt;<span class=\"hljs-built_in\">number</span>&gt;arrayNumber.find(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> num &gt; <span class=\"hljs-number\">2</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1518\">\n                      以上两种方式虽然没有任何区别，但是尖括号格式会与 JSX\n                      产生语法冲突，因此我们更推荐使用 as 语法。\n                    </p>\n                    <blockquote data-nodeid=\"1519\">\n                      <p data-nodeid=\"1520\">\n                        注意：类型断言的操作对象必须满足某些约束关系，否则我们将得到一个\n                        ts(2352)\n                        错误，即从类型“源类型”到类型“目标类型”的转换是错误的，因为这两种类型不能充分重叠。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1521\">\n                      我一度喜欢用“指鹿为马”来形容类型断言，但其实也不够准确。\n                    </p>\n                    <p data-nodeid=\"1522\">\n                      从物种类型上看，鹿和马肯定不能转换，虽然它们都是动物（继承自同一个父类），但是鹿有“角属性”，马有“鬃毛属性”，所以两者不能充分重叠。\n                    </p>\n                    <p data-nodeid=\"1523\">\n                      <strong data-nodeid=\"1693\"\n                        >如果我们把它换成“指白马为马”“指马为白马”，就可以很贴切地体现类型断言的约束条件：父子、子父类型之间可以使用类型断言进行转换。</strong\n                      >\n                    </p>\n                    <blockquote data-nodeid=\"1524\">\n                      <p data-nodeid=\"1525\">\n                        <strong data-nodeid=\"1722\">注意</strong\n                        >：这个结论完全适用于复杂类型，但是对于\n                        number、string、boolean\n                        原始类型来说，不仅父子类型可以相互断言，父类型相同的类型也可以相互断言，比如\n                        1 as 2、'a' as 'b'、true as false（这里的 2、'b'、false\n                        被称之为字面量类型，在第 4 讲里会详细介绍），反过来 2 as\n                        1、'b' as 'a'、false as true 也是被允许的（这里的\n                        1、'a'、true\n                        是字面量类型），尽管这样的断言没有任何意义。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1526\">\n                      另外，any 和 unknown\n                      这两个特殊类型属于万金油，因为它们既可以被断言成任何类型，反过来任何类型也都可以被断言成\n                      any 或\n                      unknown。因此，如果我们想强行“指鹿为马”，就可以先把“鹿”断言为\n                      any 或 unknown，然后再把 any 和 unknown 断言为“马”，比如鹿\n                      as any as 马。\n                    </p>\n                    <p data-nodeid=\"1527\">\n                      我们除了可以把特定类型断言成符合约束添加的其他类型之外，还可以使用“字面量值\n                      + as const”语法结构进行常量断言，具体示例如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">/** str 类型是 '\"str\"' */</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'str'</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/** readOnlyArr 类型是 'readonly [0, 1]' */</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> readOnlyArr = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1529\">\n                      常量断言所涉及的字面量（字面量即代码中，比如\n                      '\"str\"'、'1'、'true'、'{}'）与字面量类型相关的知识点将在\n                      <strong data-nodeid=\"1748\">“第 03 讲：字面量类型”</strong>\n                      中详细讲解，这里我们就不对实例代码做原理解析了。你可以保持着好奇心，期待后续内容。\n                    </p>\n                    <p data-nodeid=\"1530\">\n                      此外还有一种特殊非空断言，即在值（变量、属性）的后边添加\n                      '!' 断言操作符，它可以用来排除值为 null、undefined\n                      的情况，具体示例如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> mayNullOrUndefinedOrString: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">mayNullOrUndefinedOrString!.toString(); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">mayNullOrUndefinedOrString.toString(); <span class=\"hljs-comment\">// ts(2531)</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1532\">\n                      对于非空断言来说，我们同样应该把它视作和 any\n                      一样危险的选择。\n                    </p>\n                    <p data-nodeid=\"1533\">\n                      在复杂应用场景中，如果我们使用非空断言，就无法保证之前一定非空的值，比如页面中一定存在\n                      id 为 feedback 的元素，数组中一定有满足 &gt; 2\n                      条件的数字，这些都不会被其他人改变。而一旦保证被改变，错误只会在运行环境中抛出，而静态类型检测是发现不了这些错误的。\n                    </p>\n                    <p data-nodeid=\"1534\">\n                      所以，我们建议使用类型守卫（更多讲解，见“第 11\n                      讲：类型守卫”）来代替非空断言，比如如下所示的条件判断：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">let</span> mayNullOrUndefinedOrString: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> mayNullOrUndefinedOrString === <span class=\"hljs-string\">'string'</span>) {\n</div></li><li><div class=\"code-word\">  mayNullOrUndefinedOrString.toString(); <span class=\"hljs-comment\">// ok</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"1536\">小结与预告</h3>\n                    <p data-nodeid=\"1537\">\n                      到这里，TypeScript\n                      所有的基础类型就交代完了，你需要反复消化，夯实基础，为\n                      04讲将要接触的稍微复杂的类型和应用场景做好准备。\n                    </p>\n                    <p data-nodeid=\"1538\" class=\"\">\n                      这里插播一个思考题：类型断言需要满足什么约束条件？欢迎你在留言区与我进行互动、交流。另外，如果你觉得本专栏有价值，欢迎分享给更多的好友哦~\n                    </p>\n            "}