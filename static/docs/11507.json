{"title":"05 | 多进程解决方案：cluster 模式以及 PM2 工具的原理介绍","context":"\n                    <p data-nodeid=\"1613\" class=\"\">\n                      前几讲我们都使用了一种非常简单暴力的方式（node\n                      app.js）启动 Node.js 服务器，而在线上我们要考虑使用多核\n                      CPU，充分利用服务器资源，这里就用到多进程解决方案，所以本讲介绍\n                      PM2 的原理以及如何应用一个 cluster 模式启动 Node.js 服务。\n                    </p>\n                    <h3 data-nodeid=\"1614\">单线程问题</h3>\n                    <p data-nodeid=\"1615\">\n                      在<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6783\"\n                        data-nodeid=\"1750\"\n                        >《01 | 事件循环：高性能到底是如何做到的？》</a\n                      >中我们分析了 Node.js 主线程是单线程的，如果我们使用 node\n                      app.js 方式运行，就启动了一个进程，只能在<strong\n                        data-nodeid=\"1764\"\n                        >一个 CPU 中进行运算</strong\n                      >，无法应用服务器的多核\n                      CPU，因此我们需要寻求一些解决方案。你能想到的解决方案肯定是<strong\n                        data-nodeid=\"1765\"\n                        >多进程分发策略</strong\n                      >，即主进程接收所有请求，然后通过一定的<strong\n                        data-nodeid=\"1766\"\n                        >负载均衡策略</strong\n                      >分发到不同的 Node.js 子进程中。如图 1 的方案所示：\n                    </p>\n                    <p data-nodeid=\"1616\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1D/E0/CioPOWBQKV2ABtnsAAAuF7ZUkEQ818.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"1769\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1617\">这一方案有 2 个不同的实现：</p>\n                    <ul data-nodeid=\"1618\">\n                      <li data-nodeid=\"1619\">\n                        <p data-nodeid=\"1620\">\n                          主进程监听一个端口，子进程不监听端口，通过主进程分发请求到子进程；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1621\">\n                        <p data-nodeid=\"1622\">\n                          主进程和子进程分别监听不同端口，通过主进程分发请求到子进程。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1623\">\n                      在 Node.js 中的 cluster 模式使用的是第一个实现。\n                    </p>\n                    <h3 data-nodeid=\"1624\">cluster 模式</h3>\n                    <p data-nodeid=\"1625\">\n                      cluster 模式其实就是我们上面图 1 所介绍的模式，<strong\n                        data-nodeid=\"1784\"\n                        >一个主进程</strong\n                      >和<strong data-nodeid=\"1785\">多个子进程</strong\n                      >，从而形成一个集群的概念。我们先来看看 cluster\n                      模式的应用例子。\n                    </p>\n                    <h4 data-nodeid=\"1626\">应用</h4>\n                    <p data-nodeid=\"1627\">\n                      我们先实现一个简单的 app.js，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 创建 http 服务，简单返回\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    res.write(<span class=\"hljs-string\">\\`hello world, start with cluster <span class=\"hljs-subst\">${process.pid}</span>\\`</span>);\n</div></li><li><div class=\"code-word\">    res.end();\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 启动服务\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\">server.listen(<span class=\"hljs-number\">3000</span>, () =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'server start http://127.0.0.1:3000'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`Worker <span class=\"hljs-subst\">${process.pid}</span> started\\`</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1629\">\n                      这是最简单的一个 Node.js 服务，接下来我们应用 cluster\n                      模式来包装这个服务，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> cluster = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'cluster'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> instances = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 启动进程数量</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (cluster.isMaster) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;i&lt;instances;i++) { <span class=\"hljs-comment\">// 使用 cluster.fork 创建子进程</span>\n</div></li><li><div class=\"code-word\">        cluster.fork();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./app.js'</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1631\">首先判断是否为主进程：</p>\n                    <ul data-nodeid=\"1632\">\n                      <li data-nodeid=\"1633\">\n                        <p data-nodeid=\"1634\">\n                          如果是则使用 cluster.fork 创建子进程；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1635\">\n                        <p data-nodeid=\"1636\">\n                          如果不是则为子进程 require 具体的 app.js。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1637\">然后运行下面命令启动服务。</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$ node cluster.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1639\">\n                      启动成功后，再打开另外一个命令行窗口，多次运行以下命令：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">curl <span class=\"hljs-string\">\"http://127.0.0.1:3000/\"</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1641\">你可以看到如下输出：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">hello world, start with cluster <span class=\"hljs-number\">4543</span>\n</div></li><li><div class=\"code-word\">hello world, start with cluster <span class=\"hljs-number\">4542</span>\n</div></li><li><div class=\"code-word\">hello world, start with cluster <span class=\"hljs-number\">4543</span>\n</div></li><li><div class=\"code-word\">hello world, start with cluster <span class=\"hljs-number\">4542</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1643\">\n                      后面的进程 ID 是比较有规律的随机数，有时候输出\n                      4543，有时候输出 4542，4543 和 4542 就是我们\n                      <strong data-nodeid=\"1800\">fork 出来的两个子进程</strong\n                      >，接下来我们看下为什么是这样的。\n                    </p>\n                    <h4 data-nodeid=\"1644\">原理</h4>\n                    <p data-nodeid=\"1645\">首先我们需要搞清楚两个问题：</p>\n                    <ul data-nodeid=\"1646\">\n                      <li data-nodeid=\"1647\">\n                        <p data-nodeid=\"1648\">\n                          Node.js 的 cluster 是如何做到多个进程监听一个端口的；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1649\">\n                        <p data-nodeid=\"1650\">\n                          Node.js 是如何进行负载均衡请求分发的。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1651\">\n                      <strong data-nodeid=\"1808\">多进程端口问题</strong>\n                    </p>\n                    <p data-nodeid=\"1652\">\n                      在 cluster 模式中存在 master 和 worker 的概念，<strong\n                        data-nodeid=\"1818\"\n                        >master 就是主进程</strong\n                      >，<strong data-nodeid=\"1819\">worker 则是子进程</strong\n                      >，因此这里我们需要看下 master 进程和 worker\n                      进程的创建方式。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> cluster = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'cluster'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> instances = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 启动进程数量</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (cluster.isMaster) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;i&lt;instances;i++) { <span class=\"hljs-comment\">// 使用 cluster.fork 创建子进程</span>\n</div></li><li><div class=\"code-word\">        cluster.fork();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./app.js'</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1654\">\n                      这段代码中，第一次 require 的 cluster 对象就默认是一个\n                      master，这里的判断逻辑在<a\n                        href=\"https://github.com/nodejs/node/blob/master/lib/cluster.js\"\n                        data-nodeid=\"1823\"\n                        >源码</a\n                      >中，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-meta\">'use strict'</span>;\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">const</span> childOrPrimary = <span class=\"hljs-string\">'NODE_UNIQUE_ID'</span> <span class=\"hljs-keyword\">in</span> process.env ? <span class=\"hljs-string\">'child'</span> : <span class=\"hljs-string\">'primary'</span>;\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\\`internal/cluster/<span class=\"hljs-subst\">${childOrPrimary}</span>\\`</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1656\">\n                      通过<strong data-nodeid=\"1830\">进程环境变量设置</strong\n                      >来判断：\n                    </p>\n                    <ul data-nodeid=\"1657\">\n                      <li data-nodeid=\"1658\">\n                        <p data-nodeid=\"1659\">如果没有设置则为 master 进程；</p>\n                      </li>\n                      <li data-nodeid=\"1660\">\n                        <p data-nodeid=\"1661\">如果有设置则为子进程。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1662\">\n                      因此第一次调用 cluster 模块是 master\n                      进程，而后都是子进程。\n                    </p>\n                    <p data-nodeid=\"1663\">主进程和子进程 require 文件不同：</p>\n                    <ul data-nodeid=\"1664\">\n                      <li data-nodeid=\"1665\">\n                        <p data-nodeid=\"1666\">\n                          前者是 internal/cluster/primary；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1667\">\n                        <p data-nodeid=\"1668\">\n                          后者是 internal/cluster/child。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1669\">\n                      我们先来看下 master 进程的创建过程，这部分<a\n                        href=\"https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/primary.js#L60\"\n                        data-nodeid=\"1840\"\n                        >代码在这里</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"1670\">\n                      可以看到 cluster.fork，一开始就会调用 setupPrimary\n                      方法，创建主进程，由于该方法是通过 cluster.fork\n                      调用，因此会调用多次，但是该模块有个全局变量 initialized\n                      用来区分是否为首次，如果是首次则创建，否则则跳过，如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (initialized === <span class=\"hljs-literal\">true</span>)\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-keyword\">return</span> process.nextTick(setupSettingsNT, settings);\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t  initialized = <span class=\"hljs-literal\">true</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1672\">\n                      接下来继续看 cluster.fork 方法，源码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">cluster.fork = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">env</span>) </span>{\n</div></li><li><div class=\"code-word\">\t  cluster.setupPrimary();\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">const</span> id = ++ids;\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">const</span> workerProcess = createWorkerProcess(id, env);\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">const</span> worker = <span class=\"hljs-keyword\">new</span> Worker({\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-attr\">id</span>: id,\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-attr\">process</span>: workerProcess\n</div></li><li><div class=\"code-word\">\t  });\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t  worker.on(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">message, handle</span>) </span>{\n</div></li><li><div class=\"code-word\">\t    cluster.emit(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-keyword\">this</span>, message, handle);\n</div></li><li><div class=\"code-word\">\t  });\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1674\">\n                      在上面代码中第 2 行就是<strong data-nodeid=\"1855\"\n                        >创建主进程</strong\n                      >，第 4 行就是<strong data-nodeid=\"1856\"\n                        >创建 worker 子进程</strong\n                      >，在这个 createWorkerProcess 方法中，最终是使用\n                      child_process\n                      来创建子进程的。在初始化代码中，我们调用了两次\n                      cluster.fork 方法，因此会创建 2\n                      个子进程，在创建后又会调用我们项目根目录下的 cluster.js\n                      启动一个新实例，这时候由于 cluster.isMaster 是\n                      false，因此会 require 到 internal/cluster/child 这个方法。\n                    </p>\n                    <p data-nodeid=\"1675\">\n                      由于是 worker 进程，因此代码会 require ('./app.js')\n                      模块，在该模块中会监听具体的端口，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 启动服务\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\">server.listen(<span class=\"hljs-number\">3000</span>, () =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'server start http://127.0.0.1:3000'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\\`Worker <span class=\"hljs-subst\">${process.pid}</span> started\\`</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1677\">\n                      这里的 server.listen 方法很重要，这部分<a\n                        href=\"https://github.com/nodejs/node/blob/15164cebcebfcad9822d3f065234a8c1511776a4/lib/net.js\"\n                        data-nodeid=\"1865\"\n                        >源代码在这里</a\n                      >，其中的 server.listen 会调用该模块中的 listenInCluster\n                      方法，该方法中有一个关键信息，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (cluster.isPrimary || exclusive) {\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-comment\">// Will create a new handle</span>\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-comment\">// _listen2 sets up the listened handle, it is still named like this</span>\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-comment\">// to avoid breaking code that wraps this method</span>\n</div></li><li><div class=\"code-word\">\t    server._listen2(address, port, addressType, backlog, fd, flags);\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">\t  }\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">const</span> serverQuery = {\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-attr\">address</span>: address,\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-attr\">port</span>: port,\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-attr\">addressType</span>: addressType,\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-attr\">fd</span>: fd,\n</div></li><li><div class=\"code-word\">\t    flags,\n</div></li><li><div class=\"code-word\">\t  };\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-comment\">// Get the primary's server handle, and listen on it</span>\n</div></li><li><div class=\"code-word\">\t  cluster._getServer(server, serverQuery, listenOnPrimaryHandle);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1679\">\n                      上面代码中的第 6 行，判断为<strong data-nodeid=\"1880\"\n                        >主进程</strong\n                      >，就是<strong data-nodeid=\"1881\"\n                        >真实的监听端口启动服务</strong\n                      >，而如果非主进程则调用 cluster._getServer 方法，也就是\n                      internal/cluster/child 中的 cluster._getServer 方法。\n                    </p>\n                    <p data-nodeid=\"1680\">接下来我们看下这部分代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">obj.once(<span class=\"hljs-string\">'listening'</span>, () =&gt; {\n</div></li><li><div class=\"code-word\">\t    cluster.worker.state = <span class=\"hljs-string\">'listening'</span>;\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-keyword\">const</span> address = obj.address();\n</div></li><li><div class=\"code-word\">\t    message.act = <span class=\"hljs-string\">'listening'</span>;\n</div></li><li><div class=\"code-word\">\t    message.port = (address &amp;&amp; address.port) || options.port;\n</div></li><li><div class=\"code-word\">\t    send(message);\n</div></li><li><div class=\"code-word\">\t  });\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1682\">\n                      这一代码通过 send 方法，如果监听到 listening\n                      发送一个消息给到主进程，主进程也有一个同样的 listening\n                      事件，监听到该事件后将子进程通过 EventEmitter\n                      绑定在主进程上，这样就完成了主子进程之间的<strong\n                        data-nodeid=\"1892\"\n                        >关联绑定</strong\n                      >，并且只监听了一个端口。而主子进程之间的通信方式，就是我们常听到的\n                      <strong data-nodeid=\"1893\">IPC 通信方式</strong>。\n                    </p>\n                    <p data-nodeid=\"1683\">\n                      <strong data-nodeid=\"1897\">负载均衡原理</strong>\n                    </p>\n                    <p data-nodeid=\"1684\">\n                      既然 Node.js cluster\n                      模块使用的是主子进程方式，那么它是如何进行负载均衡处理的呢，这里就会涉及\n                      Node.js cluster 模块中的两个模块。\n                    </p>\n                    <ul data-nodeid=\"1685\">\n                      <li data-nodeid=\"1686\">\n                        <p data-nodeid=\"1687\">\n                          <a\n                            href=\"https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/round_robin_handle.js\"\n                            data-nodeid=\"1905\"\n                            >round_robin_handle.js</a\n                          >（非 Windows 平台应用模式），这是一个<strong\n                            data-nodeid=\"1911\"\n                            >轮询处理模式</strong\n                          >，也就是轮询调度分发给空闲的子进程，处理完成后回到\n                          worker\n                          空闲池子中，这里要注意的就是如果绑定过就会复用该子进程，如果没有则会重新判断，这里可以通过上面的\n                          app.js\n                          代码来测试，用浏览器去访问，你会发现每次调用的子进程\n                          ID 都会不变。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1688\">\n                        <p data-nodeid=\"1689\">\n                          <a\n                            href=\"https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/shared_handle.js\"\n                            data-nodeid=\"1916\"\n                            >shared_handle.js</a\n                          >（ Windows\n                          平台应用模式），通过将文件描述符、端口等信息传递给子进程，子进程通过信息创建相应的\n                          SocketHandle /\n                          ServerHandle，然后进行相应的端口绑定和监听、处理请求。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1690\">\n                      以上就是 cluster 的原理，总结一下就是 cluster 模块应用\n                      child_process 来创建子进程，子进程通过复写掉\n                      cluster._getServer 方法，从而在 server.listen\n                      来保证只有主进程监听端口，主子进程通过 IPC\n                      进行通信，其次主进程根据平台或者协议不同，应用两种不同模块（round_robin_handle.js\n                      和\n                      shared_handle.js）进行请求分发给子进程处理。接下来我们看一下\n                      cluster 的成熟的应用工具 PM2 的应用和原理。\n                    </p>\n                    <h3 data-nodeid=\"1691\">PM2 原理</h3>\n                    <p data-nodeid=\"1692\">\n                      PM2 是<strong data-nodeid=\"1935\">守护进程管理器</strong\n                      >，可以帮助你管理和保持应用程序在线。PM2\n                      入门非常简单，它是一个简单直观的 CLI 工具，可以通过 NPM\n                      安装，接下来我们看下一些简单的用法。\n                    </p>\n                    <h4 data-nodeid=\"1693\">应用</h4>\n                    <p data-nodeid=\"1694\">\n                      你可以使用如下命令进行 NPM 或者 Yarn 的安装：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$ npm install pm2@latest -g\n</div></li><li><div class=\"code-word\"># or\n</div></li><li><div class=\"code-word\">$ yarn global add pm2\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1696\">\n                      安装成功后，可以使用如下命令查看是否安装成功以及当前的版本：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$&nbsp;pm2 --version\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1698\">\n                      接下来我们使用 PM2 启动一个简单的 Node.js\n                      项目，进入本讲代码的项目根目录，然后运行下面命令：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$&nbsp;pm2 start app.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1700\">运行后，再执行如下命令：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$&nbsp;pm2&nbsp;list\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1702\">\n                      可以看到如图 2 所示的结果，代表运行成功了。\n                    </p>\n                    <p data-nodeid=\"1703\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1D/E3/Cgp9HWBQKZeAM-MIAAB0_RHaw1E022.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"1944\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1704\">\n                      <p style=\"text-align: center\">图 2 pm2 list 运行结果</p>\n                    </div>\n                    <p data-nodeid=\"1705\">\n                      PM2 启动时可以带一些配置化参数，具体参数列表你可以参考<a\n                        href=\"https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/\"\n                        data-nodeid=\"1948\"\n                        >官方文档</a\n                      >。在开发中我总结出了一套最佳的实践，如以下配置所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-built_in\">module</span>.exports = {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">apps</span> : [{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"nodejs-column\"</span>, <span class=\"hljs-comment\">// 启动进程名</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">script</span>: <span class=\"hljs-string\">\"./app.js\"</span>, <span class=\"hljs-comment\">// 启动文件</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">instances</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// 启动进程数</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">exec_mode</span>: <span class=\"hljs-string\">'cluster'</span>, <span class=\"hljs-comment\">// 多进程多实例</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">env_development</span>: {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">\"development\"</span>,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">watch</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// 开发环境使用 true，其他必须设置为 false</span>\n</div></li><li><div class=\"code-word\">      },\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">env_testing</span>: {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">\"testing\"</span>,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">watch</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// 开发环境使用 true，其他必须设置为 false</span>\n</div></li><li><div class=\"code-word\">      },\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">env_production</span>: {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">\"production\"</span>,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">watch</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// 开发环境使用 true，其他必须设置为 false</span>\n</div></li><li><div class=\"code-word\">      },\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">log_date_format</span>: <span class=\"hljs-string\">'YYYY-MM-DD HH:mm Z'</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">error_file</span>: <span class=\"hljs-string\">'~/data/err.log'</span>, <span class=\"hljs-comment\">// 错误日志文件，必须设置在项目外的目录，这里为了测试</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">out_file</span>: <span class=\"hljs-string\">'~/data/info.log'</span>, <span class=\"hljs-comment\">//  流水日志，包括 console.log 日志，必须设置在项目外的目录，这里为了测试</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">max_restarts</span>: <span class=\"hljs-number\">10</span>,\n</div></li><li><div class=\"code-word\">    }]\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3650\" class=\"te-preview-highlight\">\n                      在上面的配置中要特别注意\n                      <strong data-nodeid=\"3664\">error_file</strong> 和\n                      <strong data-nodeid=\"3665\">out_file</strong\n                      >，这里的日志目录在项目初始化时要创建好，如果不提前创建好会导致线上运行失败，特别是无权限创建目录时。其次如果存在环境差异的配置时，可以放置在不同的环境下，最终可以使用下面三种方式来启动项目，分别对应不同环境。\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"shell\"><ol><li><div class=\"code-word\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> pm2 start pm2.config.js --env development</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> pm2 start pm2.config.js --env testing</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> pm2 start pm2.config.js --env production</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"1709\">原理</h4>\n                    <p data-nodeid=\"1710\">\n                      接下来我们来看下是如何实现的，由于整个项目是比较复杂庞大的，这里我们主要关注<strong\n                        data-nodeid=\"1971\"\n                        >进程创建管理的原理</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1711\">\n                      首先我们来看下进程创建的方式，整体的流程如图 3 所示。\n                    </p>\n                    <p data-nodeid=\"1712\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1D/E0/CioPOWBQKaWAHrR1AAKhg2CW1Z0319.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1975\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1713\">\n                      <p style=\"text-align: center\">\n                        图 3 PM2 源码多进程创建方式\n                      </p>\n                    </div>\n                    <p data-nodeid=\"1714\">这一方式涉及五个模块文件。</p>\n                    <ul data-nodeid=\"1715\">\n                      <li data-nodeid=\"1716\">\n                        <p data-nodeid=\"1717\">\n                          CLI（lib/binaries/CLI.js）处理命令行输入，如我们运行的命令：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">pm2 start pm2.config.js --env development\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"1719\">\n                      <li data-nodeid=\"1720\">\n                        <p data-nodeid=\"1721\">\n                          API（lib/API.js）对外暴露的各种命令行调用方法，比如上面的\n                          start 命令对应的 API-&gt;start 方法。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1722\">\n                        <p data-nodeid=\"1723\">\n                          Client\n                          （lib/Client.js）可以理解为命令行接收端，负责创建守护进程\n                          Daemon，并与 Daemon（lib/Daemon.js）保持 RPC 连接。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1724\">\n                        <p data-nodeid=\"1725\">\n                          God （lib/God.js）主要负责进程的创建和管理，主要是通过\n                          Daemon 调用，Client 所有调用都是通过 RPC 调用\n                          Daemon，然后 Daemon 调用 God 中的方法。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1726\">\n                        <p data-nodeid=\"1727\">\n                          最终在 God 中调用\n                          ClusterMode（lib/God/ClusterMode.js）模块，在\n                          ClusterMode 中调用 Node.js 的 cluster.fork\n                          创建子进程。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1728\">\n                      图 3 中首先通过命令行解析调用 API，API 中的方法基本上是与\n                      CLI 中的命令行一一对应的，API 中的 start\n                      方法会根据传入参数判断是否是调用的方法，一般情况下使用的都是一个\n                      JSON 配置文件，因此调用 API 中的私有方法 _startJson。\n                    </p>\n                    <p data-nodeid=\"1729\">\n                      接下来就开始在 Client 模块中流转了，在 _startJson 中会调用\n                      executeRemote 方法，该方法会先判断 PM2 的守护进程 Daemon\n                      是否启动，如果没有启动会先调用 Daemon\n                      模块中的方法启动守护进程 RPC 服务，启动成功后再通知 Client\n                      并建立 RPC 通信连接。\n                    </p>\n                    <p data-nodeid=\"1730\">\n                      成功建立连接后，Client 会发送启动 Node.js 子进程的命令\n                      prepare，该命令传递 Daemon，Daemon\n                      中有一份对应的命令的执行方法，该命令最终会调用 God 中的\n                      prepare 方法。\n                    </p>\n                    <p data-nodeid=\"1731\">\n                      在 God 中最终会调用 God 文件夹下的 ClusterMode 模块，应用\n                      Node.js 的 cluster.fork\n                      创建子进程，这样就完成了整个启动过程。\n                    </p>\n                    <p data-nodeid=\"1732\">\n                      综上所述，PM2 通过命令行，使用 RPC 建立 Client 与 Daemon\n                      进程之间的通信，通过 RPC 通信方式，调用 God，从而应用\n                      Node.js 的 cluster.fork\n                      创建子进程的。以上是启动的流程，对于其他命令指令，比如\n                      stop、restart\n                      等，也是一样的通信流转过程，你参照上面的流程分析就可以了，如果遇到任何问题，都可以在留言区与我交流。\n                    </p>\n                    <blockquote data-nodeid=\"1733\">\n                      <p data-nodeid=\"1734\">\n                        以上的分析你需要参考<a\n                          href=\"https://github.com/Unitech/pm2/tree/64f8ea0f2c31c7d70a415eccc6222547b3664e65\"\n                          data-nodeid=\"1994\"\n                          >PM2 的 GitHub 源码</a\n                        >。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"1735\">总结</h3>\n                    <p data-nodeid=\"1736\">\n                      本讲主要介绍了 Node.js 中的 cluster\n                      模块，并深入介绍了其核心原理，其次介绍了目前比较常用的多进程管理工具\n                      PM2 的应用和原理。学完本讲后，需要掌握 Node.js cluster\n                      原理，并且掌握 PM2 的实现原理。\n                    </p>\n                    <p data-nodeid=\"1737\">\n                      接下来我们将开始讲解一些关于 Node.js\n                      性能相关的知识，为后续的高性能服务做一定的准备，其次也在为后续性能优化打下一定的技术基础。\n                    </p>\n                    <p data-nodeid=\"1738\">\n                      下一讲会讲解，目前我们在使用的 Node.js cluster\n                      模式存在的性能问题。\n                    </p>\n                    <hr data-nodeid=\"1739\" />\n                    <p data-nodeid=\"1740\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"2004\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"2003\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"1741\">\n                      <strong data-nodeid=\"2008\">《大前端高薪训练营》</strong>\n                    </p>\n                    <p data-nodeid=\"1742\" class=\"\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"2012\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}