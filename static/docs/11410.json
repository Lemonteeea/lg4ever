{"title":"08&nbsp;| 排序：如何利用合并与快排的小技巧，解决算法难题？","context":"\n                    <p data-nodeid=\"6713\" class=\"\">\n                      今天我们开始学习一个非常有用的算法技能，排序。\n                    </p>\n                    <p data-nodeid=\"6714\">\n                      <strong data-nodeid=\"7094\"\n                        >排序在工程应用中有非常重要的作用</strong\n                      >，比如你随意点开一个搜索引擎，通过搜索得到的结果就是经过排序处理的；你参加互联网电商的秒杀活动，用户请求到达服务器之后，服务端程序会根据请求到达的时间进行排序处理。在数据库的设计中，字段的有序性也会影响我们的查询性能。\n                    </p>\n                    <p data-nodeid=\"6715\">\n                      因此，<strong data-nodeid=\"7104\">面试</strong\n                      >中出现关于排序的算法题也就不足为奇了。但是，这里我们并不去介绍所有的排序算法，而是通过面试中<strong\n                        data-nodeid=\"7105\"\n                        >最经常出现的</strong\n                      >两种排序算法进行深度展开。\n                    </p>\n                    <ul data-nodeid=\"6716\">\n                      <li data-nodeid=\"6717\">\n                        <p data-nodeid=\"6718\">\n                          <strong data-nodeid=\"7109\">合并排序</strong>\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6719\">\n                        <p data-nodeid=\"6720\">\n                          <strong data-nodeid=\"7113\">快速排序</strong>\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6721\">\n                      学完本讲，你将收获相应的代码模板、排序的考点，以及排序在面试中的变化。现在，开始我们的算法旅程与探险！\n                    </p>\n                    <h3 data-nodeid=\"6722\">合并排序</h3>\n                    <p data-nodeid=\"6723\">\n                      <strong data-nodeid=\"7128\">合并排序</strong\n                      >是将一个数组里面的元素进行排序的有效手段。它应该是在读书时学习的一个非常经典的排序算法了。不过这里我们不再采用教科书上的讲解方式，而是采用与“<strong\n                        data-nodeid=\"7129\"\n                        >二叉树</strong\n                      >”进行结合的方式来学习。<strong data-nodeid=\"7130\"\n                        >合并排序本质上与二叉树的后序遍历非常类似的</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6724\">\n                      如果你还能回想起来我们学习二叉树的时候，<strong\n                        data-nodeid=\"7140\"\n                        >后序遍历</strong\n                      >有个重要的特点：<strong data-nodeid=\"7141\"\n                        >拿到子树的信息，利用子树的信息，整合出整棵树的信息</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6725\">\n                      如果我们把<strong data-nodeid=\"7159\">有序性</strong\n                      >也当成<strong data-nodeid=\"7160\">信息</strong\n                      >，那么<strong data-nodeid=\"7161\"\n                        >合并排序本质上就是一个后序遍历。这时新知识就和我们的旧知识产生了化学反应</strong\n                      >。合并排序的思路可以用<strong data-nodeid=\"7162\"\n                        >二叉树</strong\n                      >表示如下：\n                    </p>\n                    <p data-nodeid=\"6726\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/47/CioPOWBa1D-AO_IyABbezYcjvnc676.gif\"\n                        alt=\"1.gif\"\n                        data-nodeid=\"7165\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6727\">可以用伪代码表示如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">function 后序遍历/合并排序():\n</div></li><li><div class=\"code-word\">    sub_info = 子结构(子树/子数组)\n</div></li><li><div class=\"code-word\">    full_info = 整合(sub_info)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6729\">\n                      那么<strong data-nodeid=\"7172\">合并排序/后序遍历</strong\n                      >的考点就可以总结为以下 3 点：\n                    </p>\n                    <ul data-nodeid=\"6730\">\n                      <li data-nodeid=\"6731\">\n                        <p data-nodeid=\"6732\">如何划分子结构</p>\n                      </li>\n                      <li data-nodeid=\"6733\">\n                        <p data-nodeid=\"6734\">获取子结构的信息</p>\n                      </li>\n                      <li data-nodeid=\"6735\">\n                        <p data-nodeid=\"6736\">\n                          利用子结构的信息，整合出整棵树的信息\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6737\">\n                      我们可以把<strong data-nodeid=\"7181\">关联信息</strong\n                      >表达如下：\n                    </p>\n                    <p data-nodeid=\"6738\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4A/Cgp9HWBa1EmAafFZAAEIbICXCH8196.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"7184\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6739\">\n                      那么接下来我们就从这三方面入手。并且与二叉树的后序遍历的代码对照着一起看。\n                    </p>\n                    <p data-nodeid=\"6740\">\n                      在正式开始讲题目之前，我们先学习一下<strong\n                        data-nodeid=\"7193\"\n                        >开闭原则</strong\n                      >。实际上，绝大部分语言在设计的时候，都是按照这个原则。比如数组的第一个元素取下标\n                      0，那么长度为 n 的数组，就需要用开闭原则区间 [0, n)\n                      来表示。\n                    </p>\n                    <p data-nodeid=\"11755\" class=\"te-preview-highlight\">\n                      这样表示好处理，区间长度直接就是右边界减去左边界。比如 [0,\n                      10) 的区间长度就是 10。但是如果使用双闭区间，比如 [0,\n                      9]，那么求区间长度时，运行式为：9 - 0 +\n                      1。还需要在减法的基础上加 1。\n                    </p>\n\n                    <h4 data-nodeid=\"6742\">1. 划分</h4>\n                    <p data-nodeid=\"6743\">\n                      首先我们看一下如何划分子数组。对于二叉树而言，子树的划分是天然的，已经在数据结构里面约定好了，比如\n                      TreeNode.left、TreeNode.right。\n                    </p>\n                    <p data-nodeid=\"6744\">\n                      但是对于数组而言，在切分的时候，如果想到达最优的效率，那么将数组切为平均的两半效率应该是最高的（可以联想到二叉平衡树的效率）。为了帮助你理解，我绘制了动图演示，如下所示：\n                    </p>\n                    <p data-nodeid=\"6745\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/47/CioPOWBa1F-AdVjkAAW3LaUuQBI088.gif\"\n                        alt=\"2.gif\"\n                        data-nodeid=\"7208\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6746\">二叉树的写法如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 二叉树的后序遍历左右子树</span>\n</div></li><li><div class=\"code-word\">root.left, root.right; 可以直接通过root的结构体信息得到。\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6748\">合并排序的写法如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 合并排序切分左右子数组</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> m = b + ((e-b)&gt;&gt;<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">数组a, [b, m) =&gt; 表示左子数组。\n</div></li><li><div class=\"code-word\">数组a, [m, e) =&gt; 表示右子数组。\n</div></li><li><div class=\"code-word\">需要通过计算得到。\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"6750\">2. 子数组的信息</h4>\n                    <p data-nodeid=\"6751\">\n                      由于这里是排序，那么就分别需要对左子数组和右子数组进行排序。如果你还能想起来我们在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"7217\"\n                        >第 06 讲</a\n                      >”介绍过的“二叉树的后序遍历”，那么对子数组的排序，只需要递归就可以了。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 二叉树的后序遍历拿左右子树的信息</span>\n</div></li><li><div class=\"code-word\">postOrder(root.left);\n</div></li><li><div class=\"code-word\">postOrder(root.right);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6753\">合并排序则需要这样写：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 合并排序去拿左右子数组的信息</span>\n</div></li><li><div class=\"code-word\">merge_sort(a, b, m);\n</div></li><li><div class=\"code-word\">merge_sort(a, m, e);\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"6755\">3. 信息的整合</h4>\n                    <p data-nodeid=\"6756\">\n                      接下来，我们需要将从子树/子数组里面拿到的信息进行加工。不同的需求会导致加工的方式也不太一样。对于合并排序而言，我们需要将两个有序的子数组，合并成一个大的有序的数组。\n                    </p>\n                    <p data-nodeid=\"6757\">\n                      最后，还需要考虑一下<strong data-nodeid=\"7229\"\n                        >边界</strong\n                      >：\n                    </p>\n                    <ul data-nodeid=\"6758\">\n                      <li data-nodeid=\"6759\">\n                        <p data-nodeid=\"6760\">\n                          当 b &gt;=\n                          e，说明这个区间是一个空区间，没有必要再排序；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6761\">\n                        <p data-nodeid=\"6762\">\n                          当 b + 1 == e，说明只有一个元素，也没有必要排序。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6763\">\n                      <strong data-nodeid=\"7236\"\n                        >以上两种边界情况分别可以对应到当二叉树为空，以及二叉树只有一个结点的情况</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6764\">\n                      【<strong data-nodeid=\"7242\">代码</strong\n                      >】到这里，我们已经可以写出合并排序的代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">msort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e, <span class=\"hljs-keyword\">int</span> t[])</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 空区间 或 只有一个元素</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 为了防止b + 1溢出，这里用b &gt;= e先判断一下</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (b &gt;= e || b + <span class=\"hljs-number\">1</span> &gt;= e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 分成两半, 二叉树可以自动取得root.left, root.right</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里我们需要通过计算来得到左右子数组。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> m = b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 类比二叉树分别遍历左子树和右子树。</span>\n</div></li><li><div class=\"code-word\">    msort(a, b, m, t);\n</div></li><li><div class=\"code-word\">    msort(a, m, e, t);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// i指向左子数组的开头，j指向右子数组的开头</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// to指向要临时数组t与区间[b, e)对应的位置</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> i = b;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> j = m;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> to = b;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将两个子数组进行合并, 注意下面是一个很重要的模板</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里的判断条是，只要两个子数组中还有元素</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (i &lt; m || j &lt; e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果右子数组没有元素 或 左子数组开头的元素小于右子数组开头的元素</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 那么取走左子数组开头的元素</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 考点：a[i] &lt;= a[j]这样可以保证合并排序是稳定的，不要写错!</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (j &gt;= e || i &lt; m &amp;&amp; a[i] &lt;= a[j]) {\n</div></li><li><div class=\"code-word\">        t[to++] = a[i++];\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 否则就是取右子数组开头的元素</span>\n</div></li><li><div class=\"code-word\">        t[to++] = a[j++];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 把合并的结果拷回原来的数组a[]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (i = b; i &lt; e; i++) {\n</div></li><li><div class=\"code-word\">      a[i] = t[i];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mergeSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果传进来的数组为空</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (nums == <span class=\"hljs-keyword\">null</span> || nums.length == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// t是一个临时中转的数组</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[nums.length];\n</div></li><li><div class=\"code-word\">    msort(nums, <span class=\"hljs-number\">0</span>, nums.length, t);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6766\">\n                      <p data-nodeid=\"6767\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/mergeSort.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7246\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/mergeSort.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7250\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/mergeSort.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7254\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6768\">\n                      <strong data-nodeid=\"7259\">复杂度分析</strong>：时间复杂度\n                      O(NlgN)，空间复杂度 O(N)。\n                    </p>\n                    <p data-nodeid=\"6769\">\n                      【<strong data-nodeid=\"7265\">小结</strong\n                      >】这里我们归纳一下合并排序的考点：\n                    </p>\n                    <ul data-nodeid=\"6770\">\n                      <li data-nodeid=\"6771\">\n                        <p data-nodeid=\"6772\">如何切分左右子数组；</p>\n                      </li>\n                      <li data-nodeid=\"6773\">\n                        <p data-nodeid=\"6774\">\n                          如何进行合并，合并时注意循环的条件，以及稳定排序的写法；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6775\">\n                        <p data-nodeid=\"6776\">开闭原则。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6777\">\n                      所以解决这道题目的考点可以总结如下：\n                    </p>\n                    <p data-nodeid=\"6778\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/4A/Cgp9HWBa1IiAdYjFAAD5CqCiV9s051.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"7272\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6779\">\n                      <strong data-nodeid=\"7277\">拓展思路</strong\n                      >：如果你已经成功获得了合并排序的秘籍，那么可以进一步尝试一下解决链表的合并排序。\n                    </p>\n                    <p data-nodeid=\"6780\">\n                      <strong data-nodeid=\"7282\">思考题</strong\n                      >：给定一个链表，如何排序，使其时间复杂度能够达到\n                      O(NlogN)。空间复杂度为\n                      O(1)。小提示：会用到合并排序，以及前面介绍的链表小技巧。\n                    </p>\n                    <blockquote data-nodeid=\"6781\">\n                      <p data-nodeid=\"6782\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7286\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7290\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7294\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6783\">\n                      我们还注意到：排序与<strong data-nodeid=\"7308\"\n                        >二叉树的后序遍历</strong\n                      >联系在一起了。在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"7302\"\n                        >第 06 讲</a\n                      >”中我们提到过，后序遍历有一个非常有趣的用法就是“<strong\n                        data-nodeid=\"7309\"\n                        >项庄舞剑，意在沛公</strong\n                      >”，那么合并排序是不是也有同样的性质呢？\n                    </p>\n                    <p data-nodeid=\"6784\">\n                      当然可以了，那么接下来，我们利用合并排序再玩一下这个套路。\n                    </p>\n                    <h4 data-nodeid=\"6785\">例 1：逆序对</h4>\n                    <p data-nodeid=\"6786\">\n                      【<strong data-nodeid=\"7335\">题目</strong\n                      >】一个整数数组，当 a[i] &gt; a[j]，并且 i &lt; j\n                      的时候，(a[i], a[j])\n                      构成一个逆序对。求一个数组中逆序对的数目。\n                    </p>\n                    <p data-nodeid=\"6787\">输入：[1, 2, 3, 4, 0]</p>\n                    <p data-nodeid=\"6788\">输出：4</p>\n                    <p data-nodeid=\"6789\">\n                      <strong data-nodeid=\"7345\">解释</strong>：数字 0\n                      会和前面的每一个数构成逆序对。一共有 4 对。所以输出 4。\n                    </p>\n                    <p data-nodeid=\"6790\">\n                      【<strong data-nodeid=\"7363\">分析</strong\n                      >】我们打算用<strong data-nodeid=\"7364\">合并排序</strong\n                      >解决这个问题。其中，合并排序提供的信息是“有序性”，那么我们就找到了“项庄”——<strong\n                        data-nodeid=\"7365\"\n                        >有序性</strong\n                      >。而我们真正要求解的是“<strong data-nodeid=\"7366\"\n                        >逆序对</strong\n                      >”，所以“沛公”也找到了。\n                    </p>\n                    <p data-nodeid=\"6791\">\n                      下面我们回顾一下“<a\n                        href=\"http://%E6%89%80%E4%BB%A5%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%A2%98%E7%9B%AE%E7%9A%84%E8%80%83%E7%82%B9%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%EF%BC%9A?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"7370\"\n                        >第 06 讲</a\n                      >”学习后序遍历的时候，我们总是利用左右子树的信息进行整合，进而得到“沛公”。对于合并排序而言，当得到有序的左右子数组之后，应该怎么得到逆序对信息呢？\n                    </p>\n                    <p data-nodeid=\"6792\">这里我们用画图来表示一下：</p>\n                    <p data-nodeid=\"6793\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/4A/Cgp9HWBa1KaAW4PrAACHWC33XvY027.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"7375\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6794\">\n                      当两个有序的子数组合并的时候，如果 a[i] &lt;=\n                      a[j]，此时应该执行 t[to++] = a[i++]。那么左子数组的 [b,\n                      i)，以及右子数组 [m, j) 里面的元素肯定都在 a[i]\n                      之前就被合并掉了。\n                    </p>\n                    <p data-nodeid=\"6795\">\n                      由于 a[i] 在左子数组，所以 a[i] 与 [m, j)\n                      这个范围里面的元素就构成逆序对。\n                      因此，在此时可以得到的逆序对的数目需要加上 j - m。\n                    </p>\n                    <p data-nodeid=\"6796\">\n                      【<strong data-nodeid=\"7419\">代码</strong\n                      >】到这里我们就一起来写一下代码吧（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> cnt = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">msort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e, <span class=\"hljs-keyword\">int</span>[] t)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (b &gt;= e || b + <span class=\"hljs-number\">1</span> &gt;= e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> m = b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    msort(a, b, m, t);\n</div></li><li><div class=\"code-word\">    msort(a, m, e, t);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> i = b;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> j = m;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> to = b;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (i &lt; m || j &lt; e) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (j &gt;= e || i &lt; m &amp;&amp; a[i] &lt;= a[j]) {\n</div></li><li><div class=\"code-word\">        t[to++] = a[i++];\n</div></li><li><div class=\"code-word\">        cnt += j - m; <span class=\"hljs-comment\">// 是的，就在这里加一行代码就可以了。</span>\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        t[to++] = a[j++];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (i = b; i &lt; e; i++) {\n</div></li><li><div class=\"code-word\">      a[i] = t[i];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">reversePairs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (nums == <span class=\"hljs-keyword\">null</span> || nums.length &lt;= <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[nums.length];\n</div></li><li><div class=\"code-word\">    cnt = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    msort(nums, <span class=\"hljs-number\">0</span>, nums.length, t);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> cnt;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6798\">\n                      <p data-nodeid=\"6799\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/reversePairs.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7423\"\n                          >Jafva</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/reversePairs.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7427\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/reversePairs.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7431\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6800\">\n                      【<strong data-nodeid=\"7437\">小结</strong\n                      >】我们再总结一下合并排序的特点和用法。关于逆序对这道题目，还可以做一个小更改：求解拿到顺序对的数目。开动你的聪明大脑想一想吧！你可以把想法写在留言区，我们一起交流。\n                    </p>\n                    <blockquote data-nodeid=\"6801\">\n                      <p data-nodeid=\"6802\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/seqNumber.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7441\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/seqNumber.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7445\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/seqNumber.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7449\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6803\">\n                      接下来我们再<strong data-nodeid=\"7455\"\n                        >从求逆序对那句关键的代码</strong\n                      >进行展开：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (j &gt;= e || i &lt; m &amp;&amp; a[i] &lt;= a[j]) {\n</div></li><li><div class=\"code-word\">  t[to++] = a[i++];\n</div></li><li><div class=\"code-word\">  cnt += j - m; <span class=\"hljs-comment\">// 是的，就在这里加一行代码就可以了。</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6805\">\n                      由上述代码可以得知，这里求出来的逆序对是属于 a[i]\n                      的，根据前面的分析，我们可以拓展出下面这道思考题。\n                    </p>\n                    <p data-nodeid=\"6806\">\n                      <strong data-nodeid=\"7479\">深度扩展</strong>：给定一个数组\n                      A[]，你能够返回一个数组 ans[]，ans[i] 存放 A[i]\n                      的逆序对数目。如果做出来这道题目，你能想一下增加的考点和变化是什么吗？可以写在留言区哦。\n                    </p>\n                    <blockquote data-nodeid=\"6807\">\n                      <p data-nodeid=\"6808\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/315.%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7483\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/315.%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7487\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/315.%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7491\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6809\">\n                      接下来我们看一下<strong data-nodeid=\"7497\"\n                        >广度扩展</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"6810\">例 2：找出两个有序数组的中位数</h4>\n                    <p data-nodeid=\"6811\">\n                      【<strong data-nodeid=\"7504\">题目</strong\n                      >】给定两个有序数组，请找出这两个有序数组的中位数。\n                    </p>\n                    <p data-nodeid=\"6812\">输入：A = [1, 2], B = [3, 4]</p>\n                    <p data-nodeid=\"6813\">输出：(2 + 3) / 2 = 2.5</p>\n                    <p data-nodeid=\"6814\">\n                      <strong data-nodeid=\"7518\">解释</strong\n                      >：当个数为奇数时，取排序之后的中间那个数。当个数为偶数时，取排序后中间两个数的平均值。\n                    </p>\n                    <p data-nodeid=\"6815\">\n                      【<strong data-nodeid=\"7532\">分析</strong\n                      >】这是一道来自<strong data-nodeid=\"7533\">百度</strong\n                      >的面试题。解法有很多，我们重点介绍<strong\n                        data-nodeid=\"7534\"\n                        >基于合并模板</strong\n                      >的解法。\n                    </p>\n                    <p data-nodeid=\"6816\">\n                      通过合并排序，我们已经能够将两个有序的数组合并成一个有序的数组了。<strong\n                        data-nodeid=\"7548\"\n                        >合并</strong\n                      >是一个非常经典的<strong data-nodeid=\"7549\"\n                        >模板代码</strong\n                      >，你一定要理解并且<strong data-nodeid=\"7550\"\n                        >背下来</strong\n                      >，很多地方都会用。比如合并有序链表，合并数组。\n                    </p>\n                    <p data-nodeid=\"6817\">\n                      你可能会想到直接将两个有序数组合并成一个有序的数组，再取这个有序数组的中位数。但是这样操作的话，时间复杂度就变成\n                      O(N)，并且空间复杂度也是 O(N)。\n                    </p>\n                    <p data-nodeid=\"6818\">\n                      如果在面试现场，面试官一定会问你，<strong\n                        data-nodeid=\"7561\"\n                        >有没有更好的办法</strong\n                      >？所以我们应该有效地利用<strong data-nodeid=\"7562\"\n                        >两个数组的有序性</strong\n                      >解决这道题。下面我会从简单的情况开始分析。\n                    </p>\n                    <p data-nodeid=\"6819\">\n                      首先我们看<strong data-nodeid=\"7568\">一维有序数组</strong\n                      >的情况，如果我们要拿第 5 小的数。（注：第 1\n                      小就是最小的数。）只需要将前面 4\n                      个数扔掉，然后排在前面的数就是第 5 小的数。\n                    </p>\n                    <p data-nodeid=\"6820\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/47/CioPOWBa1LSANaspAACnv4r9rY4076.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"7571\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6821\">\n                      那么二个有序数组应该怎么办呢？不过现在非常确定的是，我们一定<strong\n                        data-nodeid=\"7577\"\n                        >会扔掉 4 个数</strong\n                      >。那么接下来，你再思考一下在两个数组 A，B 中如何扔掉这 4\n                      个数？\n                    </p>\n                    <p data-nodeid=\"6822\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/47/CioPOWBa1VSAUvT8AAW3QKZNDKo893.gif\"\n                        alt=\"3.gif\"\n                        data-nodeid=\"7580\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"6823\">\n                      <li data-nodeid=\"6824\">\n                        <p data-nodeid=\"6825\">\n                          <strong data-nodeid=\"7585\"\n                            >第 1 步：要扔掉 4 个数，我们需要看一下两个数组前 2\n                            个元素</strong\n                          >，如下图所示：\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6826\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/47/CioPOWBa1MyAO-hIAAC5HXxgqTU581.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"7588\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6827\">\n                      此时，我们当然不知道 K、L、V、W 这四个数之间的关系。假设 L\n                      &gt;= W，就需要证明：当 L &gt;= W 的时候，[V, W]\n                      都不可能是第 5 小的数，可以扔掉。\n                    </p>\n                    <p data-nodeid=\"6828\">\n                      <strong data-nodeid=\"7602\">解</strong>：利用<strong\n                        data-nodeid=\"7603\"\n                        >反证法，假设 W 可以成为第 5 小的数</strong\n                      >。推导过程如下：\n                    </p>\n                    <p data-nodeid=\"6829\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/4C/Cgp9HWBa1dSAFbuyAADZMsuD8Ow586.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"7606\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6830\">\n                      同样的方法可以证明，V 也不可能成为第 5 小的数。所以如果当\n                      <strong data-nodeid=\"7621\">L</strong>&gt;=<strong\n                        data-nodeid=\"7622\"\n                        >W</strong\n                      >\n                      的时候，可以把 [V, W] 扔掉，不影响去拿第 5 小的数。\n                    </p>\n                    <ul data-nodeid=\"6831\">\n                      <li data-nodeid=\"6832\">\n                        <p data-nodeid=\"6833\">\n                          <strong data-nodeid=\"7627\"\n                            >第 2 步：当我们扔掉 2\n                            个数之后，两个有序数组已经变成如下图所示的样子</strong\n                          >：\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6834\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/4C/Cgp9HWBa1fOAIoAkAACiXXbxAyQ531.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"7630\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6835\">\n                      由于我们的目标是扔掉 4 个数，扔掉 2 个数之后，<strong\n                        data-nodeid=\"7636\"\n                        >还需要再扔 2 个数</strong\n                      >。此时我们只需要比较数组开头的一个元素 K, X\n                      的大小，谁小就把谁扔掉。这里我们假设 K 比较小。\n                    </p>\n                    <ul data-nodeid=\"6836\">\n                      <li data-nodeid=\"6837\">\n                        <p data-nodeid=\"6838\">\n                          <strong data-nodeid=\"7641\"\n                            >第 3 步：此时还剩下 1 个数需要扔掉，那么只需要扔掉\n                            M 和 X 中较小的就可以了</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6839\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/4C/Cgp9HWBa1fyARh_eAAChVnnqza8481.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"7644\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6840\">\n                      【<strong data-nodeid=\"7650\">结论</strong>】当我们需要扔掉\n                      k 个元素：\n                    </p>\n                    <ul data-nodeid=\"6841\">\n                      <li data-nodeid=\"6842\">\n                        <p data-nodeid=\"6843\">\n                          k 是偶数的时候，我们只需要比较 A[k/2-1] 和 B[k/2-1]\n                          的大小，谁小就扔掉对应的 [0...k/2-1] 这一段；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6844\">\n                        <p data-nodeid=\"6845\">\n                          k 是奇数的时候，我们只需要比较 A[k/2] 和 B[k/2]\n                          的大小，谁小就扔掉对应的 [0...k/2] 这一段。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6846\">\n                      如前面所展示的推导过程，无论 k\n                      是偶数还是奇数，这两种情况都可以用反证法来证明。这里我总结一下偶数的情况：\n                    </p>\n                    <p data-nodeid=\"6847\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/49/CioPOWBa1gSARtRHAADy4Q6lRic201.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"7680\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6848\">\n                      <strong data-nodeid=\"7685\">思考题</strong>：你能证明 k\n                      为奇数的情况吗？\n                    </p>\n                    <p data-nodeid=\"6849\">\n                      <strong data-nodeid=\"7710\">分析</strong\n                      >：不过由于整数在程序中的整除特性，我们可以将奇数和偶数的情况统一起来。需要扔掉\n                      k 个数的时候，p = (k-1)/ 2，你只需要比较 A[p] 和 B[p]\n                      的大小即可。如果 A[p] &gt;= B[p]，那么就可以把 B[0....p]\n                      这段都扔掉。\n                    </p>\n                    <p data-nodeid=\"6850\">\n                      【<strong data-nodeid=\"7716\">代码</strong\n                      >】根据之前的思考，我们可以得到如下解法（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">findMedianSortedArrays</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span>[] B)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> len = A.length + B.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> alen = A.length, blen = B.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, j = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果两个数组的总长度为0</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//那么不用再找了，肯定是没有中位数的，这里直接返回一个0</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (len == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 总长度为偶数的情况：</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果有4个数，那么当扔掉1个数之后</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 接下来需要合并的两个数排[2,3]就是中位数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 总长度为奇数的情况：</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 比如如果有5个数，那么当合并掉2个数之后</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 接下来的那个排[3]位的就是中位数。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 所以这里k表示：要扔掉的数的个数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> k = (len - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (k &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 我们需要比较A[p]与B[p]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 只不过当数组的起始位置是i和j的时候。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 比较的元素就变成 A[i+p], B[j+p]</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> p = (k - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这时直接比较A[i + p]和B[j+p]来决定谁可以被扔掉掉</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意这里扔掉的时候，只需要前移p + 1即可。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (j + p &gt;= blen || (i + p &lt; alen &amp;&amp; A[i + p] &lt; B[j + p])) {\n</div></li><li><div class=\"code-word\">      i += p + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      j += p + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    k -= p + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 把排在前面的数取出来</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">double</span> front =\n</div></li><li><div class=\"code-word\">    (j &gt;= blen || (i &lt; alen &amp;&amp; A[i] &lt; B[j])) ? A[i++] : B[j++];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果总长度为奇数，那么这个时候，front就是我们要找的中位数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> ((len &amp; <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> front;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 此时总的数目为偶数，那么需要再取一个数，求平均值。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">double</span> back = \n</div></li><li><div class=\"code-word\">     (j &gt;= blen || (i &lt; alen &amp;&amp; A[i] &lt; B[j])) ? A[i] : B[j];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> (front + back) / <span class=\"hljs-number\">2.0</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"6852\">\n                      <p data-nodeid=\"6853\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7720\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7724\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7728\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6854\">\n                      <strong data-nodeid=\"7733\">复杂度分析</strong\n                      >：一共要合并的长度可以认为是\n                      N/2，然后每次取一半进行合并。因此，合并次数为\n                      O(lgN)，空间复杂度为 O(1)。\n                    </p>\n                    <p data-nodeid=\"6855\">\n                      【<strong data-nodeid=\"7739\">小结</strong\n                      >】至此，我们需要总结一下这道有点数学趣味的题目（实际上只是用了一个简单的反证法）。\n                    </p>\n                    <p data-nodeid=\"6856\">\n                      如果，我们再看一下合并排序的过程（这里我加了一个变量 k）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> alen = A.length;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> blen = B.length;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> k = alen + blen, to = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span>[] t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[k];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> (k &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (j &gt;= blen || i &lt; alen &amp;&amp; A[i] &lt;= B[j]) {\n</div></li><li><div class=\"code-word\">    t[to++] = A[i];\n</div></li><li><div class=\"code-word\">    i += <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    t[to++] = B[j];\n</div></li><li><div class=\"code-word\">    j += <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  k -= <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6858\">\n                      再看<strong data-nodeid=\"7746\">这道题</strong\n                      >的核心循环的写法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> alen = A.length, blen = B.length;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> len = alen + blen;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> k = (len - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, j = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">while</span> (k &gt; <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> p = (k - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (j + p &gt;= blen || (i + p &lt; alen &amp;&amp; A[i + p] &lt; B[j + p])) {\n</div></li><li><div class=\"code-word\">    i += p + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    j += p + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  k -= p + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6860\">\n                      我们发现，正常情况下的合并排序，就是步长 p = 0\n                      的时候的特例。那么接下来我们归纳一下合并的用法：\n                    </p>\n                    <p data-nodeid=\"6861\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/49/CioPOWBa1hCAQFCXAACzeuL27BA859.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"7750\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6862\">\n                      那么合并模板还有没有别的用法呢？这里我给你留了两道练习题。\n                    </p>\n                    <p data-nodeid=\"6863\">\n                      <strong data-nodeid=\"7756\">练习题 1</strong\n                      >：给定两个有序数组 A，B。假设 A\n                      数组中有足够的空间，不借助外部存储空间的情况下，请将\n                      A，B，两个数组合并至 A 数组中。\n                    </p>\n                    <blockquote data-nodeid=\"6864\">\n                      <p data-nodeid=\"6865\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7760\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7764\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7768\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6866\">\n                      <strong data-nodeid=\"7773\">练习题 2</strong\n                      >：合并两个有序链表\n                    </p>\n                    <blockquote data-nodeid=\"6867\">\n                      <p data-nodeid=\"6868\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7777\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7781\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7785\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6869\">\n                      如果你做完练习，应该就可以将合并模板的知识图谱补充如下了：\n                    </p>\n                    <p data-nodeid=\"6870\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4D/Cgp9HWBa1hmARdhgAAE4KKhQNNk730.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"7789\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6871\">\n                      一个小小的合并模板可就以解决这么多问题，多积累模版可以帮助我们在面试中快速答题，希望你理解并且背下来这个模板！你自己还整理过其他的通用性较强的模板吗？可以在留言区和我分享。\n                    </p>\n                    <h3 data-nodeid=\"6872\">快速排序</h3>\n                    <p data-nodeid=\"6873\">\n                      快速排序也是我们在算法书里面认识的老朋友了。不过今天我仍然不会按照书里面的套路来介绍快速排序。前面我介绍了合并排序与二叉树的后序遍历有非常类似的地方，那么快速排序又和什么遍历相似呢？\n                    </p>\n                    <p data-nodeid=\"6874\">\n                      是二叉树的<strong data-nodeid=\"7798\">前序遍历</strong\n                      >！前序遍历有两个重要的特点：\n                    </p>\n                    <ul data-nodeid=\"6875\">\n                      <li data-nodeid=\"6876\">\n                        <p data-nodeid=\"6877\">拿到根结点的信息</p>\n                      </li>\n                      <li data-nodeid=\"6878\">\n                        <p data-nodeid=\"6879\">将根结点的信息，传递给左右子树</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6880\">\n                      对于排序来说，有序性就是信息。因此，我们要做的事情就是把能拿到的有序信息，传递给左子数组和右子数组。\n                    </p>\n                    <h4 data-nodeid=\"6881\">1. 有序性的传递</h4>\n                    <p data-nodeid=\"6882\">\n                      对于快排而言，它传递有序性的手段就是将选择一个数\n                      x，并且利用这个数，将数组分成三部分：\n                    </p>\n                    <ul data-nodeid=\"6883\">\n                      <li data-nodeid=\"6884\">\n                        <p data-nodeid=\"6885\">小于 x 的部分放在数组的最前面</p>\n                      </li>\n                      <li data-nodeid=\"6886\">\n                        <p data-nodeid=\"6887\">等于 x 的部分放在数组的中间</p>\n                      </li>\n                      <li data-nodeid=\"6888\">\n                        <p data-nodeid=\"6889\">大于 x 的部分放在数组的最后面</p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"6890\">2. 左右子数组的处理</h4>\n                    <p data-nodeid=\"6891\">\n                      此时，可以把小于 x 的部分当成二叉树中的左子树，大于 x\n                      的部分当成二叉树的右子树。等于 x\n                      的部分当成二叉树的根结点。\n                    </p>\n                    <p data-nodeid=\"6892\">\n                      那么接下来要做的事情就是像前序遍历一样，递归地处理左子数组和右子数组。\n                    </p>\n                    <p data-nodeid=\"6893\">\n                      这里我们模拟一下像前序遍历一样的快速排序，演示如下动图所示：\n                    </p>\n                    <p data-nodeid=\"6894\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4D/Cgp9HWBa1j-ALNp1ABgNWSm15-g263.gif\"\n                        alt=\"4.gif\"\n                        data-nodeid=\"7817\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6895\">\n                      相对于二叉树的前序遍历来说，快速排序也有它自己的特点：\n                    </p>\n                    <ul data-nodeid=\"6896\">\n                      <li data-nodeid=\"6897\">\n                        <p data-nodeid=\"6898\">\n                          根结点的处理，需要执行“三路切分”操作，将一个数组切分为三段；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6899\">\n                        <p data-nodeid=\"6900\">\n                          左右子区间是由切分动态生成的，并不像二叉树那样由指针固定。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6901\">可以用伪代码表示如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">function 前序遍历/快速排序():\n</div></li><li><div class=\"code-word\">    获取根结点的信息\n</div></li><li><div class=\"code-word\">    将根结点的信息传递左右子树/左右子数组\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6903\">\n                      那么<strong data-nodeid=\"7827\">前序遍历/快速排序</strong\n                      >的考点就可以总结为以下 3 点：\n                    </p>\n                    <ul data-nodeid=\"6904\">\n                      <li data-nodeid=\"6905\">\n                        <p data-nodeid=\"6906\">如何划分子结构</p>\n                      </li>\n                      <li data-nodeid=\"6907\">\n                        <p data-nodeid=\"6908\">获取根结点的信息</p>\n                      </li>\n                      <li data-nodeid=\"6909\">\n                        <p data-nodeid=\"6910\">\n                          如何将根结点的信息，传递给左右子树/左右子数组。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6911\">\n                      我们可以把前序遍历与快速排序<strong data-nodeid=\"7836\"\n                        >关联信息</strong\n                      >表达如下：\n                    </p>\n                    <p data-nodeid=\"6912\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4A/CioPOWBa1k6ARbllAAEScdmg-qE957.png\"\n                        alt=\"Drawing 15.png\"\n                        data-nodeid=\"7839\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6913\">\n                      那么接下来我们就从上图中展示的三个方面入手，并且与二叉树的前序遍历的代码对照着一起看。\n                    </p>\n                    <h4 data-nodeid=\"6914\">1. 划分</h4>\n                    <p data-nodeid=\"6915\">\n                      首先我们看一下如何划分子数组。对于二叉树而言，子树的划分是天然的，已经在数据结构里面约定好了，比如\n                      TreeNode.left、TreeNode.right。\n                    </p>\n                    <p data-nodeid=\"6916\">\n                      但是对于数组而言，切分的时候，如果想到达最优的效率，那么将数组切为平均的两半效率应该是最高的（可以联想到二叉平衡树的效率）。<strong\n                        data-nodeid=\"7850\"\n                        >但是快排不能保证选择一个数，就一定能将数组切分成为两半</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6917\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/26/4B/CioPOWBa1nyASnSGAAVDCbYUIkI338.gif\"\n                        alt=\"5.gif\"\n                        data-nodeid=\"7853\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6918\">切分的结果如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">利用x将数组 A[]切分为三段，[小于x的部分，等于x的部分，大于x的部分]\n</div></li><li><div class=\"code-word\">左子树 = [小于x的部分] = [b, l)\n</div></li><li><div class=\"code-word\">根结点 = [等于x的部分] = [l, i)\n</div></li><li><div class=\"code-word\">右 子树 = [大 于x的部分] = [i, e)\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"6920\">2. 子数组的递归</h4>\n                    <p data-nodeid=\"6921\">\n                      由于这里是排序，就需要分别对左子数组和右子数组进行排序。如果你还能想起来我们之前介绍过的“二叉树的前序遍历”，那么对子数组的排序应该也只需要递归就可以了。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 二叉树的前序遍历拿左右子树的信息</span>\n</div></li><li><div class=\"code-word\">preOrder(root.left);\n</div></li><li><div class=\"code-word\">preOrder(root.right);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6923\">快速排序则需要这么写：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 快速排序去拿左右子数组的信息</span>\n</div></li><li><div class=\"code-word\">qsort(a, b, l);\n</div></li><li><div class=\"code-word\">qsort(a, i, e);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6925\">\n                      最后，我们还需要考虑一下<strong data-nodeid=\"7865\"\n                        >边界</strong\n                      >情况：\n                    </p>\n                    <ul data-nodeid=\"6926\">\n                      <li data-nodeid=\"6927\">\n                        <p data-nodeid=\"6928\">\n                          当 b &gt;= e\n                          的时候，说明这个区间是一个空区间，没有必要再排序；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6929\">\n                        <p data-nodeid=\"6930\">\n                          当 b + 1 == e\n                          的时候，说明只有一个元素，也没有必要排序。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6931\">\n                      以上两种边界情况可以对应到当二叉树为空，以及二叉树只有一个结点的情况。\n                    </p>\n                    <p data-nodeid=\"6932\">\n                      【<strong data-nodeid=\"7874\">代码</strong\n                      >】让我们一起写一下快速排序的代码吧（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 交换数组中两个元素的值 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> t = A[i];\n</div></li><li><div class=\"code-word\">  A[i] = A[j];\n</div></li><li><div class=\"code-word\">  A[j] = t;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 将数组[b, e)范围的元素进行排序 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">qsort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 像二叉树一样，如果空树/只有一个结点，那么不需要再递归了 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果给定的区间段为空，或者只有一个结点。 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (b &gt;= e || b + <span class=\"hljs-number\">1</span> &gt;= e) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 取数组中间的元素作为x</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> m = b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = A[m];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 三路切分,这部分代码在例 3详细介绍!</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> l = b, i = b, r = e - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (i &lt;= r) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (A[i] &lt; x) {\n</div></li><li><div class=\"code-word\">      swap(A, l++, i++);\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (A[i] == x) {\n</div></li><li><div class=\"code-word\">      i++;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      swap(A, r--, i);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 像二叉树的前序遍历一样，分别遍历左子树与右子树。</span>\n</div></li><li><div class=\"code-word\">  qsort(A, b, l);\n</div></li><li><div class=\"code-word\">  qsort(A, i, e);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 主函数，将数组nums排序 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (nums == <span class=\"hljs-keyword\">null</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">  qsort(nums, <span class=\"hljs-number\">0</span>, nums.length);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6934\">\n                      <strong data-nodeid=\"7883\">复杂度分析</strong\n                      >：快速排序在较优情况下是 O(NlgN)，在较差情况下是\n                      O(N<sup>2</sup>)。\n                    </p>\n                    <blockquote data-nodeid=\"6935\">\n                      <p data-nodeid=\"6936\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.qsort.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7887\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.qsort.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7891\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.qsort.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"7895\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6937\">\n                      不过，我们好像还没有详细地介绍怎么进行切分操作，也就是如何将数组切分成三部分。由于切分非常重要（在\n                      EMC\n                      的面试中曾经单独出现过），所以我们重点介绍一下，暂且把它叫作“<strong\n                        data-nodeid=\"7901\"\n                        >三路切分</strong\n                      >”。\n                    </p>\n                    <h4 data-nodeid=\"6938\">例 3：三路切分</h4>\n                    <p data-nodeid=\"6939\">\n                      【<strong data-nodeid=\"7912\">题目</strong>】给定一个只包含\n                      [0, 1, 2] 的数组，如何只通过 swap\n                      操作，将这个数组进行排序？\n                    </p>\n                    <p data-nodeid=\"6940\">输入：[2, 1, 0]</p>\n                    <p data-nodeid=\"6941\">输出：[0, 1, 2]</p>\n                    <p data-nodeid=\"6942\">\n                      <strong data-nodeid=\"7925\">要求</strong\n                      >：你的时间复杂度需要是 O(N)，空间复杂度需要是 O(1)。\n                    </p>\n                    <p data-nodeid=\"6943\">\n                      【<strong data-nodeid=\"7931\">分析</strong\n                      >】回想一下，我们前面学过的“三路切分”，在快速排序的时候，我们通过一个整数\n                      x\n                      将数组切分成小于、等于、大于三部分。分别可以映射到三个值上：\n                    </p>\n                    <ul data-nodeid=\"6944\">\n                      <li data-nodeid=\"6945\">\n                        <p data-nodeid=\"6946\">0 的部分对应到小于 x 的部分</p>\n                      </li>\n                      <li data-nodeid=\"6947\">\n                        <p data-nodeid=\"6948\">1 的部分对应到等于 x 的部分</p>\n                      </li>\n                      <li data-nodeid=\"6949\">\n                        <p data-nodeid=\"6950\">2 的部分对应到大于 x 的部分</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6951\">\n                      问题的关键就是如何在时间复杂度 O(N)，空间复杂度 O(1)\n                      条件下完成这个操作。我们假设数组已经被切分成 4\n                      段，如下图所示：\n                    </p>\n                    <p data-nodeid=\"6952\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4E/Cgp9HWBa1pKANA4tAACo1XkrwR8163.png\"\n                        alt=\"Drawing 17.png\"\n                        data-nodeid=\"7938\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6953\">\n                      对于这 4\n                      段区间，我们需要有以下约束（注意这里都要满足开闭原则）：\n                    </p>\n                    <ul data-nodeid=\"6954\">\n                      <li data-nodeid=\"6955\">\n                        <p data-nodeid=\"6956\">[0, L) 表示全是 0 的区间</p>\n                      </li>\n                      <li data-nodeid=\"6957\">\n                        <p data-nodeid=\"6958\">[L, i) 表示全是 1 的区间</p>\n                      </li>\n                      <li data-nodeid=\"6959\">\n                        <p data-nodeid=\"6960\">\n                          [i, r] 表示还是未处理的数的区间\n                        </p>\n                      </li>\n                      <li data-nodeid=\"6961\">\n                        <p data-nodeid=\"6962\">(r, N) 表示全是 2 的区间</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6963\">后续所有的操作都必须满足这个性质。</p>\n                    <p data-nodeid=\"6964\">\n                      <strong data-nodeid=\"7966\">初始条件</strong>：L = 0, i =\n                      0, r = N - 1。形成的 4 个区间就是：[0, 0), [0, 0), [0,\n                      N-1], (N-1, N)，除了 [0, N-1] 非空以外，另外 3\n                      个区间都是空集，所以满足前面对区间的约束原则。\n                    </p>\n                    <p data-nodeid=\"6965\">\n                      <strong data-nodeid=\"7973\">推导</strong>：在 [i, r)\n                      区间中的值 x 取值只可能是下面 3 种情况（x = 0, x = 1, x =\n                      2），我们分别处理如下。\n                    </p>\n                    <ul data-nodeid=\"6966\">\n                      <li data-nodeid=\"6967\">\n                        <p data-nodeid=\"6968\">\n                          当 x = 0 的时候，我们想要把 0 放到 [0, L)\n                          区间里面，也就是插入到所有的 1 的前面。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6969\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4C/CioPOWBa1v-AAIJ0AAC982gygBM237.png\"\n                        alt=\"Drawing 18.png\"\n                        data-nodeid=\"7979\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6970\">\n                      除了像插入排序一样一个一个地移动 1，还有没有更好的办法呢？\n                    </p>\n                    <p data-nodeid=\"6971\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4F/Cgp9HWBa1waAUggGAAC5a2hQFcY926.png\"\n                        alt=\"Drawing 19.png\"\n                        data-nodeid=\"7983\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6972\">\n                      答案是，不需要一个一个移动！因为 [L, i) 区间里面全都是\n                      1，只需要将 A[L] 与 A[i] 进行交换即可。\n                    </p>\n                    <p data-nodeid=\"6973\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4F/Cgp9HWBa1w6ACb84AAFajqHAao8089.png\"\n                        alt=\"Drawing 20.png\"\n                        data-nodeid=\"7997\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6974\">\n                      不过由于 A[L] 与 A[i] 交换完成之后，看起来像是一个新来的 0\n                      插入到区间 [L, i) 的前面，[L, i)\n                      区间整体向右平移了一样。所以需要执行 L++,\n                      i++。经此操作，变更后的区间仍然满足约束。\n                    </p>\n                    <ul data-nodeid=\"6975\">\n                      <li data-nodeid=\"6976\">\n                        <p data-nodeid=\"6977\">\n                          当 x = 1 的时候，就比较简单了。只需要为 1 的区间 [L,\n                          i) 向右扩展一下就可以了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6978\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4F/Cgp9HWBa1xeAR5k5AAE7tiU3JNs442.png\"\n                        alt=\"Drawing 21.png\"\n                        data-nodeid=\"8016\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6979\">\n                      由于像 [L, i) 尾部增加了一个元素一样，所以只需要执行 i++\n                      就可以。区间变更后，仍然满足约束。\n                    </p>\n                    <ul data-nodeid=\"6980\">\n                      <li data-nodeid=\"6981\">\n                        <p data-nodeid=\"6982\">\n                          当 x = 2 的时候。首先需要执行 swap(A[i], A[r])。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6983\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4F/Cgp9HWBa1yGAYzAPAAE2795PdwA120.png\"\n                        alt=\"Drawing 22.png\"\n                        data-nodeid=\"8031\"\n                      />\n                    </p>\n                    <p data-nodeid=\"6984\">\n                      但是，如此一来，(r, N) 应该把左边新来的 2\n                      包含进去，所以还需要在这个基础上执行\n                      r--。区间变更后，仍然满足约束。\n                    </p>\n                    <p data-nodeid=\"6985\">\n                      <strong data-nodeid=\"8045\">最终状态</strong\n                      >：所有的数都被处理之后，[i, r]\n                      区间肯定为空集。由于两边都是取闭，那么必然当 i &gt; r\n                      的时候，[i, r] 才是空集。原本的四个区间，变成三个区间。\n                    </p>\n                    <ul data-nodeid=\"6986\">\n                      <li data-nodeid=\"6987\">\n                        <p data-nodeid=\"6988\">[0, L) 等于 0 的区间</p>\n                      </li>\n                      <li data-nodeid=\"6989\">\n                        <p data-nodeid=\"6990\">[L, i) 等于 1 的区间</p>\n                      </li>\n                      <li data-nodeid=\"6991\">\n                        <p data-nodeid=\"6992\">\n                          [i, N) 等于 2 的区间。注意此时由于 i &gt; r，实际上 i\n                          = r + 1，那么区间 (r, N) 就是 [i, N)。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"6993\">\n                      由于最终状态是将一个乱序的数组切分成三部分，所以这个方法又叫<strong\n                        data-nodeid=\"8059\"\n                        >三路切分</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6994\">\n                      【<strong data-nodeid=\"8065\">代码</strong\n                      >】到此为止，相信你已经可以根据思路写出代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> t = A[i];\n</div></li><li><div class=\"code-word\">  A[i] = A[j];\n</div></li><li><div class=\"code-word\">  A[j] = t;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">split</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, l = <span class=\"hljs-number\">0</span>, r = N - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (i &lt;= r) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// case 0: 需要将0元素放到左区间。l++, i++完成[L, i)区间的平移。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (A[i] == <span class=\"hljs-number\">0</span>)\n</div></li><li><div class=\"code-word\">      swap(A, l++, i++);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// case 1: 元素1直接append在[L, i)区间的后面就可以了。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (A[i] == <span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">      i++;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// case 2: 元素2需要与A[r]交换。然后区间(r, N)向左扩张</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span>\n</div></li><li><div class=\"code-word\">      swap(A, r--, i);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"6996\">\n                      <strong data-nodeid=\"8070\">复杂度分析</strong\n                      >：时间复杂度是 O(N)，空间复杂度是\n                      O(1)。因此满足题目要求。\n                    </p>\n                    <blockquote data-nodeid=\"6997\">\n                      <p data-nodeid=\"6998\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8074\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8078\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8082\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"6999\">\n                      【<strong data-nodeid=\"8088\">小结</strong\n                      >】这道题目如果没有只能用 swap\n                      操作这个限制还是很简单的，但加上这个限制之后。你就只能使用“三路切分”的绝技了。三路切分的考点可以总结如下：\n                    </p>\n                    <p data-nodeid=\"7000\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4C/CioPOWBa1y6AKiDXAACdNXyT-iM446.png\"\n                        alt=\"Drawing 23.png\"\n                        data-nodeid=\"8091\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7001\">\n                      由上图可以知，三路切分的考点比较单一。\n                      这里我还给你留了一道练习题，帮你巩固下这个知识点。\n                    </p>\n                    <p data-nodeid=\"7002\">\n                      <strong data-nodeid=\"8097\">练习题 3</strong>：数组中有 0\n                      和非 0 元素，请把 0\n                      元素移动到数组末尾。其他元素保持相对顺序不变。\n                    </p>\n                    <blockquote data-nodeid=\"7003\">\n                      <p data-nodeid=\"7004\">\n                        代码:<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/283.%E7%A7%BB%E5%8A%A8%E9%9B%B6.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8101\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/283.%E7%A7%BB%E5%8A%A8%E9%9B%B6.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8105\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/283.%E7%A7%BB%E5%8A%A8%E9%9B%B6.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8109\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7005\">\n                      三路切分不仅可以用在快速排序中，还有其他一些非常有趣的应用，让我们一起来看一下。\n                    </p>\n                    <h4 data-nodeid=\"7006\">例 4：只出现一次的数</h4>\n                    <p data-nodeid=\"7007\">\n                      【<strong data-nodeid=\"8117\">题目</strong\n                      >】给定一个数组，除一个数以外，其他的数都出现了两次，请把这个数找出来。\n                    </p>\n                    <p data-nodeid=\"7008\">输入：nums = [3,3,1,2,2]</p>\n                    <p data-nodeid=\"7009\">输出：1</p>\n                    <p data-nodeid=\"7010\">要求：时间复杂度 O(N)</p>\n                    <p data-nodeid=\"7011\">\n                      【<strong data-nodeid=\"8129\">分析</strong\n                      >】对于这道题，这里我们不采用异或的做法，而是利用三路切分的方式来求解这道题，思路如下：\n                    </p>\n                    <p data-nodeid=\"7012\">\n                      首先任意选择一个数\n                      x，将数组进行“三路切分”，得到的情况可能有以下 3\n                      种（因为其他的数都是出现了两次）。\n                    </p>\n                    <p data-nodeid=\"7013\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4F/Cgp9HWBa1z6AY5MBAADdMHlfEo0699.png\"\n                        alt=\"Drawing 24.png\"\n                        data-nodeid=\"8133\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7014\">\n                      Case 1：只出现一次的数在左边，那么左区间的长度为奇数。\n                    </p>\n                    <p data-nodeid=\"7015\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4C/CioPOWBa10SAHug2AACvcZWpRb0183.png\"\n                        alt=\"Drawing 25.png\"\n                        data-nodeid=\"8137\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7016\">\n                      Case 2：只出现一次的数在中间，那么中间的数的长度为\n                      1。直接返回 x。\n                    </p>\n                    <p data-nodeid=\"7017\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/50/Cgp9HWBa10yAdrcgAADb9niMdDU093.png\"\n                        alt=\"Drawing 26.png\"\n                        data-nodeid=\"8141\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7018\">\n                      Case 3：只出现一次的数在右边，那么右区间的长度为奇数。\n                    </p>\n                    <p data-nodeid=\"7019\">\n                      通过分析可知，前面 3 种情况中，只有 Case 2\n                      得到了结果。接下来我们分别讨论 Case 1 和 Case3：在 Case 1\n                      中，只出现 1 次的数在左区间时，只需要递归地处理左区间；在\n                      Case 3 中，只出现 1\n                      次的数在右区间时，只需要递归地处理右区间。\n                    </p>\n                    <p data-nodeid=\"7020\">\n                      【<strong data-nodeid=\"8149\">代码</strong\n                      >】题目的思路还是相当简洁的，下面我们开始写代码吧（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 辅助函数：交换数组中的两个元素</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> t = A[i];\n</div></li><li><div class=\"code-word\">  A[i] = A[j];\n</div></li><li><div class=\"code-word\">  A[j] = t;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 三路切分</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">threeSplit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 我们取数组中间的数 </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> m = b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = A[m];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 注意我们的初始区间有四个：</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// [b, l) [l, i) [i, r] (r, N)</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// [小于)  [等于) [未知]  (大于)</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> l = b;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> i = b;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> r = e - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (i &lt;= r) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (A[i] &lt; x) {\n</div></li><li><div class=\"code-word\">      swap(A, l++, i++);\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (A[i] == x) {\n</div></li><li><div class=\"code-word\">      i++;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      swap(A, r--, i);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 切分完毕之后，只有三个区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// [b, l) [l, i) [i, N)</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 首先看中间的区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (i - l == <span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> A[l];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 再看左区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (((l - b) &amp; <span class=\"hljs-number\">0x01</span>) == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> threeSplit(A, b, l);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 再看右区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> threeSplit(A, i, e);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">singleNumber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (A == <span class=\"hljs-keyword\">null</span> || A.length &lt;= <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> threeSplit(A, <span class=\"hljs-number\">0</span>, A.length);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"7022\">\n                      <p data-nodeid=\"7023\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8153\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8157\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8161\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7024\">\n                      <strong data-nodeid=\"8166\">复杂度分析</strong\n                      >：严格的时间复杂度计算是非常复杂的，《算法导论》中专门花了大量篇幅来分析。不过在本讲，我们可以简单地分析，每次扔掉的数组长度大概是\n                      N/2，那么取极限累计求和，复杂度大概是 O(2N)，也就是\n                      O(N)。而变量只用了 O(1)，如果栈也算上空间，那么大概是\n                      O(H)。H 就是递归的深度。\n                    </p>\n                    <p data-nodeid=\"7025\">\n                      【<strong data-nodeid=\"8176\">小结</strong\n                      >】尽管与位运算相比，这种解法算不上最优，不过也不失一种有趣的解法。下面我们再深挖一下这种解法的特点，与我们以前学过的知识<strong\n                        data-nodeid=\"8177\"\n                        >联动</strong\n                      >一下。\n                    </p>\n                    <p data-nodeid=\"7026\">\n                      这里我们与“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6695&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"8181\"\n                        >第 06 讲</a\n                      >”中介绍的“<strong data-nodeid=\"8187\"\n                        >二叉搜索树的查找</strong\n                      >”（练习题，你做了吗？）进行一下对比。二叉搜索树的查找代码可以写成如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">TreeNode <span class=\"hljs-title\">searchBST</span><span class=\"hljs-params\">(TreeNode root, <span class=\"hljs-keyword\">int</span> val)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 首先看中间的结点</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span> || root.val == val) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> root;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 把右子树扔掉，只看左子树</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (root.val &gt; val) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> searchBST(root.left, val);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 把左子树扔掉，只看右子树</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> searchBST(root.right, val);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7028\">\n                      将上述代码与我们当前这道题的代码进行比较，会发现很多有趣的地方。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">threeSplit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 这里进行三路切分....代码省略掉。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 首先看中间的区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (i - l == <span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> A[l];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 把右边的扔掉，只看左区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (((l - b) &amp; <span class=\"hljs-number\">0x01</span>) == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> threeSplit(A, b, l);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 把左边的扔掉，只看右区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> threeSplit(A, i, e);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7030\">\n                      为了方便你理解，我把这两部分代码的联系整理在下方的思维导图中，其中有非常有趣的联系：\n                    </p>\n                    <p data-nodeid=\"7031\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4C/CioPOWBa11mAYIeqAAEKqbsIKUc687.png\"\n                        alt=\"Drawing 27.png\"\n                        data-nodeid=\"8192\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7032\">\n                      可以得出结论，数组其实是另外一种形式的二叉树，只不过有时候需要我们动态地把左/右子树给切分出来，不同的切分方式，可以解决不同的问题。\n                    </p>\n                    <p data-nodeid=\"7033\">\n                      <strong data-nodeid=\"8198\">练习题 4</strong\n                      >：只出现一次的数，其他的数都出现了 3\n                      次。请你把只出现一次的数找出来。\n                    </p>\n                    <blockquote data-nodeid=\"7034\">\n                      <p data-nodeid=\"7035\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8202\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8206\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8210\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7036\" class=\"\">\n                      三路切分还有其他一些有趣的应用，让我们继续前进。\n                    </p>\n                    <h4 data-nodeid=\"7037\">例 5：第 k 小的数</h4>\n                    <p data-nodeid=\"7038\">\n                      【<strong data-nodeid=\"8218\">题目</strong\n                      >】给定一个数组，请找出第 k 小的数（最小的数为第 1 小）。\n                    </p>\n                    <p data-nodeid=\"7039\">输入：A = [2, 4, 1, 5, 3], k = 3</p>\n                    <p data-nodeid=\"7040\">输出：3</p>\n                    <p data-nodeid=\"7041\">\n                      【<strong data-nodeid=\"8234\">分析</strong\n                      >】如果我们把数组排序之后，直接取 A[k-1]\n                      的数。那么就可以得到结果。但是有没有复杂度更低一点的算法呢？\n                    </p>\n                    <p data-nodeid=\"7042\">\n                      仔细观察题目的特点：可以发现题目没有要求所有的数都有序，只是要求第\n                      k 小的数即可。\n                    </p>\n                    <p data-nodeid=\"7043\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/50/Cgp9HWBa12aAJAvPAADQtdqxOSg472.png\"\n                        alt=\"Drawing 28.png\"\n                        data-nodeid=\"8238\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7044\">\n                      因此，这道题，应该可以用堆来解决。你能想一想吗？\n                    </p>\n                    <blockquote data-nodeid=\"7045\">\n                      <p data-nodeid=\"7046\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.Sort/786.%E7%AC%ACk%E4%B8%AA%E6%95%B0.heap.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8243\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.Sort/786.%E7%AC%ACk%E4%B8%AA%E6%95%B0.heap.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8247\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.Sort/786.%E7%AC%ACk%E4%B8%AA%E6%95%B0.heap.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8251\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7047\">\n                      我们再回顾一下前面的例 4 和例 5 两道题目。例 4\n                      要求找出那个唯一的数。而例 5 中找到的第 k\n                      小的数，也是唯一的。\n                    </p>\n                    <p data-nodeid=\"7048\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4C/CioPOWBa126ABdszAADUJRcYiwA778.png\"\n                        alt=\"Drawing 29.png\"\n                        data-nodeid=\"8255\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7049\">\n                      这里我们从题目的“<strong data-nodeid=\"8261\">唯一性</strong\n                      >”这个特点着手，可以发现：在例 4\n                      中是需要判断这个唯一的数在哪个区间，那么就把其他的区间扔掉。如果能扔掉不要的区间，然后在余下的区间上递归，那我们就可以达到\n                      O(N) 的时间复杂度了（和例 4 一样了）。\n                    </p>\n                    <p data-nodeid=\"7050\">\n                      可是怎样才能判断第 k\n                      小的数在哪个区间呢？三路切分完毕之后，应该有三个区间，下面我们基于这三个区间分别讨论。\n                    </p>\n                    <p data-nodeid=\"7051\">\n                      <strong data-nodeid=\"8267\">注意</strong\n                      >：在写代码之前，我们还是要注意一下边界。由于题目中给定的\n                      k 的值是从 1 开始。也就是当 k = 1\n                      时，实际上对应的是最小的数，而我们数组的下标是从 0\n                      开始的，先执行 k -- 可以让 k 从 0 开始。（后面的 k 都是从\n                      0 开始了！）\n                    </p>\n                    <p data-nodeid=\"7052\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/50/Cgp9HWBa14-AfibNAACmG9lcp3w742.png\"\n                        alt=\"Drawing 30.png\"\n                        data-nodeid=\"8270\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7053\">\n                      Case 1. 第 k 小的数在左区间，此时 k &lt; lcnt，其中 lcnt\n                      是左区间中数的个数。\n                    </p>\n                    <p data-nodeid=\"7054\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/4C/CioPOWBa15aARbkjAACsa_IopOo721.png\"\n                        alt=\"Drawing 31.png\"\n                        data-nodeid=\"8276\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7055\">\n                      Case 2. 第 k 小的数在中间，此时 lcnt &lt;= k &lt; lcnt +\n                      mcnt。其中 mcnt 是中间区间的数的个数。\n                    </p>\n                    <p data-nodeid=\"7056\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/50/Cgp9HWBa15uAKuRJAACsaFjbbdM444.png\"\n                        alt=\"Drawing 32.png\"\n                        data-nodeid=\"8284\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7057\">\n                      Case 3. 第 k 小的数在右区间，此时 k &gt;= lcnt + mcnt。\n                    </p>\n                    <p data-nodeid=\"7058\">那么，此时条件就会变成：</p>\n                    <ul data-nodeid=\"7059\">\n                      <li data-nodeid=\"7060\">\n                        <p data-nodeid=\"7061\">k &lt; lcnt 表示在左区间</p>\n                      </li>\n                      <li data-nodeid=\"7062\">\n                        <p data-nodeid=\"7063\">\n                          k &gt;= lcnt &amp;&amp; k &lt; lcnt + mcnt 表示在中间\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7064\">\n                        <p data-nodeid=\"7065\">\n                          k &gt;= lcnt + mcnt 表示在右区间\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7066\">\n                      【<strong data-nodeid=\"8302\">代码</strong\n                      >】有了前面的思路，那么我们一起来写一下这道题的代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> t = A[i];\n</div></li><li><div class=\"code-word\">  A[i] = A[j];\n</div></li><li><div class=\"code-word\">  A[j] = t;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 注意这里区间为[b, e), k也是从0开始算的</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">kth</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e, <span class=\"hljs-keyword\">int</span> k)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果为空</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果只有一个元素</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (b + <span class=\"hljs-number\">1</span> &gt;= e) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> A[b];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 进行三路切分</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> x = A[b + ((e - b) &gt;&gt; <span class=\"hljs-number\">1</span>)];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> i = b;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> l = b;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> r = e - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (i &lt;= r) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (A[i] &lt; x)\n</div></li><li><div class=\"code-word\">      swap(A, l++, i++);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (A[i] == x)\n</div></li><li><div class=\"code-word\">      i++;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span>\n</div></li><li><div class=\"code-word\">      swap(A, r--, i);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 分别拿到三段的长度</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> lcnt = l - b;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mcnt = i - l;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果第k个数落在左区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (k &lt; lcnt)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> kth(A, b, l, k);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果第k个数落在右区间</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (k &gt;= (lcnt + mcnt))\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> kth(A, i, e, k - lcnt - mcnt);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果第k个数落在中间，那么直接返回x</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> x;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">kthNumber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> k)</span> </span>{ \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> kth(A, <span class=\"hljs-number\">0</span>, n, k - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"7068\">\n                      <p data-nodeid=\"7069\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/786.%E7%AC%ACk%E4%B8%AA%E6%95%B0.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8306\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/786.%E7%AC%ACk%E4%B8%AA%E6%95%B0.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8310\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/786.%E7%AC%ACk%E4%B8%AA%E6%95%B0.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8314\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7070\">\n                      <strong data-nodeid=\"8319\">复杂度分析</strong>：时间复杂度\n                      O(N)，严格地分析非常复杂，你可以查看《算法导论》中推导，空间复杂度\n                      O(H)，H 是递归的深度。\n                    </p>\n                    <p data-nodeid=\"7071\">\n                      【<strong data-nodeid=\"8325\">小结</strong>】如果我们将例 3\n                      与例 5 放在一起，就可以总结出这些题的考点：\n                    </p>\n                    <p data-nodeid=\"7072\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/50/Cgp9HWBa16SAXU4SAAEW-ldWtII513.png\"\n                        alt=\"Drawing 33.png\"\n                        data-nodeid=\"8328\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7073\">\n                      如果你已经掌握了例 5\n                      里面的解题技巧与代码模板。那么接下来我们再进行一下<strong\n                        data-nodeid=\"8334\"\n                        >深度扩展</strong\n                      >，你可以尝试思考下面这道练习题。\n                    </p>\n                    <p data-nodeid=\"7074\">\n                      <strong data-nodeid=\"8339\">练习题 5</strong\n                      >：给定一个整数数组，请找出里面 k 个最小的数。\n                    </p>\n                    <blockquote data-nodeid=\"7075\">\n                      <p data-nodeid=\"7076\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8343\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8347\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8351\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7077\">\n                      <strong data-nodeid=\"8356\">广度扩展</strong\n                      >：“三路切分”本质上是将二叉树的一些思路移到数组上，那么是否可以适用到其他数据结构上呢？你可以在链表上试试，比如下面这道练习题。\n                    </p>\n                    <p data-nodeid=\"7078\">\n                      <strong data-nodeid=\"8361\">练习题 6</strong\n                      >：排序一个单向链表（这里我们需要使用快速排序）\n                    </p>\n                    <blockquote data-nodeid=\"7079\">\n                      <p data-nodeid=\"7080\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.qsort.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8365\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.qsort.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8369\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.qsort.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8373\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"7081\">总结与延伸</h3>\n                    <p data-nodeid=\"7082\">\n                      在这里，我们一起学习了关于排序的两个知识点，合并排序和快速排序。我们再把介绍过的知识点进行一个汇总：\n                    </p>\n                    <p data-nodeid=\"7083\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/26/50/Cgp9HWBa166AD9hdAAKp0wZR38g493.png\"\n                        alt=\"Drawing 34.png\"\n                        data-nodeid=\"8378\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7084\">\n                      在本讲，虽然只讲了两个排序，但经过不断地浇灌，我们的知识树从萌芽逐渐长成了一棵大树。前面我们也提到过，实际上，堆在上浮或者上沉的时候，操作会与“插入排序”非常类似。由于篇幅的限制，这里我们不再去详细地挖掘插入排序了。\n                    </p>\n                    <p data-nodeid=\"7085\">\n                      你可以自己思考和尝试，期待你还能发现更多排序的特点和巧妙用法，并且将它们总结下来，让你“大树”（思维导图）像花儿一样开得绚烂多姿。也欢迎你在评论区和我交流，期待看到大家的奇思妙想。\n                    </p>\n                    <h3 data-nodeid=\"7086\">思考题</h3>\n                    <p data-nodeid=\"7087\">\n                      我再给你留一道<strong data-nodeid=\"8387\">思考题</strong\n                      >：给定一个链表，请使用插入排序对这个链表排序吧。\n                    </p>\n                    <p data-nodeid=\"7088\" class=\"\">\n                      你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。下一讲将介绍\n                      09 | 二分搜索：为什么说有序皆可用二分？记得按时来探险。\n                    </p>\n            "}