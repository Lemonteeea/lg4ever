{"title":"加餐 | 模块四思考题解答","context":"\n                    <p data-nodeid=\"25826\" class=\"\">\n                      今天我会带你把《<strong data-nodeid=\"25832\"\n                        >模块四：Web 技术</strong\n                      >》中涉及的课后练习题，逐一讲解，并给出每个课时练习题的解题思路和答案。\n                    </p>\n\n                    <h3 data-nodeid=\"25112\">练习题详解</h3>\n                    <h4 data-nodeid=\"25113\">\n                      15 | 内容分发网络：请简述 CDN 回源如何工作？\n                    </h4>\n                    <p data-nodeid=\"25114\">\n                      【<strong data-nodeid=\"25168\">问题</strong\n                      >】如果你的应用需要智能 DNS 服务，你将如何实现？\n                    </p>\n                    <p data-nodeid=\"25115\">\n                      【<strong data-nodeid=\"25174\">解析</strong\n                      >】首先你可以在你的域名解析系统中增加两条（或以上）ns\n                      记录。比如说你的域名是 example.com，那么你可以增加\n                      ns1.exmaple.com, ns2.example.com。当然，指定这两个域名的\n                      IP 还需要配置两个 A 记录。\n                    </p>\n                    <p data-nodeid=\"25116\">\n                      然后你需要两台机器（也可以是容器或者虚拟机），对应 ns1 和\n                      ns2。最好用不在同一个物理机上的两个容器，这样可以避免一台物理机故障导致服务瘫痪。然后在每个容器（虚拟机）上安装一个\n                      Named 服务。Named 是一个专门用来提供 DNS\n                      服务的工具，在虚拟机上安装完成 Named\n                      后，这个虚拟机就变成了一个权威服务器节点。\n                    </p>\n                    <p data-nodeid=\"25117\">\n                      配置好 Named 后，你需要写几个脚本文件，给要提供 DNS\n                      的域名配置信息。Named 配套使用的有个叫作 GeoDNS\n                      的插件，可以提供基于地理位置的智能 DNS 服务。\n                    </p>\n                    <p data-nodeid=\"25118\">\n                      更具体的操作，你可以参考这篇文档：<a\n                        href=\"https://bind9.readthedocs.io/en/latest/configuration.html?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"25180\"\n                        >https://bind9.readthedocs.io/en/latest/configuration.html</a\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"25119\">\n                      17 | HTTP 协议面试通关：强制缓存和协商缓存的区别是？\n                    </h4>\n                    <p data-nodeid=\"25120\">\n                      【<strong data-nodeid=\"25188\">问题</strong\n                      >】写一张网页，用 WebRTC 实现点到点通信。\n                    </p>\n                    <p data-nodeid=\"26111\">\n                      【<strong data-nodeid=\"26122\">解析</strong\n                      >】这里我为你找到了一份 Github 上的源代码：<a\n                        href=\"https://github.com/ScaleDrone/webrtc/blob/master/script.js?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"26120\"\n                        >https://github.com/ScaleDrone/webrtc/blob/master/</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"26112\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/43/52/Cgp9HWC4nISASrfFAAEwZ4EyOXU323.png\"\n                        alt=\"image (5).png\"\n                        data-nodeid=\"26129\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"25122\">\n                      在 WebRTC\n                      的网络世界中，视频传输可以走点到点服务。客户端被称作\n                      Peer，Peer 的数据直接传送给另一个 Peer，我们也称作<strong\n                        data-nodeid=\"25208\"\n                        >P2P 网络</strong\n                      >。在<strong data-nodeid=\"25209\"\n                        >P2P 网络中，要解决 NAT 穿墙问题，WebRTC\n                        设计了一个网络的抽象框架被称作交互式网络建立连接（Interactive\n                        Connectivity Establishment， ICE）</strong\n                      >，图中的 STUN 是 ICE 的一个实现。\n                    </p>\n                    <p data-nodeid=\"25123\">\n                      对于一个 P2P 网络中的 Peer，它每次要接入这个 P2P\n                      网络会获得一个身份，这个身份就包括它的 IP\n                      地址、端口使用的协议等，这个身份被抽象成了一个对象——Candidate（候选人）。当候选人创建一个\n                      P2P\n                      连接的时候，它会获得候选人的身份。但这个时候，它还没有发起任何真实的数据连接。此时它必须知道另一个人的身份，才能够进行通信。\n                    </p>\n                    <p data-nodeid=\"25124\">\n                      <strong data-nodeid=\"25215\"\n                        >P2P\n                        网络本身不具备传输身份的能力，因此这个时候需要另一个第三方网络提供身份的交换</strong\n                      >。代码中的这个第三方服务就是\n                      ScaleDrone。当用户加入聊天室，会先创建连接：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">pc = <span class=\"hljs-keyword\">new</span> RTCPeerConnection(...)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25126\">\n                      接下来会触发<code data-backticks=\"1\" data-nodeid=\"25217\"\n                        >onicecanddiate</code\n                      >事件获得候选人（Candidate）身份：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">pc.onicecandidate = event =&gt; {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> (event.candidate) {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-comment\">// 通过ScaleDrone分发身份</span>\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\"> };\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25128\">\n                      在实际的代码操作中，代码将获得的身份（event.candiate）直接发送到了\n                      ScaleDrone\n                      提供的某个聊天室中去，这样聊天室的其他用户就会拿到这个身份。\n                    </p>\n                    <p data-nodeid=\"25129\">\n                      当有新用户进入聊天室后，ScaleDrone 会广播新用户的身份：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  room.on(<span class=\"hljs-string\">'data'</span>, (message, client) =&gt; {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// Message was sent by us</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> (client.id === drone.clientId) {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> (message.sdp) {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-comment\">// This is called after receiving an offer or answer from another peer</span>\n</div></li><li><div class=\"code-word\">     pc.setRemoteDescription(<span class=\"hljs-keyword\">new</span> RTCSessionDescription(message.sdp), () =&gt; {\n</div></li><li><div class=\"code-word\">       <span class=\"hljs-comment\">// When receiving an offer lets answer it</span>\n</div></li><li><div class=\"code-word\">       <span class=\"hljs-keyword\">if</span> (pc.remoteDescription.type === <span class=\"hljs-string\">'offer'</span>) {\n</div></li><li><div class=\"code-word\">         pc.createAnswer().then(localDescCreated).<span class=\"hljs-keyword\">catch</span>(onError);\n</div></li><li><div class=\"code-word\">       }\n</div></li><li><div class=\"code-word\">     }, onError);\n</div></li><li><div class=\"code-word\">   } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message.candidate) {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-comment\">// Add the new ICE candidate to our connections remote description</span>\n</div></li><li><div class=\"code-word\">     pc.addIceCandidate(\n</div></li><li><div class=\"code-word\">       <span class=\"hljs-keyword\">new</span> RTCIceCandidate(message.candidate), onSuccess, onError\n</div></li><li><div class=\"code-word\">     );\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\"> });\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25131\">\n                      这个时候，用户彼此都会将对方加入自己的候选人列表：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"> pc.addIceCandidate(\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">new</span> RTCIceCandidate(message.candidate), onSuccess, onError\n</div></li><li><div class=\"code-word\"> )\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25133\">\n                      加入之后，如果远程候选人录制了视频，WebRTC 的 ontract\n                      事件就会收到视频的数据流，也就是下面这段程序：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"> pc.ontrack = event =&gt; {\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">const</span> stream = event.streams[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-keyword\">if</span> (!remoteVideo.srcObject || remoteVideo.srcObject.id !== stream.id) {\n</div></li><li><div class=\"code-word\">     remoteVideo.srcObject = stream;\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\"> };\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25135\">\n                      这份代码的优势是不需要提供中转的流媒体服务器，就可以完成点到点的视频通信。同理，如果是多人视频，也可以用同样的方法实现。这段程序中需要两个第三方的服务：\n                    </p>\n                    <ol data-nodeid=\"25136\">\n                      <li data-nodeid=\"25137\">\n                        <p data-nodeid=\"25138\">\n                          基于 ICE 标准提供 P2P 网络的服务（提供 NAT\n                          穿透能力），这个可以使用 STUN；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"25139\">\n                        <p data-nodeid=\"25140\">\n                          第三方聊天室服务，用于实现聊天的具体逻辑和交换身份。\n                        </p>\n                      </li>\n                    </ol>\n                    <h4 data-nodeid=\"25141\">\n                      18 | 爬虫和反爬虫：如何防止黑产爬取我的数据？\n                    </h4>\n                    <p data-nodeid=\"25142\">\n                      【<strong data-nodeid=\"25232\">问题</strong\n                      >】用最熟悉的语言写一段程序，模拟成浏览器访问拉勾教育的首页获取首页数据。\n                    </p>\n                    <p data-nodeid=\"25143\">\n                      【<strong data-nodeid=\"25242\">解析</strong>】<strong\n                        data-nodeid=\"25243\"\n                        >我这里推荐用 selenium+py 解决这个问题</strong\n                      >。Selenium 是一个用于自动化测试框架。我这里会用到\n                      Selenium 的 WebDriver，这个 WebDriver 支持多款浏览器，比如\n                      Chrome、Safari 等。具体来说，可以用下面的程序引入 selenium\n                      和选择要使用的 WebDriver：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">from selenium <span class=\"hljs-keyword\">import</span> webdriver\n</div></li><li><div class=\"code-word\">driver = webdriver.Chrome()\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"25145\">\n                      我这里选择了 Chrome，然后我们就可以模拟浏览器发送请求了：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">driver.get(<span class=\"hljs-string\">\"https://edu.lagou.com\"</span>)\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"25147\">总结</h3>\n                    <p data-nodeid=\"25148\">\n                      这一模块我们学习了和 Web 技术相关的内容。<strong\n                        data-nodeid=\"25251\"\n                        >在实际工作中，配置 DNS 往往是 Leader 的职责</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"25149\">\n                      作为 Leader 要关注域名、资源的 URL\n                      的命名是否合理，方便记忆；要配置好 CDN\n                      防止有资源直接从源站被获取；要部署好智能 DNS\n                      实现负载均衡；在网站域名发生变更的时候，还要考虑到老域名如何迁移新域名。另一方面，对\n                      HTTP 协议作为 Web 技术的核心，Leader\n                      还要关注它的性能优化连接、资源大小、缓存等，这样才能更好地制作用户体验。\n                    </p>\n                    <p data-nodeid=\"25150\">\n                      这一讲就到这里，发现求知的乐趣，我是林䭽。感谢你学习本次课程，下一讲我们将学习《19\n                      | 网络安全概述：对称、非对称加密的区别是？》，再见！\n                    </p>\n            "}