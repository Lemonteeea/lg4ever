{"title":"06 | 树：如何深度运用树的遍历？","context":"\n                    <p data-nodeid=\"7849\" class=\"\">\n                      树在我们的应用程序中非常常见，大部分语言的 Map\n                      数据结构，大多是基于树来实现的。此外还经常会遇到很多其他树结构的变种，比如\n                      MySQL 会使用 B+ 树、MongoDB 会使用 B-\n                      树。其中二叉树是各种树的基础，相关的题目也是变化多样，因此，各大公司都喜欢通过二叉树，考察面试者对语言底层数据结构的理解。\n                    </p>\n                    <p data-nodeid=\"7850\">\n                      二叉树的结点定义较为简单，一般采用如下方式来定义：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TreeNode</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">int</span> val = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; TreeNode left = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; TreeNode right = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; TreeNode() {}\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; TreeNode(<span class=\"hljs-keyword\">int</span> val) { <span class=\"hljs-keyword\">this</span>.val = val; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"7852\">一个树的结点里面分别存放着：</p>\n                    <ul data-nodeid=\"7853\">\n                      <li data-nodeid=\"7854\">\n                        <p data-nodeid=\"7855\">值：用 val 表示</p>\n                      </li>\n                      <li data-nodeid=\"7856\">\n                        <p data-nodeid=\"7857\">左子结点：用 left 指针表示</p>\n                      </li>\n                      <li data-nodeid=\"7858\">\n                        <p data-nodeid=\"7859\">右子结点：用 right 指针表示</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7860\">\n                      在我学习二叉树的过程中，发现很多问题实际上都可以通过二叉树的遍历进行求解。\n                      二叉树的遍历可以分为以下 4 种：\n                    </p>\n                    <ul data-nodeid=\"7861\">\n                      <li data-nodeid=\"7862\">\n                        <p data-nodeid=\"7863\">前序遍历</p>\n                      </li>\n                      <li data-nodeid=\"7864\">\n                        <p data-nodeid=\"7865\">中序遍历</p>\n                      </li>\n                      <li data-nodeid=\"7866\">\n                        <p data-nodeid=\"7867\">后序遍历</p>\n                      </li>\n                      <li data-nodeid=\"7868\">\n                        <p data-nodeid=\"7869\">层次遍历</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7870\">\n                      在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"8307\"\n                        >第 02 讲</a\n                      >”我们已经介绍了层次遍历，因此，本讲会重点介绍前 3\n                      种遍历以及它们的深度运用。<strong data-nodeid=\"8317\"\n                        >由于二叉树关联的面试题目考察的重点都是在各种遍历上</strong\n                      >，所以在讲解时，我会采用更加<strong data-nodeid=\"8318\"\n                        >单刀直入</strong\n                      >的方式，带你开启一段“爬树”的旅程。\n                    </p>\n                    <h3 data-nodeid=\"7871\">前序遍历</h3>\n                    <p data-nodeid=\"7872\">前序遍历的顺序为：</p>\n                    <ol data-nodeid=\"7873\">\n                      <li data-nodeid=\"7874\">\n                        <p data-nodeid=\"7875\">遍历根结点</p>\n                      </li>\n                      <li data-nodeid=\"7876\">\n                        <p data-nodeid=\"7877\">左子树</p>\n                      </li>\n                      <li data-nodeid=\"7878\">\n                        <p data-nodeid=\"7879\">右子树</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"7880\">\n                      这里我们不再按照课本上一步一步演示的方式。将采用<strong\n                        data-nodeid=\"8329\"\n                        >整体概括处理的方式</strong\n                      >，比如把左子树或者右子树作为一个整体来处理，如下图所示：\n                    </p>\n                    <p data-nodeid=\"7881\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtI-AItMYAAjasV3sa24039.gif\"\n                        alt=\"1.gif\"\n                        data-nodeid=\"8332\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"7882\">\n                      <li data-nodeid=\"7883\">\n                        <p data-nodeid=\"7884\">\n                          Step 1. 首先遍历根结点，然后<strong data-nodeid=\"8338\"\n                            >遍历左子树的时候，就把左子树放到相应的位置；遍历右子树的时候，就把右子树放到相应的位置</strong\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7885\">\n                        <p data-nodeid=\"7886\">\n                          Step 2. 接着再把左子树展开，放到相应位置。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7887\">\n                        <p data-nodeid=\"7888\">\n                          Step 3.\n                          最后再把右子树展开，放到相应位置。此时就得到了最终前序遍历的结果。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7889\">\n                      不过你在处理根结点或者子树的时候，需要注意空树的情况。避免访问空指针！\n                    </p>\n                    <h4 data-nodeid=\"7890\">递归前序遍历</h4>\n                    <p data-nodeid=\"7891\">\n                      基于以上思路，可以写出递归的前序遍历的代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">(TreeNode root, List&lt;Integer&gt; ans)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 边界处理：如果树为空，那么不需要处理</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (root != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 先访问根结点</span>\n</div></li><li><div class=\"code-word\">        ans.add(root.val);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 再分别访问左子树</span>\n</div></li><li><div class=\"code-word\">        preOrder(root.left, ans);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 再访问右子树</span>\n</div></li><li><div class=\"code-word\">        preOrder(root.right, ans);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"7893\">\n                      <p data-nodeid=\"7894\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8347\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8351\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8355\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7895\">\n                      接下来我们看一下算法的复杂度，在面试中经常有人将时间复杂度与空间复杂度混淆，这里很<strong\n                        data-nodeid=\"8361\"\n                        >容易出错</strong\n                      >，你需要格外注意。\n                    </p>\n                    <ul data-nodeid=\"7896\">\n                      <li data-nodeid=\"7897\">\n                        <p data-nodeid=\"7898\">\n                          <strong data-nodeid=\"8366\">时间复杂度</strong\n                          >，由于树上的每个结点都只访问一次，并且每次访问都只有一次压栈弹栈操作，所以复杂度为\n                          O(N)。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7899\">\n                        <p data-nodeid=\"7900\">\n                          <strong data-nodeid=\"8371\">空间复杂度</strong\n                          >，由于函数调用栈的深度与树的高度有关系，所以使用的空间为\n                          O(H)。H 表示树的高度。（注意：一般而言，输出结果存放的\n                          List 并不算在空间复杂度里面）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7901\">\n                      <strong data-nodeid=\"8376\">提示</strong\n                      >：在面试时候，你需要问清楚面试官：访问每个结点的时候，是需要\n                      Print 出来，还是放到一个 List\n                      里面返回。搞清楚需求再开始写代码！\n                    </p>\n                    <h4 data-nodeid=\"7902\">使用栈完成前序遍历</h4>\n                    <p data-nodeid=\"7903\">\n                      接下来，我们看一下如何将递归的前序代码改成非递归的前序代码，如下所示（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;Integer&gt; <span class=\"hljs-title\">preorderTraversal</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 用来进行递归的栈</span>\n</div></li><li><div class=\"code-word\">        Stack&lt;TreeNode&gt; s = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 用来存放遍历的结果，不算在空间复杂度里面 </span>\n</div></li><li><div class=\"code-word\">        List&lt;Integer&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 开始利用栈来进行遍历</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-keyword\">null</span> || !s.empty()) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 模拟递归的压栈过程</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">                s.push(root);\n</div></li><li><div class=\"code-word\">                ans.add(root.val);\n</div></li><li><div class=\"code-word\">                root = root.left;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 当无法压栈的时候，将root.right进行压栈</span>\n</div></li><li><div class=\"code-word\">            root = s.peek();\n</div></li><li><div class=\"code-word\">            s.pop();\n</div></li><li><div class=\"code-word\">            root = root.right;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"7905\">\n                      <p data-nodeid=\"7906\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8382\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8386\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8390\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7907\">\n                      <strong data-nodeid=\"8395\">算法复杂度</strong\n                      >：每个结点都入栈出栈一次，遍历整棵树的时间复杂度为\n                      O(N)，空间复杂度就是栈的最大使用空间，而这个空间是由树的高度决定的，所以空间复杂度就是\n                      O(H)。\n                    </p>\n                    <p data-nodeid=\"7908\">\n                      <strong data-nodeid=\"8400\">备注</strong\n                      >：虽然面试的时候极难考到 Morris\n                      遍历，如果你有时间，可以看看 Morris\n                      遍历，这种算法的优点是只需要使用 O(1)\n                      的空间（没有函数递归）。\n                    </p>\n                    <blockquote data-nodeid=\"7909\">\n                      <p data-nodeid=\"7910\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8404\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8408\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8412\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7911\">\n                      下面我们通过几道题目还原一下面试场景，看看面试官都给你埋了哪些雷。\n                    </p>\n                    <h4 data-nodeid=\"7912\">例 1：验证二叉搜索树</h4>\n                    <p data-nodeid=\"7913\">\n                      【<strong data-nodeid=\"8420\">题目</strong\n                      >】二叉搜索树有以下特点：\n                    </p>\n                    <ul data-nodeid=\"7914\">\n                      <li data-nodeid=\"7915\">\n                        <p data-nodeid=\"7916\">\n                          根结点的值大于所有的左子树结点的值\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7917\">\n                        <p data-nodeid=\"7918\">\n                          根结点的值小于所有的右子树结点的值\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7919\">\n                        <p data-nodeid=\"7920\">左右子树也必须满足以上特性</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7921\">\n                      现给定一棵二叉树，判断是否是二叉搜索树。\n                    </p>\n                    <p data-nodeid=\"7922\">输入:</p>\n                    <p data-nodeid=\"7923\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/42/Cgp9HWBRtKeAYSGpAACZpTIXfU0084.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"8428\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7924\">输出: true</p>\n                    <p data-nodeid=\"7925\">\n                      【<strong data-nodeid=\"8439\">分析</strong\n                      >】二叉搜索树的定义，<strong data-nodeid=\"8440\"\n                        >本质上就是一个前序遍历</strong\n                      >。因此，可以利用前序遍历的思路来解决这道题。\n                    </p>\n                    <p data-nodeid=\"7926\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/38/CioPOWBUIueAOJfcAAdhS5BAUGo971.gif\"\n                        alt=\"11.gif\"\n                        data-nodeid=\"8443\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7927\">\n                      【<strong data-nodeid=\"8453\">模拟</strong\n                      >】首先我们在这棵树上进行模拟，效果如下 （用 INT64_MIN\n                      表示负无穷大，INT64_MAX 表示正无穷大）：\n                    </p>\n                    <p data-nodeid=\"7928\">\n                      Step 1. 我们假设<strong data-nodeid=\"8463\"\n                        >根结点总是对的</strong\n                      >。如果总是对的，那么可以认为结点的值总是：处在区间(INT64_MIN,\n                      INT64_MAX)以内。由于二叉树结点的值是 int，如果用 int64\n                      总是可以保证一定在范围里面。\n                    </p>\n                    <p data-nodeid=\"7929\">\n                      Step 2. 根据二叉搜索树的定义，左子树总是小于根结点\n                      5，那么左子树的范围就应该设置为(INT64_MIN, 5)。\n                    </p>\n                    <p data-nodeid=\"7930\">\n                      Step 3. 根据二叉搜索树的定久，右子树总是大于根结点\n                      5，那么右子树的范围就应该设置为 (5, INT64_MAX)。\n                    </p>\n                    <p data-nodeid=\"7931\">\n                      Step 4. 然后再看结点 7 的左子树，范围应该是 (5, 7)。\n                    </p>\n                    <p data-nodeid=\"7932\">\n                      【<strong data-nodeid=\"8476\">规律</strong\n                      >】经过运行的模拟，我们可以总结出以下特点：\n                    </p>\n                    <ul data-nodeid=\"7933\">\n                      <li data-nodeid=\"7934\">\n                        <p data-nodeid=\"7935\">\n                          通过原本给出的那棵二叉树，实际上能够构造出一棵“影子”<strong\n                            data-nodeid=\"8482\"\n                            >区间二叉树</strong\n                          >，只不过这个二叉树上的结点是一个区间；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7936\">\n                        <p data-nodeid=\"7937\">\n                          原二叉树上的值，需要掉在新二叉树的区间范围里面。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7938\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtNGAeo22AACebFDJtSc681.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"8486\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7939\">\n                      因此，<strong data-nodeid=\"8492\">解题的思路</strong>就是：\n                    </p>\n                    <ul data-nodeid=\"7940\">\n                      <li data-nodeid=\"7941\">\n                        <p data-nodeid=\"7942\">\n                          如何有效利用右边的“区间”二叉树验证左边二叉树的有效性？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7943\">\n                        <p data-nodeid=\"7944\">\n                          当右边的“区间”二叉树不能成功构建，原二叉树就是一棵无效的二叉搜索树。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7945\">\n                      <em data-nodeid=\"8498\"\n                        >注：我们不是真的要构建“影子”二叉树，这样做的目的是方便思考。</em\n                      >\n                    </p>\n                    <p data-nodeid=\"7946\">\n                      “影子”二叉树是通过原二叉树生成的。树上结点就是不停地将区间进行拆分，比如：\n                    </p>\n                    <ul data-nodeid=\"7947\">\n                      <li data-nodeid=\"7948\">\n                        <p data-nodeid=\"7949\">\n                          (INT64_MIN, INT64_MAX) -&gt; (INT64_MIN, 5) , (5,\n                          INT64_MAX)\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7950\">\n                        <p data-nodeid=\"7951\">\n                          (5, INT64_MAX) -&gt; (5, 7), (7, INT64_MAX)\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7952\">\n                      【<strong data-nodeid=\"8519\">匹配</strong\n                      >】我们就利用二叉树的前序遍历，同时遍历这两棵二叉树。注意，其中“影子”二叉树是动态生成的，并且我们也不保存其数据结构。\n                    </p>\n                    <p data-nodeid=\"7953\">\n                      【<strong data-nodeid=\"8525\">边界</strong\n                      >】关于二叉树的边界，我们需要考虑一种情况：\n                    </p>\n                    <ul data-nodeid=\"7954\">\n                      <li data-nodeid=\"7955\">\n                        <p data-nodeid=\"7956\">一棵空二叉树；</p>\n                      </li>\n                      <li data-nodeid=\"7957\">\n                        <p data-nodeid=\"7958\">\n                          题目的定义采用的“小于”，“大于”；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"7959\">\n                        <p data-nodeid=\"7960\">\n                          当任何一个位置不满足二叉树的定义，就可以不用再遍历下去了。因此，我们要注意快速返回。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"7961\">\n                      <strong data-nodeid=\"8533\">【代码】</strong>\n                      有了思路，也有了运行图，此时就可以写出以下核心代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> ans = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">(TreeNode root, Long l, Long r)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 1. 如果为空树</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 2. 如果已经有结点不满足BST的要求了</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span> || !ans) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 检查当前结点是不是在影子二叉树的区间里面</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 这里相当于在检查两棵二叉树相同位置的结点</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!(l &lt; root.val &amp;&amp; root.val &lt; r)) {\n</div></li><li><div class=\"code-word\">            ans = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 这里同时遍历左子树，(l, root.val)就是影子二叉树的左子结点</span>\n</div></li><li><div class=\"code-word\">        preOrder(root.left, l, Long.valueOf(root.val));\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 这里同时遍历右子树，(root.val, r)就是影子二叉树的右子结点</span>\n</div></li><li><div class=\"code-word\">        preOrder(root.right, Long.valueOf(root.val), r);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\n</div></li><li><div class=\"code-word\">        ans = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">        preOrder(root, Long.MIN_VALUE, Long.MAX_VALUE);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"7963\">\n                      <p data-nodeid=\"7964\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8537\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8541\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8545\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7965\">\n                      【<strong data-nodeid=\"8559\">小结</strong\n                      >】我们在传统经验的前序遍历基础上，进行了一点扩展，需要创建一棵“影子”二叉树才能进行前序遍历。因此这道题的<strong\n                        data-nodeid=\"8560\"\n                        >考点</strong\n                      >就是：<strong data-nodeid=\"8561\"\n                        >找到隐藏的“影子”二叉树</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"7966\">\n                      此外，遍历二叉树的时候，如果可以用递归，那么应该也可以用栈，或者\n                      Morris\n                      遍历。作为一道思考题，你能用栈来完成“验证二叉搜索树”这道题目吗？\n                    </p>\n                    <blockquote data-nodeid=\"7967\">\n                      <p data-nodeid=\"7968\">\n                        代码：<a\n                          href=\"https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8566\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8570\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8574\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7969\">\n                      为了巩固我们前面所讲的知识，下面我再给你留两道练习题。\n                    </p>\n                    <p data-nodeid=\"7970\">\n                      <strong data-nodeid=\"8584\">练习题 1</strong\n                      >：“影子”二叉树还可以解决“<strong data-nodeid=\"8585\"\n                        >是否相同的树</strong\n                      >”的问题。比如给定两棵二叉树，要求判断这两棵二叉树是不是一样的？思考的时候，再想一下，“影子”二叉树是怎么样的呢？\n                    </p>\n                    <blockquote data-nodeid=\"7971\">\n                      <p data-nodeid=\"7972\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8589\"\n                          >Java</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8593\"\n                          >C++</a\n                        >,<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8597\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7973\">\n                      当然，有时候出题人还会将一些考点进行组合，比如将“相同的子树”与“前序遍历”进行组合，就可以得到一道新的题目。\n                    </p>\n                    <p data-nodeid=\"7974\">\n                      <strong data-nodeid=\"8607\">练习题 2</strong\n                      >：当我们写出“判断是否相同的树”的代码之后，可以开始思考另外一个问题——如何判断<strong\n                        data-nodeid=\"8608\"\n                        >一棵树是不是另外一棵树的子树</strong\n                      >？\n                    </p>\n                    <blockquote data-nodeid=\"7975\">\n                      <p data-nodeid=\"7976\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8612\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8616\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8620\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"7977\">\n                      你可以把答案或者思考的过程写在评论区，我们一起讨论。\n                    </p>\n                    <p data-nodeid=\"7978\">\n                      到这里，我们可以总结一下解题时用到的知识点和收获。为了方便你理解和复习，我把关于“树的遍历”的考点整理在一张大图里，如下图所示：\n                    </p>\n                    <p data-nodeid=\"7979\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtOmAcCa2AADXoM_tlx4996.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"8625\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7980\">\n                      然后，我们收获了一种思路——“影子”二叉树；一个模板——如何判断相同的树。\n                    </p>\n                    <h4 data-nodeid=\"7981\">例 2：目标和的所有路径</h4>\n                    <p data-nodeid=\"7982\">\n                      【<strong data-nodeid=\"8633\">题目</strong\n                      >】给定一棵二叉树，一个目标值。请输出所有路径，需要满足根结点至叶子结点之和等于给定的目标值。\n                    </p>\n                    <p data-nodeid=\"7983\">输入：target = 9</p>\n                    <p data-nodeid=\"7984\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtPWAR1otAACA-Iu2vmU954.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"8637\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7985\">输出：[[5,4], [5,3,1]]</p>\n                    <p data-nodeid=\"7986\">\n                      <strong data-nodeid=\"8672\">解释</strong\n                      >：从根结点到叶子结点形成的路径有 3 条：[5, 4], [5, 3, 1],\n                      [5, 3, 2]，其中只有 [5, 4], [5, 3, 1] 形成的和为 9。\n                    </p>\n                    <p data-nodeid=\"7987\">\n                      【<strong data-nodeid=\"8682\">分析</strong\n                      >】这是一道来自<strong data-nodeid=\"8683\">头条</strong\n                      >的面试题目。首先题目要求从根结点出发，最后到达叶子结点。因此，从遍历的顺序上来说，符合前序遍历。\n                    </p>\n                    <p data-nodeid=\"7988\">\n                      【<strong data-nodeid=\"8689\">模拟</strong\n                      >】那么接下来我们进行一轮模拟，过程如下所示：\n                    </p>\n                    <p data-nodeid=\"7989\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/42/Cgp9HWBRtQqAeOlzAA3wDEKa3P4970.gif\"\n                        alt=\"3.gif\"\n                        data-nodeid=\"8692\"\n                      />\n                    </p>\n                    <p data-nodeid=\"7990\">\n                      Step 1. 首先从结点 5 出发，此时形成的并不完整的路径为\n                      [5]。\n                    </p>\n                    <p data-nodeid=\"7991\">\n                      Step 2. 接着走向左子结点 4，形成一个有效路径 [5, 4]。\n                    </p>\n                    <p data-nodeid=\"7992\">\n                      Step 3. 接下来在换一条路之前，需要把 4 扔掉。\n                    </p>\n                    <p data-nodeid=\"7993\">\n                      Step 4. 按照前序遍历顺序访问 3，形成并不完整的路径 [5,\n                      3]。\n                    </p>\n                    <p data-nodeid=\"7994\">\n                      Step 5. 接下来访问结点 1，形成完整的有效路径 [5, 3, 1]。\n                    </p>\n                    <p data-nodeid=\"7995\">\n                      Step 6. 当结点 1 遍历完之后，需要从路径中扔掉。\n                    </p>\n                    <p data-nodeid=\"7996\">\n                      Step 7. 接下来遍历结点 2，形成路径 [5, 3, 2]。总和为\n                      10，并不是一个有效解。\n                    </p>\n                    <p data-nodeid=\"7997\">\n                      因此，我们一共找到两个有效解 [5, 4], [5, 3, 1]。\n                    </p>\n                    <p data-nodeid=\"7998\">\n                      【<strong data-nodeid=\"8734\">规律</strong\n                      >】经过模拟的过程，可以发现了以下特点：\n                    </p>\n                    <ul data-nodeid=\"7999\">\n                      <li data-nodeid=\"8000\">\n                        <p data-nodeid=\"8001\">\n                          遇到新结点，路径总是从尾部添加结点；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8002\">\n                        <p data-nodeid=\"8003\">\n                          遍历完结点，路径就把它从尾部扔掉；\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8004\">\n                      路径里面的元素刚好与递归时压栈的元素完全一样。因此，我们需要在递归结束时，把路径里面的元素像“弹栈”一样扔掉。\n                    </p>\n                    <p data-nodeid=\"8005\">\n                      【<strong data-nodeid=\"8747\">匹配</strong\n                      >】基于二叉树而言，这里的考点当然是前序遍历。但是我们发现：还需要另外一个信息“<strong\n                        data-nodeid=\"8748\"\n                        >路径</strong\n                      >”：随着参数的压栈、弹栈而变化。\n                    </p>\n                    <p data-nodeid=\"8006\">\n                      【<strong data-nodeid=\"8754\">边界</strong\n                      >】按照题意，这里需要注意两点：\n                    </p>\n                    <ul data-nodeid=\"8007\">\n                      <li data-nodeid=\"8008\">\n                        <p data-nodeid=\"8009\">题目一定要根结点到叶子结点</p>\n                      </li>\n                      <li data-nodeid=\"8010\">\n                        <p data-nodeid=\"8011\">注意代码要支持空树</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8012\">\n                      【<strong data-nodeid=\"8762\">代码</strong\n                      >】此时，我们已经可以写一写代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">backtrace</span><span class=\"hljs-params\">(TreeNode root, \n</span></span></div></li><li><div class=\"code-word\">      List&lt;Integer&gt; path, <span class=\"hljs-keyword\">int</span> sum, <span class=\"hljs-keyword\">int</span> target) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果已经是空树，那么没有必要看</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 前序遍历，加上累计的和</span>\n</div></li><li><div class=\"code-word\">        sum += root.val;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 将结点添加到路径中，相当于压栈一样</span>\n</div></li><li><div class=\"code-word\">        path.add(root.val);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (root.left == <span class=\"hljs-keyword\">null</span> &amp;&amp; root.right == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果已经形成了一个有效路径!</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (sum == target) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 添加到ans中</span>\n</div></li><li><div class=\"code-word\">                ans.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(path));\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 回溯，分别再看子情况。</span>\n</div></li><li><div class=\"code-word\">            backtrace(root.left, path, sum, target);\n</div></li><li><div class=\"code-word\">            backtrace(root.right, path, sum, target);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 函数结束的时候弹栈，也要把结点从路径最后扔掉!</span>\n</div></li><li><div class=\"code-word\">        path.remove(path.size()-<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class=\"hljs-keyword\">int</span> sum) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 路径</span>\n</div></li><li><div class=\"code-word\">        List&lt;Integer&gt; path = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        backtrace(root, path, <span class=\"hljs-number\">0</span>, sum);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8014\">\n                      <p data-nodeid=\"8015\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8766\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8770\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8774\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8016\">\n                      <strong data-nodeid=\"8781\">复杂度分析</strong\n                      >：首先遍历每个结点，复杂度肯定是\n                      O(N)。但是最大的复杂度在于复制有效路径。假设有一棵满二叉树，最下面一层结点都符合要求。那么一共需要复制\n                      N/2 次。而每次需要复制路径深度为 log(N)。因此，复杂度为\n                      N/2 * log(N)，即 NlgN。\n                    </p>\n                    <p data-nodeid=\"8017\">\n                      【<strong data-nodeid=\"8795\">小结</strong\n                      >】本质上，这道题的考点就是：<strong data-nodeid=\"8796\"\n                        >回溯</strong\n                      >，只不过借用了二叉树这个皮。反过来，在<strong\n                        data-nodeid=\"8797\"\n                        >二叉树上进行回溯的代码模板，你也需要熟练掌握</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8018\">\n                      如果我们把题目中“路径之和等于\n                      target”这个条件去掉，那么题目就变成了需要输出二叉树到叶子结点的所有路径。想必这道题目你也能够解决了吧？\n                    </p>\n                    <p data-nodeid=\"8019\">\n                      到这里，我们又可以进一步丰富了前面总结出的关于“二叉树的前序遍历”的思维导图了，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8020\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtRmAU_NjAAEAKqKMPsY246.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"8802\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8021\">\n                      在这里，我们收获了：二叉树上的<strong data-nodeid=\"8808\"\n                        >回溯模板</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8022\">\n                      前序遍历的变种还有很多，结合不同的考点，还会有新的题型出现，但是只要我们能分析出题目的考点，有效地掌握一些代码模板进行相互组合，一定能克服这些新鲜的题目。\n                    </p>\n                    <h3 data-nodeid=\"8023\">中序遍历</h3>\n                    <p data-nodeid=\"8024\">\n                      接下来我们看一下中序遍历。中序遍历的顺序：\n                    </p>\n                    <ol data-nodeid=\"8025\">\n                      <li data-nodeid=\"8026\">\n                        <p data-nodeid=\"8027\">左子树</p>\n                      </li>\n                      <li data-nodeid=\"8028\">\n                        <p data-nodeid=\"8029\">根结点</p>\n                      </li>\n                      <li data-nodeid=\"8030\">\n                        <p data-nodeid=\"8031\">右子树</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"8032\">\n                      这里不再按照课本上一步一步演示的方式，同样可以采用一种概括处理的思路，如下所示：\n                    </p>\n                    <p data-nodeid=\"8033\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtSuAPkajAAkCntnG56c613.gif\"\n                        alt=\"4.gif\"\n                        data-nodeid=\"8818\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"8034\">\n                      <li data-nodeid=\"8035\">\n                        <p data-nodeid=\"8036\">\n                          Step 1.\n                          左子树作为一个整体放到左边；然后把根结点放到中间；最后把右子树作为一个整体放右边。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8037\">\n                        <p data-nodeid=\"8038\">Step 2. 接着再把左子树展开。</p>\n                      </li>\n                      <li data-nodeid=\"8039\">\n                        <p data-nodeid=\"8040\">\n                          Step 3.\n                          最后再把右子树展开，此时我们就得到了最终中序遍历的结果。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8041\">\n                      经过上述过程的拆解和分析，有助于帮助你理解中序遍历。但是仍然要注意输出结点的顺序，结点真正输出顺序如下图所示：\n                    </p>\n                    <p data-nodeid=\"8042\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/21/3A/CioPOWBUI-qAV1MZAACWlNh4bls274.png\"\n                        alt=\"2021319-12844.png\"\n                        data-nodeid=\"8825\"\n                      />\n                    </p>\n                    <h4 data-nodeid=\"8043\">递归中序遍历</h4>\n                    <p data-nodeid=\"8044\">\n                      基于以上思路，我们可以写出递归的中序遍历的代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">(TreeNode root, List&lt;Integer&gt; ans)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (root != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 先遍历左子树</span>\n</div></li><li><div class=\"code-word\">        preOrder(root.left, ans);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 然后遍历中间的根结点</span>\n</div></li><li><div class=\"code-word\">        ans.add(root.val);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 最后遍历右子树</span>\n</div></li><li><div class=\"code-word\">        preOrder(root.right, ans);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8046\">\n                      <p data-nodeid=\"8047\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8831\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8835\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8839\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8048\">\n                      <strong data-nodeid=\"8844\">复杂度分析</strong\n                      >：时间复杂度为\n                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)\n                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。\n                    </p>\n                    <h4 data-nodeid=\"8049\">使用栈完成中序遍历</h4>\n                    <p data-nodeid=\"8050\">\n                      接下来，我们看一下如何将递归的中序代码，改成<strong\n                        data-nodeid=\"8851\"\n                        >非递归的中序代码</strong\n                      >（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;Integer&gt; <span class=\"hljs-title\">inorderTraversal</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; Stack&lt;TreeNode&gt; s = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; List&lt;Integer&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 注意这里的判断条件，需要root或stack非空</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-keyword\">null</span> || !s.empty()) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 往左边走，连续入栈，直到不能再走为止</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.push(root);\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = root.left;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 到达了最左边，把结点弹出来，进行遍历</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = s.peek();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.pop();\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans.add(root.val);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 转向右子树</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root = root.right;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 返回遍历的结果</span>\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8052\">\n                      <p data-nodeid=\"8053\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8855\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8859\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8863\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8054\">\n                      <strong data-nodeid=\"8868\">复杂度分析</strong\n                      >：时间复杂度为\n                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)\n                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。\n                    </p>\n                    <p data-nodeid=\"8055\">\n                      <strong data-nodeid=\"8873\">备注</strong\n                      >：虽然面试的时候极难考到\n                      Morris，但如果你想多掌握一种解题方法，可以尝试用 Morris\n                      遍历，其优点是只需要使用 O(1)\n                      的空间复杂度。这里我先给出完整实现代码，如有你有疑问可以写在留言区，我们一起讨论。\n                    </p>\n                    <blockquote data-nodeid=\"8056\">\n                      <p data-nodeid=\"8057\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8877\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8881\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8885\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h4 data-nodeid=\"8058\">例 3：验证二叉搜索树</h4>\n                    <p data-nodeid=\"8059\">\n                      【<strong data-nodeid=\"8892\">题目</strong>】（与例 1\n                      一样）给定一棵二叉树，要求验证是不是一棵二叉搜索树。\n                    </p>\n                    <p data-nodeid=\"8060\">\n                      【<strong data-nodeid=\"8906\">分析</strong>】根据<strong\n                        data-nodeid=\"8907\"\n                        >二叉搜索树</strong\n                      >的特性，可以知道。<strong data-nodeid=\"8908\"\n                        >中序遍历一定有序</strong\n                      >。因此，可以利用这个特性进行验证。如果从这个角度来切入，那么题目的考点就可以总结如下：\n                    </p>\n                    <p data-nodeid=\"8061\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtUiAJEr9AAC21ET_Iqs675.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"8911\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8062\">\n                      接下来我们就尝试用中序遍历解决这道题目，代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">boolean</span> ans = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    Long preValue = Long.MIN_VALUE;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">midOrder</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!ans) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (root != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">            midOrder(root.left);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 只需要在中序遍历的时候，</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 与前面的值进行一下比较就可以了。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (preValue &gt;= root.val) {\n</div></li><li><div class=\"code-word\">                ans = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 比较完成之后，更新一下前面结点的值</span>\n</div></li><li><div class=\"code-word\">            preValue = Long.valueOf(root.val);\n</div></li><li><div class=\"code-word\">            midOrder(root.right);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\n</div></li><li><div class=\"code-word\">        ans = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 注意，为了防止root.val取到最小值INT_MIN</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 这里需要初始化为64位的最小值。</span>\n</div></li><li><div class=\"code-word\">        preValue = Long.MIN_VALUE;\n</div></li><li><div class=\"code-word\">        midOrder(root);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8064\">\n                      <p data-nodeid=\"8065\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8916\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8920\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8924\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8066\">\n                      <strong data-nodeid=\"8929\">复杂度分析</strong>：时间复杂度\n                      O(N)，每个结点只遍历一次，并且每个结点访问只需要 O(1)\n                      时间复杂度。空间复杂度为 O(H)，其中 H 为树的高度。\n                    </p>\n                    <p data-nodeid=\"8067\">\n                      【<strong data-nodeid=\"8935\">小结</strong\n                      >】平时练习的时候，你不妨将同类型的二叉树题目串起来进行比较，也许会发现题目真正的考点。比如将“二叉树的中序遍历”与“验证二叉搜索树”这两类题目放在一起思考，就会发现，考点是将中序遍历访问结点时候的处理做了一点小小的变化。\n                    </p>\n                    <p data-nodeid=\"8068\">\n                      另外，在处理二叉搜索树的时候，还需要利用有序性。中序遍历二叉搜索树的时候，可以把它<strong\n                        data-nodeid=\"8940\"\n                        >看成一个有序的数组，在此基础上展开思路。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"8069\">\n                      <strong data-nodeid=\"8945\">练习题 3</strong\n                      >：找出二叉搜索树里面出现次数最多的数。\n                    </p>\n                    <blockquote data-nodeid=\"8070\">\n                      <p data-nodeid=\"8071\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8949\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8953\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"8957\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8072\">\n                      我们还可以做进一步思考。经典的中序遍历只访问了一个结点，<strong\n                        data-nodeid=\"8967\"\n                        >关心一个结点的性质</strong\n                      >。而“验证二叉搜索树”需要访问两个结点，用<strong\n                        data-nodeid=\"8968\"\n                        >两个结点的信息</strong\n                      >做决策。\n                    </p>\n                    <p data-nodeid=\"8073\">\n                      因此，从“需要用的<strong data-nodeid=\"8974\"\n                        >结点个数</strong\n                      >”角度出发，也可以衍生出一些题目。这里给你留两道练习题，帮助你巩固前面所讲的知识，希望你可以在课下完成它。\n                    </p>\n                    <p data-nodeid=\"8074\">\n                      <strong data-nodeid=\"8979\">练习题 4</strong\n                      >：找出二叉搜索树任意两结点之间绝对值的最小值\n                    </p>\n                    <blockquote data-nodeid=\"8075\">\n                      <p data-nodeid=\"8076\">\n                        代码：<a\n                          href=\"http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.java\"\n                          data-nodeid=\"8983\"\n                          >Java</a\n                        >/<a\n                          href=\"http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.cpp\"\n                          data-nodeid=\"8987\"\n                          >C++</a\n                        >/<a\n                          href=\"http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.py\"\n                          data-nodeid=\"8991\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8077\">\n                      <strong data-nodeid=\"8996\">练习题 5</strong\n                      >：一棵二叉搜索树的两个结点被交换了，恢复这棵二叉搜索树\n                    </p>\n                    <blockquote data-nodeid=\"8078\">\n                      <p data-nodeid=\"8079\">\n                        解法 1（递归）：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java\"\n                          data-nodeid=\"9000\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.cpp\"\n                          data-nodeid=\"9004\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.py\"\n                          data-nodeid=\"9008\"\n                          >Python</a\n                        ><br />\n                        解法 2（栈）：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.java\"\n                          data-nodeid=\"9013\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.cpp\"\n                          data-nodeid=\"9017\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.py\"\n                          data-nodeid=\"9021\"\n                          >Python</a\n                        ><br />\n                        解法 3（Morris）：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.java\"\n                          data-nodeid=\"9026\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.cpp\"\n                          data-nodeid=\"9030\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.py\"\n                          data-nodeid=\"9034\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8080\">\n                      至此，我们已经挖掘了中序遍历可能的考点，如下图所示：<br />\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtVWASUJoAAD2XJCLLgQ425.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"9039\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8081\">\n                      讲完二叉搜索树（BST），我们再来看看“如何删除二叉搜索树的结点”，这也是面试中很重要的一个考点。\n                    </p>\n                    <h4 data-nodeid=\"8082\">例 4：删除二叉搜索树的结点</h4>\n                    <p data-nodeid=\"8083\">\n                      【<strong data-nodeid=\"9047\">题目</strong\n                      >】删除二叉搜索树的指定结点。返回删除之后的根结点。接口如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">TreeNode <span class=\"hljs-title\">deleteNode</span><span class=\"hljs-params\">(TreeNode root, <span class=\"hljs-keyword\">int</span> value)</span></span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8085\">\n                      【<strong data-nodeid=\"9057\">分析</strong\n                      >】这是一道来自<strong data-nodeid=\"9058\">微软</strong\n                      >的面试题。它的难点在于需要考虑各种情况。因此，针对这道题的题目特点，我们把重点放在分析各种\n                      Case。\n                    </p>\n                    <p data-nodeid=\"8086\">\n                      Case 1：空树。如果树是空树，那么只需要返回 null 即可。\n                    </p>\n                    <p data-nodeid=\"8087\">\n                      Case 2：如果 value\n                      比根结点小，那么去左子树里面删除相应结点，执行：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (value &lt; root.val) {\n</div></li><li><div class=\"code-word\">    root.left = deleteNode(root.left, value);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8089\">\n                      这里只有一行核心代码，但却<strong data-nodeid=\"9066\"\n                        >非常有意思</strong\n                      >。因为这行代码统一处理了以下几种情况。\n                    </p>\n                    <p data-nodeid=\"8090\">\n                      a）当结点 1 删除之后，左子树为空，需要设置 root.left =\n                      null。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8091\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtWWAIxSJAABkVgPnF_o374.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"9070\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8092\">\n                      b）当结点 1 删除之后，左子树的根结点为 2，需要设置\n                      root.left 指向结点 2。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8093\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtW2AARGtAAB29vC847A588.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"9074\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8094\">\n                      c）当结点 1 删除之后，左子树根结点变成 2，需要设置\n                      root.left 指向结点 2。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8095\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtXaALQrkAAB3-_72MrY558.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"9078\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8096\">因此，删除结点时，需要：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">root.left = deleteNode(root.left, value);\n</div></li><li><div class=\"code-word\">或\n</div></li><li><div class=\"code-word\">root.right = deleteNode(root.right, value);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8098\">\n                      虽然看起来\n                      b）没有重新赋值的必要，但是利用这一句话，却把a）、b）、c）三情况都统一起来了。我们再思考时，就不需要考虑更多的情况了。\n                    </p>\n                    <p data-nodeid=\"8099\">\n                      Case 3：如果 value 比根结点大，那么需要执行：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (value &gt; root.val) {\n</div></li><li><div class=\"code-word\">    root.right = deleteNode(root.right, value);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8101\">\n                      Case 4：如果 value\n                      与根结点的值相等，那么需要再分四种情况考虑。\n                    </p>\n                    <p data-nodeid=\"8102\">a）此时只有一个结点。比如：</p>\n                    <p data-nodeid=\"8103\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtYOAaCxfAABz2q7dEO8442.png\"\n                        alt=\"Drawing 15.png\"\n                        data-nodeid=\"9086\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8104\">在删除 1 之后，都需要返回 null。</p>\n                    <p data-nodeid=\"8105\">\n                      b）如果被删除的结点有左子树。那么需要从<strong\n                        data-nodeid=\"9101\"\n                        >左子树中找到最大值</strong\n                      >，然后与当前结点进行值<strong data-nodeid=\"9102\"\n                        >交换</strong\n                      >。最后<strong data-nodeid=\"9103\"\n                        >再在左子树中删除 value</strong\n                      >。步骤如下：\n                    </p>\n                    <p data-nodeid=\"8106\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtZiAEkBKAAanEhq-SYE408.gif\"\n                        alt=\"5.gif\"\n                        data-nodeid=\"9106\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8107\">\n                      Step 1. 找到要删除的结点\n                      1，发现它还有左子树。并不能直接删除。\n                    </p>\n                    <p data-nodeid=\"8108\">\n                      Step 2. 找到左子树里面的最大值 -1。\n                    </p>\n                    <p data-nodeid=\"8109\">\n                      Step 3. 将值 -1 与 1 的值进行交换。注意：我们只是交换\n                      node.val，而不是交换 node。\n                    </p>\n                    <p data-nodeid=\"8110\">\n                      Step 4. 交换之后，接着在左子树中删除结点 1。\n                    </p>\n                    <p data-nodeid=\"8111\">\n                      Step 5. 最终得到的仍然是一棵二叉搜索树。\n                    </p>\n                    <p data-nodeid=\"8112\">\n                      c）如果要删除的结点只有右子树。那么需要从<strong\n                        data-nodeid=\"9125\"\n                        >右子树中找到最小值</strong\n                      >，然后与当前结点进行值<strong data-nodeid=\"9126\"\n                        >交换</strong\n                      >。然后<strong data-nodeid=\"9127\"\n                        >再在右子树中删除 value</strong\n                      >。步骤如下：\n                    </p>\n                    <p data-nodeid=\"8113\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtbCAEv1OAAXuSoTT_wY014.gif\"\n                        alt=\"6.gif\"\n                        data-nodeid=\"9130\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8114\">\n                      Step 1. 找到要删除的结点 1，发现它还有右子树。\n                    </p>\n                    <p data-nodeid=\"8115\">Step 2. 在右子树中找到最小的值 2。</p>\n                    <p data-nodeid=\"8116\">\n                      Step 3. 交换值。注意：是交换值，不是结点交换。\n                    </p>\n                    <p data-nodeid=\"8117\">Step 4. 继续在右子树中删除结点 1。</p>\n                    <p data-nodeid=\"8118\">\n                      Step 5. 最终我们得到一棵删除结点 1 之后的二叉搜索树。\n                    </p>\n                    <p data-nodeid=\"8119\">\n                      d）被删除的结点既有左子树，也有右子树。这时，假设它只有左子树，或者假设它只有右子树，这两种假设你可以任选一个进行删除即可。\n                    </p>\n                    <p data-nodeid=\"8120\">\n                      不过这里我要给你留道<strong data-nodeid=\"9142\"\n                        >思考题</strong\n                      >：如果我们想要删除结点之后，想让二叉搜索树尽量保持平衡，有什么办法呢？提示：可以增加一些结点信息。\n                    </p>\n                    <p data-nodeid=\"8121\">\n                      【<strong data-nodeid=\"9152\">代码</strong\n                      >】至此，我们把<strong data-nodeid=\"9153\"\n                        >删除二叉搜索树的结点</strong\n                      >涉及的所有情况都分析清楚了，接下来就可以直接写代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swapValue</span><span class=\"hljs-params\">(TreeNode a, TreeNode b)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> t = a.val;\n</div></li><li><div class=\"code-word\">        a.val = b.val;\n</div></li><li><div class=\"code-word\">        b.val = t;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title\">deleteNode</span><span class=\"hljs-params\">(TreeNode root, <span class=\"hljs-keyword\">int</span> key)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// case 1</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// case 2</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (key &lt; root.val) {\n</div></li><li><div class=\"code-word\">            root.left = deleteNode(root.left, key);\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key &gt; root.val) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// case 3</span>\n</div></li><li><div class=\"code-word\">            root.right = deleteNode(root.right, key);\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// case 4. case4又分为4种小情况，最后一种可以被合并掉。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 所以这里只处理了三种。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 当前树只有一个结点，那么直接返回null</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (root.left == <span class=\"hljs-keyword\">null</span> &amp;&amp; root.right == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (root.left != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 当前结点还有左子树</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 那么需要从左子树中找个较大的值。</span>\n</div></li><li><div class=\"code-word\">                TreeNode large = root.left;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">while</span> (large.right != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">                    large = large.right;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 交换再删除</span>\n</div></li><li><div class=\"code-word\">                swapValue(root, large);\n</div></li><li><div class=\"code-word\">                root.left = deleteNode(root.left, key);\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (root.right != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 当前结点还有右子树</span>\n</div></li><li><div class=\"code-word\">                TreeNode small = root.right;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 那么需要从右子树中找个较小的值</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">while</span> (small.left != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">                    small = small.left;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 交换再删除</span>\n</div></li><li><div class=\"code-word\">                swapValue(root, small);\n</div></li><li><div class=\"code-word\">                root.right = deleteNode(root.right, key);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> root;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8123\">\n                      <p data-nodeid=\"8124\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9157\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9161\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9165\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8125\">\n                      <strong data-nodeid=\"9170\">复杂度分析</strong\n                      >：如果是一棵平衡的二叉搜索树，那么时间复杂度为\n                      O(lgn)，否则时间复杂度为 O(N)。\n                    </p>\n                    <p data-nodeid=\"8126\">\n                      【<strong data-nodeid=\"9184\">小结</strong\n                      >】我们对“二叉搜索树的删除结点”的考点做一下小结。一方面是利用<strong\n                        data-nodeid=\"9185\"\n                        >有序性</strong\n                      >，另一方面就是<strong data-nodeid=\"9186\"\n                        >考察应聘者的分析能力</strong\n                      >。因此，这道题的重点是清晰分析出其中涉及的四种情况。面试的时候，面试官会要求你：\n                    </p>\n                    <ul data-nodeid=\"8127\">\n                      <li data-nodeid=\"8128\">\n                        <p data-nodeid=\"8129\">能清晰地讲出每种情况的处理办法</p>\n                      </li>\n                      <li data-nodeid=\"8130\">\n                        <p data-nodeid=\"8131\">能清晰简洁地实现代码</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8132\">\n                      既然我们已经学习了二叉搜索树删除结点操作，那么另外两种操作想必你可以拿来练练手了。\n                    </p>\n                    <p data-nodeid=\"8133\">\n                      <strong data-nodeid=\"9194\">练习题 6</strong>:\n                      二叉搜索树插入一个新结点\n                    </p>\n                    <blockquote data-nodeid=\"8134\">\n                      <p data-nodeid=\"8135\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9198\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jcpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9202\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9206\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8136\">\n                      <strong data-nodeid=\"9211\">练习题 7</strong\n                      >：二叉搜索树查找结点\n                    </p>\n                    <blockquote data-nodeid=\"8137\">\n                      <p data-nodeid=\"8138\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9215\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9219\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9223\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8139\">\n                      此时我们就可以将<strong data-nodeid=\"9241\"\n                        >二叉搜索树的中序遍历</strong\n                      >、<strong data-nodeid=\"9242\">查找</strong>、<strong\n                        data-nodeid=\"9243\"\n                        >插入</strong\n                      >，<strong data-nodeid=\"9244\">以及删除</strong\n                      >加入我们的知识树里面了，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8140\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtcGAHdsVAAD8g3mqZEQ373.png\"\n                        alt=\"Drawing 18.png\"\n                        data-nodeid=\"9247\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"8141\">后序遍历</h3>\n                    <p data-nodeid=\"8142\">\n                      接下来我们看一下后序遍历。后序遍历的顺序：\n                    </p>\n                    <ol data-nodeid=\"8143\">\n                      <li data-nodeid=\"8144\">\n                        <p data-nodeid=\"8145\">左子树</p>\n                      </li>\n                      <li data-nodeid=\"8146\">\n                        <p data-nodeid=\"8147\">右子树</p>\n                      </li>\n                      <li data-nodeid=\"8148\">\n                        <p data-nodeid=\"8149\">根结点</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"8150\">\n                      这里我们同样采用一种**概括处理的思路，**不再按照课本上一步一步演示的方式。下图是我们处理的步骤：\n                    </p>\n                    <p data-nodeid=\"8151\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtc6AUcUpAAoB4AbuqCg073.gif\"\n                        alt=\"7.gif\"\n                        data-nodeid=\"9262\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"8152\">\n                      <li data-nodeid=\"8153\">\n                        <p data-nodeid=\"8154\">\n                          Step 1.\n                          左子树作为一个整体放到左边，右子树作为一个整体放右边。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8155\">\n                        <p data-nodeid=\"8156\">Step 2. 再把左子树展开。</p>\n                      </li>\n                      <li data-nodeid=\"8157\">\n                        <p data-nodeid=\"8158\">Step 3. 接着把右子树展开。</p>\n                      </li>\n                      <li data-nodeid=\"8159\">\n                        <p data-nodeid=\"8160\">Step 4. 最后放上根结点。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8161\">\n                      这样有助于帮助你理解后序遍历。但是仍然要<strong\n                        data-nodeid=\"9272\"\n                        >注意输出结点的顺序</strong\n                      >。结点真正输出顺序如下图所示（红色表示顺序）：\n                    </p>\n                    <p data-nodeid=\"8162\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtdmAVCQTAACWpvqFKDQ011.png\"\n                        alt=\"Drawing 20.png\"\n                        data-nodeid=\"9275\"\n                      />\n                    </p>\n                    <h4 data-nodeid=\"8163\">递归后序遍历</h4>\n                    <p data-nodeid=\"8164\">\n                      基于以上思路，我们可以写出递归的后序遍历代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">(TreeNode root, List&lt;Integer&gt; ans)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (root != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 先遍历左子树</span>\n</div></li><li><div class=\"code-word\">    postOrder(root.left, ans);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 最后遍历右子树</span>\n</div></li><li><div class=\"code-word\">    postOrder(root.right, ans);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 然后遍历中间的根结点</span>\n</div></li><li><div class=\"code-word\">    ans.add(root.val);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8166\">\n                      <p data-nodeid=\"8167\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9281\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9285\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9289\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8168\">\n                      <strong data-nodeid=\"9294\">复杂度分析</strong\n                      >：时间复杂度为\n                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)\n                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。\n                    </p>\n                    <h4 data-nodeid=\"8169\">使用栈完成后序遍历</h4>\n                    <p data-nodeid=\"8170\">\n                      接下来，我们看一下如何将递归的后序代码，改成<strong\n                        data-nodeid=\"9301\"\n                        >非递归的后序代码</strong\n                      >（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;Integer&gt; <span class=\"hljs-title\">postorderTraversal</span><span class=\"hljs-params\">(TreeNode t)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 存放遍历的结果</span>\n</div></li><li><div class=\"code-word\">        List&lt;Integer&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// pre表示遍历时前面一个已经遍历过的结点</span>\n</div></li><li><div class=\"code-word\">        TreeNode pre = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">        Stack&lt;TreeNode&gt; s = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果栈中还有元素，或者当前结点t非空</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (!s.isEmpty() || t != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 顺着左子树走，并且将所有的元素压入栈中</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">while</span> (t != <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">                s.push(t);\n</div></li><li><div class=\"code-word\">                t = t.left;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 当没有任何元素可以压栈的时候</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 拿栈顶元素，注意这里并不将栈顶元素弹出</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 因为在迭代时，根结点需要遍历两次，这里需要判断一下</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 右子树是否遍历完毕</span>\n</div></li><li><div class=\"code-word\">            t = s.peek();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果要遍历当前结点，需要确保右子树已经遍历完毕</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 1. 如果当前结点右子树为空，那么右子树没有遍历的必要</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 需要将当前结点放到ans中</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 2. 当t.right == pre时，说明右子树已经被打印过了</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 那么此时需要将当前结点放到ans中</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (t.right == <span class=\"hljs-keyword\">null</span> || t.right == pre) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 右子树已经遍历完毕，放到ans中。</span>\n</div></li><li><div class=\"code-word\">                ans.add(t.val);\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 弹栈</span>\n</div></li><li><div class=\"code-word\">                s.pop();\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 因为已经遍历了当前结点，所以需要更新pre结点</span>\n</div></li><li><div class=\"code-word\">                pre = t;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 已经打印完毕。需要设置为空，否则下一轮循环</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 还会遍历t的左子树。</span>\n</div></li><li><div class=\"code-word\">                t = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 第一次走到t结点，不能放到ans中，因为t的右子树还没有遍历。</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 需要将t结点的右子树遍历</span>\n</div></li><li><div class=\"code-word\">                t = t.right;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n\n                    <blockquote data-nodeid=\"8172\">\n                      <p data-nodeid=\"8173\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9305\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9309\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9313\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8174\">\n                      <strong data-nodeid=\"9318\">复杂度分析</strong>：时间复杂度\n                      O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1)\n                      复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。\n                    </p>\n                    <p data-nodeid=\"8175\">\n                      迭代写法的<strong data-nodeid=\"9324\">考点</strong\n                      >：判断当前结点是不是应该放到 ans 中。\n                      这里我们用了两个条件进行判断：\n                    </p>\n                    <ul data-nodeid=\"8176\">\n                      <li data-nodeid=\"8177\">\n                        <p data-nodeid=\"8178\">是否有右子树</p>\n                      </li>\n                      <li data-nodeid=\"8179\">\n                        <p data-nodeid=\"8180\">\n                          pre 指针是不是指向当前结点的右子树\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8181\">\n                      <strong data-nodeid=\"9331\">备注</strong\n                      >：虽然面试的时候极难考到\n                      Morris，但如果你有时间我还是建议你看看 Morris\n                      后序遍历，其优点是只需要使用 O(1) 的空间复杂度。\n                    </p>\n                    <blockquote data-nodeid=\"8182\">\n                      <p data-nodeid=\"8183\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9335\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9339\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9343\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8184\">\n                      相比前序遍历、中序遍历，后序遍历出题形式变化更多样。接下来我们看一下如何用后序遍历处理例\n                      1。\n                    </p>\n                    <h4 data-nodeid=\"8185\">例 5：验证二叉搜索树</h4>\n                    <p data-nodeid=\"8186\">\n                      【<strong data-nodeid=\"9351\">题目</strong>】（与例\n                      1一样）给定一棵二叉树，要求验证是不是一棵二叉搜索树。\n                    </p>\n                    <p data-nodeid=\"8187\">\n                      【<strong data-nodeid=\"9357\">分析</strong\n                      >】这里要利用后序遍历来求解这道题目。回到二叉搜索树的定义：左子树所有值都比根结点小，右子树所有值都比根结点大。\n                    </p>\n                    <p data-nodeid=\"8188\">\n                      如果我们能够拿到左右子树的信息，根结点就可以利用这些信息判断是否满足二叉搜索树的要求。\n                    </p>\n                    <p data-nodeid=\"8189\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRte6AGgSSAANZYCc0W0I359.png\"\n                        alt=\"Drawing 21.png\"\n                        data-nodeid=\"9361\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8190\">\n                      如上图所示：如果满足 lmax &lt; x 并且 x &lt;\n                      rmin，那么可以认为这棵树是二叉搜索树。注意，<strong\n                        data-nodeid=\"9371\"\n                        >我们是先拿到了左子树与右子树的信息，然后再利用这个信息做出判断</strong\n                      >。这样的操作符合后序遍历的要求。\n                    </p>\n                    <p data-nodeid=\"8191\">\n                      【<strong data-nodeid=\"9377\">画图</strong\n                      >】这里我们拿一棵二叉搜索树来画图演示步骤，动图如下：\n                    </p>\n                    <p data-nodeid=\"8192\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/21/38/CioPOWBUIwGAAv3NAAp9VZSO5a4731.gif\"\n                        alt=\"12.gif\"\n                        data-nodeid=\"9380\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8193\">\n                      Step 1.\n                      想要判断根结点是否大于左子树，小于右子树。但是此时还没有拿到左右子树的信息，于是分别去拿左子树/右子树的信息。\n                    </p>\n                    <p data-nodeid=\"8194\">\n                      Step 2. 观察左子树.可以发现 1 &lt; 2， 并且 2 &lt;\n                      3，左子树是一棵二叉搜索树，此外我们还得到了左子树的范围\n                      [1, 3]。\n                    </p>\n                    <p data-nodeid=\"8195\">\n                      Step 3. 然后再看右子树，可以发现 5 &lt; 6 并且 6 &lt;\n                      7，右子树是一棵二叉搜索树，此外我们还得到了右子树的范围\n                      [5, 7]。\n                    </p>\n                    <p data-nodeid=\"8196\">\n                      Step 4.\n                      分别得到左右子树的信息之后，我们将这个信息替换掉原来的子树，然后再比较\n                      lmax = 3 &lt; 4 并且 4 &lt; rmin =\n                      5，因此这棵树是一棵有效的二叉搜索树。\n                    </p>\n                    <p data-nodeid=\"8197\">\n                      【<strong data-nodeid=\"9410\">技巧</strong\n                      >】在利用后序遍历处理这道题目的时候，还需要考虑空结点带来的麻烦，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8198\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtgKAIBrtAABQgHb3MVg861.png\"\n                        alt=\"Drawing 23.png\"\n                        data-nodeid=\"9413\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8199\">\n                      我们在处理结点 4 的时候，右子树的范围比较容易确定 [5,\n                      5]。但是左子树是一棵空树，返回什么范围给结点 4\n                      合适呢？有什么办法可以比较好地避免用 if/else\n                      去判断空结点呢？\n                    </p>\n                    <p data-nodeid=\"8200\">\n                      这里给你介绍一个<strong data-nodeid=\"9436\"\n                        >技巧：用 [Long.MAX_VALUE,\n                        Long.MIN_VALUE]表示一个空区间</strong\n                      >，也就是<strong data-nodeid=\"9437\"\n                        >下界是一个最大的数，上界是一个最小的数</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8201\">\n                      下面我们利用动图演示一下为什么在这种情况下可以工作（画图时分别用\n                      -inf 取代最小值，用inf 取代最大值）：\n                    </p>\n                    <p data-nodeid=\"8202\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtheAAqTpAAqrC7nn9cs642.gif\"\n                        alt=\"9.gif\"\n                        data-nodeid=\"9441\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8203\">\n                      Step 1.\n                      根据后序遍历的要求，首先应该去查看左子树和右子树的信息。\n                    </p>\n                    <p data-nodeid=\"8204\">\n                      Step 2. 左子树是一棵空树，那么得到的区间就是\n                      <strong data-nodeid=\"9450\">[inf, -inf]</strong\n                      >。注意这里表示空区间的方式。\n                    </p>\n                    <p data-nodeid=\"8205\">\n                      Step 3. 右子树只有一个结点 5，其左右子树也是空树，因此结点\n                      5 的左右区间分别为 [inf, -inf] 和 [inf, -inf]。<strong\n                        data-nodeid=\"9468\"\n                        >接下来进行比较，lmax = -inf &lt; 5 并且 5 &lt; rmin =\n                        inf</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8206\">\n                      Step 4.\n                      然后我们需要总结右子树的区间范围。这个区间就可以这样取了：[<strong\n                        data-nodeid=\"9484\"\n                        >min(lmin=inf, 5)</strong\n                      >,<strong data-nodeid=\"9485\">max(5, rmax=-inf)</strong\n                      >]，也就是 [5, 5]。\n                    </p>\n                    <p data-nodeid=\"8207\">\n                      Step 5.\n                      接下来利用左子树的信息和右子树的信息，首先判断范围，lmax =\n                      -inf &lt; 4并且4 &lt; rmin = 5，再得到整棵树的范围[<strong\n                        data-nodeid=\"9505\"\n                        >min(lmin=inf, 4)</strong\n                      >,<strong data-nodeid=\"9506\">max(5, rmax=5)</strong\n                      >]，也就是 [4, 5]。\n                    </p>\n                    <p data-nodeid=\"8208\">\n                      【<strong data-nodeid=\"9512\">代码</strong\n                      >】到这里，我们已经可以开始写一下代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 用来存放一棵树里面数值的区间</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Range</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> Long min = Long.MAX_VALUE;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> Long max = Long.MIN_VALUE;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Range</span><span class=\"hljs-params\">()</span> </span>{}\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Range</span><span class=\"hljs-params\">(Long l, Long r)</span> </span>{\n</div></li><li><div class=\"code-word\">      min = l;\n</div></li><li><div class=\"code-word\">      max = r;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> ans = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> Range emptyRange = <span class=\"hljs-keyword\">new</span> Range();\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Range <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果是空树，或者已经判断不是一棵二叉搜索树了</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 那么就不需要再继续遍历了。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span> || !ans) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> emptyRange;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    Range l = postOrder(root.left);\n</div></li><li><div class=\"code-word\">    Range r = postOrder(root.right);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!(l.max &lt; root.val &amp;&amp; root.val &lt; r.min)) {\n</div></li><li><div class=\"code-word\">      ans = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 当不符合的时候，返回任意区间都是可以的</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> emptyRange;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 需要取左子树最小值与当前结点的最小值。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 需要取右子树最大值与当前结点的最大值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Range(Math.min(l.min, root.val),\n</div></li><li><div class=\"code-word\">                    Math.max(r.max, root.val));\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isValidBST</span><span class=\"hljs-params\">(TreeNode root)</span> </span>{\n</div></li><li><div class=\"code-word\">    ans = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    postOrder(root);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8210\">\n                      <p data-nodeid=\"8211\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9516\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9520\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9524\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8212\">\n                      <strong data-nodeid=\"9529\">复杂度分析</strong\n                      >：时间复杂度为 O(n)，空间复杂度为 O(H)，其中 H\n                      表示树的高度。\n                    </p>\n                    <p data-nodeid=\"8213\">\n                      【<strong data-nodeid=\"9535\">小结</strong\n                      >】写完代码之后，我们来看一下这道题的考点：\n                    </p>\n                    <ul data-nodeid=\"8214\">\n                      <li data-nodeid=\"8215\">\n                        <p data-nodeid=\"8216\">拿到子树的区间</p>\n                      </li>\n                      <li data-nodeid=\"8217\">\n                        <p data-nodeid=\"8218\">\n                          利用子树的区间，整合出整棵树的区间\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8219\">\n                        <p data-nodeid=\"8220\">如何处理空结点</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8221\">\n                      我们可以把这些知识点浓缩一下，方便我们以后复习，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8222\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtiyAGHC7AACr9Dp8WWE577.png\"\n                        alt=\"Drawing 25.png\"\n                        data-nodeid=\"9542\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8223\">\n                      如果我们再深入思考一下，就会发现，后序遍历的时候有个<strong\n                        data-nodeid=\"9556\"\n                        >特点</strong\n                      >：<strong data-nodeid=\"9557\">想要验证</strong\n                      >一棵树是否是二叉搜索树，后序遍历的<strong\n                        data-nodeid=\"9558\"\n                        >返回值</strong\n                      >却是整棵树的信息。\n                    </p>\n                    <p data-nodeid=\"8224\">这里画图来表示一下：</p>\n                    <p data-nodeid=\"8225\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtjaACs7TAABq6h1DLRQ985.png\"\n                        alt=\"Drawing 26.png\"\n                        data-nodeid=\"9562\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8226\">\n                      有点“<strong data-nodeid=\"9568\">项庄舞剑，意在沛公</strong\n                      >”的味道。那么我们再对后序遍历做一个小结，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8227\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtj6AF94_AAC54hdOUJs668.png\"\n                        alt=\"Drawing 27.png\"\n                        data-nodeid=\"9571\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8228\">\n                      完成总结后，我们再通过一道题目，加深对这个考点的理解。\n                    </p>\n                    <h4 data-nodeid=\"8229\">例 6：最低公共祖先</h4>\n                    <p data-nodeid=\"8230\">\n                      【<strong data-nodeid=\"9583\">题目</strong\n                      >】给定一棵二叉树，和两个在树上的结点，返回这两个结点的最低公共祖先。比如\n                      [5,3] 两个结点的最低公共祖先是结点 6。\n                    </p>\n                    <p data-nodeid=\"8231\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtkaAE0QsAADAh6zPbnk294.png\"\n                        alt=\"Drawing 28.png\"\n                        data-nodeid=\"9586\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8232\">\n                      【<strong data-nodeid=\"9600\">分析</strong\n                      >】这是一道来自<strong data-nodeid=\"9601\">微软</strong\n                      >的面试题。在面试时，注意面试官要求的是两个结点的<strong\n                        data-nodeid=\"9602\"\n                        >最低</strong\n                      >公共祖先。\n                    </p>\n                    <p data-nodeid=\"8233\">\n                      一个结点 x 如果是 p，q 的最低公共祖先，那么以结点 x\n                      为根的树，必然包含了 p，q 这<strong data-nodeid=\"9608\"\n                        >2</strong\n                      >个结点。并且只可能下面 2 种 Case。\n                    </p>\n                    <p data-nodeid=\"8234\">\n                      <strong data-nodeid=\"9613\">Case 1</strong>：两个结点 p，q\n                      分别在 x 的左边和右边。此时左子树会找到 1\n                      个结点，右子树会找到 1 个结点。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8235\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtlCAbdR9AARsIH_iZJY236.png\"\n                        alt=\"Drawing 29.png\"\n                        data-nodeid=\"9616\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8236\">\n                      Case 2：根结点为 q，另外一个结点 p\n                      在子树里，反之亦然。如下图所示：\n                    </p>\n                    <p data-nodeid=\"8237\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtlmAcMP0AAJsaaiXrk4163.png\"\n                        alt=\"Drawing 30.png\"\n                        data-nodeid=\"9620\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8238\">\n                      这里你可能会想，如果<strong data-nodeid=\"9626\"\n                        >左子树</strong\n                      >找到 2 个结点怎么办？比如下图展示的情况：\n                    </p>\n                    <p data-nodeid=\"8239\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/44/Cgp9HWBRtmKADj4gAAKGC_G6FjM242.png\"\n                        alt=\"Drawing 31.png\"\n                        data-nodeid=\"9629\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8240\">\n                      绿色结点发现左子树计数有两个结点，那么绿色结点肯定不是最低公共祖先，最低公共祖先应该是左子树，比如红色结点。说明在处理左子树时，已经找到了最低公共祖先。这种情况不需要做什么处理。\n                    </p>\n                    <p data-nodeid=\"8241\">\n                      我们再提取一下分析思路里的<strong data-nodeid=\"9636\"\n                        >关键信息</strong\n                      >。\n                    </p>\n                    <ul data-nodeid=\"8242\">\n                      <li data-nodeid=\"8243\">\n                        <p data-nodeid=\"8244\">\n                          最终想要的结论（<strong data-nodeid=\"9642\"\n                            >沛公</strong\n                          >）：找到二叉树里面的最低公共祖先。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8245\">\n                        <p data-nodeid=\"8246\">\n                          函数的返回值（<strong data-nodeid=\"9652\">项庄</strong\n                          >）：在当前子树中，<strong data-nodeid=\"9653\"\n                            >统计</strong\n                          >结点为 p，q 的个数。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8247\">\n                      此时，我们已经有了“<strong data-nodeid=\"9659\"\n                        >沛公，项庄</strong\n                      >”，就可以展开“鸿门宴”了。\n                    </p>\n                    <p data-nodeid=\"8248\">\n                      【<strong data-nodeid=\"9665\">画图</strong\n                      >】接下来通过一个实例先在一棵树上进行模拟，动图演示如下：\n                    </p>\n                    <p data-nodeid=\"8249\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtm-AabKNAAto4bxyLyY509.gif\"\n                        alt=\"10.gif\"\n                        data-nodeid=\"9668\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8250\">\n                      Step 1. 给定一棵二叉树，需要找到结点 5, 3\n                      的最低公共祖先。<strong data-nodeid=\"9674\"\n                        >后序遍历时，从最下层的结点开始逐层往上归纳信息</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8251\">\n                      Step 2. 最下层的结点为 3，统计数目为 1。\n                    </p>\n                    <p data-nodeid=\"8252\">\n                      Step 3. 接着处理倒数第二层，统计出当前子树里面结点为 [5,\n                      3] 的个数。\n                    </p>\n                    <p data-nodeid=\"8253\">\n                      Step 4. 处理倒数第 3 层，分别统计出结点 7, 9 里面结点为\n                      [5, 3] 的个数，[7, 9] 得到的统计值都为 1。\n                    </p>\n                    <p data-nodeid=\"8254\">\n                      Step 5. 处理结点 6，此时左结点统计值为 1，右子树统计值为\n                      1，那么最低公共祖先为结点 6。\n                    </p>\n                    <p data-nodeid=\"8255\" class=\"\">\n                      Step 6. 处理结点 11，此时统计值为\n                      2，但是由于右子树统计值已经是 2 了，那么结点 11\n                      不是最低公共祖先。\n                    </p>\n                    <p data-nodeid=\"8256\">\n                      【<strong data-nodeid=\"9697\">代码</strong\n                      >】至此，我们已经定义好了函数的返回值，也知道了利用子树的统计值处理前面提到的两种\n                      Case，进而得到真正的答案。代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">private</span> TreeNode ans = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 查看子结点的梳计个数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> lcnt = postOrder(root.left, p, q);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> rcnt = postOrder(root.right, p, q);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 利用子结点返回的信息来进行处理</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果左边有一个，右边有一个，那么当前root就是最低公共祖先</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (lcnt == <span class=\"hljs-number\">1</span> &amp;&amp; rcnt == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      ans = root;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (lcnt == <span class=\"hljs-number\">1</span> || rcnt == <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果左边找到一个，或者右边找到一个</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 并且我等于其中某一个结点p|q</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 那么当前root就是最低公共祖先</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (root == p || root == q) {\n</div></li><li><div class=\"code-word\">        ans = root;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 返回值为以root为根的子树, 统计里面的p,q结点的个数。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> lcnt + rcnt + ((root == p || root == q) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TreeNode <span class=\"hljs-title\">lowestCommonAncestor</span><span class=\"hljs-params\">(TreeNode root,\n</span></span></div></li><li><div class=\"code-word\">                              TreeNode p, TreeNode q) {\n</div></li><li><div class=\"code-word\">    ans = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">    postOrder(root, p, q);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"8258\">\n                      <p data-nodeid=\"8259\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9701\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9705\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9709\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8260\">\n                      <strong data-nodeid=\"9714\">复杂度分析</strong\n                      >：时间复杂度为 O(N)，空间复杂度为 O(H)，H 为树的高度。\n                    </p>\n                    <p data-nodeid=\"8261\">\n                      【<strong data-nodeid=\"9720\">小结</strong\n                      >】就这道题来说，考点为：\n                    </p>\n                    <ul data-nodeid=\"8262\">\n                      <li data-nodeid=\"8263\">\n                        <p data-nodeid=\"8264\">\n                          定义函数的返回值为统计结点 p，q 的个数;\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8265\">\n                        <p data-nodeid=\"8266\">\n                          利用子树返回的结点个数，得到想要的最低公共祖先。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8267\">\n                      如果仔细思考一下，这道题还可以用前序遍历的方法来解决。你能思考一下吗？\n                    </p>\n                    <blockquote data-nodeid=\"8268\">\n                      <p data-nodeid=\"8269\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9727\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9731\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9735\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8270\">\n                      <strong data-nodeid=\"9740\">思考题</strong\n                      >：我们再把这道题从广度和深度上进行展开：\n                    </p>\n                    <p data-nodeid=\"8271\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtoqAPZ6tAADozszBVY4858.png\"\n                        alt=\"Drawing 33.png\"\n                        data-nodeid=\"9743\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8272\">\n                      虽然我们只介绍了两个结点的后序遍历解法，但你也可以开阔思路来试一下多叉树的题目。\n                    </p>\n                    <p data-nodeid=\"8273\">\n                      我们再归纳一下<strong data-nodeid=\"9754\"\n                        >后序遍历的思路</strong\n                      >，可以<strong data-nodeid=\"9755\"\n                        >总结为 8 个字“项庄舞剑，意在沛公”</strong\n                      >，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8274\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtpGAUxzZAADV23ElNds459.png\"\n                        alt=\"Drawing 34.png\"\n                        data-nodeid=\"9758\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"8275\">\n                      <li data-nodeid=\"8276\">\n                        <p data-nodeid=\"8277\">\n                          子树的信息：即如何定义函数的返回值。可以巧妙记为“项庄是谁？”。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8278\">\n                        <p data-nodeid=\"8279\">\n                          信息的处理：如何利用子树返回的信息，得到我们最终想要的结论，可以巧妙地记为“如何得到沛公？”。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"8280\">总结与延伸</h3>\n                    <p data-nodeid=\"8281\">\n                      经过前面几讲的学习，我们马上就要和二叉树说再见了，回到知识层面，我再把本讲重点介绍，且需要你掌握的内容总结在一张思维导图中，如下图所示：\n                    </p>\n                    <p data-nodeid=\"8282\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtp2ACQ-ZAAKKPaNyzjs632.png\"\n                        alt=\"Drawing 35.png\"\n                        data-nodeid=\"9765\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8283\">\n                      除去知识的扩展，你还要学会浓缩和简化，抓住三种遍历的核心。我同样为你总结了一张思维导图：\n                    </p>\n                    <p data-nodeid=\"8284\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtqWAL6DXAADFeBomwio444.png\"\n                        alt=\"Drawing 36.png\"\n                        data-nodeid=\"9769\"\n                      />\n                    </p>\n                    <p data-nodeid=\"8285\">\n                      除去介绍知识本身，这里我重点介绍了“我是如何通过三种遍历搞定所有的二叉树的题目”。由于篇幅的限制，关于“树”的介绍就要到这里。今天所讲的内容只是一引子，期待你还能发现更多树的特点和巧妙用法。欢迎在评论区和我交流，期待看到大家的奇思妙想。\n                    </p>\n                    <h3 data-nodeid=\"8286\">思考题</h3>\n                    <p data-nodeid=\"8287\">\n                      我再给你留一道<strong data-nodeid=\"9777\">思考题</strong\n                      >：给定一个二叉树的前序遍历和中序遍历，请构建出这棵二叉树。\n                    </p>\n                    <p data-nodeid=\"8288\">\n                      输入：pre = [2,1,3], mid = [1, 2, 3]\n                    </p>\n                    <p data-nodeid=\"8289\">\n                      输出：返回二叉树根结点 [2]，左子结点为 1，右子结点为3.\n                    </p>\n                    <blockquote data-nodeid=\"8290\">\n                      <p data-nodeid=\"8291\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9794\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9798\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"9802\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"8292\" class=\"\">\n                      你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。下一讲将介绍\n                      0<strong data-nodeid=\"9810\"\n                        >7 |\n                        并查集，如何利用两行代码完成并查集的解题技巧</strong\n                      >？让我们一起前进。\n                    </p>\n            "}