{"title":"17&nbsp;| 深度思考子集：如何掌握 5 种通用解法？","context":"\n                    <p data-nodeid=\"3681\" class=\"\">\n                      今天我会带你深度思考子集，介绍掌握 5 种通用解法。\n                    </p>\n                    <p data-nodeid=\"3682\">\n                      不知道你对子集问题是否还有印象，我们曾在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"3901\"\n                        >12 | 回溯：我把回溯总结成一个公式，回溯题一出就用它</a\n                      >”，花了大量篇幅深入讨论过子集相关的问题。但当时的思路是已经知道了解题方法，然后再对题目实施“精确制导的定向爆破”。\n                    </p>\n                    <p data-nodeid=\"3683\">\n                      但是，子集问题的解法就只有回溯吗？我们是否还可以继续深挖题目给予的信息？在这个“一题多解”的模块里面，我们需要重新审视子集问题，比如看一看：\n                    </p>\n                    <ul data-nodeid=\"3684\">\n                      <li data-nodeid=\"3685\">\n                        <p data-nodeid=\"3686\">能否挖掘出更多的信息？</p>\n                      </li>\n                      <li data-nodeid=\"3687\">\n                        <p data-nodeid=\"3688\">\n                          能不能匹配到更多的算法和数据结构？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3689\">\n                        <p data-nodeid=\"3690\">能不能找到更多有趣的解法。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3691\">\n                      下面请你带着以上三个问题，开启今天的探索旅程。\n                    </p>\n                    <h3 data-nodeid=\"3692\">题目</h3>\n                    <p data-nodeid=\"3693\">\n                      首先，子集问题实际上包含两类问题。下面我们通过两个题目详细介绍一下。\n                    </p>\n                    <p data-nodeid=\"3694\">\n                      【<strong data-nodeid=\"3915\">题目 1</strong\n                      >】给你一个整数数组 nums\n                      ，数组中的元素互不相同。返回该数组所有可能的子集。\n                    </p>\n                    <p data-nodeid=\"3695\">\n                      解集<strong data-nodeid=\"3925\">不能</strong\n                      >包含重复的子集。你可以按<strong data-nodeid=\"3926\"\n                        >任意顺序</strong\n                      >返回解集。\n                    </p>\n                    <p data-nodeid=\"3696\">\n                      <strong data-nodeid=\"3930\">示例 1</strong>\n                    </p>\n                    <p data-nodeid=\"3697\">输入：nums = [1,2,3]</p>\n                    <p data-nodeid=\"3698\">\n                      输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n                    </p>\n                    <p data-nodeid=\"3699\">\n                      【<strong data-nodeid=\"3985\">题目 2</strong\n                      >】给你一个整数数组 nums ，其中<strong data-nodeid=\"3986\"\n                        >可能包含重复</strong\n                      >元素，请你返回该数组所有可能的子集。解集<strong\n                        data-nodeid=\"3987\"\n                        >不能</strong\n                      >包含重复的子集。返回的解集中，子集可以按<strong\n                        data-nodeid=\"3988\"\n                        >任意顺序</strong\n                      >排列。\n                    </p>\n                    <p data-nodeid=\"3700\">\n                      <strong data-nodeid=\"3992\">示例 1</strong>\n                    </p>\n                    <p data-nodeid=\"3701\">输入：nums = [1,2,2]</p>\n                    <p data-nodeid=\"3702\">\n                      输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n                    </p>\n                    <p data-nodeid=\"3703\">\n                      注：在后文中，我们将分别用题目 1、题目 2\n                      来引用这两个题目。\n                    </p>\n                    <p data-nodeid=\"3704\">\n                      声明：对于这个题目，在最差情况下，时间复杂度都是\n                      O(N2<sup>N</sup>)。不算返回值的情况下，空间复杂度为\n                      O(N)（BFS 的空间复杂度会到\n                      O(2<sup>N</sup>)）。因此，后面的代码不会再对时间复杂度和空间复杂度做特别的声明。\n                    </p>\n                    <h3 data-nodeid=\"3705\">通用方法 1：回溯</h3>\n                    <p data-nodeid=\"3706\">\n                      首先，因为题目中已经说明了，数组中的每个元素都是不相同的，因此题目\n                      1 不涉及去重。我们在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"4036\"\n                        >第 12 讲</a\n                      >”中利用“回溯法：一个核心，三个条件”写过题目 1\n                      的回溯代码。关于这种方法，不再做过多的叙述，你可以参考如下代码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">append</span><span class=\"hljs-params\">(List&lt;Integer&gt; box, List&lt;List&lt;Integer&gt;&gt; all)</span> </span>{\n</div></li><li><div class=\"code-word\">  all.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (Integer x : box) {\n</div></li><li><div class=\"code-word\">    all.get(all.size() - <span class=\"hljs-number\">1</span>).add(x);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">backTrace</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A,\n</span></span></div></li><li><div class=\"code-word\">               <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-comment\">/*第i个人的选择范围[start, N)*/</span>\n</div></li><li><div class=\"code-word\">               List&lt;Integer&gt; box,\n</div></li><li><div class=\"code-word\">               List&lt;List&lt;Integer&gt;&gt; all) {\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 公布当前箱子的状态</span>\n</div></li><li><div class=\"code-word\">  append(box, all);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果我是最后一个人，并且没有东西给我选了</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 那么原样返回箱子</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (start &gt;= N) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 我还是有宝石可以选择的。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = start; j &lt; N; j++) {\n</div></li><li><div class=\"code-word\">    box.add(A[j]);\n</div></li><li><div class=\"code-word\">    backTrace(A, j + <span class=\"hljs-number\">1</span>, box, all);\n</div></li><li><div class=\"code-word\">    box.remove(box.size() - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"hljs-keyword\">int</span>[] A) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  List&lt;Integer&gt; box = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">  List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">  backTrace(A, <span class=\"hljs-number\">0</span>, box, ans);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> ans;\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3708\">\n                      <p data-nodeid=\"3709\">\n                        代码:<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/78.%E5%AD%90%E9%9B%86.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4041\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/78.%E5%AD%90%E9%9B%86.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4045\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/78.%E5%AD%90%E9%9B%86.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4049\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3710\">\n                      可以看到，题目 2 与题目 1 有一点不同：\n                    </p>\n                    <blockquote data-nodeid=\"3711\">\n                      <p data-nodeid=\"3712\">\n                        题目 2\n                        给定的数组可能存在重复元素，因此，还需要对子集进行去重。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3713\">\n                      接下来我们讨论题目 2 中涉及的去重问题。\n                    </p>\n                    <p data-nodeid=\"3714\">\n                      当时，我们采用“<strong data-nodeid=\"4058\"\n                        >排序 + 判断元素是否出现过</strong\n                      >”的方法进行去重。经过优化后的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">append</span><span class=\"hljs-params\">(List&lt;Integer&gt; box,\n</span></span></div></li><li><div class=\"code-word\">                      List&lt;List&lt;Integer&gt;&gt; ans) {\n</div></li><li><div class=\"code-word\">    ans.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (Integer x : box) {\n</div></li><li><div class=\"code-word\">      ans.get(ans.size() - <span class=\"hljs-number\">1</span>).add(x);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">backtrace</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A,\n</span></span></div></li><li><div class=\"code-word\">                         <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-comment\">/*第i个人的选择范围(start, N)*/</span>\n</div></li><li><div class=\"code-word\">                         List&lt;Integer&gt; box,\n</div></li><li><div class=\"code-word\">                         List&lt;List&lt;Integer&gt;&gt; ans)\n</div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">      append(box, ans);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 已经没得选了</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (start &gt;= N) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = start; j &lt; N; j++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (j &gt; start &amp;&amp; A[j] == A[j-<span class=\"hljs-number\">1</span>]) <span class=\"hljs-keyword\">continue</span>;\n</div></li><li><div class=\"code-word\">        box.add(A[j]);\n</div></li><li><div class=\"code-word\">        backtrace(A, j + <span class=\"hljs-number\">1</span>, box, ans);\n</div></li><li><div class=\"code-word\">        box.remove(box.size()-<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class=\"hljs-keyword\">int</span>[] A) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">      List&lt;Integer&gt; box = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">      List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (N &lt;= <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      Arrays.sort(A);\n</div></li><li><div class=\"code-word\">      backtrace(A, <span class=\"hljs-number\">0</span>, box, ans);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3716\">\n                      <p data-nodeid=\"3717\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/90.%E5%AD%90%E9%9B%86-ii.2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4062\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/90.%E5%AD%90%E9%9B%86-ii.2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4066\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/90.%E5%AD%90%E9%9B%86-ii.2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4070\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3718\">\n                      其实，这是一道非常经典的题目，我们可以从不同角度思考这个题目，进而得到不同的解法。\n                    </p>\n                    <h3 data-nodeid=\"3719\">通用方法 2：BFS</h3>\n                    <p data-nodeid=\"3720\">\n                      既然可以利用回溯（可以认为回溯是某种形式的\n                      DFS），那么应该也可以尝试往 BFS\n                      方向思考。因为大部分时候，DFS 的代码都可以改写为 BFS\n                      的代码，\n                    </p>\n                    <p data-nodeid=\"3721\">\n                      题目 1 不需要考虑去重的问题。我们可以假设数组为 A[] = {1,\n                      2, 3}，那么可以进行如下的操作（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">cur = {{}}; <span class=\"hljs-comment\">// 一开始我只有一个空集</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> x in A:\n</div></li><li><div class=\"code-word\">    tmp = {};\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> subset in cur: <span class=\"hljs-comment\">// 复制当前已有的子集subset</span>\n</div></li><li><div class=\"code-word\">        subset.add(x)  <span class=\"hljs-comment\">// 把数组中元素x加到子集中</span>\n</div></li><li><div class=\"code-word\">        tmp.add(subset)<span class=\"hljs-comment\">// 把更新后的subset放到tmp中。</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> subset in tmp:\n</div></li><li><div class=\"code-word\">        cur.add(subset)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> cur\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3723\">\n                      不过，我们也要注意到，这里在进行 BFS 的时候，与常规的 BFS\n                      不太一样。\n                    </p>\n                    <blockquote data-nodeid=\"3724\">\n                      <p data-nodeid=\"3725\">\n                        BFS 的方法有两种，一种是使用\n                        Queue，另一种是使用“两段击”。这里我们指的是两段击。<br />\n                        如果你忘了什么是“两段击”，那么快去看一下“<a\n                          href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4086\"\n                          >02 | 队列：FIFO 队列与单调队列的深挖与扩展</a\n                        >”。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3726\">\n                      常规的 BFS 流程如下（我们<strong data-nodeid=\"4093\"\n                        >聚焦</strong\n                      >于 BFS 的一轮迭代）：\n                    </p>\n                    <p data-nodeid=\"3727\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/1C/CioPOWCChpeATCyQAABtL-4I4AU783.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"4096\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3728\">\n                      我们发现，进行 BFS 的时候，在生成 next\n                      之后，并不是直接赋值给 cur，而是采用了 cur +\n                      next。这里我建议你花点时间完成下面两道常规 BFS\n                      的练习题，巩固一下 BFS 的知识。\n                    </p>\n                    <p data-nodeid=\"3729\">\n                      <strong data-nodeid=\"4102\">练习题 1</strong\n                      >：从上到下按层打印二叉树，同一层结点按照从左到右的顺序打印，每一层打印到一行。\n                    </p>\n                    <blockquote data-nodeid=\"3730\">\n                      <p data-nodeid=\"3731\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/02.Queue/01.TreeLevelOrder.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4106\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/02.Queue/01.TreeLevelOrder.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4110\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/02.Queue/01.TreeLevelOrder.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4114\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3732\">\n                      <strong data-nodeid=\"4119\">练习题 2</strong>：有 n\n                      个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w\n                      抵达 v。现在给定所有的城市和航班，以及出发城市 src\n                      和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k\n                      站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。\n                    </p>\n                    <p data-nodeid=\"3733\">\n                      输入：n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src =\n                      0, dst = 2, k = 1\n                    </p>\n                    <p data-nodeid=\"3734\">输出：200</p>\n                    <p data-nodeid=\"3735\">城市航班图如下：</p>\n                    <p data-nodeid=\"3736\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChp6Ab6B3AAB6kPgo4wQ968.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"4139\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3737\">\n                      从城市 0 到城市 2 在 1 站中转的最便宜价格是\n                      200，如上图中红色所示：\n                    </p>\n                    <blockquote data-nodeid=\"3738\">\n                      <p data-nodeid=\"3739\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/787.k-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4144\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/787.k-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4148\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/787.k-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4152\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3740\">\n                      既然我们已经知道子集的 BFS 的程序框架了，针对题目\n                      1，可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"hljs-keyword\">int</span>[] nums) {\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; cur = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// cur里面会有一个空集</span>\n</div></li><li><div class=\"code-word\">        cur.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; next = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x: nums) {\n</div></li><li><div class=\"code-word\">            next.clear();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; subset: cur) {\n</div></li><li><div class=\"code-word\">                List&lt;Integer&gt; newSubset = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(subset);\n</div></li><li><div class=\"code-word\">                newSubset.add(x);\n</div></li><li><div class=\"code-word\">                next.add(newSubset);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// cur = cur + next;</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; newSubset: next) {\n</div></li><li><div class=\"code-word\">                cur.add(newSubset);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> cur;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3742\">\n                      <p data-nodeid=\"3743\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.BFS.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4157\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4161\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.BFS.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4165\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3744\">\n                      当<strong data-nodeid=\"4178\">题目 1</strong\n                      >解决之后，我们再来看一下能不能用同样的BFS 方法解决<strong\n                        data-nodeid=\"4179\"\n                        >题目 2</strong\n                      >。假设 A[] = {1,2,2}。看看是否会出现什么问题，步骤如下：\n                    </p>\n                    <p data-nodeid=\"3745\">Step 1. 一开始 cur = [{}]；</p>\n                    <p data-nodeid=\"3746\">\n                      Step 2. 当加入元素 1，生成 next = [{1}]；\n                    </p>\n                    <p data-nodeid=\"3747\">\n                      Step 3. cur = cur + next = [{}, {1}]；\n                    </p>\n                    <p data-nodeid=\"3748\">\n                      Step 4. 再加入元素 2，生成 next = [{2}, {1,2}]；\n                    </p>\n                    <p data-nodeid=\"3749\">\n                      Step 5. cur = cur + next = [{}, {1}, {2}, {1,2}]；\n                    </p>\n                    <p data-nodeid=\"3750\">\n                      Step 6. 再加入元素 2，生成 next = [{2}, {1,2}, {2,2},\n                      {1,2,2}]；\n                    </p>\n                    <p data-nodeid=\"3751\">\n                      Step 7. 最后执行cur = cur + next = [{}, {1}, {2},\n                      {1,2},{2}, {1,2}, {2,2}, {1,2,2}]。\n                    </p>\n                    <p data-nodeid=\"3752\">\n                      我们发现，如果还是沿用题目 1 的 BFS\n                      方法，会在最终解中<strong data-nodeid=\"4220\"\n                        >产生重复的子集</strong\n                      >。那么，有没有办法去除这些重复的子集？\n                    </p>\n                    <p data-nodeid=\"3753\">\n                      下面我们需要追踪一下这些重复元素是如何生成的，可以画出下图：\n                    </p>\n                    <p data-nodeid=\"3754\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCChqiAdm7xAADFwWCKF6U657.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"4224\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3755\">\n                      重复元素 [{2}, {1,2}] 是由 [{}, {1}] 加入元素 2\n                      后生成的。重复的元素分别是在 Step 4 和 Step 6\n                      生成的，如下图所示：\n                    </p>\n                    <p data-nodeid=\"3756\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/14/Cgp9HWCChq-AbWGFAACfXWp9Low360.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"4236\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3757\">\n                      因此，在更新的时候，应该要注意，如果一些元素，比如 [{},\n                      {1}] 已经被元素 2 更新过了。那么后面就不应该再去更新了。\n                    </p>\n                    <p data-nodeid=\"3758\">此时，我们应该可以写出伪代码了：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">cur = [{}]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> x in A:\n</div></li><li><div class=\"code-word\">    next = []\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> subset in cur:\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-title\">updated</span><span class=\"hljs-params\">(subset, x)</span> </span>== False:\n</div></li><li><div class=\"code-word\">            next.add(subset.clone().add(x))\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> newSubset in next:\n</div></li><li><div class=\"code-word\">        cur.add(newSubset)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> cur\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3760\">\n                      现在问题的重点在于：如何完成 updated(subset, x)\n                      的检查。我们发现可以按照下图这样的方式操作：\n                    </p>\n                    <p data-nodeid=\"3761\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/1D/CioPOWCChs6ASdvfAAY7y-x_0T0475.gif\"\n                        alt=\"3.gif\"\n                        data-nodeid=\"4246\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3762\">\n                      通过上述分析， 我们可以总结出如下结论：\n                    </p>\n                    <ul data-nodeid=\"3763\">\n                      <li data-nodeid=\"3764\">\n                        <p data-nodeid=\"3765\">\n                          如果加入的元素与前面加入的元素一样，那么只需要更新“<strong\n                            data-nodeid=\"4253\"\n                            >新增的部分</strong\n                          >”；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3766\">\n                        <p data-nodeid=\"3767\">\n                          为了同时达到，就需要与前面一轮的元素进行比较，并且记住前面新增的部分。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3768\">也就是说，我们需要做两个事情：</p>\n                    <ul data-nodeid=\"3769\">\n                      <li data-nodeid=\"3770\">\n                        <p data-nodeid=\"3771\">\n                          对数组排序，排序之后，我们总是可以很容易得出与前面一轮的元素是否相等；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3772\">\n                        <p data-nodeid=\"3773\">\n                          记住前面新增的部分，我们只需要每次<strong\n                            data-nodeid=\"4262\"\n                            >更新之前</strong\n                          >，记录一下 cur 的 size 就可以了。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3774\">\n                      基于这两点，可以写出题目 2 的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class=\"hljs-keyword\">int</span>[] nums) {\n</div></li><li><div class=\"code-word\">        Arrays.sort(nums);\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; cur = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// cur里面会有一个空集</span>\n</div></li><li><div class=\"code-word\">        cur.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; next = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 前面用来更新的元素的值</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> pre = Integer.MAX_VALUE;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 在利用pre元素更新之前</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// cur里面item的个数</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 注意：是利用pre更新之前，不是pre更新之后的元素的个数!</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> beforePreUpdateSize = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> curValue: nums) {\n</div></li><li><div class=\"code-word\">            next.clear();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 在更新之前，我们需要判断一下，是从cur的哪里开始更新</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 正常情况下，都是从cur[0]开始更新</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> startUpdatePos = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果与pre值相等</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (curValue == pre) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 那么在更新的时候，需要从beforePreUpdateSize这里开始更新。</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 因为[0, ...., beforePreUpdateSize)这部分内容</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 肯定已经被等于pre的值给更新过了</span>\n</div></li><li><div class=\"code-word\">                startUpdatePos = beforePreUpdateSize;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = startUpdatePos; i &lt; cur.size(); i++) {\n</div></li><li><div class=\"code-word\">                List&lt;Integer&gt; newSubset = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(cur.get(i));\n</div></li><li><div class=\"code-word\">                newSubset.add(curValue);\n</div></li><li><div class=\"code-word\">                next.add(newSubset);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 记录一下更新前的大小</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> beforeCurValueUpdateSize = cur.size();\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; subset: next) {\n</div></li><li><div class=\"code-word\">                cur.add(subset);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 更新一下大小的情况</span>\n</div></li><li><div class=\"code-word\">            beforePreUpdateSize = beforeCurValueUpdateSize;\n</div></li><li><div class=\"code-word\">            pre = curValue;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> cur;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3776\">\n                      <p data-nodeid=\"3777\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4267\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4271\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4275\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3778\">\n                      【<strong data-nodeid=\"4281\">小结</strong\n                      >】我们不妨将用到的 BFS\n                      进行比较，通过比较它们之间的异同，有助于梳理知识点里面的考点（红色部分是变更之后的考点）。\n                    </p>\n                    <p data-nodeid=\"3779\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/1D/CioPOWCChtmACSQgAAByLMtH9fw534.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"4284\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3780\">\n                      我们发现，题目 1 与题目 2 无非就是在原始的 BFS\n                      上不停地更改 BFS 的条件，然后就出现了新的题型与考点。\n                    </p>\n                    <p data-nodeid=\"3781\">\n                      这里我再给你留一个练习题，通过这些练习，可以和我们以前学习过的知识产生联动，让你对题目、知识点的理解更加深刻。\n                    </p>\n                    <p data-nodeid=\"3782\">\n                      <strong data-nodeid=\"4299\">练习题 3</strong>：在学习“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"4293\"\n                        >第 12 讲</a\n                      >”回溯中例 4 的时候，也讲到了题目\n                      2。在那里，我们同样用到了去重的技巧，并且也用到了排序。那么请问，“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"4297\"\n                        >第 12 讲</a\n                      >”中用到的排序和这里 BFS 的排序的目的有什么异同点？\n                    </p>\n                    <p data-nodeid=\"3783\">\n                      <strong data-nodeid=\"4310\">练习题 4</strong>：题目 2\n                      在进行 BFS 的时候，采用了使用部分 cur\n                      里面的元素来进行更新，并且生成 next 的办法。我们在讲解“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"4308\"\n                        >11 | 贪心：这种思想，没有模板，如何才能掌握它？</a\n                      >”贪心算法例 3“青蛙跳”的时候，曾说过可以采用类似 BFS\n                      的方法进行思考。那么题目 2 和“青蛙跳”有什么异同呢？\n                    </p>\n                    <h3 data-nodeid=\"3784\">通用方法 3：选与不选</h3>\n                    <p data-nodeid=\"3785\">\n                      现在我们换一种思路来看这个题目：生成一个子集的时候，对于一个元素而言，就只有选与不选两种选择。如果用二进制\n                      bit，0 表示选中，1 表示没有选中。\n                    </p>\n                    <p data-nodeid=\"3786\">\n                      那么对于一个有 n\n                      个元素的数组，可以用一个二进制串表示一个子集。比如空集就是所有的二进制\n                      bit 都是 0。\n                    </p>\n                    <p data-nodeid=\"3787\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChuGAZqi8AAChWwRZV6U128.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"4316\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3788\">\n                      比如，我们还可以用 b0110 表示子集 {A[1],\n                      A[2]}。那么现在你应该明白，针对四个元素的子集，可以按照\n                      [0, ~ b1111] 顺序遍历，然后依次遍历二进制串的每一位，通过\n                      bit 0/1 决定是否需要把相应的元素放到集合中。\n                    </p>\n                    <p data-nodeid=\"3789\">\n                      通过这种思路，我们可以写出<strong data-nodeid=\"4337\"\n                        >题目 1</strong\n                      >的代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"hljs-keyword\">int</span>[] nums) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = nums == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : nums.length;\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; (<span class=\"hljs-number\">1</span>&lt;&lt;N); i++) {\n</div></li><li><div class=\"code-word\">            List&lt;Integer&gt; subset = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 看一下哪些元素会被选择</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; j++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 如果要选择nums[j]</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mask = <span class=\"hljs-number\">1</span> &lt;&lt; j;\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> ((i &amp; mask) != <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">                    subset.add(nums[j]);\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 然后把tmp 加到 ans里面 </span>\n</div></li><li><div class=\"code-word\">            ans.add(subset);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3791\">\n                      <p data-nodeid=\"3792\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.binary.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4341\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.binary.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4345\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.binary.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4349\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3793\">\n                      学完这种解法之后，我们会发现和“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6703&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"4355\"\n                        >14 | DP：我是怎么治好‘DP 头痛症’的？</a\n                      >”里面的状态压缩有非常类似的地方：\n                    </p>\n                    <blockquote data-nodeid=\"3794\">\n                      <ol data-nodeid=\"3795\">\n                        <li data-nodeid=\"3796\">\n                          <p data-nodeid=\"3797\">\n                            都是用 0/1 bit 位来表示一个元素的选中和不选中；\n                          </p>\n                        </li>\n                        <li data-nodeid=\"3798\">\n                          <p data-nodeid=\"3799\">\n                            都是用一个整数来表示一个集合的状态。\n                          </p>\n                        </li>\n                      </ol>\n                    </blockquote>\n                    <p data-nodeid=\"3800\">\n                      题目 1 解决之后，我们接下来看一下<strong\n                        data-nodeid=\"4367\"\n                        >题目 2</strong\n                      >。如果仍然采用这种方法，可能会面临一个问题。对于给定数组\n                      A[] = {1,2,2,2}。如下图所示：\n                    </p>\n                    <p data-nodeid=\"3801\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChvGAQ8GAAACmdtVGGo0109.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"4370\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3802\">\n                      虽然用了两个不同的二进制串，但是会导致它们映射到同样的子集。因此，也就存在重复的可能性。那么，有没有什么办法可以去重呢？\n                    </p>\n                    <p data-nodeid=\"3803\">\n                      我们接着来看下面这个例子。对于数组 A[] =\n                      {1,2,2,2,2}，可以发现有些二进制串实际上是等价的。比如只选中一个\n                      1 的时候，如下图所示：\n                    </p>\n                    <p data-nodeid=\"3804\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChviAf9KNAAFHgJCoZvU511.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"4378\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3805\">\n                      例 2：只选择 2 个 2 到子集里面的时候。如下图所示：<br />\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/1D/CioPOWCChv-AG6oSAAFVoOOh6qQ752.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"4383\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3806\">\n                      假设需要选择 x 个 2 出来，只需要数字 2 对应的位置 bit = 1\n                      的总数有 x 个就可以了。比如，以选择 2 个 2 为例，只需 2\n                      对应的位置有 2 个 bit=1 就可以了。\n                    </p>\n                    <p data-nodeid=\"3807\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChwaAefbdAAB7Y8WLUUY506.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"4387\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3808\">\n                      那么，在这些二进制串中，需要选择一个我们想要的数字出来。所以，现在问题的重点，就是<strong\n                        data-nodeid=\"4393\"\n                        >选谁</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"3809\">\n                      经过一系列挑选，我们<strong data-nodeid=\"4403\"\n                        >精心</strong\n                      >按照<strong data-nodeid=\"4404\">一定规则，即</strong\n                      >相同的数的 bit = 1，挑选了如下数组的所有二进制串：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 比如A[] = [1, 2, 2, 2, 2]</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  0  0  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  0  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  1  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  1  1  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  1  1  1</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  0  0  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  0  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  1  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  1  1  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  1  1  1</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3811\">\n                      也就是说，本质上我们是在具有重复含义的二进制串中选出了“代表”。比如下面这两个二进制串：\n                    </p>\n                    <p data-nodeid=\"3812\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChw6AT5_KAAETiNOj7Xs819.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"4408\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3813\">两个二进制串都表示往集合中添加：</p>\n                    <ul data-nodeid=\"3814\">\n                      <li data-nodeid=\"3815\">\n                        <p data-nodeid=\"3816\">1 个 1</p>\n                      </li>\n                      <li data-nodeid=\"3817\">\n                        <p data-nodeid=\"3818\">2 个 3</p>\n                      </li>\n                      <li data-nodeid=\"3819\">\n                        <p data-nodeid=\"3820\">2 个 4</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3821\">\n                      你可以观察上图中红色勾选的二进制串，上述选择规则有 2\n                      个条件。注意，这里的条件都是针对数组中值相同的元素：\n                    </p>\n                    <ul data-nodeid=\"3822\">\n                      <li data-nodeid=\"3823\">\n                        <p data-nodeid=\"3824\">\n                          对于数组中的相同的元素，选中的时候，bit 为 1\n                          时，都必须<strong data-nodeid=\"4419\">连</strong\n                          >在一起；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3825\">\n                        <p data-nodeid=\"3826\">\n                          对于数组中的相同的元素，bit 为 1 时，都必须靠<strong\n                            data-nodeid=\"4425\"\n                            >左边</strong\n                          >连续存放。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3827\">\n                      注意：这里的“靠左存放”不是靠整个二进制串的左边，而是靠着相同元素的左边界存放。如下图所示：\n                    </p>\n                    <p data-nodeid=\"3828\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChxeAQxZXAACagi2nfs8308.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"4429\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3829\">\n                      我们认为上图中相同元素 3 和元素 4 的 bit = 1\n                      都是靠其左边连续存放的。\n                    </p>\n                    <p data-nodeid=\"3830\">这里我给出一些示例，如下图所示：</p>\n                    <p data-nodeid=\"3831\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChx6AF3lnAAB7jvDEfhA419.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"4434\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3832\">\n                      例 1，满足条件 1，不满足条件 2。因为选中元素 2 的 bit = 1\n                      没有连续靠左存放。\n                    </p>\n                    <p data-nodeid=\"3833\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChyWACm9rAAB7k7a6eos642.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"4438\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3834\">\n                      例 2，不满足条件 1，也不满足条件 2，因为选中相同元素的 bit\n                      = 1 没有连续，也没有靠左存放。\n                    </p>\n                    <p data-nodeid=\"3835\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChyuAd3A7AAB4Cz6xpA8058.png\"\n                        alt=\"Drawing 15.png\"\n                        data-nodeid=\"4442\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3836\">\n                      例 3，满足条件 1，也满足条件 2。针对相同元素 3 的 bit = 1\n                      同时满足上面两个条件。\n                    </p>\n                    <p data-nodeid=\"3837\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCChzGAQNfYAAB_IwcBfBU453.png\"\n                        alt=\"Drawing 16.png\"\n                        data-nodeid=\"4446\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3838\">\n                      例 4，针对元素 3 的选择，同时满足两个条件。\n                    </p>\n                    <p data-nodeid=\"3839\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCChziACLWvAACesKL-RlQ770.png\"\n                        alt=\"Drawing 17.png\"\n                        data-nodeid=\"4450\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3840\">\n                      例 5，针对相同元素 3 和 4，其中元素 3 的 bit = 1\n                      满足两个条件，但是元素 4 的 bit 位不满足条件\n                      2。因此，这个二进制串也不满足两个条件。\n                    </p>\n                    <p data-nodeid=\"3841\">\n                      那么按照这个规则，在生成子集的同时，我们还要<strong\n                        data-nodeid=\"4457\"\n                        >检查一下二进制串是否满足条件 1 和条件 2</strong\n                      >。\n                    </p>\n                    <blockquote data-nodeid=\"3842\">\n                      <p data-nodeid=\"3843\">\n                        注意：这里只是为了方便写代码，所以采用这个规则来挑选二进制串，挑选二进制串的方法并不是唯一的，你也可以选择其他简便的方法。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3844\">\n                      经过前面的分析，我们可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class=\"hljs-keyword\">int</span>[] nums) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = nums == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : nums.length;\n</div></li><li><div class=\"code-word\">        Arrays.sort(nums);\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; (<span class=\"hljs-number\">1</span>&lt;&lt;N); i++) {\n</div></li><li><div class=\"code-word\">            List&lt;Integer&gt; subset = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 这里在检查每个bit的时候，还要带个逻辑</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 那就是如果值相同的时候，我们希望是有连续的1bit</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">boolean</span> validSubset = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 我们依次查看每个bit</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; j++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 如果当前值与之前的值是一样的。</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (j &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[j] == nums[j-<span class=\"hljs-number\">1</span>]) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 取出当前bit</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> curBit = i &amp; (<span class=\"hljs-number\">1</span>&lt;&lt;j);\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 取出之前一位bit</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> preBit = i &amp; (<span class=\"hljs-number\">1</span>&lt;&lt;(j-<span class=\"hljs-number\">1</span>));\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 如果当前位为1，但是之前位为0</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 这种情况是不允许的</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">if</span> (curBit != <span class=\"hljs-number\">0</span> &amp;&amp; preBit == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">                        validSubset = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">                        <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">                    }\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 如果这个bit为1，那么被选中</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> ((i &amp; (<span class=\"hljs-number\">1</span>&lt;&lt;j)) != <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">                    subset.add(nums[j]);\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (validSubset) {\n</div></li><li><div class=\"code-word\">                ans.add(subset);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3846\">\n                      <p data-nodeid=\"3847\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.binary.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4463\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.binary.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4467\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.binary.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4471\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"3848\">通用方法 4：以退为进</h3>\n                    <p data-nodeid=\"3849\">\n                      接下来，我们重点讨论一下题目 2。在题目 2\n                      去重的时候。如果我们再深入思考一下挑选二进制串的本质。不难发现，当数组为\n                      A[] = {1, 2, 2, 2, 2} 时，我们只是想往子集中加入 2\n                      的时候，分别往子集中添加：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 比如A[] = [1, 2, 2, 2, 2]</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  0  0  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  0  0  0 &lt;-- 加入1个2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  1  0  0 &lt;-- 加入2个2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  1  1  0 &lt;-- 加入3个2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      0  1  1  1  1 &lt;-- 加入4个2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  0  0  0  0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  0  0  0 &lt;-- 加入1个2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  1  0  0 &lt;-- 加入2个2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  1  1  0 &lt;-- 加入3个2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//      1  1  1  1  1 &lt;-- 加入4个2</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3851\">\n                      那么，我们有没有可能采用下面这种思路？\n                    </p>\n                    <p data-nodeid=\"3852\">\n                      首先记录数组中每个数出现的次数 hash[number] =\n                      count；接着，将数组中的元素去重。最后，当我们需要往子集中加入某个数的时候，只需要在题目\n                      1 的基础上做一点变动：\n                    </p>\n                    <blockquote data-nodeid=\"3853\">\n                      <p data-nodeid=\"3854\">\n                        选中某个数的时候，需要加入 1 个,2 个, ..., hash[number]\n                        个这样的数。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3855\">\n                      处理题目 2 的过程，实际上是先退回了题目 1（这里我们选中了\n                      BFS 算法），然后再在加入元素的次数上做了调整。\n                    </p>\n                    <p data-nodeid=\"3856\">\n                      通过这种思路，就可以写出题目 2 代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HashMap</span>&lt;<span class=\"hljs-title\">Integer</span>, <span class=\"hljs-title\">Integer</span>&gt; </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(Integer k)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> containsKey(k) ? <span class=\"hljs-keyword\">super</span>.get(k) : <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k, <span class=\"hljs-keyword\">int</span> v)</span> </span>{\n</div></li><li><div class=\"code-word\">        put(k, get(k) + v);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (get(k) &lt;= <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">            remove(k);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class=\"hljs-keyword\">int</span>[] nums) {\n</div></li><li><div class=\"code-word\">        Counter cnt = <span class=\"hljs-keyword\">new</span> Counter();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x: nums) {\n</div></li><li><div class=\"code-word\">            cnt.add(x, <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; cur = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        cur.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;Integer,Integer&gt; en: cnt.entrySet()) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// BFS的next</span>\n</div></li><li><div class=\"code-word\">            List&lt;List&lt;Integer&gt;&gt; next = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> addTimes = <span class=\"hljs-number\">1</span>; \n</div></li><li><div class=\"code-word\">                 addTimes &lt;= en.getValue(); addTimes++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 遍历cur中的每一个subset</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; subset: cur) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 生成新的subset</span>\n</div></li><li><div class=\"code-word\">                    List&lt;Integer&gt; newSubset = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(subset);\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 添加选中的数 addTimes次到集合中</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; addTimes; j++) {\n</div></li><li><div class=\"code-word\">                        newSubset.add(en.getKey());\n</div></li><li><div class=\"code-word\">                    }\n</div></li><li><div class=\"code-word\">                    next.add(newSubset);\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 将next放到cur中。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; subset: next) {\n</div></li><li><div class=\"code-word\">                cur.add(subset);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> cur;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3858\">\n                      <p data-nodeid=\"3859\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4493\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4497\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4501\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"3860\">通用方法 5：分治</h3>\n                    <p data-nodeid=\"3861\">\n                      首先我们看一下<strong data-nodeid=\"4511\">题目 1</strong\n                      >，如果给定的数组 A[] = {1,\n                      2}。实际上我们同然可以这样操作，得到所有的子集。\n                    </p>\n                    <blockquote data-nodeid=\"3862\">\n                      <p data-nodeid=\"3863\">\n                        分治算法总是可以画成二叉树的样子，所以这里我们借助二叉树来展示分治的过程。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3864\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/3B/15/Cgp9HWCCh0eATulfAAT7HVtlTIg477.gif\"\n                        alt=\"1.gif\"\n                        data-nodeid=\"4515\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3865\">\n                      基于这种思想，可以得到<strong data-nodeid=\"4521\"\n                        >题目 1</strong\n                      >分治的解法，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将两个合并成一个</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> List&lt;Integer&gt; <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(List&lt;Integer&gt; a, List&lt;Integer&gt; b)</span> </span>{\n</div></li><li><div class=\"code-word\">        List&lt;Integer&gt; tmp = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(a);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (Integer x: b) {\n</div></li><li><div class=\"code-word\">            tmp.add(x);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> tmp;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意：这里给的区间是左闭右开[b, e)</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> List&lt;List&lt;Integer&gt;&gt; dq(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e) {\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        ans.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        List&lt;Integer&gt; tmp = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (b + <span class=\"hljs-number\">1</span> == e) {\n</div></li><li><div class=\"code-word\">            tmp.add(nums[b]);\n</div></li><li><div class=\"code-word\">            ans.add(tmp);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果数组里面没有重复元素，那么只需要从中间切分开就可以了</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> mid = b + ((e-b)&gt;&gt;<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; l = dq(nums, b, mid);\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; r = dq(nums, mid, e);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 两两组合</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; x: l) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; y: r) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 由于我们已经在ans中存放了空集，所以如果遇到两个都是空集的时候</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 我们就不再进行merge</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (x.isEmpty() &amp;&amp; y.isEmpty()) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">continue</span>;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                ans.add(merge(x, y));\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"hljs-keyword\">int</span>[] nums) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = nums == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : nums.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> dq(nums, <span class=\"hljs-number\">0</span>, N);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3867\">\n                      <p data-nodeid=\"3868\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.dq.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4525\"\n                          >Jav</a\n                        ><a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4528\"\n                          >a/</a\n                        ><a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4531\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.dq.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4535\"\n                          >Python</a\n                        ><br />\n                        我们需要格外注意空集的处理，合并的时候，如果两个集合都是空集，就不要再加入返回值了。因为它们之前已经加入空集（代码\n                        13 行）了，重复加入会导致返回值中存在很多空集。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"3869\">\n                      那么，我们应该如何处理题目 2\n                      呢？如果仍然延续上述处理思路，在处理 A[] = {1, 2, 2, 2}\n                      的时候，就会遇到问题。\n                    </p>\n                    <p data-nodeid=\"3870\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCCh1SAOfdmABHxRZZnCOw782.gif\"\n                        alt=\"2.gif\"\n                        data-nodeid=\"4544\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3871\">\n                      那么，有没有办法解决冲突 1 和冲突 2 呢？\n                    </p>\n                    <p data-nodeid=\"3872\">\n                      首先来看<strong data-nodeid=\"4555\">冲突 1</strong\n                      >，产生冲突 1 的本质是因为，当数组已经被切分成 [2, 2]\n                      的时候，实际上可以直接通过计算 2 的个数来生成子集。这里有\n                      2 个 2，所以可以直接生成如下子集：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{},   <span class=\"hljs-number\">0</span>个<span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">{<span class=\"hljs-number\">2</span>},  <span class=\"hljs-number\">1</span>个<span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>} <span class=\"hljs-number\">2</span>个<span class=\"hljs-number\">2</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"3874\">\n                      也就是说，当数组里面的元素都是一样的时候，我们不能再进行切分。\n                    </p>\n                    <p data-nodeid=\"3875\">\n                      那么再查看<strong data-nodeid=\"4562\">冲突 2</strong\n                      >。产生冲突 2 的根本原因在于：元素 2\n                      分散在很多地方，每次合并的时候，都有可能生成重复的子集。在切分的时候，我们应该采用如下图所示的方法进行切分：\n                    </p>\n                    <p data-nodeid=\"3876\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCCh16AHJ7BAABqOFr59u8458.png\"\n                        alt=\"Drawing 20.png\"\n                        data-nodeid=\"4565\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3877\">那么，这里可以总结为两个原则。</p>\n                    <ul data-nodeid=\"3878\">\n                      <li data-nodeid=\"3879\">\n                        <p data-nodeid=\"3880\">\n                          原则\n                          1：当范围里面的数都是一样的时候，不能切分，而是采用计数的原则来生成子集。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"3881\">\n                        <p data-nodeid=\"3882\">\n                          原则 2：相同的数，不能被切分开，而是要当成一个整体。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"3883\">\n                      基于这两个原则，我们就可以写出题目 2\n                      的分治的代码了，如下所示（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将两个合并成一个</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> List&lt;Integer&gt; <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(List&lt;Integer&gt; a, List&lt;Integer&gt; b)</span> </span>{\n</div></li><li><div class=\"code-word\">        List&lt;Integer&gt; tmp = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(a);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (Integer x: b) {\n</div></li><li><div class=\"code-word\">            tmp.add(x);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> tmp;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 查看这段区域里面的值是不是都是一样的</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isSame</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">boolean</span> same = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = b; i &lt; e; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (nums[i] != nums[b]) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注意：这里给的区间是左闭右开[b, e)</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> List&lt;List&lt;Integer&gt;&gt; dq(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> b, <span class=\"hljs-keyword\">int</span> e) {\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        ans.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (b &gt;= e) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果整段区间里面的值都是一样的</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 那么在选择的时候，只有e - b种情况</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 比如有[2, 2]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 那么这里会添加子集</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// - [2]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// - [2, 2]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 使用原则1：</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">boolean</span> same =isSame(nums, b, e);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (same) {\n</div></li><li><div class=\"code-word\">            List&lt;Integer&gt; tmp = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = b; i &lt; e; i++) {\n</div></li><li><div class=\"code-word\">                tmp.add(nums[i]);\n</div></li><li><div class=\"code-word\">                ans.add(<span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(tmp));\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果数组里面没有重复元素，那么只需要从中间切分开就可以了</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> mid = b + ((e-b)&gt;&gt;<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 接下来是使用原则2：要让所有相同的数，必须要当成一个整体</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 不能被切散了</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> l = mid - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (l &gt;= b &amp;&amp; nums[l] == nums[mid]) {\n</div></li><li><div class=\"code-word\">            l--;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> r = mid;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (r &lt; e &amp;&amp; nums[r] == nums[mid]) {\n</div></li><li><div class=\"code-word\">            r++;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 正常情况下，我们切分点都选择 r</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> cutPos = r;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 但是如果右边[r, e)这个区间已经没有数了</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (r &gt;= e) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 我们需要把(l, r)这个区间划给右边</span>\n</div></li><li><div class=\"code-word\">            cutPos = l + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; lans = dq(nums, b, cutPos);\n</div></li><li><div class=\"code-word\">        List&lt;List&lt;Integer&gt;&gt; rans = dq(nums, cutPos, e);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 两两组合</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; x: lans) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (List&lt;Integer&gt; y: rans) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 由于我们已经在ans中存放了空集，所以如果遇到两个都是空集的时候</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 我们就不再进行merge</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (x.isEmpty() &amp;&amp; y.isEmpty()) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">continue</span>;\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">                ans.add(merge(x, y));\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class=\"hljs-keyword\">int</span>[] nums) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (nums == <span class=\"hljs-keyword\">null</span> || nums.length == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        Arrays.sort(nums);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> dq(nums, <span class=\"hljs-number\">0</span>, nums.length);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"3885\">\n                      <p data-nodeid=\"3886\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4573\"\n                          >Jav</a\n                        ><a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4576\"\n                          >a</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4580\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"4584\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"3887\">总结</h3>\n                    <p data-nodeid=\"6453\">\n                      在本讲，我们通过分析题目的不同特点，展开了不同的解题思路，构造出了\n                      5 种不同的解法。这里，我将 5\n                      种解法进行了一个总结，如下图所示：\n                    </p>\n                    <p data-nodeid=\"6454\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/9C/CioPOWCGG5KAdVEJAAHM2pBloNY568.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"6458\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"3890\">\n                      题目是做不完的，但是我们可以通过分析每一个题目来锻炼挖掘题目信息的能力，以及匹配到我们大脑中已经存储的数据结构与算法的能力。同时，也可以通过这种方式，将学会的知识变成我们解决问题的能力，只有这样“学习”才能变成“学会”。\n                    </p>\n                    <h3 data-nodeid=\"3891\">思考题</h3>\n                    <p data-nodeid=\"3892\">\n                      <strong data-nodeid=\"4596\"\n                        >最后，我再给你留一个思考题：在求解题目 2\n                        的每一种方法中，我们都提前对数组进行了排序的处理，每次排序的原因和目的分别是什么</strong\n                      >？\n                    </p>\n                    <p data-nodeid=\"3893\">\n                      可以把你的分析写在留言区，我们一起讨论。如果你觉得今天的内容对你有所启发，欢迎分享给身边的朋友。\n                    </p>\n                    <p data-nodeid=\"3894\" class=\"\">\n                      好了，子集问题我们就学习到这里，希望你还能找出更多有趣的解法。接下来让我们前进到18\n                      | 单词接龙：如何巧用深搜与广搜的变形？记得按时来探险。\n                    </p>\n            "}