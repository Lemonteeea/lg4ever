{"title":"10 | 流程分解：Webpack 的完整构建流程","context":"\n                    <p data-nodeid=\"1177\">\n                      上节课我们聊了过去 20\n                      余年里，前端项目开发时的工程化需求，以及对应产生的工具解决方案，其中最广泛运用的构建工具是\n                      Webpack。这节课我们就来深入分析 Webpack 中的效率优化问题。\n                    </p>\n\n                    <p data-nodeid=\"3\">\n                      要想全面地分析 Webpack\n                      构建工具的优化方案，首先要先对它的工作流程有一定理解，这样才能针对项目中可能存在的构建问题，进行有目标地分析和优化。\n                    </p>\n                    <h3 data-nodeid=\"4\">Webpack 的基本工作流程</h3>\n                    <p data-nodeid=\"5\">\n                      我们从两方面来了解 Webpack 的基本工作流程：\n                    </p>\n                    <ol data-nodeid=\"6\">\n                      <li data-nodeid=\"7\">\n                        <p data-nodeid=\"8\">\n                          通过 Webpack 的源码来了解具体函数执行的逻辑。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9\">\n                        <p data-nodeid=\"10\">\n                          通过 Webpack 对外暴露的声明周期\n                          Hooks，理解整体流程的阶段划分。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1959\" class=\"\">\n                      其中会涉及对 Webpack 源代码的分析，源代码取自 Webpack\n                      仓库的\n                      <a\n                        href=\"https://github.com/webpack/webpack/blob/webpack-4\"\n                        data-nodeid=\"1963\"\n                        >webpack-4 分支</a\n                      >，而最新的 Webpack 5 中的优化我们会在后续课程中单独分析。\n                    </p>\n\n                    <p data-nodeid=\"12\">\n                      通常，在项目中有两种运行 Webpack\n                      的方式：基于命令行的方式或基于代码的方式。\n                    </p>\n                    <p data-nodeid=\"2745\" class=\"\">\n                      两种示例的代码分别如下（具体示例参照\n                      <a\n                        href=\"https://github.com/fe-efficiency/lessons_fe_efficiency/tree/master/10_webpack_workflow\"\n                        data-nodeid=\"2753\"\n                        >10_webpack_workflow</a\n                      >）：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">//第一种：基于命令行的方式</span>\n</div></li><li><div class=\"code-word\">webpack --config webpack.config.js\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//第二种：基于代码的方式</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'webpack'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> config = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./webpack.config'</span>)\n</div></li><li><div class=\"code-word\">webpack(config, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, stats</span>) =&gt;</span> {})\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"15\">webpack.js 中的基本流程</h4>\n                    <p data-nodeid=\"4321\" class=\"\">\n                      无论用哪种方式运行 Webpack，本质上都是\n                      <a\n                        href=\"https://github.com/webpack/webpack/blob/webpack-4/lib/webpack.js\"\n                        data-nodeid=\"4325\"\n                        >webpack.js</a\n                      >\n                      中的 Webpack 函数。\n                    </p>\n\n                    <p data-nodeid=\"17\">\n                      这一函数的核心逻辑是：根据配置生成编译器实例\n                      compiler，然后处理参数，执行\n                      WebpackOptionsApply().process，根据参数加载不同内部插件。在有回调函数的情况下，根据是否是\n                      watch 模式来决定要执行 compiler.watch 还是 compiler.run。\n                    </p>\n                    <p data-nodeid=\"18\">\n                      为了讲解通用的流程，我们以没有 watch\n                      模式的情况进行分析。简化流程后的代码示例如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> webpack = <span class=\"hljs-function\">(<span class=\"hljs-params\">options, callback</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  options = ... <span class=\"hljs-comment\">//处理options默认值</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">let</span> compiler = <span class=\"hljs-keyword\">new</span> Compiler(options.context)\n</div></li><li><div class=\"code-word\">  ... <span class=\"hljs-comment\">//处理参数中的插件等</span>\n</div></li><li><div class=\"code-word\">  compiler.options = <span class=\"hljs-keyword\">new</span> WebpackOptionsApply().process(options, compiler); <span class=\"hljs-comment\">//分析参数，加载各内部插件</span>\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">  if (callback) {\n</div></li><li><div class=\"code-word\">    ... \n</div></li><li><div class=\"code-word\">    compiler.run(callback)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> compiler\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"20\">Compiler.js 中的基本流程</h4>\n                    <p data-nodeid=\"5893\" class=\"\">\n                      我们再来看下运行编译器实例的内部逻辑，具体源代码在\n                      <a\n                        href=\"https://github.com/webpack/webpack/blob/webpack-4/lib/Compiler.js\"\n                        data-nodeid=\"5897\"\n                        >Compiler.js</a\n                      >\n                      中。\n                    </p>\n\n                    <p data-nodeid=\"22\">\n                      compiler.run(callback)\n                      中的执行逻辑较为复杂，我们把它按流程抽象一下。抽象后的执行流程如下：\n                    </p>\n                    <ol data-nodeid=\"9235\">\n                      <li data-nodeid=\"9236\">\n                        <p data-nodeid=\"9237\">\n                          <strong data-nodeid=\"9263\">readRecords</strong\n                          >：读取<a\n                            href=\"https://webpack.js.org/configuration/other-options/#recordspath\"\n                            data-nodeid=\"9261\"\n                            >构建记录</a\n                          >，用于分包缓存优化，在未设置 recordsPath 时直接返回。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9238\">\n                        <p data-nodeid=\"9239\">\n                          <strong data-nodeid=\"9268\"\n                            >compile 的主要构建过程</strong\n                          >，涉及以下几个环节：\n                        </p>\n                        <ol data-nodeid=\"9240\">\n                          <li data-nodeid=\"9241\" class=\"\">\n                            <p data-nodeid=\"9242\">\n                              <strong data-nodeid=\"9273\"\n                                >newCompilationParams</strong\n                              >：创建 NormalModule 和 ContextModule\n                              的工厂实例，用于创建后续模块实例。\n                            </p>\n                          </li>\n                          <li data-nodeid=\"9243\">\n                            <p data-nodeid=\"9244\">\n                              <strong data-nodeid=\"9278\">newCompilation</strong\n                              >：创建编译过程 Compilation\n                              实例，传入上一步的两个工厂实例作为参数。\n                            </p>\n                          </li>\n                          <li data-nodeid=\"9245\">\n                            <p data-nodeid=\"9246\">\n                              <strong data-nodeid=\"9287\"\n                                >compiler.hooks.make.callAsync</strong\n                              >：触发 make 的 Hook，执行所有监听 make\n                              的插件（例如\n                              <a\n                                href=\"https://github.com/webpack/webpack/blob/webpack-4/lib/SingleEntryPlugin.js\"\n                                data-nodeid=\"9285\"\n                                >SingleEntryPlugin.js</a\n                              >\n                              中，会在相应的监听中触发 compilation 的 addEntry\n                              方法）。其中，Hook 的作用，以及其他 Hook\n                              会在下面的小节中再谈到。\n                            </p>\n                          </li>\n                          <li data-nodeid=\"9247\">\n                            <p data-nodeid=\"9248\">\n                              <strong data-nodeid=\"9292\"\n                                >compilation.finish</strong\n                              >：编译过程实例的 finish 方法，触发相应的 Hook\n                              并报告构建模块的错误和警告。\n                            </p>\n                          </li>\n                          <li data-nodeid=\"9249\">\n                            <p data-nodeid=\"9250\">\n                              <strong data-nodeid=\"9297\"\n                                >compilation.seal</strong\n                              >：编译过程的 seal 方法，下一节中我会进一步分析。\n                            </p>\n                          </li>\n                        </ol>\n                      </li>\n                      <li data-nodeid=\"9251\">\n                        <p data-nodeid=\"9252\">\n                          <strong data-nodeid=\"9302\">emitAssets</strong>：调用\n                          compilation.getAssets()，将产物内容写入输出文件中。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9253\">\n                        <p data-nodeid=\"9254\">\n                          <strong data-nodeid=\"9307\">emitRecords</strong\n                          >：对应第一步的\n                          readRecords，用于写入构建记录，在未设置 recordsPath\n                          时直接返回。\n                        </p>\n                      </li>\n                    </ol>\n\n                    <p data-nodeid=\"43\">\n                      在编译器运行的流程里，核心过程是第二步编译。具体流程在生成的\n                      Compilation\n                      实例中进行，接下来我们再来看下这部分的源码逻辑。\n                    </p>\n                    <h4 data-nodeid=\"44\">Compilation.js 中的基本流程</h4>\n                    <p data-nodeid=\"10874\" class=\"\">\n                      这部分的源码位于\n                      <a\n                        href=\"https://github.com/webpack/webpack/blob/webpack-4/lib/Compilation.js\"\n                        data-nodeid=\"10878\"\n                        >Compilation.js</a\n                      >\n                      中。其中，在编译执行过程中，我们主要从外部调用的是两个方法：\n                    </p>\n\n                    <ol data-nodeid=\"46\">\n                      <li data-nodeid=\"47\">\n                        <p data-nodeid=\"48\">\n                          <strong data-nodeid=\"261\">addEntry</strong>：从 entry\n                          开始递归添加和构建模块。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"49\">\n                        <p data-nodeid=\"50\">\n                          <strong data-nodeid=\"266\">seal</strong\n                          >：冻结模块，进行一系列优化，以及触发各优化阶段的\n                          Hooks。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"51\">\n                      以上就是执行 Webpack 构建时的基本流程，这里再稍做总结：\n                    </p>\n                    <ol data-nodeid=\"52\">\n                      <li data-nodeid=\"53\">\n                        <p data-nodeid=\"54\">创建编译器 Compiler 实例。</p>\n                      </li>\n                      <li data-nodeid=\"55\">\n                        <p data-nodeid=\"56\">\n                          根据 Webpack 参数加载参数中的插件，以及程序内置插件。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"57\">\n                        <p data-nodeid=\"58\">\n                          执行编译流程：创建编译过程 Compilation\n                          实例，从入口递归添加与构建模块，模块构建完成后冻结模块，并进行优化。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"59\">\n                        <p data-nodeid=\"60\">\n                          构建与优化过程结束后提交产物，将产物内容写到输出文件中。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"61\">\n                      除了了解上面的基本工作流程外，还有两个相关的概念需要理解：Webpack\n                      的生命周期和插件系统。\n                    </p>\n                    <h3 data-nodeid=\"62\">读懂 Webpack 的生命周期</h3>\n                    <p data-nodeid=\"63\">\n                      Webpack 工作流程中最核心的两个模块：Compiler 和\n                      Compilation 都扩展自 Tapable\n                      类，用于实现工作流程中的生命周期划分，以便在不同的生命周期节点上注册和调用<strong\n                        data-nodeid=\"283\"\n                        >插件</strong\n                      >。其中所暴露出来的生命周期节点称为<strong\n                        data-nodeid=\"284\"\n                        >Hook</strong\n                      >（俗称钩子）。\n                    </p>\n                    <h4 data-nodeid=\"64\">Webpack 中的插件</h4>\n                    <p data-nodeid=\"65\">\n                      Webpack 引擎基于插件系统搭建而成，不同的插件各司其职，在\n                      Webpack\n                      工作流程的某一个或多个时间点上，对构建流程的某个方面进行处理。Webpack\n                      就是通过这样的工作方式，在各生命周期中，经一系列插件将源代码逐步变成最后的产物代码。\n                    </p>\n                    <p data-nodeid=\"66\">\n                      一个 Webpack 插件是一个包含 apply 方法的 JavaScript\n                      对象。这个 apply 方法的执行逻辑，通常是注册 Webpack\n                      工作流程中某一生命周期 Hook，并添加对应 Hook\n                      中该插件的实际处理函数。例如下面的代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloWorldPlugin</span> </span>{\n</div></li><li><div class=\"code-word\">  apply(compiler) {\n</div></li><li><div class=\"code-word\">    compiler.hooks.run.tap(<span class=\"hljs-string\">\"HelloWorldPlugin\"</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">compilation</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello world'</span>);\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">module</span>.exports = HelloWorldPlugin;\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"68\">Hook 的使用方式</h4>\n                    <p data-nodeid=\"69\">Hook 的使用分为四步：</p>\n                    <ol data-nodeid=\"70\">\n                      <li data-nodeid=\"71\">\n                        <p data-nodeid=\"72\">\n                          在构造函数中定义 Hook 类型和参数，生成 Hook 对象。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"73\">\n                        <p data-nodeid=\"74\">\n                          在插件中注册 Hook，添加对应 Hook 触发时的执行函数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"75\">\n                        <p data-nodeid=\"76\">生成插件实例，运行 apply 方法。</p>\n                      </li>\n                      <li data-nodeid=\"77\">\n                        <p data-nodeid=\"78\">\n                          在运行到对应生命周期节点时调用\n                          Hook，执行注册过的插件的回调函数。如下面的代码所示：\n                        </p>\n                      </li>\n                    </ol>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">lib/Compiler.js\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">this</span>.hooks = {\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">  make: <span class=\"hljs-keyword\">new</span> SyncHook([<span class=\"hljs-string\">'compilation'</span>, <span class=\"hljs-string\">'params'</span>]), <span class=\"hljs-comment\">//1. 定义Hook</span>\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">...\n</div></li><li><div class=\"code-word\">this.hooks.compilation.call(compilation, params); <span class=\"hljs-comment\">//4. 调用Hook</span>\n</div></li><li><div class=\"code-word\">...\n</div></li><li><div class=\"code-word\">lib/dependencies/CommonJsPlugin.js\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//2. 在插件中注册Hook</span>\n</div></li><li><div class=\"code-word\">compiler.hooks.compilation.tap(<span class=\"hljs-string\">\"CommonJSPlugin\"</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">compilation, { contextModuleFactory, normalModuleFactory }</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">})\n</div></li><li><div class=\"code-word\">lib/WebpackOptionsApply.js\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">//3. 生成插件实例，运行apply方法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">new</span> CommonJsPlugin(options.module).apply(compiler);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"80\">\n                      以上就是 Webpack 中 Hook\n                      的一般使用方式。正是通过这种方式，Webpack\n                      将编译器和编译过程的生命周期节点提供给外部插件，从而搭建起弹性化的工作引擎。\n                    </p>\n                    <p data-nodeid=\"81\">\n                      Hook\n                      的类型按照同步或异步、是否接收上一插件的返回值等情况分为 9\n                      种。不同类型的 Hook 接收注册的方法也不同，更多信息可参照<a\n                        href=\"https://github.com/webpack/tapable#tapable\"\n                        data-nodeid=\"298\"\n                        >官方文档</a\n                      >。下面我们来具体介绍 Compiler 和 Compilation 中的 Hooks。\n                    </p>\n                    <h4 data-nodeid=\"82\">Compiler Hooks</h4>\n                    <p data-nodeid=\"83\">\n                      构建器实例的生命周期可以分为 3\n                      个阶段：初始化阶段、构建过程阶段、产物生成阶段。下面我们就来大致介绍下这些不同阶段的\n                      Hooks ：\n                    </p>\n                    <p data-nodeid=\"84\">\n                      <strong data-nodeid=\"305\">初始化阶段</strong>\n                    </p>\n                    <ul data-nodeid=\"85\">\n                      <li data-nodeid=\"86\">\n                        <p data-nodeid=\"87\">\n                          environment、afterEnvironment：在创建完 compiler\n                          实例且执行了配置内定义的插件的 apply 方法后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"88\">\n                        <p data-nodeid=\"89\">\n                          entryOption、afterPlugins、afterResolvers：在\n                          WebpackOptionsApply.js 中，这 3 个 Hooks 分别在执行\n                          EntryOptions 插件和其他 Webpack 内置插件，以及解析了\n                          resolver 配置后触发。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"90\">\n                      <strong data-nodeid=\"311\">构建过程阶段</strong>\n                    </p>\n                    <ul data-nodeid=\"91\">\n                      <li data-nodeid=\"92\">\n                        <p data-nodeid=\"93\">\n                          normalModuleFactory、contextModuleFactory：在两类模块工厂创建后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"94\">\n                        <p data-nodeid=\"95\">\n                          beforeRun、run、watchRun、beforeCompile、compile、thisCompilation、compilation、make、afterCompile：在运行构建过程中触发。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"96\">\n                      <strong data-nodeid=\"317\">产物生成阶段</strong>\n                    </p>\n                    <ul data-nodeid=\"97\">\n                      <li data-nodeid=\"98\">\n                        <p data-nodeid=\"99\">\n                          shouldEmit、emit、assetEmitted、afterEmit：在构建完成后，处理产物的过程中触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"100\">\n                        <p data-nodeid=\"101\">\n                          failed、done：在达到最终结果状态时触发。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"102\">Compilation Hooks</h4>\n                    <p data-nodeid=\"103\">\n                      构建过程实例的生命周期我们分为两个阶段：\n                    </p>\n                    <p data-nodeid=\"104\">\n                      <strong data-nodeid=\"325\">构建阶段</strong>\n                    </p>\n                    <ul data-nodeid=\"105\">\n                      <li data-nodeid=\"106\">\n                        <p data-nodeid=\"107\">\n                          addEntry、failedEntry、succeedEntry：在添加入口和添加入口结束时触发（Webpack\n                          5 中移除）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"108\">\n                        <p data-nodeid=\"109\">\n                          buildModule、rebuildModule、finishRebuildingModule、failedModule、succeedModule：在构建单个模块时触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"110\">\n                        <p data-nodeid=\"111\">\n                          finishModules：在所有模块构建完成后触发。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"112\">\n                      <strong data-nodeid=\"332\">优化阶段</strong>\n                    </p>\n                    <p data-nodeid=\"12424\">\n                      优化阶段在 seal 函数中共有 12\n                      个主要的处理过程，如下图所示：\n                    </p>\n                    <p data-nodeid=\"12425\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/4D/B4/Ciqc1F9bGtqAJo4uAABnYGwsyYs218.png\"\n                        alt=\"image (4).png\"\n                        data-nodeid=\"12433\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"116\">\n                      每个过程都暴露了相应的 Hooks，分别如下:\n                    </p>\n                    <ul data-nodeid=\"13214\">\n                      <li data-nodeid=\"13215\">\n                        <p data-nodeid=\"13216\">\n                          seal、needAdditionalSeal、unseal、afterSeal：分别在\n                          seal 函数的起始和结束的位置触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13217\">\n                        <p data-nodeid=\"13218\">\n                          optimizeDependencies、afterOptimizeDependencies：触发优化依赖的插件执行，例如FlagDependencyUsagePlugin。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13219\">\n                        <p data-nodeid=\"13220\">\n                          beforeChunks、afterChunks：分别在生成 Chunks\n                          的过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13221\">\n                        <p data-nodeid=\"13222\">\n                          optimize：在生成 chunks\n                          之后，开始执行优化处理的阶段触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13223\">\n                        <p data-nodeid=\"13224\">\n                          optimizeModule、afterOptimizeModule：在优化模块过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13225\">\n                        <p data-nodeid=\"13226\" class=\"\">\n                          optimizeChunks、afterOptimizeChunks：在优化 Chunk\n                          过程的前后触发，用于\n                          <a\n                            href=\"https://webpack.js.org/guides/tree-shaking/\"\n                            data-nodeid=\"13253\"\n                            >Tree Shaking</a\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13227\">\n                        <p data-nodeid=\"13228\">\n                          optimizeTree、afterOptimizeTree：在优化模块和 Chunk\n                          树过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13229\">\n                        <p data-nodeid=\"13230\">\n                          optimizeChunkModules、afterOptimizeChunkModules：在优化\n                          ChunkModules 的过程前后触发，例如\n                          ModuleConcatenationPlugin，利用这一 Hook 来做<a\n                            href=\"https://webpack.js.org/plugins/module-concatenation-plugin/#optimization-bailouts\"\n                            data-nodeid=\"13259\"\n                            >Scope Hoisting</a\n                          >的优化。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13231\">\n                        <p data-nodeid=\"13232\">\n                          shouldRecord、recordModules、recordChunks、recordHash：在\n                          shouldRecord 返回为 true 的情况下，依次触发\n                          recordModules、recordChunks、recordHash。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13233\">\n                        <p data-nodeid=\"13234\">\n                          reviveModules、beforeModuleIds、moduleIds、optimizeModuleIds、afterOptimizeModuleIds：在生成模块\n                          Id 过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13235\">\n                        <p data-nodeid=\"13236\">\n                          reviveChunks、beforeChunkIds、optimizeChunkIds、afterOptimizeChunkIds：在生成\n                          Chunk id 过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13237\">\n                        <p data-nodeid=\"13238\">\n                          beforeHash、afterHash：在生成模块与 Chunk 的 hash\n                          过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13239\">\n                        <p data-nodeid=\"13240\">\n                          beforeModuleAssets、moduleAsset：在生成模块产物数据过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13241\">\n                        <p data-nodeid=\"13242\">\n                          shouldGenerateChunkAssets、beforeChunkAssets、chunkAsset：在创建\n                          Chunk 产物数据过程的前后触发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"13243\">\n                        <p data-nodeid=\"13244\">\n                          additionalAssets、optimizeChunkAssets、afterOptimizeChunkAssets、optimizeAssets、afterOptimizeAssets：在优化产物过程的前后触发，例如在\n                          TerserPlugin 的<a\n                            href=\"https://github.com/webpack-contrib/terser-webpack-plugin/blob/master/src/index.js\"\n                            data-nodeid=\"13270\"\n                            >压缩代码</a\n                          >插件的执行过程中，就用到了 optimizeChunkAssets。\n                        </p>\n                      </li>\n                    </ul>\n\n                    <h3 data-nodeid=\"148\">代码实践：编写一个简单的统计插件</h3>\n                    <p data-nodeid=\"149\">\n                      在了解了 Webpack\n                      的工作流程后，下面我们进行一个简单的实践。\n                    </p>\n                    <p data-nodeid=\"14052\" class=\"\">\n                      编写一个统计构建过程生命周期耗时的插件，这类插件会作为后续优化构建效率的准备工作。插件片段示例如下（完整代码参见\n                      <a\n                        href=\"https://github.com/fe-efficiency/lessons_fe_efficiency/tree/master/10_webpack_workflow\"\n                        data-nodeid=\"14060\"\n                        >10_webpack_workflow</a\n                      >）：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SamplePlugin</span> </span>{\n</div></li><li><div class=\"code-word\">  apply(compiler) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> start = Date.now()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> statsHooks = [<span class=\"hljs-string\">'environment'</span>, <span class=\"hljs-string\">'entryOption'</span>, <span class=\"hljs-string\">'afterPlugins'</span>, <span class=\"hljs-string\">'compile'</span>]\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> statsAsyncHooks = [\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'beforeRun'</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'beforeCompile'</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'make'</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'afterCompile'</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'emit'</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'done'</span>,\n</div></li><li><div class=\"code-word\">    ]\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    statsHooks.forEach((hookName) =&gt; {\n</div></li><li><div class=\"code-word\">      compiler.hooks[hookName].tap(<span class=\"hljs-string\">'Sample Plugin'</span>, () =&gt; {\n</div></li><li><div class=\"code-word\">        console.log(\\`Compiler Hook ${hookName}, Time: ${Date.now() - start}ms\\`)\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">    ...\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">})\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = SamplePlugin;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"18826\">\n                      执行构建后，可以看到在控制台输出了相应的统计时间结果（这里的时间是从构建起始到各阶段\n                      Hook 触发为止的耗时），如下图所示：\n                    </p>\n                    <p data-nodeid=\"18827\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/4D/B4/Ciqc1F9bGvGAFRmpAAGFrvBhTHE475.png\"\n                        alt=\"image (5).png\"\n                        data-nodeid=\"18835\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"17254\">\n                      根据这样的输出结果，我们就可以分析项目里各阶段的耗时情况，再进行针对性地优化。这个统计插件将在后面几课的优化实践中运用。\n                    </p>\n                    <p data-nodeid=\"17255\">\n                      除了这类自己编写的统计插件外，Webpack\n                      社区中也有一些较成熟的统计插件，例如<a\n                        href=\"https://github.com/stephencookdev/speed-measure-webpack-plugin\"\n                        data-nodeid=\"17268\"\n                        >speed-measure-webpack-plugin</a\n                      >等，感兴趣的话，你可以进一步了解。\n                    </p>\n                    <h3 data-nodeid=\"17256\">总结</h3>\n                    <p data-nodeid=\"17257\">\n                      这一课时起，我们进入了 Webpack\n                      构建优化的主题。在这节课中，我主要为你勾画了一个 Webpack\n                      工作流程的轮廓，通过对三个源码文件的分析，让你对执行构建命令后的内部流程有一个基本概念。然后我们讨论了\n                      Compiler 和 Compilation 工作流程中的生命周期\n                      Hooks，以及插件的基本工作方式。最后，我们编写了一个简单的统计插件，用于实践上面所讲的课程内容。\n                    </p>\n                    <p data-nodeid=\"17258\">\n                      今天的课后思考题是：在今天介绍的 Compiler 和 Compilation\n                      的各生命周期阶段里，通常耗时最长的分别是哪个阶段呢？可以结合自己所在的项目测试分析一下。\n                    </p>\n            "}