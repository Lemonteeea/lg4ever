{"title":"01 | 事件循环：高性能到底是如何做到的？","context":"\n                    <p data-nodeid=\"1453\" class=\"\">\n                      在介绍 Node.js 的应用之前，我们先来讲解下 Node.js\n                      中最基础也是最核心的部分：事件循环的原理。这一部分在面试过程中是必考的点，然而大家在网络上查找到的知识或多或少有些出入，会被误导。\n                    </p>\n                    <p data-nodeid=\"1814\" class=\"te-preview-highlight\">\n                      所以本讲就基于 Node.js 10+\n                      版本，为你讲解事件循环的原理，不过要注意这个<strong\n                        data-nodeid=\"1824\"\n                        >事件循环原理</strong\n                      >和<strong data-nodeid=\"1825\">浏览器的原理</strong\n                      >是不同的，Node.js 10+\n                      版本后虽然在运行结果上与浏览器一致，但是两者在原理上一个是基于浏览器，一个是基于\n                      libuv 库。浏览器核心的是宏任务和微任务，而在 Node.js\n                      还有阶段性任务执行阶段。\n                    </p>\n\n                    <h3 data-nodeid=\"1455\">Node.js 事件循环</h3>\n                    <p data-nodeid=\"1456\">\n                      <strong data-nodeid=\"1625\"\n                        >事件循环通俗来说就是一个无限的 while 循环</strong\n                      >。现在假设你对这个 while\n                      循环什么都不了解，你一定会有以下疑问。\n                    </p>\n                    <ol data-nodeid=\"1457\">\n                      <li data-nodeid=\"1458\">\n                        <p data-nodeid=\"1459\">\n                          谁来启动这个循环过程，循环条件是什么？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1460\">\n                        <p data-nodeid=\"1461\">循环的是什么任务呢？</p>\n                      </li>\n                      <li data-nodeid=\"1462\">\n                        <p data-nodeid=\"1463\">循环的任务是否存在优先级概念？</p>\n                      </li>\n                      <li data-nodeid=\"1464\">\n                        <p data-nodeid=\"1465\">\n                          什么进程或者线程来执行这个循环？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1466\">\n                        <p data-nodeid=\"1467\">无限循环有没有终点？</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1468\">\n                      带着这些问题，我们先来看看 Node.js\n                      官网提供的事件循环原理图。\n                    </p>\n                    <h4 data-nodeid=\"1469\">Node.js 循环原理</h4>\n                    <p data-nodeid=\"1470\">\n                      图 1 为 Node.js 官网的事件循环原理的核心流程图。\n                    </p>\n                    <p data-nodeid=\"1471\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/1F/CioPOWBB0_iAYF-EAACboqFVHbQ092.png\"\n                        alt=\"image (1).png\"\n                        data-nodeid=\"1636\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1472\">\n                      <p style=\"text-align: center\">图 1 事件循环原理流程图</p>\n                    </div>\n                    <p data-nodeid=\"1473\">\n                      可以看到，这一流程包含 6\n                      个阶段，每个阶段代表的含义如下所示。\n                    </p>\n                    <p data-nodeid=\"1474\">\n                      （1）<strong data-nodeid=\"1643\">timers</strong\n                      >：本阶段执行已经被 setTimeout() 和 setInterval()\n                      调度的回调函数，简单理解就是由这两个函数启动的回调函数。\n                    </p>\n                    <p data-nodeid=\"1475\">\n                      （2）<strong data-nodeid=\"1649\">pending callbacks</strong\n                      >：本阶段执行某些系统操作（如 TCP 错误类型）的回调函数。\n                    </p>\n                    <p data-nodeid=\"1476\">\n                      （3）<strong data-nodeid=\"1655\">idle、prepare</strong\n                      >：仅系统内部使用，你只需要知道有这 2 个阶段就可以。\n                    </p>\n                    <p data-nodeid=\"1477\">\n                      （4）<strong data-nodeid=\"1661\">poll</strong>：检索新的\n                      I/O 事件，执行与 I/O 相关的回调，其他情况 Node.js\n                      将在适当的时候在此阻塞。这也是最复杂的一个阶段，所有的事件循环以及回调处理都在这个阶段执行，接下来会详细分析这个过程。\n                    </p>\n                    <p data-nodeid=\"1478\">\n                      （5）<strong data-nodeid=\"1667\">check</strong\n                      >：setImmediate() 回调函数在这里执行，setImmediate\n                      并不是立马执行，而是当事件循环 poll\n                      中没有新的事件处理时就执行该部分，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n</div></li><li><div class=\"code-word\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-comment\">// 新的事件循环的起点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'1'</span>); \n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">setImmediate( <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'setImmediate 1'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 将会在 poll 阶段执行</span>\n</div></li><li><div class=\"code-word\">fs.readFile(<span class=\"hljs-string\">'./test.conf'</span>, {<span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">'utf-8'</span>}, (err, data) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'read file success'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 该部分将会在首次事件循环中执行</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'poll callback'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 首次事件循环执行</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'2'</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1480\">\n                      在这一代码中有一个非常奇特的地方，就是 setImmediate 会在\n                      setTimeout 之后输出。有以下几点原因：\n                    </p>\n                    <ul data-nodeid=\"1481\">\n                      <li data-nodeid=\"1482\">\n                        <p data-nodeid=\"1483\">\n                          setTimeout 如果不设置时间或者设置时间为 0，则会默认为\n                          1ms；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1484\">\n                        <p data-nodeid=\"1485\">\n                          主流程执行完成后，超过 1ms 时，会将 setTimeout\n                          回调函数逻辑插入到待执行回调函数poll 队列中；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1486\">\n                        <p data-nodeid=\"1487\">\n                          由于当前 poll\n                          队列中存在可执行回调函数，因此需要先执行完，待完全执行完成后，才会执行<strong\n                            data-nodeid=\"1676\"\n                            >check</strong\n                          >：setImmediate。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1488\">\n                      因此这也验证了这句话，<strong data-nodeid=\"1682\"\n                        >先执行回调函数，再执行 setImmediate</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1489\">\n                      （6）<strong data-nodeid=\"1692\">close callbacks</strong\n                      >：执行一些关闭的回调函数，如 socket.on('close', ...)。\n                    </p>\n                    <p data-nodeid=\"1490\">\n                      以上就是循环原理的 6\n                      个过程，针对上面的点，我们再来解答上面提出的 5 个疑问。\n                    </p>\n                    <h4 data-nodeid=\"1491\">运行起点</h4>\n                    <p data-nodeid=\"1492\">\n                      从图 1 中我们可以看出事件循环的起点是\n                      timers，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'1'</span>);\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'2'</span>)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1494\">\n                      在代码 setTimeout\n                      中的回调函数就是新一轮事件循环的起点，看到这里有很多同学会提出非常合理的疑问：“为什么会先输出\n                      2 然后输出 1，不是说 timer 的回调函数是运行起点吗？”\n                    </p>\n                    <p data-nodeid=\"1495\">\n                      这里有一个非常关键点，当 Node.js\n                      启动后，会初始化事件循环，处理已提供的输入脚本，它可能会先调用一些异步的\n                      API、调度定时器，或者\n                      process.nextTick()，然后再开始处理事件循环。因此可以这样理解，Node.js\n                      进程启动后，就发起了一个新的事件循环，也就是事件循环的起点。\n                    </p>\n                    <p data-nodeid=\"1496\">\n                      总结来说，Node.js 事件循环的发起点有 4 个：\n                    </p>\n                    <ul data-nodeid=\"1497\">\n                      <li data-nodeid=\"1498\">\n                        <p data-nodeid=\"1499\">Node.js 启动后；</p>\n                      </li>\n                      <li data-nodeid=\"1500\">\n                        <p data-nodeid=\"1501\">setTimeout 回调函数；</p>\n                      </li>\n                      <li data-nodeid=\"1502\">\n                        <p data-nodeid=\"1503\">setInterval 回调函数；</p>\n                      </li>\n                      <li data-nodeid=\"1504\">\n                        <p data-nodeid=\"1505\">\n                          也可能是一次 I/O 后的回调函数。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1506\">\n                      以上就解释了我们上面提到的第 1 个问题。\n                    </p>\n                    <h4 data-nodeid=\"1507\">Node.js 事件循环</h4>\n                    <p data-nodeid=\"1508\">\n                      在了解谁发起的事件循环后，我们再来回答第 2\n                      个问题，即循环的是什么任务。在上面的核心流程中真正需要关注循环执行的就是\n                      <strong data-nodeid=\"1714\">poll 这个过程</strong>。在 poll\n                      过程中，主要处理的是异步 I/O\n                      的回调函数，以及其他几乎所有的回调函数，<strong\n                        data-nodeid=\"1715\"\n                        >异步 I/O 又分为网络 I/O 和文件 I/O</strong\n                      >。这是我们常见的代码逻辑部分的异步回调逻辑。\n                    </p>\n                    <p data-nodeid=\"1509\">\n                      事件循环的主要包含微任务和宏任务。具体是怎么进行循环的呢？如图\n                      2 所示。\n                    </p>\n                    <p data-nodeid=\"1510\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/13/20/CioPOWBB1rCAM7NxAAFF-n4jMtY220.png\"\n                        alt=\"image (2).png\"\n                        data-nodeid=\"1719\"\n                      />\n                    </p>\n                    <div data-nodeid=\"1511\">\n                      <p style=\"text-align: center\">图 2 事件循环过程</p>\n                    </div>\n                    <p data-nodeid=\"1512\">\n                      在解释上图之前，我们先来解释下两个概念，微任务和宏任务。\n                    </p>\n                    <p data-nodeid=\"1513\">\n                      <strong data-nodeid=\"1725\">微任务</strong>：在 Node.js\n                      中微任务包含 2 种——process.nextTick 和\n                      Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且process.nextTick\n                      和 Promise 也存在优先级，process.nextTick 高于 Promise。\n                    </p>\n                    <p data-nodeid=\"1514\">\n                      <strong data-nodeid=\"1734\">宏任务</strong>：在 Node.js\n                      中宏任务包含 4 种——setTimeout、setInterval、setImmediate\n                      和\n                      I/O。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么<strong\n                        data-nodeid=\"1735\"\n                        >优先将微任务队列清空，再执行宏任务队列</strong\n                      >。这也解释了我们前面提到的第 3\n                      个问题，事件循环中的事件类型是存在优先级。\n                    </p>\n                    <p data-nodeid=\"1515\">\n                      在图 2\n                      的左侧，我们可以看到有一个核心的主线程，它的执行阶段主要处理三个核心逻辑。\n                    </p>\n                    <ul data-nodeid=\"1516\">\n                      <li data-nodeid=\"1517\">\n                        <p data-nodeid=\"1518\">同步代码。</p>\n                      </li>\n                      <li data-nodeid=\"1519\">\n                        <p data-nodeid=\"1520\">\n                          将异步任务插入到微任务队列或者宏任务队列中。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1521\">\n                        <p data-nodeid=\"1522\">\n                          执行微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插入微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执行微任务，不存在则判断在宏任务队列是否有任务，有则执行。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1523\">\n                      如果微任务和宏任务都只有一层时，那么看起来是比较简单的，比如下面的例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 首次事件循环执行</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'start'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 将会在新的事件循环中的阶段执行</span>\n</div></li><li><div class=\"code-word\">fs.readFile(<span class=\"hljs-string\">'./test.conf'</span>, {<span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">'utf-8'</span>}, (err, data) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'read file success'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-comment\">// 新的事件循环的起点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'setTimeout'</span>); \n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 该部分将会在首次事件循环中执行</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Promise callback'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 执行 process.nextTick</span>\n</div></li><li><div class=\"code-word\">process.nextTick(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'nextTick callback'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 首次事件循环执行</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'end'</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1525\">\n                      根据上面介绍的执行过程，我们来分析下上面代码的执行过程：\n                    </p>\n                    <ol data-nodeid=\"1526\">\n                      <li data-nodeid=\"1527\">\n                        <p data-nodeid=\"1528\">\n                          第一个事件循环主线程发起，因此先执行同步代码，所以先输出\n                          start，然后输出 end；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1529\">\n                        <p data-nodeid=\"1530\">\n                          再从上往下分析，遇到微任务，插入微任务队列，遇到宏任务，插入宏任务队列，分析完成后，微任务队列包含：Promise.resolve\n                          和 process.nextTick，宏任务队列包含：fs.readFile 和\n                          setTimeout；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1531\">\n                        <p data-nodeid=\"1532\">\n                          先执行微任务队列，但是根据优先级，先执行\n                          process.nextTick 再执行 Promise.resolve，所以先输出\n                          nextTick callback 再输出 Promise callback；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1533\">\n                        <p data-nodeid=\"1534\">\n                          再执行宏任务队列，根据宏任务插入先后顺序执行\n                          setTimeout 再执行 fs.readFile，这里需要注意，先执行\n                          setTimeout\n                          由于其回调时间较短，因此回调也先执行，并非是\n                          setTimeout\n                          先执行所以才先执行回调函数，但是它执行需要时间肯定大于\n                          1ms，所以虽然 fs.readFile 先于 setTimeout 执行，但是\n                          setTimeout 执行更快，所以先输出 setTimeout ，最后输出\n                          read file success。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1535\">\n                      根据上面的分析，我们可以得到如下的执行结果：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">start\n</div></li><li><div class=\"code-word\">end\n</div></li><li><div class=\"code-word\">nextTick callback\n</div></li><li><div class=\"code-word\">Promise callback\n</div></li><li><div class=\"code-word\">setTimeout\n</div></li><li><div class=\"code-word\">read file success\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1537\">\n                      但是当微任务和宏任务又产生新的微任务和宏任务时，又应该如何处理呢？如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n</div></li><li><div class=\"code-word\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-comment\">// 新的事件循环的起点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'1'</span>); \n</div></li><li><div class=\"code-word\">    fs.readFile(<span class=\"hljs-string\">'./config/test.conf'</span>, {<span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">'utf-8'</span>}, (err, data) =&gt; {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'read file sync success'</span>);\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 回调将会在新的事件循环之前</span>\n</div></li><li><div class=\"code-word\">fs.readFile(<span class=\"hljs-string\">'./config/test.conf'</span>, {<span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">'utf-8'</span>}, (err, data) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'read file success'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 该部分将会在首次事件循环中执行</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'poll callback'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 首次事件循环执行</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'2'</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1539\">\n                      在上面代码中，有 2 个宏任务和 1 个微任务，宏任务是\n                      setTimeout 和 fs.readFile，微任务是 Promise.resolve。\n                    </p>\n                    <ol data-nodeid=\"1540\">\n                      <li data-nodeid=\"1541\">\n                        <p data-nodeid=\"1542\">\n                          整个过程优先执行主线程的第一个事件循环过程，所以先执行同步逻辑，先输出\n                          2。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1543\">\n                        <p data-nodeid=\"1544\">\n                          接下来执行微任务，输出 poll callback。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1545\">\n                        <p data-nodeid=\"1546\">\n                          再执行宏任务中的 fs.readFile 和 setTimeout，由于\n                          fs.readFile 优先级高，先执行\n                          fs.readFile。但是处理时间长于 1ms，因此会先执行\n                          setTimeout 的回调函数，输出\n                          1。这个阶段在执行过程中又会产生新的宏任务\n                          fs.readFile，因此又将该 fs.readFile 插入宏任务队列。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1547\">\n                        <p data-nodeid=\"1548\">\n                          最后由于只剩下宏任务了\n                          fs.readFile，因此执行该宏任务，并等待处理完成后的回调，输出\n                          read file sync success。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1549\">\n                      根据上面的分析，我们可以得出最后的执行结果，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">poll callback\n</div></li><li><div class=\"code-word\"><span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">read file success\n</div></li><li><div class=\"code-word\">read file sync success\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1551\">\n                      在上面的例子中，我们来思考一个问题，主线程是否会被阻塞，具体我们来看一个代码例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n</div></li><li><div class=\"code-word\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-comment\">// 新的事件循环的起点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'1'</span>); \n</div></li><li><div class=\"code-word\">    sleep(<span class=\"hljs-number\">10000</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sleep 10s'</span>);\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 将会在 poll 阶段执行</span>\n</div></li><li><div class=\"code-word\">fs.readFile(<span class=\"hljs-string\">'./test.conf'</span>, {<span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">'utf-8'</span>}, (err, data) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'read file success'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'2'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/// 函数实现，参数 n 单位 毫秒 ；</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sleep</span> (<span class=\"hljs-params\"> n </span>) </span>{ \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">var</span> start = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() ;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> ( <span class=\"hljs-literal\">true</span> ) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> ( <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() - start &gt; n ) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 使用  break  实现；</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1553\">\n                      我们在 setTimeout\n                      中增加了一个阻塞逻辑，这个阻塞逻辑的现象是，只有等待当次事件循环结束后，才会执行\n                      fs.readFile 回调函数。这里会发现 fs.readFile\n                      其实已经处理完了，并且通知回调到了主线程，但是由于主线程在处理回调时被阻塞了，导致无法处理\n                      fs.readFile\n                      的回调。因此可以得出一个结论，主线程会因为回调函数的执行而被阻塞，这也符合图\n                      2 中的执行流程图。\n                    </p>\n                    <p data-nodeid=\"1554\">\n                      如果把上面代码中 setTimeout 的时间修改为 10\n                      ms，你将会优先看到 fs.readFile 的回调函数，因为\n                      fs.readFile\n                      执行完成了，并且还未启动下一个事件循环，修改的代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { <span class=\"hljs-comment\">// 新的事件循环的起点</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'1'</span>); \n</div></li><li><div class=\"code-word\">    sleep(<span class=\"hljs-number\">10000</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sleep 10s'</span>);\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-number\">10</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1556\">\n                      最后我们再来回答第 5\n                      个问题，当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执行了，但是也并不能代表循环结束了。因为可能存在当前还未回调的异步\n                      I/O，所以这个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执行。\n                    </p>\n                    <h3 data-nodeid=\"1557\">实践分析</h3>\n                    <p data-nodeid=\"1558\">\n                      了解了整个原理流程，我们再来实践验证下 Node.js\n                      的事件驱动，以及 I/O\n                      到底有什么效果和为什么能提高并发处理能力。我们的实验分别从同步和异步的代码性能分析对比，从而得出两者的差异。\n                    </p>\n                    <p data-nodeid=\"1559\">\n                      <strong data-nodeid=\"1764\"\n                        >Node.js 不善于处理 CPU 密集型的业务</strong\n                      >，就会导致性能问题，如果要实现一个耗时 CPU\n                      的计算逻辑，处理方法有 2 种：\n                    </p>\n                    <ul data-nodeid=\"1560\">\n                      <li data-nodeid=\"1561\">\n                        <p data-nodeid=\"1562\">直接在主业务流程中处理；</p>\n                      </li>\n                      <li data-nodeid=\"1563\">\n                        <p data-nodeid=\"1564\">\n                          通过网络异步 I/O 给其他进程处理。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1565\">\n                      接下来，我们用 2 种方法分别计算从 0 到 1000000000\n                      之间的和，然后对比下各自的效果。\n                    </p>\n                    <h4 data-nodeid=\"1566\">主流程执行</h4>\n                    <p data-nodeid=\"1567\">\n                      为了效果，我们把两部分计算分开，这样能更好地形成对比，没有异步驱动计算的话，只能同步的去执行两个函数\n                      startCount 和 nextCount，然后将两部分计算结果相加。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 创建 http 服务，简单返回\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    res.write(<span class=\"hljs-string\">\\`<span class=\"hljs-subst\">${startCount() + nextCount()}</span>\\`</span>);\n</div></li><li><div class=\"code-word\">    res.end();\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * 从 0 计算到 500000000 的和\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">startCount</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">500000000</span>; i++){\n</div></li><li><div class=\"code-word\">        sum = sum + i;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> sum;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * 从 500000000 计算到 1000000000 之间的和\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextCount</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">500000000</span>; i&lt;<span class=\"hljs-number\">1000000000</span>; i++){\n</div></li><li><div class=\"code-word\">        sum = sum + i;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> sum;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 启动服务\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\">server.listen(<span class=\"hljs-number\">4000</span>, () =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'server start http://127.0.0.1:4000'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1569\">接下来使用下面命令启动该服务：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">node sync.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1571\">\n                      启动成功后，再在另外一个命令行窗口执行如下命令，查看响应时间，运行命令如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">time curl http:<span class=\"hljs-comment\">//127.0.0.1:4000</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1573\">运行完成以后可以看到如下的结果：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">499999999075959400</span>\n</div></li><li><div class=\"code-word\">real&nbsp; &nbsp; <span class=\"hljs-number\">0</span>m1<span class=\"hljs-number\">.100</span>s\n</div></li><li><div class=\"code-word\">user&nbsp; &nbsp; <span class=\"hljs-number\">0</span>m0<span class=\"hljs-number\">.004</span>s\n</div></li><li><div class=\"code-word\">sys&nbsp; &nbsp; &nbsp;<span class=\"hljs-number\">0</span>m0<span class=\"hljs-number\">.005</span>s\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1575\">\n                      启动第一行是计算结果，第二行是执行时长。经过多次运行，其结果基本相近，都在\n                      1.1s 左右。接下来我们利用 Node.js\n                      异步事件循环的方式来优化这部分计算方式。\n                    </p>\n                    <h4 data-nodeid=\"1576\">异步网络 I/O</h4>\n                    <p data-nodeid=\"1577\">\n                      异步网络 I/O\n                      对比主流程执行，优化的思想是将上面的两个计算函数\n                      startCount 和 nextCount\n                      分别交给其他两个进程来处理，然后主进程应用异步网络 I/O\n                      的方式来调用执行。\n                    </p>\n                    <p data-nodeid=\"1578\">\n                      我们先看下主流程逻辑，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> rp = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'request-promise'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 创建 http 服务，简单返回\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">Promise</span>.all([startCount(), nextCount()]).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">values</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">let</span> sum = values.reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">prev, curr, idx, arr</span>)</span>{\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(prev) + <span class=\"hljs-built_in\">parseInt</span>(curr);\n</div></li><li><div class=\"code-word\">        })\n</div></li><li><div class=\"code-word\">        res.write(<span class=\"hljs-string\">\\`<span class=\"hljs-subst\">${sum}</span>\\`</span>);\n</div></li><li><div class=\"code-word\">        res.end(); \n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * 从 0 计算到 500000000 的和\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">startCount</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> rp.get(<span class=\"hljs-string\">'http://127.0.0.1:5000'</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * 从 500000000 计算到 1000000000 之间的和\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextCount</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> rp.get(<span class=\"hljs-string\">'http://127.0.0.1:6000'</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 启动服务\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\">server.listen(<span class=\"hljs-number\">4000</span>, () =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'server start http://127.0.0.1:4000'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1580\">\n                      代码中使用到了 Promise.all 来异步执行两个函数 startCount\n                      和 nextCount，待 2\n                      个异步执行结果返回后再计算求和。其中两个函数 startCount 和\n                      nextCount 中的 rp.get 地址分别是：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:5000</span>\n</div></li><li><div class=\"code-word\">http:<span class=\"hljs-comment\">//127.0.0.1:6000</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1582\">\n                      其实是两个新的进程分别计算两个求和的逻辑，具体以 5000\n                      端口的逻辑为例看下，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 创建 http 服务，简单返回\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">let</span> sum = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">500000000</span>; i++){\n</div></li><li><div class=\"code-word\">        sum = sum + i;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    res.write(<span class=\"hljs-string\">\\`<span class=\"hljs-subst\">${sum}</span>\\`</span>);\n</div></li><li><div class=\"code-word\">    res.end();\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> * \n</div></li><li><div class=\"code-word\"> * 启动服务\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\">server.listen(<span class=\"hljs-number\">5000</span>, () =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'server start http://127.0.0.1:5000'</span>);\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1584\">\n                      接下来我们分别打开三个命令行窗口，使用以下命令分别启动三个服务：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">node startServer.js\n</div></li><li><div class=\"code-word\">node nextServer.js&nbsp;\n</div></li><li><div class=\"code-word\">node async.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1586\">\n                      启动成功后，再运行如下命令，查看执行时间：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">time curl http:<span class=\"hljs-comment\">//127.0.0.1:4000</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1588\">运行成功后，你可以看到如下结果：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-number\">499999999075959400</span>\n</div></li><li><div class=\"code-word\">real&nbsp; &nbsp; <span class=\"hljs-number\">0</span>m0<span class=\"hljs-number\">.575</span>s\n</div></li><li><div class=\"code-word\">user&nbsp; &nbsp; <span class=\"hljs-number\">0</span>m0<span class=\"hljs-number\">.004</span>s\n</div></li><li><div class=\"code-word\">sys&nbsp; &nbsp; &nbsp;<span class=\"hljs-number\">0</span>m0<span class=\"hljs-number\">.005</span>s\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1590\">\n                      结果还是一致的，但是运行时间缩减了一半，大大地提升了执行效率。\n                    </p>\n                    <h4 data-nodeid=\"1591\">响应分析</h4>\n                    <p data-nodeid=\"1592\">\n                      两个服务的执行时间相差一半，因为异步网络 I/O 充分利用了\n                      Node.js 的异步事件驱动能力，将耗时 CPU\n                      计算逻辑给到其他进程来处理，而无须等待耗时 CPU\n                      计算，可以直接处理其他请求或者其他部分逻辑。第一种同步执行的方式就无法去处理其逻辑，导致性能受到影响。\n                    </p>\n                    <p data-nodeid=\"1593\">\n                      如果使用压测还可以使对比效果更加明显，我将在第 12\n                      讲为你详细介绍关于压测使用以及分析过程。\n                    </p>\n                    <h3 data-nodeid=\"1594\">单线程/多线程</h3>\n                    <p data-nodeid=\"1595\">\n                      我相信在面试过程中，面试官经常会问这个问题“Node.js\n                      是单线程的还是多线程的”。\n                    </p>\n                    <p data-nodeid=\"1596\">学完上面的内容后，你就可以回答了。</p>\n                    <blockquote data-nodeid=\"1597\">\n                      <p data-nodeid=\"1598\">\n                        主线程是单线程执行的，但是 Node.js\n                        存在多线程执行，多线程包括 setTimeout 和异步 I/O\n                        事件。其实 Node.js\n                        还存在其他的线程，包括垃圾回收、内存优化等。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1599\">\n                      这里也可以解释我们前面提到的第 4 个问题，<strong\n                        data-nodeid=\"1795\"\n                        >主要还是主线程来循环遍历当前事件</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"1600\">总结</h3>\n                    <p data-nodeid=\"1601\">\n                      本讲主要介绍了 Node.js\n                      事件循环机制和原理，然后通过实践对比了两种情况下的性能耗时，并且说明了异步事件循环驱动的好处。学完本讲以后，你就可以掌握\n                      Node.js 的事件循环原理，也可以掌握如何充分利用 Node.js\n                      的事件循环原理的优势。\n                    </p>\n                    <p data-nodeid=\"1602\">\n                      你可以自行思考下这个问题：浏览器的事件循环原理和 Node.js\n                      事件循环原理的区别以及联系有哪些点，欢迎你把答案写在评论区。\n                    </p>\n                    <p data-nodeid=\"1603\">\n                      本讲就到这了，下一讲我会为你介绍服务端研发的 RPC\n                      服务的知识点。\n                    </p>\n                    <hr data-nodeid=\"1604\" />\n                    <p data-nodeid=\"1605\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"1804\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"1803\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"1606\">\n                      <strong data-nodeid=\"1808\">《大前端高薪训练营》</strong>\n                    </p>\n                    <p data-nodeid=\"1607\" class=\"\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"1812\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}