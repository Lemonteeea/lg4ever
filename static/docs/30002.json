{"title":"01 | JSX 代码是如何“摇身一变”成为 DOM 的？","context":"\n                    <p data-nodeid=\"1113\" class=\"\">\n                      时下虽然接入 JSX\n                      语法的框架越来越多，但与之缘分最深的毫无疑问仍然是\n                      React。2013 年，当 React 带着 JSX 横空出世时，社区曾对 JSX\n                      有过不少的争议，但如今，越来越多的人面对 JSX\n                      都要说上一句“真香”！本课时我们就来一起认识下这个“真香”的\n                      JSX，聊一聊“JSX 代码是如何‘摇身一变’成为 DOM 的”。\n                    </p>\n                    <h3 data-nodeid=\"1114\">关于 JSX 的 3 个“大问题”</h3>\n                    <p data-nodeid=\"1115\">\n                      在日常的 React 开发工作中，我们已经习惯了使用 JSX 来描述\n                      React 的组件内容。关于 JSX 语法本身，相信每位 React\n                      开发者都不陌生。这里我用一个简单的 React\n                      组件，来帮你迅速地唤醒自己脑海中与 JSX\n                      相关的记忆。下面这个组件中的 render 方法返回值，就是用 JSX\n                      代码来填充的：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-dom\"</span>;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"App\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"title\"</span>&gt;</span>I am the title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span>I am the content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> rootElement = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"root\"</span>);\n</div></li><li><div class=\"code-word\">ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>, rootElement);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1117\">\n                      由于本专栏的整体目标是帮助你在 React\n                      这个领域完成从“小工”到“行家”的进阶，此处我无意再去带你反复咀嚼\n                      JSX 的基础语法，而是希望能够引导你去探寻 JSX\n                      背后的故事。针对这“背后的故事”，我总结了 3\n                      个最具代表性和区分度的问题。\n                    </p>\n                    <p data-nodeid=\"1118\">\n                      在开始正式讲解之前，我希望你能在自己心中尝试回答这 3\n                      个问题：\n                    </p>\n                    <ul data-nodeid=\"1119\">\n                      <li data-nodeid=\"1120\">\n                        <p data-nodeid=\"1121\">\n                          JSX 的本质是什么，它和 JS 之间到底是什么关系？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1122\">\n                        <p data-nodeid=\"1123\">\n                          为什么要用 JSX？不用会有什么后果？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1124\">\n                        <p data-nodeid=\"1125\">\n                          JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1126\">\n                      面对以上问题，如果你无法形成清晰且系统的思路，那么很可能是你把\n                      JSX\n                      想得过于简单了。大多数人只是简单地把它理解为模板语法的一种，但事实上，JSX\n                      作为 React 框架的一大特色，它与 React\n                      本身的运作机制之间存在着千丝万缕的联系。\n                    </p>\n                    <p data-nodeid=\"1127\">\n                      上述 3\n                      个问题的答案，就恰恰隐藏在这层“联系”中，在面试场景下，候选人对这层“联系”吃得透不透，是我们评价其在\n                      React 方面是否“资深”的一个重要依据。\n                    </p>\n                    <p data-nodeid=\"1128\">\n                      接下来，我就将带你由表及里地起底 JSX\n                      相关的底层原理，帮助你吃透这层“联系”，建立起强大的理论自信。你可以将“能够用自己的话回答上面\n                      3\n                      个问题”来作为本课时的学习目标，待课时结束后，记得回来检验自己的学习成果^_^。\n                    </p>\n                    <h3 data-nodeid=\"1129\">\n                      JSX 的本质：JavaScript 的语法扩展\n                    </h3>\n                    <p data-nodeid=\"1130\">\n                      JSX 到底是什么，我们先来看看\n                      <a\n                        href=\"https://reactjs.org/docs/glossary.html#jsx\"\n                        data-nodeid=\"1217\"\n                        >React 官网</a\n                      >给出的一段定义：\n                    </p>\n                    <blockquote data-nodeid=\"1131\">\n                      <p data-nodeid=\"1132\">\n                        JSX 是 JavaScript\n                        的一种语法扩展，它和模板语言很接近，但是它充分具备\n                        JavaScript 的能力。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1133\">\n                      “语法扩展”这一点在理解上几乎不会产生歧义，不过“它充分具备\n                      JavaScript 的能力”这句，却总让人摸不着头脑，JSX 和 JS\n                      怎么看也不像是一路人啊？这就引出了“<strong\n                        data-nodeid=\"1225\"\n                        >JSX 语法是如何在 JavaScript 中生效的</strong\n                      >”这个问题。\n                    </p>\n                    <h4 data-nodeid=\"1134\">\n                      JSX 语法是如何在 JavaScript 中生效的：认识 Babel\n                    </h4>\n                    <p data-nodeid=\"1135\">\n                      Facebook 公司给 JSX 的定位是 JavaScript 的“扩展”，而非\n                      JavaScript\n                      的“某个版本”，这就直接决定了浏览器并不会像天然支持\n                      JavaScript 一样地支持 JSX。那么，JSX 的语法是如何在\n                      JavaScript 中生效的呢？<a\n                        href=\"https://reactjs.org/docs/glossary.html#jsx\"\n                        data-nodeid=\"1230\"\n                        >React 官网</a\n                      >其实早已给过我们线索：\n                    </p>\n                    <blockquote data-nodeid=\"1136\">\n                      <p data-nodeid=\"1137\">\n                        JSX 会被编译为\n                        React.createElement()，&nbsp;React.createElement()\n                        将返回一个叫作“React Element”的 JS 对象。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1138\">\n                      这里提到，JSX 在被<strong data-nodeid=\"1238\">编译</strong\n                      >后，会变成一个针对 React.createElement\n                      的调用，此时你大可不必急于关注 React.createElement 这个\n                      API\n                      到底做了什么（下文会单独讲解）。咱们先来说说这个“编译”是怎么回事：“编译”这个动作，是由\n                      Babel 来完成的。\n                    </p>\n                    <p data-nodeid=\"1139\">\n                      <strong data-nodeid=\"1242\">什么是 Babel 呢？</strong>\n                    </p>\n                    <blockquote data-nodeid=\"1140\">\n                      <p data-nodeid=\"1141\">\n                        Babel 是一个工具链，主要用于将 ECMAScript 2015+\n                        版本的代码转换为向后兼容的 JavaScript\n                        语法，以便能够运行在当前和旧版本的浏览器或其他环境中。<br />\n                        —— Babel 官网\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1142\">\n                      比如说，ES2015+\n                      版本推出了一种名为“模板字符串”的新语法，这种语法在一些低版本的浏览器里并不兼容。下面是一段模板字符串的示例代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"Guy Fieri\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> place = <span class=\"hljs-string\">\"Flavortown\"</span>;\n</div></li><li><div class=\"code-word\">\\`Hello ${name}, ready <span class=\"hljs-keyword\">for</span> ${place}?\\`;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1144\">\n                      Babel\n                      就可以帮我们把这段代码转换为大部分低版本浏览器也能够识别的\n                      ES5 代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"Guy Fieri\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> place = <span class=\"hljs-string\">\"Flavortown\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-string\">\"Hello \"</span>.concat(name, <span class=\"hljs-string\">\", ready for \"</span>).concat(place, <span class=\"hljs-string\">\"?\"</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1146\">\n                      类似的，<strong data-nodeid=\"1255\"\n                        >Babel 也具备将 JSX 语法转换为 JavaScript\n                        代码的能力</strong\n                      >。<br />\n                      那么 Babel 具体会将 JSX 处理成什么样子呢？我们不如直接打开\n                      Babel 的 playground\n                      来看一看。这里我仍然键入文章开头示例代码中的JSX 部分：\n                    </p>\n                    <p data-nodeid=\"1147\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5C/73/CgqCHl-BegWAbxNEAAH9HxafvWE988.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"1258\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1148\">\n                      可以看到，所有的 JSX 标签都被转化成了 React.createElement\n                      调用，这也就意味着，我们写的 JSX 其实写的就是\n                      React.createElement，虽然它看起来有点像\n                      HTML，但也只是“看起来像”而已。<strong data-nodeid=\"1272\"\n                        >JSX 的本质是</strong\n                      >React.createElement<strong data-nodeid=\"1273\"\n                        >这个 JavaScript 调用的语法糖</strong\n                      >，这也就完美地呼应上了 React 官方给出的“<strong\n                        data-nodeid=\"1274\"\n                        >JSX 充分具备 JavaScript 的能力</strong\n                      >”这句话。\n                    </p>\n                    <h4 data-nodeid=\"1149\">React 选用 JSX 语法的动机</h4>\n                    <p data-nodeid=\"1150\">\n                      换个角度想想，既然 JSX 等价于一次 React.createElement\n                      调用，那么 React 官方为什么不直接引导我们用\n                      React.createElement 来创建元素呢？\n                    </p>\n                    <p data-nodeid=\"1151\">\n                      原因非常简单，我们来看一个相对复杂一些的组件的 JSX 代码和\n                      React.createElement\n                      调用之间的对比。它们各自的形态如下图所示，图中左侧是 JSX\n                      代码，右侧是 React.createElement 调用：\n                    </p>\n                    <p data-nodeid=\"1152\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5C/73/CgqCHl-Beg-AXBihAA4t3S7nxKc532.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"1280\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1153\">\n                      你会发现，在实际功能效果一致的前提下，JSX\n                      代码层次分明、嵌套关系清晰；而 React.createElement\n                      代码则给人一种非常混乱的“杂糅感”，这样的代码不仅读起来不友好，写起来也费劲。\n                    </p>\n                    <p data-nodeid=\"1154\">\n                      <strong data-nodeid=\"1285\"\n                        >JSX 语法糖允许前端开发者使用我们最为熟悉的类 HTML\n                        标签语法来创建虚拟\n                        DOM，在降低学习成本的同时，也提升了研发效率与研发体验。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1155\">\n                      读到这里，相信你已经充分理解了“<strong data-nodeid=\"1291\"\n                        >JSX 是 JavaScript\n                        的一种语法扩展，它和模板语言很接近，但是它充分具备\n                        JavaScript 的能力</strong\n                      >。&nbsp;”这一定义背后的深意。那么我们文中反复提及的\n                      React.createElement\n                      又是何方神圣呢？下面我们就深入相关源码来一窥究竟。\n                    </p>\n                    <h3 data-nodeid=\"1156\">\n                      JSX 是如何映射为 DOM 的：起底 createElement 源码\n                    </h3>\n                    <p data-nodeid=\"1157\">\n                      在分析开始之前，你可以先尝试阅读我追加进源码中的逐行代码解析，大致理解\n                      createElement 中每一行代码的作用：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">/**\n</span></div></li><li><div class=\"code-word\"> 101. React的创建元素方法\n</div></li><li><div class=\"code-word\"> */\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">createElement</span><span class=\"hljs-params\">(type, config, children)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// propName 变量用于储存后面需要用到的元素属性</span>\n</div></li><li><div class=\"code-word\">  let propName; \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// props 变量用于储存元素属性的键值对集合</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> props = {}; \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// key、ref、self、source 均为 React 元素的属性，此处不必深究</span>\n</div></li><li><div class=\"code-word\">  let key = <span class=\"hljs-keyword\">null</span>;\n</div></li><li><div class=\"code-word\">  let ref = <span class=\"hljs-keyword\">null</span>; \n</div></li><li><div class=\"code-word\">  let self = <span class=\"hljs-keyword\">null</span>; \n</div></li><li><div class=\"code-word\">  let source = <span class=\"hljs-keyword\">null</span>; \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// config 对象中存储的是元素的属性</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (config != <span class=\"hljs-keyword\">null</span>) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (hasValidRef(config)) {\n</div></li><li><div class=\"code-word\">      ref = config.ref;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 此处将 key 值字符串化</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (hasValidKey(config)) {\n</div></li><li><div class=\"code-word\">      key = <span class=\"hljs-string\">''</span> + config.key; \n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    self = config.__self === undefined ? <span class=\"hljs-keyword\">null</span> : config.__self;\n</div></li><li><div class=\"code-word\">    source = config.__source === undefined ? <span class=\"hljs-keyword\">null</span> : config.__source;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (propName in config) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 筛选出可以提进 props 对象里的属性</span>\n</div></li><li><div class=\"code-word\">        hasOwnProperty.call(config, propName) &amp;&amp;\n</div></li><li><div class=\"code-word\">        !RESERVED_PROPS.hasOwnProperty(propName) \n</div></li><li><div class=\"code-word\">      ) {\n</div></li><li><div class=\"code-word\">        props[propName] = config[propName]; \n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> childrenLength = arguments.length - <span class=\"hljs-number\">2</span>; \n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (childrenLength === <span class=\"hljs-number\">1</span>) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 直接把这个参数的值赋给props.children</span>\n</div></li><li><div class=\"code-word\">    props.children = children; \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 处理嵌套多个子元素的情况</span>\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (childrenLength &gt; <span class=\"hljs-number\">1</span>) { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 声明一个子元素数组</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> childArray = Array(childrenLength); \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 把子元素推进数组里</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i &lt; childrenLength; i++) { \n</div></li><li><div class=\"code-word\">      childArray[i] = arguments[i + <span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 最后把这个数组赋值给props.children</span>\n</div></li><li><div class=\"code-word\">    props.children = childArray; \n</div></li><li><div class=\"code-word\">  } \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 defaultProps</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (type &amp;&amp; type.defaultProps) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> defaultProps = type.defaultProps;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (propName in defaultProps) { \n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (props[propName] === undefined) {\n</div></li><li><div class=\"code-word\">        props[propName] = defaultProps[propName];\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> ReactElement(\n</div></li><li><div class=\"code-word\">    type,\n</div></li><li><div class=\"code-word\">    key,\n</div></li><li><div class=\"code-word\">    ref,\n</div></li><li><div class=\"code-word\">    self,\n</div></li><li><div class=\"code-word\">    source,\n</div></li><li><div class=\"code-word\">    ReactCurrentOwner.current,\n</div></li><li><div class=\"code-word\">    props,\n</div></li><li><div class=\"code-word\">  );\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"1159\">\n                      上面是对源码细节的初步展示，接下来我会带你逐步提取源码中的关键知识点和核心思想。\n                    </p>\n                    <h4 data-nodeid=\"1160\">\n                      入参解读：创造一个元素需要知道哪些信息\n                    </h4>\n                    <p data-nodeid=\"1161\">我们先来看看方法的入参：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">export function <span class=\"hljs-title\">createElement</span><span class=\"hljs-params\">(type, config, children)</span>\n</span></div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1163\">\n                      createElement 有 3 个入参，这 3 个入参囊括了 React\n                      创建一个元素所需要知道的全部信息。\n                    </p>\n                    <ul data-nodeid=\"1164\">\n                      <li data-nodeid=\"1165\">\n                        <p data-nodeid=\"1166\">\n                          type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准\n                          HTML 标签字符串，也可以是 React 组件类型或 React\n                          fragment 类型。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1167\">\n                        <p data-nodeid=\"1168\">\n                          config：以对象形式传入，组件所有的属性都会以键值对的形式存储在\n                          config 对象中。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1169\">\n                        <p data-nodeid=\"1170\">\n                          children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1171\">\n                      如果文字描述使你觉得抽象，下面这个调用示例可以帮你增进对概念的理解：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">React.createElement(<span class=\"hljs-string\">\"ul\"</span>, {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 传入属性键值对</span>\n</div></li><li><div class=\"code-word\">  className: <span class=\"hljs-string\">\"list\"</span>\n</div></li><li><div class=\"code-word\">   <span class=\"hljs-comment\">// 从第三个入参开始往后，传入的参数都是 children</span>\n</div></li><li><div class=\"code-word\">}, React.createElement(<span class=\"hljs-string\">\"li\"</span>, {\n</div></li><li><div class=\"code-word\">  key: <span class=\"hljs-string\">\"1\"</span>\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-string\">\"1\"</span>), React.createElement(<span class=\"hljs-string\">\"li\"</span>, {\n</div></li><li><div class=\"code-word\">  key: <span class=\"hljs-string\">\"2\"</span>\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-string\">\"2\"</span>));\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1173\">这个调用对应的 DOM 结构如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;ul className=<span class=\"hljs-string\">\"list\"</span>&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"1\"</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/ul&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1175\">\n                      对入参的形式和内容有了大致的把握之后，下面我们继续来讲解\n                      createElement 的函数逻辑。\n                    </p>\n                    <h4 data-nodeid=\"1176\">createElement 函数体拆解</h4>\n                    <p data-nodeid=\"1177\" class=\"\">\n                      前面你已经阅读过 createElement\n                      源码细化到每一行的解读，这里我想和你探讨的是\n                      createElement<strong data-nodeid=\"1310\"\n                        >在逻辑层面的任务流转</strong\n                      >。针对这个过程，我为你总结了下面这张流程图：\n                    </p>\n                    <p data-nodeid=\"1178\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5C/69/Ciqc1F-BeuGAepNsAACqreYXrj0410.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1313\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1179\">\n                      这个流程图，或许会打破不少同学对 createElement\n                      的幻想。<strong data-nodeid=\"1323\"\n                        >在实际的面试场景下，许多候选人由于缺乏对源码的了解，谈及\n                        createElement 时总会倾向于去夸大它的“工作量”</strong\n                      >。但其实，相信你也已经发现了，createElement\n                      中并没有十分复杂的涉及算法或真实 DOM 的逻辑，它的<strong\n                        data-nodeid=\"1324\"\n                        >每一个步骤几乎都是在格式化数据</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1180\">\n                      说得更直白点，createElement 就像是开发者和 ReactElement\n                      调用之间的一个“<strong data-nodeid=\"1334\">转换器</strong\n                      >”、一个<strong data-nodeid=\"1335\">数据处理层</strong\n                      >。它可以从开发者处接受相对简单的参数，然后将这些参数按照\n                      ReactElement 的预期做一层格式化，最终通过调用 ReactElement\n                      来实现元素的创建。整个过程如下图所示：\n                    </p>\n                    <p data-nodeid=\"1181\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5C/69/Ciqc1F-BevGANuu4AACN5mBDMlg569.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"1338\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1182\">\n                      现在看来，createElement\n                      原来只是个“参数中介”。此时我们的注意力自然而然地就聚焦在了\n                      ReactElement 上，接下来我们就乘胜追击，一起去挖一挖\n                      ReactElement 的源码吧！\n                    </p>\n                    <h4 data-nodeid=\"1183\">出参解读：初识虚拟 DOM</h4>\n                    <p data-nodeid=\"1184\">\n                      上面已经分析过，createElement 执行到最后会 return 一个针对\n                      ReactElement 的调用。这里关于\n                      ReactElement，我依然先给出源码 + 注释形式的解析：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ReactElement = function(type, key, ref, self, source, owner, props) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> element = {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span>\n</div></li><li><div class=\"code-word\">    $$typeof: REACT_ELEMENT_TYPE,\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 内置属性赋值</span>\n</div></li><li><div class=\"code-word\">    type: type,\n</div></li><li><div class=\"code-word\">    key: key,\n</div></li><li><div class=\"code-word\">    ref: ref,\n</div></li><li><div class=\"code-word\">    props: props,\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录创造该元素的组件</span>\n</div></li><li><div class=\"code-word\">    _owner: owner,\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// </span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (__DEV__) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> element;\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1186\">\n                      ReactElement\n                      的代码出乎意料的简短，从逻辑上我们可以看出，ReactElement\n                      其实只做了一件事情，那就是“<strong data-nodeid=\"1351\"\n                        >创建</strong\n                      >”，说得更精确一点，是“<strong data-nodeid=\"1352\"\n                        >组装</strong\n                      >”：ReactElement 把传入的参数按照一定的规范，“组装”进了\n                      element 对象里，并把它返回给了 React.createElement，最终\n                      React.createElement\n                      又把它交回到了开发者手中。整个过程如下图所示：\n                    </p>\n                    <p data-nodeid=\"1187\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5C/74/CgqCHl-Bex6AM5rhAACJMrix5bk913.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"1355\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1188\">\n                      如果你想要验证这一点，可以尝试输出我们示例中 App 组件的\n                      JSX 部分：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> AppJSX = (<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"App\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"title\"</span>&gt;</span>I am the title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span>I am the content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">console</span>.log(AppJSX)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1190\">\n                      你会发现它确实是一个标准的 ReactElement\n                      对象实例，如下图（生产环境下的输出结果）所示：\n                    </p>\n                    <p data-nodeid=\"1191\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5C/69/Ciqc1F-BezKAW4rXAAIUYQW6Lk0911.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"1360\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1192\">\n                      这个 ReactElement 对象实例，本质上是<strong\n                        data-nodeid=\"1370\"\n                        >以 JavaScript 对象形式存在的对 DOM 的描述</strong\n                      >，也就是老生常谈的“虚拟 DOM”（<strong data-nodeid=\"1371\"\n                        >准确地说，是虚拟 DOM 中的一个节点</strong\n                      >。关于虚拟 DOM，\n                      我们将在专栏的“模块二：核心原理”中花大量的篇幅来研究它，此处你只需要能够结合源码，形成初步认知即可）。\n                    </p>\n                    <p data-nodeid=\"1193\">\n                      既然是“虚拟 DOM”，那就意味着和渲染到页面上的真实 DOM\n                      之间还有一些距离，这个“距离”，就是由大家喜闻乐见的<strong\n                        data-nodeid=\"1377\"\n                        >ReactDOM.render</strong\n                      >方法来填补的。\n                    </p>\n                    <p data-nodeid=\"1194\">\n                      在每一个 React 项目的入口文件中，都少不了对 React.render\n                      函数的调用。下面我简单介绍下 ReactDOM.render\n                      方法的入参规则：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">ReactDOM.render(\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 需要渲染的元素（ReactElement）</span>\n</div></li><li><div class=\"code-word\">    element, \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 元素挂载的目标容器（一个真实DOM）</span>\n</div></li><li><div class=\"code-word\">    container,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 回调函数，可选参数，可以用来处理渲染结束后的逻辑</span>\n</div></li><li><div class=\"code-word\">    [callback]\n</div></li><li><div class=\"code-word\">)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1196\">\n                      ReactDOM.render 方法可以接收 3 个参数，其中<strong\n                        data-nodeid=\"1388\"\n                        >第二个参数就是一个真实的 DOM 节点</strong\n                      >，<strong data-nodeid=\"1389\"\n                        >这个真实的 DOM 节点充当“容器”的角色</strong\n                      >，React\n                      元素最终会被渲染到这个“容器”里面去。比如，示例中的 App\n                      组件，它对应的 render 调用是这样的：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> rootElement = document.getElementById(<span class=\"hljs-string\">\"root\"</span>);\n</div></li><li><div class=\"code-word\">ReactDOM.render(&lt;App /&gt;, rootElement);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1198\">\n                      注意，这个真实 DOM 一定是确实存在的。比如，在 App\n                      组件对应的 index.html 中，已经提前预置 了 id 为 root\n                      的根节点：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;body&gt;\n</div></li><li><div class=\"code-word\">    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"root\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/body&gt;\n</div></li></ol></code></pre>\n                    </div>\n            "}