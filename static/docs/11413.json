{"title":"11&nbsp;| 贪心：这种思想，没有模板，如何才能掌握它？","context":"\n                    <p data-nodeid=\"95200\" class=\"\">\n                      贪心算法（Greedy\n                      Algorithms）指的是求解问题时，总是做出在当前看来是最好的选择。\n                      一个全局最优解可以通过选择局部最优解来达到。\n                    </p>\n                    <p data-nodeid=\"95201\">\n                      贪心算法的运用非常广泛，比如哈夫曼（Huffman）树，单源最短路径（Dijkstra），构建最小生成树的\n                      Prim 算法和 Kruskal 算法等。\n                    </p>\n                    <p data-nodeid=\"95202\">学完这一讲，你将会收获：</p>\n                    <ul data-nodeid=\"95203\">\n                      <li data-nodeid=\"95204\">\n                        <p data-nodeid=\"95205\">贪心算法类题目的特点</p>\n                      </li>\n                      <li data-nodeid=\"95206\">\n                        <p data-nodeid=\"95207\">贪心算法的解题思路</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95208\">\n                      <em data-nodeid=\"95531\"\n                        >注：贪心算法没有模板可以套，其重点在于对题目的分析，对结论的推导。因此，这一讲，我们不再延用“模拟、规律、匹配、画图”四步分析法，而是将重点放在介绍一些题目是如何演变而来的，以及如何推导出贪心所用的结论。我会尝试用尽量少的数学公式，且让你能看懂的方式来讲解。</em\n                      >\n                    </p>\n                    <h3 data-nodeid=\"95209\">贪心的特点</h3>\n                    <p data-nodeid=\"95210\">\n                      面试中考察贪心算法的题目必然具备以下<strong\n                        data-nodeid=\"95543\"\n                        >2 个特点，<strong data-nodeid=\"95542\">这里我用</strong\n                        >最通俗的话</strong\n                      >给你描述。\n                    </p>\n                    <h4 data-nodeid=\"95211\">特点 1：只选局部最优解</h4>\n                    <p data-nodeid=\"95212\">\n                      在求解过程中，我们可以通过<strong data-nodeid=\"95550\"\n                        >每一步都选择最优解</strong\n                      >，最终得到整个问题的最优解。下面我们通过一个简单的题目：寻找数组中最大的数，进一步说明一下这个特点。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxValue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> maxValue = Integer.MIN_VALUE; <span class=\"hljs-comment\">// 初始集合里面的最大值</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">    maxValue = Math.max(maxValue, A[i]);  <span class=\"hljs-comment\">// 迭代当前最优解</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> maxValue; <span class=\"hljs-comment\">// 结束后，当前最优解变身全局最优解。</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95214\">\n                      <strong data-nodeid=\"95557\">首先：</strong>\n                      在一个初始集（这里是一个空集），设置一个初始解。在这里，我们设置为\n                      Integer.MIN_VALUE。\n                    </p>\n                    <p data-nodeid=\"95215\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/C9/CioPOWBm7DyAevBHAAB4d_r01V8988.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"95560\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95216\">\n                      <strong data-nodeid=\"95565\">迭代</strong\n                      >：当有新元素进来的时候，我们需要迭代当前最优解。迭代后的最优解是已知数据的最优解。\n                    </p>\n                    <p data-nodeid=\"95217\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/C9/CioPOWBm7EOAYHjdAACrP3SVk1w191.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"95568\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95218\">\n                      <strong data-nodeid=\"95581\">答案</strong\n                      >：当处理完所有的数据之后，<strong data-nodeid=\"95582\"\n                        >当前最优解</strong\n                      >立马<strong data-nodeid=\"95583\">变身全局最优解</strong>。\n                    </p>\n                    <p data-nodeid=\"95219\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7KuAMBTnAACDRzs75_E116.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"95586\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95220\">\n                      <em data-nodeid=\"95590\"\n                        >由此，我们也可以看出，贪心算法在操作的时候，总是把局部次优解直接扔掉，保留局部最优解，最终得到整个问题的最优解。</em\n                      >\n                    </p>\n                    <h4 data-nodeid=\"95221\">特点 2：不能“逆袭”</h4>\n                    <p data-nodeid=\"95222\">\n                      下面我们用一道题目说明<strong data-nodeid=\"95597\"\n                        >什么是“逆袭”</strong\n                      >。给定如下图所示的图形，从上往下走的时候，只能走到相邻格子的左边或者右边。求从顶部走到底部的最大和。\n                    </p>\n                    <p data-nodeid=\"95223\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7LSAaCRaAADJvxICzaI478.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"95600\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95224\">\n                      比如，这里我们给出合法与不合法的两种情况，如下图所示：\n                    </p>\n                    <p data-nodeid=\"95225\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7LuAEeDiAAEUHK2pjOY488.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"95604\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95226\">\n                      如果使用贪心算法求解这个问题，你可以结合下图进行思考：\n                    </p>\n                    <p data-nodeid=\"95227\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7MGALOGVAADo12H0WNA033.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"95608\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95228\">\n                      如果在每一步，我们总是选择当前能选择的最大值，那么得到的解就不是最优解。因为最优解是\n                      2 + 3 + 100 = 105。\n                    </p>\n                    <p data-nodeid=\"95229\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7MeAa4e_AAEETkRZECs168.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"95612\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95230\">\n                      那么问题出在哪里？这是因为在第二层有一个<strong\n                        data-nodeid=\"95618\"\n                        >次优解</strong\n                      >\n                      2 + 3，在第三层能够从 3 跳到\n                      100，最终变成整个问题的最优解。\n                    </p>\n                    <p data-nodeid=\"95231\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7M6AWo3fAADom4u66Ss987.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"95621\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95232\">\n                      因此，在利用贪心算法的时候，必须要满足“<strong\n                        data-nodeid=\"95627\"\n                        >不能逆袭</strong\n                      >”的特性：\n                    </p>\n                    <blockquote data-nodeid=\"95233\">\n                      <p data-nodeid=\"95234\">\n                        局部次优解不能反超，不能成为问题的最终最优解！\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95235\">\n                      <em data-nodeid=\"95632\"\n                        >注：这里我只是用一个例子来说明“不能逆袭”的特性，你能够意会到这种“次优解反超的特点”即可。</em\n                      >\n                    </p>\n                    <h4 data-nodeid=\"95236\">记忆</h4>\n                    <p data-nodeid=\"95237\">\n                      在生活中，有一句有趣的歌诀形象地表现了贪心算法的特点：龙生龙，凤生凤，老鼠生儿会打洞。\n                    </p>\n                    <p data-nodeid=\"95238\">\n                      之前的最优解“龙”生成新的“龙”，依然处在食物链的高层，最后得出的仍然是最优解。而次优解“凤”和“老鼠”通过繁育是无法完成“逆袭”的，因此无法变成最优解。\n                    </p>\n                    <p data-nodeid=\"95239\">\n                      另外，贪心算法的题目比较依赖一些现有的结论。在日常学习算法和数据结构的过程中，你要特别注意总结经验和积累结论。下面我们一起通过几道例题深入学习贪心算法，然后我还会带你总结出一些有趣的结论。\n                    </p>\n                    <h3 data-nodeid=\"95240\">例 1：木桶装水</h3>\n                    <p data-nodeid=\"95241\">\n                      【<strong data-nodeid=\"95647\">题目</strong\n                      >】给定一个数组，表示不同的木板的高度，在装水的时候，你可以选择<strong\n                        data-nodeid=\"95648\"\n                        >两根木板</strong\n                      >，然后装满水，在不能倾斜的情况下，里面能装多少水，应该由较短的木板决定。请问最多能装多少水？\n                    </p>\n                    <p data-nodeid=\"95242\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7NeAbj76AAQd0dopTpA832.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"95651\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95243\">输入：A = [1, 0, 1, 1, 0]</p>\n                    <p data-nodeid=\"95244\">输出：3</p>\n                    <p data-nodeid=\"95245\">\n                      解释：你可以选择 index = 0 和 index = 3，由于高度都为\n                      1，宽度为 3，装水为 3 x 1 = 3。这样组合装的水最多。\n                    </p>\n                    <p data-nodeid=\"95246\">\n                      【<strong data-nodeid=\"95663\">分析</strong\n                      >】在正式求解这道题目之前，我们先从一些简单的题目进行展开。比如我们非常熟悉的：求一个数组中的最大值。相信你拿到这道题目就可以开始写代码了：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMaxValue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> ans = Integer.MIN_VALUE;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">    ans = Math.max(ans, A[i]);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95248\">\n                      如果我们仔细观察上述解法，可以发现贪心算法成立的关键在于：贪心的策略保证了在已知求解范围（绿色）区域里面始终是最大的。如下图所示：\n                    </p>\n                    <p data-nodeid=\"95249\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/C3/Cgp9HWBm8cmAJOBqAAC4ja2Veks049.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"95667\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95250\">\n                      在这个解法里面，我们采用的是从一侧推进来求最大值，如果我问你，是否有其他我们已经学过的办法可以解决这道题目呢？答案就是“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6699\"\n                        data-nodeid=\"95673\"\n                        >10 |\n                        双指针：如何掌握解决最长，定长，最短区间问题的决窍？</a\n                      >”介绍的<strong data-nodeid=\"95679\">双指针</strong\n                      >。我们可以利用双指针从数组的两侧来推进，求解这个数组的最大值，代码可以写成如下这样：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMaxValue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A<span class=\"hljs-comment\">/*输入保证非空*/</span>)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, j = N - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (i &lt; j) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (A[i] &gt; A[j]) {\n</div></li><li><div class=\"code-word\">      j--;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      i++;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> A[i];\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95252\">\n                      如果用比武打个比方，这种思路的依据就是每次取两个人来比武，胜者留下，那么留下来的当然是数组中的最大值。因此，可以得到<strong\n                        data-nodeid=\"95685\"\n                        >结论 1</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"95253\">\n                      <strong data-nodeid=\"95690\">结论 1</strong>：\n                    </p>\n                    <blockquote data-nodeid=\"95254\">\n                      <p data-nodeid=\"95255\">\n                        max(A[i]，A[j]) 就是 [0...i] 和 [j ... N)\n                        这两个区间里面的最大值。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95256\">\n                      前面我们都把注意力放在了较大的数。那么，有没有什么结论留给“较小的数”呢？\n                    </p>\n                    <p data-nodeid=\"95257\">\n                      实际上，对于较小的数，还有一个有用的结论。下面我们从头开始推导一下。\n                    </p>\n                    <p data-nodeid=\"95258\">\n                      首先，数组的最大值所在位置，最终肯定可以将数组切分成 3\n                      个区域，分别用 3\n                      种颜色来表示（如果数组中有多个同值的最大值，只需要挑一个出来当最大值即可）。但是具体如何切分，我们一开始并不清楚。\n                    </p>\n                    <p data-nodeid=\"95259\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/CB/CioPOWBm8jCASGnfAACa3H_KBpM205.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"95711\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95260\">\n                      但是，如果利用 i，j 左右同时向中间走，最大值一定出现在 [i,\n                      j] 这个范围里面，所以\n                      <strong data-nodeid=\"95722\"\n                        >[0, i) 区域肯定是绿色的，而 (j, N)\n                        区域肯定是红色的</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"95261\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/C3/Cgp9HWBm8jeAPZokAACCr2BAJUs411.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"95725\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95262\">\n                      那么，如果 A[i] &gt; A[j]，留给较小的数 A[j]\n                      的结论是什么呢？\n                    </p>\n                    <p data-nodeid=\"95263\">\n                      留下的便是<strong data-nodeid=\"95744\">结论 2</strong>：\n                    </p>\n                    <blockquote data-nodeid=\"95264\">\n                      <p data-nodeid=\"95265\">\n                        异色区域，大于等于 A[j] 且离 j 最远的元素就是 A[i]。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95266\">\n                      我们用反证法简略证明一下：假设程序执行到 A[i] &gt; A[j]\n                      成立，但是数组中有另外一个元素 0 &lt;= x &lt; i，并且 A[x]\n                      &gt; A[j] 成立。那么：\n                    </p>\n                    <ul data-nodeid=\"95267\">\n                      <li data-nodeid=\"95268\">\n                        <p data-nodeid=\"95269\">\n                          根据结论 1，[0, x] 区域，和 [j, N)\n                          区域里面的最大值必然是 max(A[x], A[j])；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95270\">\n                        <p data-nodeid=\"95271\">\n                          由于A[x] &gt; A[j]，所以 [0, x] 区域和 [j, N)\n                          区域里面的最大值必然是 A[x]；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95272\">\n                        <p data-nodeid=\"95273\">\n                          那么在执行算法的时候，当执行到 A[x] &gt; A[j]\n                          时，会接着执行 j--，也就是说，程序不可能执行到 A[i]\n                          &gt; A[j] 位置，这与假设矛盾。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95274\">\n                      当然，结论 2 也可以针对 A[i] &lt; A[j] 写成：\n                    </p>\n                    <blockquote data-nodeid=\"95275\">\n                      <p data-nodeid=\"95276\">\n                        异色区域，大于等于 A[i] 且离 i 最远的元素就是 A[j]。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95277\">\n                      那么利用结论\n                      2，我们能做什么呢？由于已经知道异色区域中更大的元素的位置。我们再回到原题，用木板装水的过程中，装水量是由最短的木板决定的。\n                    </p>\n                    <p data-nodeid=\"95278\">\n                      根据上述分析，我们是不是可以得出第三个结论：装水最多的时候，是否就是<strong\n                        data-nodeid=\"95854\"\n                        >异色且成对</strong\n                      >的 &lt;i, j&gt; 呢？我们假设该结论成立。\n                    </p>\n                    <p data-nodeid=\"95279\">\n                      <strong data-nodeid=\"95859\">结论 3</strong>：\n                    </p>\n                    <blockquote data-nodeid=\"95280\">\n                      <p data-nodeid=\"95281\">\n                        装水最多的时候，必定由异色区域两根木板来装。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95282\">\n                      但是你可能很快会找到一个反例。如下图所示（注意，不同位置的竖线高度，分别表示相应位置元素的值的大小）：\n                    </p>\n                    <p data-nodeid=\"97095\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/15/Cgp9HWCCh6uAG6fTAACBJOzbUF4404.png\"\n                        alt=\"2021423-163817.png\"\n                        data-nodeid=\"97098\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"95284\">\n                      在 j 的同侧，还有一个 A[k] 比 A[j] 稍大且 A[k]，A[j]\n                      离得很远。此时 A[i] 和 A[j] 装的水（1 号区域）肯定比 A[j]\n                      和 A[k] 装的水（2 号区域）少。\n                    </p>\n                    <p data-nodeid=\"95285\">\n                      但是，既然已经出现这种情况，那么可以肯定的是，此时 A[i]\n                      &gt; A[j] 且 A[i] &gt; A[k]。并且 A[k] &gt;\n                      A[j]，实际上可以得到一个更大的装水区域。即由 A[i]，A[k]\n                      形成的下图中 3 号区域：\n                    </p>\n                    <p data-nodeid=\"100889\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCCh7OACEAIAAB4ET8YQCk104.png\"\n                        alt=\"2021423-163823.png\"\n                        data-nodeid=\"100892\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"95287\">同样也得出结论 3 是成立的。</p>\n                    <p data-nodeid=\"95288\">\n                      那么根据结论\n                      3，我们就知道最优答案只能在异色区域里面选（可以想象成装水的水桶两根木板一定要不一样的颜色）。然后根据结论\n                      2，我们又可以知道每个元素 A[x] 在异色区域里面离 x\n                      最远且更大的是谁。那么这道题目就可以求解了。\n                    </p>\n                    <p data-nodeid=\"95289\">\n                      【<strong data-nodeid=\"95945\">代码</strong>】根据结论 2\n                      和结论 3 我们可以写出代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, j = N - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">while</span> (i &lt; j) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> height = Math.min(A[i], A[j]);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> width = j - i;\n</div></li><li><div class=\"code-word\">    ans = Math.max(ans, height * width);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (A[i] &gt; A[j]) {\n</div></li><li><div class=\"code-word\">      j--;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      i++;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"95291\">\n                      <p data-nodeid=\"95292\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"95949\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"95953\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"95957\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95293\">\n                      <strong data-nodeid=\"95962\">复杂度分析</strong\n                      >：双指针左右同时遍历数组的元素，每个元素只访问一遍，因此，其复杂度为\n                      O(N)，空间复杂度为 O(1)。\n                    </p>\n                    <p data-nodeid=\"95294\">\n                      【<strong data-nodeid=\"95968\">小结</strong\n                      >】本质上这道题就是从“求一个求数组的最大值”延伸和演变而来。只是我们通过双指针求解数组最大值的过程中，总结出了结论\n                      1 和结论 2。然后再结合题意要求，得到结论\n                      3，最后使这个问题得到解决。\n                    </p>\n                    <p data-nodeid=\"95295\">这道题目的考点我们进行一下归纳。</p>\n                    <ul data-nodeid=\"95296\">\n                      <li data-nodeid=\"95297\">\n                        <p data-nodeid=\"95298\">\n                          双指针：需要从左右两端向中间走（这和我们前面所讲的双指针略有不同）。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95299\">\n                        <p data-nodeid=\"95300\">\n                          贪心算法：通过结论 1、结论 2、结论\n                          3，每一步都选择最优解，最终得到整个问题的最优解。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95301\">\n                      为了帮助你巩固上述解题方法，这里我再给你留一道类似的题目。\n                    </p>\n                    <p data-nodeid=\"95302\">\n                      <strong data-nodeid=\"95984\">练习题 1</strong\n                      >：给定一个数组 A[]，A[i]\n                      表示柱子的高度，宽度为一个单位。如果我们不停往里面加水，直到所有柱子之间都加满为止。请问：给定一个图形，最多能接多少单位面积的水？\n                    </p>\n                    <p data-nodeid=\"95303\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/C4/Cgp9HWBm8nKAdTAFAAVvP6TxkfM792.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"95987\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95304\">\n                      输入：A = [0,1,0,2,1,0,1,3,2,1,2,1]\n                    </p>\n                    <p data-nodeid=\"95305\">输出：6</p>\n                    <p data-nodeid=\"95306\">\n                      解释：如图所示，最多只能接 6\n                      个单位面积的水。蓝色部分是水，而黑色部分是柱子，数组中不同的值，由不同高度的柱子表示。\n                    </p>\n                    <blockquote data-nodeid=\"95307\">\n                      <p data-nodeid=\"95308\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"95997\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96001\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96005\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"95309\">例 2：不重叠区间</h3>\n                    <p data-nodeid=\"95310\">\n                      【<strong data-nodeid=\"96054\">题目</strong\n                      >】给定一系列区间，请你选一个子集，使得这个子集里面区间都不相互重叠，并且这个子集里面元素个数最多。不重叠的定义：区间\n                      [3,4] 和 [4,5] 就是不重叠。<br />\n                      输入：A = [[1,2],[2, 3], [3,4], [1,3]<br />\n                      输出：3<br />\n                      解释：最多只能选出 3 个区间相互不重叠[1,2], [2,3], [3,4]。\n                    </p>\n                    <p data-nodeid=\"95311\">\n                      【<strong data-nodeid=\"96060\">分析</strong\n                      >】这个问题，最后相互不重叠的区间应该是初始集合的一个子集。那么，当我们遇到一个区间的时候，应该取还是不取呢？\n                    </p>\n                    <p data-nodeid=\"95312\">\n                      下面我们从“单个区间：取和不取”来展开讲解。这里我们需要稍微进行一下推导。假设：\n                    </p>\n                    <ol data-nodeid=\"95313\">\n                      <li data-nodeid=\"95314\">\n                        <p data-nodeid=\"95315\">\n                          已经求解了下图中的绿色区域，并且得到了绿色区域的最优解\n                          maxNum；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95316\">\n                        <p data-nodeid=\"95317\">\n                          接下来我们要处理红色元素（也就是单个的区间）。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"95318\">\n                      （注意：下文的 maxNum 和 newMaxNum\n                      均表示区间里面的不重合区间的最大数目，其中 newMaxNum\n                      表示区间<strong data-nodeid=\"96077\">范围变长</strong\n                      >之后的<strong data-nodeid=\"96078\">新的不重合区间</strong\n                      >的<strong data-nodeid=\"96079\">最大数目</strong>）\n                    </p>\n                    <p data-nodeid=\"95319\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/CC/CioPOWBm8nuAQENIAACKoN1sPiQ926.png\"\n                        alt=\"Drawing 15.png\"\n                        data-nodeid=\"96082\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95320\">\n                      那么当红色区间进来的时候，应该如何更新 maxNum 的值呢？新的\n                      newMaxNum 的值又如何决定呢？\n                    </p>\n                    <p data-nodeid=\"95321\">这里可以分为两种情况。</p>\n                    <p data-nodeid=\"95322\">\n                      Case 1：newMaxNum\n                      <strong data-nodeid=\"96090\">不包含</strong\n                      >新来的区间（红色部分），应该直接等于旧的 maxNum\n                    </p>\n                    <p data-nodeid=\"95323\">\n                      Case 2：newMaxNum<strong data-nodeid=\"96096\"\n                        >一定包含</strong\n                      >新来的区间（红色部分）\n                    </p>\n                    <p data-nodeid=\"95324\">如果进行迭代的话，就是：</p>\n                    <blockquote data-nodeid=\"95325\">\n                      <p data-nodeid=\"95326\">\n                        更新后的最优解 = max（不包含红色区间 =maxNum，\n                        一定包含红色区间的最优解）\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95327\">\n                      Case 1 的值是不需要求解的。那么接下来，我们只需要看 Case\n                      2。\n                    </p>\n                    <p data-nodeid=\"95328\">这种情况又可以分为两种小情况。</p>\n                    <p data-nodeid=\"95329\">\n                      Case 2.1：新来的区间与旧的任何区间都没有交集，那么\n                      newMaxNum = maxNum + 1。\n                    </p>\n                    <p data-nodeid=\"95330\">\n                      Case 2.2：新来的区间与旧的区间有交集。\n                    </p>\n                    <p data-nodeid=\"95331\">\n                      Case 2.1 的值已经计算出来了，我们再来看 Case 2.2。\n                    </p>\n                    <p data-nodeid=\"95332\">\n                      求解 Case\n                      2.2，需要从区间的不重叠性出发。关于“区间不重叠”，有一个<strong\n                        data-nodeid=\"96109\"\n                        >性质</strong\n                      >：\n                    </p>\n                    <blockquote data-nodeid=\"95333\">\n                      <p data-nodeid=\"95334\">\n                        两个区间 [a, b] 和 [c,d] 不相交，只需要满足 b &lt;= c ||\n                        d &lt;= a 就可以了。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95335\">\n                      现在，我们知道：区间的重叠只需要看两端的大小。可以将绿色区间部分<strong\n                        data-nodeid=\"96139\"\n                        >排序</strong\n                      >。<strong data-nodeid=\"96140\">绿色区间集合</strong\n                      >将分为两部分：\n                    </p>\n                    <ul data-nodeid=\"95336\">\n                      <li data-nodeid=\"95337\">\n                        <p data-nodeid=\"95338\">\n                          集合 a. 与红色新进来的区间有交集（下图紫色部分）；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95339\">\n                        <p data-nodeid=\"95340\">\n                          集合 b. 与红色新进来的区间没有交集（下图绿色部分）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95341\">我们画图如下：</p>\n                    <p data-nodeid=\"95342\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/C4/Cgp9HWBm8oeACww_AACubbwdL_c165.png\"\n                        alt=\"Drawing 16.png\"\n                        data-nodeid=\"96146\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95343\">\n                      假设已知集合 a 中不重叠的区间个数为\n                      preMaxNum，那么我们就得到了 Case 2.2 的解：preMaxNum + 1。\n                    </p>\n                    <p data-nodeid=\"95344\">\n                      此外， preMaxNum 肯定小于 maxNum，所以此时 preMaxNum + 1\n                      &lt;= maxNum。也就是说，Case 2.2 最优的时候，都没有 Case 1\n                      好。所以对于整个问题：我们只需要考虑 Case 1 和 Case 2.1。\n                    </p>\n                    <blockquote data-nodeid=\"95345\">\n                      <p data-nodeid=\"95346\">\n                        Case 2.2 逆袭的最优情况也只是等同于 Case\n                        1。次优解不能逆袭超车，正好使用贪心算法。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95347\">\n                      那么接下来，我们看 Case 1 与 Case\n                      2.1，由此可以得到一个<strong data-nodeid=\"96157\"\n                        >结论 1</strong\n                      >：\n                    </p>\n                    <blockquote data-nodeid=\"95348\">\n                      <p data-nodeid=\"95349\">\n                        <strong data-nodeid=\"96161\"\n                          >如果新来的区间与前面的区间不重叠，那么不重叠区间数目就能增加一个。</strong\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95350\">\n                      至此，我们知道通过排序，并且依赖性质 1\n                      可以得出两个区间是否重叠。那么如何排序呢？区间有两个端点\n                      [start, end]，是按照 start 排序还是按 end 排序呢？\n                    </p>\n                    <p data-nodeid=\"95351\">\n                      这里我们先用 end 来排序（很多博客上说不能用 start\n                      排序，实际上是可以的，下面我们会具体分析）。\n                    </p>\n                    <p data-nodeid=\"95352\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/CC/CioPOWBm8pGAPhp2AACThtOxY5g556.png\"\n                        alt=\"Drawing 17.png\"\n                        data-nodeid=\"96170\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95353\">\n                      由于我们是按照每个区间的 [start, end]\n                      来排序的，并且用了一个变量 maxEnd 记录已经处理的区间的最大\n                      maxEnd。那么当新区间 [c, d] 进来的时候，只需要判断：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">newMaxNum = maxNum + (maxEnd &lt;= c ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">maxNum = newMaxNum;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95355\">\n                      此外，还需要注意 maxEnd\n                      的更新。在前面的图中，为了简化条件，我并没有清晰地指出\n                      maxEnd 指代的含义。你需要注意 maxEnd\n                      的含义：如果你选取的区间都是不重叠的，maxEnd 是你<strong\n                        data-nodeid=\"96189\"\n                        >选中的区间</strong\n                      >的最大 end，而<strong data-nodeid=\"96190\"\n                        >不是你查看过的区间</strong\n                      >的最大 end。\n                    </p>\n                    <p data-nodeid=\"95356\">\n                      因为，只有这样，我们才可以知道<strong data-nodeid=\"96196\"\n                        >要不要把新区间加入不重叠的集合</strong\n                      >里面。\n                    </p>\n                    <p data-nodeid=\"95357\">\n                      【<strong data-nodeid=\"96202\">代码</strong\n                      >】原理已经讲清楚了，下面可以开始写代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">nonOverlapIntervals</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] A)</span> </span>{\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 将区间进行排序</span>\n</div></li><li><div class=\"code-word\">Arrays.sort(A, <span class=\"hljs-keyword\">new</span> Comparator&lt;<span class=\"hljs-keyword\">int</span>[]&gt;() {\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] b)</span> </span>{\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> a[<span class=\"hljs-number\">1</span>] == b[<span class=\"hljs-number\">1</span>] ? <span class=\"hljs-number\">0</span> : (a[<span class=\"hljs-number\">1</span>] &lt; b[<span class=\"hljs-number\">1</span>] ? -<span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 已重叠的区间的最右端点</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> maxEnd = Integer.MIN_VALUE;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 不重叠 的区间的个数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 开始贪心算法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> start = A[i][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (maxEnd &lt;= start) {\n</div></li><li><div class=\"code-word\">maxEnd = A[i][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">ans++;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"95359\">\n                      <p data-nodeid=\"95360\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96206\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96210\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96214\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95361\">\n                      <strong data-nodeid=\"96219\">复杂度分析</strong>：假设有\n                      N个 区间，程序的核心分为排序与贪心。排序的时间复杂度为\n                      O(NlgN)，而贪心的算法复杂度为 O(N)，空间复杂度为 O(1)。\n                    </p>\n                    <p data-nodeid=\"95362\">\n                      【<strong data-nodeid=\"96225\">小结</strong\n                      >】我们分析这道题目的时候，并不清楚是否要引入排序，而是一步步推导得出“需要使用排序来进行预处理”，然后再使用贪心算法。\n                    </p>\n                    <p data-nodeid=\"95363\">\n                      不过前文说到，排序的时候也可以使用区间 [start, end] 中的\n                      start 排序。这里我就再给出根据 start\n                      进行排序的代码。核心思路：<strong data-nodeid=\"96235\"\n                        >如果在区间排序的时候，根据 start\n                        来排序，那么在处理的时候，需要逆序进行</strong\n                      >。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">eraseOverlapIntervals</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] A)</span> </span>{\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 区间的总数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 将区间[start, end]根据start来排序</span>\n</div></li><li><div class=\"code-word\">Arrays.sort(A, <span class=\"hljs-keyword\">new</span> Comparator&lt;<span class=\"hljs-keyword\">int</span>[]&gt;() {\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] b)</span> </span>{\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> a[<span class=\"hljs-number\">0</span>] == b[<span class=\"hljs-number\">0</span>] ? <span class=\"hljs-number\">0</span> : (a[<span class=\"hljs-number\">0</span>] &lt; b[<span class=\"hljs-number\">0</span>] ? -<span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> preStart = Integer.MAX_VALUE;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 处理的时候，从后面开始处理</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = N - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> start = A[i][<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> end = A[i][<span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (end &lt;= preStart) {\n</div></li><li><div class=\"code-word\">preStart = start;\n</div></li><li><div class=\"code-word\">ans++;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> ans;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"95365\">\n                      <p data-nodeid=\"95366\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96239\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96243\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96247\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95367\">\n                      不重叠区间问题是很多问题的模板题。你掌握了这个模板就可以解决掉更多题目。下面请你尝试完成下面一批练习题。你一定要自己动手练习，不要偷懒哦！如果有你对哪里有疑问，也欢迎你写在留言区，我们一起讨论。\n                    </p>\n                    <p data-nodeid=\"95368\">\n                      <strong data-nodeid=\"96253\">练习题 2</strong\n                      >：给定一系列区间，返回最少需要删除的区间数目，使得剩下的区间不重叠。\n                    </p>\n                    <p data-nodeid=\"95369\">输入：A = [[1,2], [2,3], [1,4]]</p>\n                    <p data-nodeid=\"95370\">输出：1</p>\n                    <p data-nodeid=\"95371\">\n                      解释：这里我们选择删除 [1, 4]\n                      剩下的区间便不再重叠。这是最少的删除区间的数目。\n                    </p>\n                    <blockquote data-nodeid=\"95372\">\n                      <p data-nodeid=\"95373\">\n                        解法 1：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96277\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96281\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96285\"\n                          >Python</a\n                        ><br />\n                        解法 2：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96290\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96294\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96298\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95374\">\n                      <strong data-nodeid=\"96303\">练习题 3</strong\n                      >：给定一个字符串，需要切分成尽可能多的切片，但是一个字母只能放在一个切片里面。\n                    </p>\n                    <p data-nodeid=\"95375\">输入：A = \"abcabdefg\"</p>\n                    <p data-nodeid=\"95376\">输出：5</p>\n                    <p data-nodeid=\"95377\">\n                      解释：最多可以分为 [\"abcab\" \"d\" \"e\" \"f\" \"g\"]。你不能切成\n                      [\"a\", \"b\", \"c\", \"a\", \"b\", \"d\", \"e\", \"f\",\n                      \"g\"]，在这种情况下 'a' 字母并没有处于同一个切片。\n                    </p>\n                    <blockquote data-nodeid=\"95378\">\n                      <p data-nodeid=\"95379\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96377\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96381\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96385\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95380\">\n                      <strong data-nodeid=\"96390\">练习题 4</strong\n                      >：给定一系列区间，将重合的区间合并在一起。\n                    </p>\n                    <p data-nodeid=\"95381\">\n                      输入：A = [[1,2], [2,3], [2,6], [7, 8]]\n                    </p>\n                    <p data-nodeid=\"95382\">输出：[[1, 6], [7,8]]</p>\n                    <blockquote data-nodeid=\"95383\">\n                      <p data-nodeid=\"95384\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96422\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96426\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96430\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"95385\">例 3：青蛙跳</h3>\n                    <p data-nodeid=\"95386\">\n                      【<strong data-nodeid=\"96455\">题目</strong>】给定一个数组\n                      A[]，元素 A[i] &gt;= 0，一只青蛙站在 index =\n                      i，那它可以跳到 A[i+1], …,\n                      A[i+A[i]]（当然，它是不能跳出数组的）。那么请问这只青蛙从\n                      index = 0 出发，能不能跳到 index = A.length - 1。\n                    </p>\n                    <p data-nodeid=\"95387\">输入：A = [2, 3, 1, 2, 1]</p>\n                    <p data-nodeid=\"95388\">输出：true</p>\n                    <p data-nodeid=\"95389\">\n                      解释：青蛙可以这样跳，A[0] → A[1] → A[4]\n                    </p>\n                    <p data-nodeid=\"95390\">\n                      【<strong data-nodeid=\"96488\">分析</strong\n                      >】这个问题的重点在于，<strong data-nodeid=\"96489\"\n                        >站在 index = i，那它可以跳到 [i, ..., i + A[i]]</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"95391\">因此，它表示的信息就是两点：</p>\n                    <ul data-nodeid=\"95392\">\n                      <li data-nodeid=\"95393\">\n                        <p data-nodeid=\"95394\">起点 i</p>\n                      </li>\n                      <li data-nodeid=\"95395\">\n                        <p data-nodeid=\"95396\">终点 i + A[i]</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95397\">\n                      这货不就是一个区间吗？因此，数组里面的每一个元素，实际上都表示了一段区间\n                      [i, i +\n                      A[i]]。并且，这些区间都已经按照区间的起始点排好序了。\n                    </p>\n                    <p data-nodeid=\"95398\">\n                      那么问题就演变成：给定一系列区间，这段区间是否可以<strong\n                        data-nodeid=\"96513\"\n                        >连续</strong\n                      >覆盖 [0, N-1] 这个范围。题目也就变成一个区间覆盖问题。\n                    </p>\n                    <p data-nodeid=\"95399\">\n                      当走到位置 i 的时候，相当于已经覆盖了范围 [0, i +\n                      A[i]]。那么接下来，由于我们需要实现的目标是：连续覆盖得越远越好。\n                    </p>\n                    <p data-nodeid=\"95400\">因此只需要选择这样的区间：</p>\n                    <ul data-nodeid=\"95401\">\n                      <li data-nodeid=\"95402\">\n                        <p data-nodeid=\"95403\">\n                          区间的起始位置 x 一定要在 [0, i + A[i]]\n                          范围里面，也就是要<strong data-nodeid=\"96535\"\n                            >满足相连</strong\n                          >；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95404\">\n                        <p data-nodeid=\"95405\">\n                          区间的终止位置 x + A[x] 一定要越远越好。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95406\">\n                      那么，我们可以写出暴力的算法<strong data-nodeid=\"96546\"\n                        >版本 1</strong\n                      >如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">canJump</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 起始位置能拿到的区间是[0, 0 + A[0]]</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> coveredRange = A[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> used = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (coveredRange &lt; N - <span class=\"hljs-number\">1</span> &amp;&amp; used &lt; N) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> oldCoveredRange = coveredRange;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 我们从0 ~ N - 1里面选一个区间</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 注意，我们并不害怕重复选择同一个区间</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 因为重复选择同一个区间，并不能让覆盖范围变长。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 不能变长的情况，我们就直接return false.</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">//</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// （扫描循环:待优化）.....</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 1. 如果这个区间和我们已经覆盖的范围是相连的!</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 满足相连性</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (i &lt;= oldCoveredRange) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 2. 如果这个区间能覆盖得更远</span>\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-keyword\">if</span> (i + A[i] &gt; coveredRange) {\n</div></li><li><div class=\"code-word\">                        <span class=\"hljs-comment\">// 更新我们能cover的范围</span>\n</div></li><li><div class=\"code-word\">                        coveredRange = i + A[i];\n</div></li><li><div class=\"code-word\">                    } \n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (oldCoveredRange == coveredRange) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 否则，已经使用的区间数目++</span>\n</div></li><li><div class=\"code-word\">            used++;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95408\">\n                      暴力算法每次在完成区间更新的时候，都是搜索所有可能的解，因此其正确性是可以得到保证的。（在<a\n                        href=\"https://leetcode-cn.com/problems/jump-game/?fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"96550\"\n                        >测试平台</a\n                      >上也可以通过）。但是面试官要的肯定不是复杂度这么高的算法。因此，我们需要在此基础上继续优化。\n                    </p>\n                    <p data-nodeid=\"95409\">\n                      <strong data-nodeid=\"96562\">【优化 1</strong\n                      >】由于连续性的要求，在扫描的时候，不需要遍历 [0, N)\n                      的所有元素，只需要遍历 [0,oldCoveredRange]\n                      这个范围里面的元素。那么扫描循环可以优化如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">            <span class=\"hljs-comment\">// （扫描循环:待优化）.....</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= oldCoveredRange; i++) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 1. 这个区间和我们已经覆盖的范围是相连的!</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 满足相连性</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 2. 如果这个区间能覆盖得更远</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (i + A[i] &gt; coveredRange) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 更新我们能cover的范围</span>\n</div></li><li><div class=\"code-word\">                    coveredRange = i + A[i];\n</div></li><li><div class=\"code-word\">                } \n</div></li><li><div class=\"code-word\">            }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95411\">\n                      <strong data-nodeid=\"96567\">【优化 2</strong>】我们发现：\n                    </p>\n                    <ul data-nodeid=\"95412\">\n                      <li data-nodeid=\"95413\">\n                        <p data-nodeid=\"95414\">\n                          如果有区间在覆盖范围 [0, A] 里面被扫描过了；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95415\">\n                        <p data-nodeid=\"95416\">\n                          在下一轮覆盖范围 [0, B] 里面还会被扫描；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95417\">\n                        <p data-nodeid=\"95418\">B &gt;= A。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95419\">\n                      而 [0, B] 实际上可以分为两段，[0, A] 和 [A+1, B]。既然\n                      [0,A]\n                      这一段已经扫描过了，那么为了避免重复扫描，接下来只需要扫描\n                      [A+1, B]\n                      即可。因此，每次扫描的时候，你都需要记住当前这次扫描的终点\n                      A。\n                    </p>\n                    <p data-nodeid=\"95420\">\n                      【<strong data-nodeid=\"96605\">代码</strong\n                      >】根据上述分析，我们就可以写出如下代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">canJump</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] A)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = A == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : A.length;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 一开始，在正式开始第一次扫描之前，肯定什么元素都还没有扫描过</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 所以之记录之前扫描位置设置为-1</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> preScanedPos = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 根据题意</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 当前能覆盖到数组的第0个元素。也就是当前可以够得着的元素</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> curCoveredRange = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果当前</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">while</span> (curCoveredRange &lt; N - <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> oldCoveredRange = curCoveredRange;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 根据优化1和优化2，我们只需要遍历</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// [preScanedPos + 1, oldCoveredRange]即可。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 然后不停更新curCoveredRange</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = preScanedPos + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">                i &lt;= oldCoveredRange; i++) {\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 1. 这个区间和我们已经覆盖的范围是相连的!</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 满足相连性</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 2. 如果这个区间能覆盖得更远</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (i + A[i] &gt; curCoveredRange) {\n</div></li><li><div class=\"code-word\">                    <span class=\"hljs-comment\">// 更新我们能cover的范围</span>\n</div></li><li><div class=\"code-word\">                    curCoveredRange = i + A[i];\n</div></li><li><div class=\"code-word\">                } \n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (oldCoveredRange == curCoveredRange) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 我们记住上次已经扫描过的位置</span>\n</div></li><li><div class=\"code-word\">            preScanedPos = oldCoveredRange;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"95422\">\n                      <p data-nodeid=\"95423\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96609\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96613\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96617\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95424\">\n                      <strong data-nodeid=\"96622\">复杂度分析</strong\n                      >：时间复杂度 O(N)，空间复杂度\n                      O(1)。实际上，这里最多每个点遍历一次，所以时间复杂度为\n                      O(N)。\n                    </p>\n                    <p data-nodeid=\"95425\">\n                      【<strong data-nodeid=\"96632\">小结</strong\n                      >】在做完这个题之后，不妨和我们“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8\"\n                        data-nodeid=\"96630\"\n                        >第 02 讲</a\n                      >”学过的 FIFO 队列进行一个知识上的联动。\n                    </p>\n                    <p data-nodeid=\"95426\">\n                      记得我以前学习队列的时候，访问一个点时，会把后续的点都放到队列中，如下图所示：\n                    </p>\n                    <p data-nodeid=\"95427\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/CD/CioPOWBm8tCAH_xHAADOxSUIRfw102.png\"\n                        alt=\"Drawing 18.png\"\n                        data-nodeid=\"96636\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95428\">\n                      但是在这道题中，当访问 i 这个点的时候，后续能够走的点是\n                      A[i+1] …\n                      A[i+A[i]]，但并没有把所有的点都入队，而是从里面选择了一个最优的点。\n                    </p>\n                    <p data-nodeid=\"95429\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/2D/C5/Cgp9HWBm8taAUbvHAADTudQRn6s636.png\"\n                        alt=\"Drawing 19.png\"\n                        data-nodeid=\"96651\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95430\">\n                      如果把遍历的顺序也放到一个队列中，那么入队的时候，就只是把后面最优的点放到队列中。这个性质和优先级队列不太一样。优先级队列会把所有的元素都放到堆里面，然后堆内有序。但是对于贪心来说，只需要把最优秀的元素入队即可。\n                    </p>\n                    <p data-nodeid=\"95431\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/C5/Cgp9HWBm8t2ASM7CAADVY3j8Qig907.png\"\n                        alt=\"Drawing 20.png\"\n                        data-nodeid=\"96655\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95432\">\n                      当然，由于每次都只选一个后续最优元素入队，因此这个 Queue\n                      的长度最长是\n                      1。这和我们之前学过的队列知识存在相似之处，但也有不同的地方。\n                    </p>\n                    <p data-nodeid=\"95433\">\n                      如果我们再从深度上挖掘一下这道题，还可以有得到下面这些练习题。\n                    </p>\n                    <p data-nodeid=\"95434\">\n                      <strong data-nodeid=\"96662\">练习题 5</strong>：问题与例 3\n                      一样，只不过这个题：需要输出最少跳跃的次数？如果不能跳到\n                      A.length-1，请输出 -1。\n                    </p>\n                    <p data-nodeid=\"95435\">输入：A = [2, 3, 1, 2, 1]</p>\n                    <p data-nodeid=\"95436\">输出：2</p>\n                    <p data-nodeid=\"95437\">\n                      解释：A[0]→A[1]→A[4] 最少跳两次就可以到达最后一个下标。\n                    </p>\n                    <blockquote data-nodeid=\"95438\">\n                      <p data-nodeid=\"95439\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96684\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96688\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96692\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95440\">\n                      接下来我们看一下：给定一系列区间，如果要完全覆盖 [start,\n                      end] 这个区间，应该如何处理呢？请看练习题 6。\n                    </p>\n                    <p data-nodeid=\"95441\">\n                      <strong data-nodeid=\"96710\">练习题 6</strong\n                      >：一个大门安装了好几个摄像头，每个摄像头会录下一段时间的视频（假设起始时间与结束时间都是一个整数，可能为负数）。如果想找到\n                      [0, T]\n                      时间段的视频，请问最少需要提取几个摄像头的视频？如果不能得到\n                      [0, T] 这个时间段的视频，输出 -1。\n                    </p>\n                    <p data-nodeid=\"95442\">\n                      输入：[[1,2], [0,2], [0,1], [2,3], [2,6], [3,8]], T = 5\n                    </p>\n                    <p data-nodeid=\"95443\">输出：2</p>\n                    <p data-nodeid=\"95444\">\n                      解释：只需要用 [0, 2]，[2,6] 就可以完全覆盖 [0, 5]\n                      这个时间段。因此，最少需要看 2 个摄像头。\n                    </p>\n                    <blockquote data-nodeid=\"95445\">\n                      <p data-nodeid=\"95446\">\n                        代码：J<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96755\"\n                          >ava/</a\n                        ><a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96758\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96762\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"95447\">例 4： 加油站</h3>\n                    <p data-nodeid=\"95448\">\n                      【<strong data-nodeid=\"96777\">题目</strong\n                      >】巨大的环形赛道上有 N 个加油站，第 i 个加油站可以加油\n                      G[i] 升，而从第 i 个加油站开到下一个加油站，需要 C[i]\n                      升汽油。请你选择一个起始加油站，能够跑完环形赛道一圈。\n                    </p>\n                    <p data-nodeid=\"95449\">\n                      条件：1. 注意是环形赛道；2. 汽车油箱总是足够大。\n                    </p>\n                    <p data-nodeid=\"95450\">输入：G = [1,2], C=[2, 1]</p>\n                    <p data-nodeid=\"95451\">输出：1</p>\n                    <p data-nodeid=\"95452\">\n                      解释：从站点 0 出发，一开始只能收获 1 升油，而从 index = 0\n                      跑到 index = 1 需要用掉 2 升汽油，所以不能从站点 0\n                      出发。而从站点 1 出发，则可以绕着环形跑道跑一圈。\n                    </p>\n                    <p data-nodeid=\"95453\">\n                      【<strong data-nodeid=\"96796\">分析</strong\n                      >】当拿到这个题的时候，我们首先考虑一种极端情况，那就是收入与付出不成正比。当\n                      sum(G) &lt; sum(C)\n                      的时候，应该是无论如何也不可能跑一圈的。\n                    </p>\n                    <p data-nodeid=\"95454\">\n                      那么接下来就<strong data-nodeid=\"96805\"\n                        >只需要考虑 sum(G) &gt;= sum(C) 的情况</strong\n                      >。在这种情况下，可以得到<strong data-nodeid=\"96806\"\n                        >结论 1：</strong\n                      >\n                    </p>\n                    <blockquote data-nodeid=\"95455\">\n                      <p data-nodeid=\"95456\">\n                        当 sum(G) &gt;= sum(C)\n                        时，必然存在某个点出发可以绕着赛道跑一圈的情况。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95457\">\n                      证明这个结论需要使用反证法。假设：当 sum(G) &gt;=\n                      sum(C)，<strong data-nodeid=\"96813\">不存在</strong\n                      >某个点出发，可以绕着赛道跑一圈。若假设成立，那么必然可以将环形跑道切成几段，如下图所示：\n                    </p>\n                    <p data-nodeid=\"95458\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/C5/Cgp9HWBm8uqAES68AAIfEBlAW9s655.png\"\n                        alt=\"Drawing 21.png\"\n                        data-nodeid=\"96816\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95459\">\n                      并且每一段都是负数（因为不能绕着跑道跑一圈）。这时不同的段用不同的颜色表示。由于每一个小段和都是\n                      sub_sum(G) &lt; sub_sum(C)，那么必然可以得到总和 sum(G)\n                      &lt; sum(C)。这与题目条件相矛盾。\n                    </p>\n                    <p data-nodeid=\"95460\">\n                      <em data-nodeid=\"96831\"\n                        >注：我们用 sub_sum()\n                        函数表示求这一小段对应子数组的和。</em\n                      >\n                    </p>\n                    <p data-nodeid=\"95461\">\n                      根据<strong data-nodeid=\"96837\">结论 1</strong>，可以将\n                      sum(G) &gt;= sum(C) 的情况再次分为两种。\n                    </p>\n                    <ul data-nodeid=\"95462\">\n                      <li data-nodeid=\"95463\">\n                        <p data-nodeid=\"95464\">\n                          Case 1：从站点 0 出发可以跑遍全场。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95465\">\n                        <p data-nodeid=\"95466\">\n                          Case 2：从非 0 站点出发可以跑遍全场。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95467\">\n                      如果是Case 1，那么我们可以写出代码如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// ans表示从哪里出发 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 车里剩余的油量。</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> left = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 开始遍历每个站点</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">  total += G[i] - C[i];\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (left + G[i] - C[i] &gt;= <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// 油量足够</span>\n</div></li><li><div class=\"code-word\">    left += G[i] - C[i]; <span class=\"hljs-comment\">// 把油耗算上去</span>\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// &lt;-- 油量不够</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 不能从站点0出发。! &lt;!待处理!&gt;</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 可以从站点0出发，此时ans = 0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> ans;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95469\">\n                      如果是Case 2，接下来我们再看一下<strong\n                        data-nodeid=\"96856\"\n                        >不能从站点 0 出发</strong\n                      >的情况。也就是存在某个点 i，使得汽油不够了。会有\n                      left（余下的汽油） + G[i] - C[i] &lt;\n                      0，那接下来应该从哪里开始呢？\n                    </p>\n                    <ul data-nodeid=\"95470\">\n                      <li data-nodeid=\"95471\">\n                        <p data-nodeid=\"95472\">\n                          首先，当 G[0] - C[0] &lt; 0 的时候，肯定是不能从 0\n                          开始。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95473\">\n                        <p data-nodeid=\"95474\">\n                          其次，当 G[0] - C[0] &gt;= 0 的时候，如果 [0, i]\n                          的油量收益为负数。那么中间任意选一个点 x，且 0 &lt; x\n                          &lt;= i，那么 [x, i]\n                          这个区间上的油量收益也必然为负（因为去掉了从 0\n                          位置出发的正收益 G[0] - C[0]）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95475\">\n                      这两种情况可以<strong data-nodeid=\"96902\">统一处理</strong\n                      >如下：当出现油量不够的时候，下一个尝试的起点应该是 i +\n                      1。\n                    </p>\n                    <p data-nodeid=\"95476\">\n                      此时我们可以统一用代码处理如下（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// ans表示从哪里出发 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 车里剩余的油量。</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> left = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 开始遍历每个站点</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">int</span> total = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// &lt;-- 结论1</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">  total += G[i] - C[i]; <span class=\"hljs-comment\">// &lt;-- 结论1</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (left + G[i] - C[i] &gt;= <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// 油量足够</span>\n</div></li><li><div class=\"code-word\">    left += G[i] - C[i]; <span class=\"hljs-comment\">// 把油耗算上去</span>\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// &lt;-- 油量不够</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 尝试新站点出发</span>\n</div></li><li><div class=\"code-word\">    ans = i + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    left = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">return</span> total &lt; <span class=\"hljs-number\">0</span> ? -<span class=\"hljs-number\">1</span> : ans; <span class=\"hljs-comment\">// &lt;-- 结论1</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"95478\">\n                      但是需要验证找到的 ans\n                      站点出发，可以绕赛道一圈？答案是不需要的，下面我们证明一下这个结论。\n                    </p>\n                    <p data-nodeid=\"95479\">\n                      假设从 ans=start\n                      站点出发，那么环形区域必然可以分为两半部分，[0, start) 和\n                      [start, N)。由于不能从 index = 0 出发，那么 [0, start)\n                      这个区域油量收益肯定是 sub_sum(G) &lt;\n                      sub_sum(C)，即油量收益肯定是负数。\n                    </p>\n                    <p data-nodeid=\"95480\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/2D/CE/CioPOWBm8xOAKZD3AAEboP-L1yM535.png\"\n                        alt=\"Drawing 22.png\"\n                        data-nodeid=\"96920\"\n                      />\n                    </p>\n                    <p data-nodeid=\"95481\">\n                      由于油的总量是 sum(G) &gt;= sum(C)，那么后半段油的收益\n                      sub_sum(G) - sub_sum(C) &gt; 0\n                      必然成立。并且，我们可以得到：后半段的收益肯定可以平衡掉前半段的负收益。因此，从\n                      start 出发，就必然可以绕着赛道跑一圈。\n                    </p>\n                    <p data-nodeid=\"95482\">\n                      【<strong data-nodeid=\"96931\">代码</strong\n                      >】到此时，我们已经可以写出代码了（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">canCompleteCircuit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] G, <span class=\"hljs-keyword\">int</span>[] C)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> N = G == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-number\">0</span> : G.length;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 找一个子数组和最大的地方</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 那么也是相当于找一个子数组和最小的地方</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">long</span> left = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">long</span> total = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> get = G[i];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> cost = C[i];\n</div></li><li><div class=\"code-word\">    total += get - cost;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果我还能开到下一站，好的，那么继续开</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (left + get - cost &gt;= <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">      left += get - cost;\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 如果从[ans ...i]这段区间里面的收益为负数</span>\n</div></li><li><div class=\"code-word\">      left = <span class=\"hljs-number\">0</span>;\n</div></li><li><div class=\"code-word\">      ans = i + <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> total &gt;= <span class=\"hljs-number\">0</span> ? ans : -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"95484\">\n                      <p data-nodeid=\"95485\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96935\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96939\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96943\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95486\">\n                      <strong data-nodeid=\"96948\">复杂度分析</strong\n                      >：时间复杂度为 O(N)，空间复杂度为 O(1)。\n                    </p>\n                    <p data-nodeid=\"95487\">\n                      【<strong data-nodeid=\"96954\">小结</strong\n                      >】我们经过层层分析，得到最终求解的代码。最后还证明了不需要额外的代码去验证\n                      ans 站点出发的有效性。在这个题中用到的结论 1\n                      是我们分析问题的关键。\n                    </p>\n                    <p data-nodeid=\"95488\">\n                      不过这个题还有一个比较<strong data-nodeid=\"96960\"\n                        >有趣的解法</strong\n                      >，解题思路是这样的：\n                    </p>\n                    <ul data-nodeid=\"95489\">\n                      <li data-nodeid=\"95490\">\n                        <p data-nodeid=\"95491\">\n                          当总和小于 0 的时候，肯定没有解；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"95492\">\n                        <p data-nodeid=\"95493\">\n                          当总和大于等于 0\n                          的时候，总是有解的，那么在选择起点的时候，可以选择一个子数组，这个子数组是数组里面的最大和，然后就以这里作为起点。（可以反证一下，如果从最大子数组和的起点出发都不能绕赛道一圈，那么其他的点就更没戏了）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"95494\">\n                      不过想要通关这种解法，需要你依次解决以下几道练习题哦。\n                    </p>\n                    <p data-nodeid=\"95495\">\n                      <strong data-nodeid=\"96968\">练习题 7</strong\n                      >：给定一个数组，求这个子数组里面的最大子数组和。\n                    </p>\n                    <p data-nodeid=\"95496\">输入：A = [1,-5,3,4]</p>\n                    <p data-nodeid=\"95497\">输出：7</p>\n                    <p data-nodeid=\"95498\">\n                      解释：最大子数组和为 [3,4]，形成的和为 7，没有比 7\n                      更大的子数组和了。\n                    </p>\n                    <blockquote data-nodeid=\"95499\">\n                      <p data-nodeid=\"95500\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96982\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96986\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"96990\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95501\">\n                      <strong data-nodeid=\"96995\">练习题 8</strong\n                      >：给定一个数组，这个数组首尾成环，求这个环形数组里面的最大子数组和。\n                    </p>\n                    <p data-nodeid=\"95502\">输入：A = [2, -2, -2, -2, 2]</p>\n                    <p data-nodeid=\"95503\">输出：4</p>\n                    <p data-nodeid=\"95504\">\n                      解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4\n                      更大的子数组和了。\n                    </p>\n                    <blockquote data-nodeid=\"95505\">\n                      <p data-nodeid=\"95506\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97009\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97013\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97017\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95507\">\n                      <strong data-nodeid=\"97026\">练习题 9</strong>：同样是例题\n                      4，你能使用我们前面提过的“<strong data-nodeid=\"97027\"\n                        >从最大子数组和的起点出发</strong\n                      >”这种思路进行求解吗？\n                    </p>\n                    <blockquote data-nodeid=\"95508\">\n                      <p data-nodeid=\"95509\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97031\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97035\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97039\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"95510\">总结与延伸</h3>\n                    <p data-nodeid=\"95511\">\n                      贪心算法是一种思路，没有模板和套路。不过经过今天的学习。可以发现，贪心算法的两个特点中，第一个特点<strong\n                        data-nodeid=\"97050\"\n                        >只选局部最优解</strong\n                      >是比较容易做到的。但是难点在于：\n                      <strong data-nodeid=\"97051\">次优解不能逆袭</strong>。\n                    </p>\n                    <p data-nodeid=\"95512\">\n                      往往我们要花非常多的时间证明，才能够保证次优解可以扔掉。这里面还涉及了非常多的数学思维，需要你活学活用。\n                    </p>\n                    <p data-nodeid=\"95513\">\n                      作为面试官，我给你的建议是：刷贪心题目的时候，<strong\n                        data-nodeid=\"97062\"\n                        >一定要注意推导</strong\n                      >！如果你不会证明：“<strong data-nodeid=\"97063\"\n                        >为什么次优解可以扔掉？</strong\n                      >”，但知道如何进行操作，这说明你还没有真正掌握贪心这种思想。\n                    </p>\n                    <h3 data-nodeid=\"95514\">\n                      <strong data-nodeid=\"97067\">思考题</strong>\n                    </h3>\n                    <p data-nodeid=\"95515\">\n                      最后我再给你留一道思考题：既然可以用练习题 8 思路解决例 4\n                      的问题，那么肯定也可以用例 4 的思路解决练习题\n                      8，你能想一下代码应该怎么写吗？\n                    </p>\n                    <p data-nodeid=\"95516\">\n                      给定一个数组，这个数组首尾成环，求这个环形子数组里面的最大子数组和。\n                    </p>\n                    <p data-nodeid=\"95517\">输入：A = [2, -2, -2, -2, 2]</p>\n                    <p data-nodeid=\"95518\">输出：4</p>\n                    <p data-nodeid=\"95519\">\n                      解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4\n                      更大的子数组和了。\n                    </p>\n                    <blockquote data-nodeid=\"95520\">\n                      <p data-nodeid=\"95521\">\n                        代码：<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97083\"\n                          >Java</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97087\"\n                          >C++</a\n                        >/<a\n                          href=\"https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8\"\n                          data-nodeid=\"97091\"\n                          >Python</a\n                        >\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"95522\" class=\"\">\n                      希望你可以自己动一动手，也欢迎在留言区分享你的思路，我们一起讨论。接下来请和我一起踏上更加奇妙的算法旅程，下一讲将介绍\n                      12\n                      |回溯：我把回溯总结成一个公式，回溯题一出就用它。记得按时来探险。\n                    </p>\n            "}