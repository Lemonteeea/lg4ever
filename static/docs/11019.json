{"title":"第16讲：浏览器同源策略与跨域方案详解","context":"\n                    <p data-nodeid=\"8577\" class=\"\">\n                      开发出高性能的 Web\n                      应用固然重要，但安全问题也不容小觑。这一课时我们继续以\n                      HTTP 为线索，展开来讲一讲浏览器安全相关的同源策略。\n                    </p>\n                    <h3 data-nodeid=\"8578\">\n                      浏览器的同源策略（Same Origin Policy）\n                    </h3>\n                    <p data-nodeid=\"9369\">\n                      源（Origin）是由 URL 中协议、主机名（域名\n                      domain）以及端口共同组成的部分。在下面的网址中，源由协议\n                      https、主机名 kaiwu.lagou.com 和默认端口 443 共同组成。\n                    </p>\n                    <p data-nodeid=\"10440\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/25/12/CioPOWBZVeWATe0uAAAhcRPjM7k018.png\"\n                        alt=\"3.png\"\n                        data-nodeid=\"10444\"\n                      />\n                    </p>\n                    <div data-nodeid=\"10441\" class=\"te-preview-highlight\">\n                      <p style=\"text-align: center\">URL 中的源</p>\n                    </div>\n\n                    <p data-nodeid=\"8582\">\n                      如果两个 URL 的源相同，我们就称之为<strong\n                        data-nodeid=\"8692\"\n                        >同源</strong\n                      >。下面的 3 个 URL 和示例 URL 都是不同的源。\n                    </p>\n                    <ul data-nodeid=\"8583\">\n                      <li data-nodeid=\"8584\">\n                        <p data-nodeid=\"8585\">\n                          <a\n                            href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content\"\n                            data-nodeid=\"8695\"\n                            >http://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content</a\n                          >：协议不同。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8586\">\n                        <p data-nodeid=\"8587\">\n                          <a\n                            href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content\"\n                            data-nodeid=\"8699\"\n                            >https://kaiwu.lagou.com:80/course/courseInfo.htm?courseId=180#/content</a\n                          >：端口不同。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8588\">\n                        <p data-nodeid=\"8589\">\n                          <a\n                            href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/content\"\n                            data-nodeid=\"8703\"\n                            >https://lagou.com/course/courseInfo.htm?courseId=180#/content</a\n                          >：主机名不同。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8590\">\n                      而下面 2 个网址和示例 URL 都是同源。\n                    </p>\n                    <ul data-nodeid=\"8591\">\n                      <li data-nodeid=\"8592\">\n                        <p data-nodeid=\"8593\">\n                          <a\n                            href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=288#/sale\"\n                            data-nodeid=\"8708\"\n                            >https://kaiwu.lagou.com/course/courseInfo.htm?courseId=288#/sale</a\n                          >：请求参数不同。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8594\">\n                        <p data-nodeid=\"8595\">\n                          <a\n                            href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=288#/sale\"\n                            data-nodeid=\"8712\"\n                            >https://kaiwu.lagou.com</a\n                          >：URL 路径不同。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8596\">\n                      当一个源访问另一个源的资源时就会产生<strong\n                        data-nodeid=\"8723\"\n                        >跨源</strong\n                      >。同源策略就是用来限制其中一些跨源访问的，包括访问 iframe\n                      中的页面、其他页面的 cookie 访问以及发送 AJAX\n                      请求。最常见的跨源场景是域名不同，即常说的“跨域”。<strong\n                        data-nodeid=\"8724\"\n                        >本课时也按照约定俗成的说法，用“跨域”来指代“跨源”</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"8597\">\n                      同源策略在保障安全的同时也带来了不少问题，比如 iframe\n                      中的子页面与父页面无法通信，浏览器与其他服务端无法交互数据。所以我们需要一些跨域方案来解决这些问题。\n                    </p>\n                    <h3 data-nodeid=\"8598\">请求跨域解决方案</h3>\n                    <p data-nodeid=\"8599\">\n                      对于浏览器请求跨域，常用的有下面 4 种方法。\n                    </p>\n                    <h4 data-nodeid=\"8600\">跨域资源共享</h4>\n                    <p data-nodeid=\"8601\">\n                      跨域资源共享（CORS，Cross-Origin Resource\n                      Sharing）是浏览器为 AJAX\n                      请求设置的一种跨域机制，让其可以在服务端允许的情况下进行跨域访问。主要通过\n                      HTTP\n                      响应头来告诉浏览器服务端是否允许当前域的脚本进行跨域访问。\n                    </p>\n                    <p data-nodeid=\"8602\">\n                      跨域资源共享将 AJAX\n                      请求分成了两类：简单请求和非简单请求。其中<strong\n                        data-nodeid=\"8735\"\n                        >简单请求</strong\n                      >符合下面 2 个特征。\n                    </p>\n                    <ul data-nodeid=\"8603\">\n                      <li data-nodeid=\"8604\">\n                        <p data-nodeid=\"8605\">请求方法为 GET、POST、HEAD。</p>\n                      </li>\n                      <li data-nodeid=\"8606\">\n                        <p data-nodeid=\"8607\">\n                          请求头只能使用下面的字段：Accept（浏览器能够接受的响应内容类型）、Accept-Language（浏览器能够接受的自然语言列表）、Content-Type\n                          （请求对应的类型，只限于\n                          text/plain、multipart/form-data、application/x-www-form-urlencoded）、Content-Language（浏览器希望采用的自然语言）、Save-Data（浏览器是否希望减少数据传输量）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8608\">\n                      <strong data-nodeid=\"8741\"\n                        >任意一条要求不符合的即为非简单请求。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"8609\">对于简单请求，处理流程如下：</p>\n                    <ul data-nodeid=\"8610\">\n                      <li data-nodeid=\"8611\">\n                        <p data-nodeid=\"8612\">\n                          浏览器发出简单请求的时候，会在请求头部增加一个 Origin\n                          字段，对应的值为当前请求的源信息；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8613\">\n                        <p data-nodeid=\"8614\">\n                          当服务端收到请求后，会根据请求头字段 Origin\n                          做出判断后返回相应的内容。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8615\">\n                        <p data-nodeid=\"8616\">\n                          浏览器收到响应报文后会根据响应头部字段\n                          Access-Control-Allow-Origin&nbsp;进行判断，这个字段值为服务端允许跨域请求的源，其中通配符“*”表示允许所有跨域请求。如果头部信息没有包含\n                          Access-Control-Allow-Origin 字段或者响应的头部字段\n                          Access-Control-Allow-Origin\n                          不允许当前源的请求，则会抛出错误。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"8617\">\n                      当处理非简单的请求时，浏览器会先发出一个预检请求（Preflight）。这个预检请求为\n                      OPTIONS 方法，并会添加了 1 个请求头部字段\n                      Access-Control-Request-Method，值为跨域请求所使用的请求方法。\n                    </p>\n                    <p data-nodeid=\"8618\">\n                      下图是一个预检请求的请求报文和响应报文。因为添加了不属于上述简单请求的头部字段，所以浏览器在请求头部添加了\n                      Access-Control-Request-Headers\n                      字段，值为跨域请求添加的请求头部字段 authorization。\n                    </p>\n                    <p data-nodeid=\"8619\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/33/5D/Ciqc1F8QAGWAXq7jAABT5RmcAOI346.png\"\n                        alt=\"image (13).png\"\n                        data-nodeid=\"8752\"\n                      />\n                    </p>\n                    <div data-nodeid=\"8620\">\n                      <p style=\"text-align: center\">预检请求头部信息</p>\n                    </div>\n                    <p data-nodeid=\"8621\">\n                      在服务端收到预检请求后，除了在响应头部添加\n                      Access-Control-Allow-Origin 字段之外，至少还会添加\n                      Access-Control-Allow-Methods\n                      字段来告诉浏览器服务端允许的请求方法，并返回 204 状态码。\n                    </p>\n                    <p data-nodeid=\"8622\">\n                      在上面的例子中，服务端还根据浏览器的\n                      Access-Control-Request-Headers 字段回应了一个\n                      Access-Control-Allow-Headers\n                      字段，来告诉浏览器服务端允许的请求头部字段。\n                    </p>\n                    <p data-nodeid=\"8623\">\n                      浏览器得到预检请求响应的头部字段之后，会判断当前请求服务端是否在服务端许可范围之内，如果在则继续发送跨域请求，反之则直接报错。\n                    </p>\n                    <h4 data-nodeid=\"8624\">JSONP</h4>\n                    <p data-nodeid=\"8625\">\n                      JSONP（JSON with Padding）的大概意思就是用 JSON\n                      数据来填充，怎么填充呢？结合它的实现方式可以知道，就是把\n                      JSON 数填充到一个回调函数中。这种比较 hack\n                      的方式，依赖的是 script 标签跨域引用 js\n                      文件不会受到浏览器同源策略的限制。\n                    </p>\n                    <p data-nodeid=\"8626\">\n                      下面以一个具体例子来讲解它的具体实现方式。\n                    </p>\n                    <p data-nodeid=\"8627\">\n                      假设我们要在 http://ww.a.com 中向 http://www.b.com\n                      请求数据。\n                    </p>\n                    <p data-nodeid=\"8628\">\n                      1.全局声明一个用来处理返回值的函数\n                      fn，该函数参数为请求的返回结果。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">result</span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">console</span>.log(result)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8630\">\n                      2.将函数名与其他参数一并写入 URL 中。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-string\">'http://www.b.com?callback=fn&amp;params=...'</span>;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8632\">\n                      3.创建一个 script 标签，把 URL 赋值给 script 的 src。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'script'</span>);\n</div></li><li><div class=\"code-word\">script.setAttribute(<span class=\"hljs-string\">\"type\"</span>,<span class=\"hljs-string\">\"text/javascript\"</span>);\n</div></li><li><div class=\"code-word\">script.src = url;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">document</span>.body.appendChild(script);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8634\">\n                      4.当服务器接收到请求后，解析 URL\n                      参数并进行对应的逻辑处理，得到结果后将其写成回调函数的形式并返回给浏览器。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\">fn({\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-attr\">list</span>: [],\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8636\">\n                      5.在浏览器收到请求返回的 js\n                      脚本之后会立即执行文件内容，即在控制台打印传入的数据内容。\n                    </p>\n                    <p data-nodeid=\"8637\">\n                      JSONP 虽然实现了跨域请求，但也存在 3 个问题：\n                    </p>\n                    <ul data-nodeid=\"8638\">\n                      <li data-nodeid=\"8639\">\n                        <p data-nodeid=\"8640\">\n                          只能发送 GET 请求，限制了参数大小和类型；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8641\">\n                        <p data-nodeid=\"8642\">\n                          请求过程无法终止，导致弱网络下处理超时请求比较麻烦；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"8643\">\n                        <p data-nodeid=\"8644\">无法捕获服务端返回的异常信息。</p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"8645\">Websocket</h4>\n                    <p data-nodeid=\"8646\">\n                      Websocket 是 HTML5\n                      规范提出的一个应用层的全双工协议，适用于浏览器与服务器进行实时通信场景。\n                    </p>\n                    <p data-nodeid=\"8647\">什么叫全双工呢？</p>\n                    <p data-nodeid=\"8648\">\n                      这是通信传输的一个术语，这里的“工”指的是通信方向，“双工”是指从客户端到服务端，以及从服务端到客户端两个方向都可以通信，“全”指的是通信双方可以同时向对方发送数据。与之相对应的还有半双工和单工，半双工指的是双方可以互相向对方发送数据，但双方不能同时发送，单工则指的是数据只能从一方发送到另一方。\n                    </p>\n                    <p data-nodeid=\"8649\">\n                      下面是一段简单的示例代码。在 a 网站直接创建一个 WebSocket\n                      连接，连接到 b 网站即可，然后调用 WebScoket 实例 ws 的\n                      send() 函数向服务端发送消息，监听实例 ws 的 onmessage\n                      事件得到响应内容。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> ws = <span class=\"hljs-keyword\">new</span> WebSocket(<span class=\"hljs-string\">\"ws://b.com\"</span>);\n</div></li><li><div class=\"code-word\">ws.onopen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// ws.send(...);</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">ws.onmessage = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)</span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-comment\">// console.log(e.data);</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"8651\">代理转发</h4>\n                    <p data-nodeid=\"8652\">\n                      跨域是为了突破浏览器的同源策略限制，既然同源策略只存在于浏览器，那可以换个思路，在服务端进行跨域，比如设置代理转发。这种在服务端设置的代理称为“<strong\n                        data-nodeid=\"8780\"\n                        >反向代理</strong\n                      >”，对于用户而言是无感知的。\n                    </p>\n                    <p data-nodeid=\"8653\">\n                      另一种在客户端使用的代理称为“<strong data-nodeid=\"8786\"\n                        >正向代理</strong\n                      >”，主要用来代理客户端发送请求，用户使用时必须配置代理服务器的网址，比如常用的\n                      VPN 工具就属于正向代理。\n                    </p>\n                    <p data-nodeid=\"8654\">\n                      代理转发实现起来非常简单，在当前被访问的服务器配置一个请求转发规则就行了。\n                    </p>\n                    <p data-nodeid=\"8655\">\n                      下面的代码是 webpack-dev-server\n                      配置代理的示例代码。当浏览器发起前缀为 /api\n                      的请求时都会被转发到 http://localhost:3000\n                      这个网址，然后将响应结果返回给浏览器。对于浏览器而言还是请求当前网站，但实际上已经被服务端转发。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// webpack.config.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">module</span>.exports = {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-attr\">devServer</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">proxy</span>: {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'/api'</span>: <span class=\"hljs-string\">'http://localhost:3000'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8657\">\n                      在 Nginx\n                      服务器上配置同样的转发规则也非常简单，下面是示例配置。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">location /api {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; proxy_pass&nbsp; &nbsp;http:<span class=\"hljs-comment\">//localhost:3000;</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8659\">\n                      通过 location 指令匹配路径，然后通过 proxy_pass\n                      指令指向代理地址即可。\n                    </p>\n                    <h3 data-nodeid=\"8660\">页面跨域解决方案</h3>\n                    <p data-nodeid=\"8661\">\n                      除了浏览器请求跨域之外，页面之间也会有跨域需求，例如使用\n                      iframe 时父子页面之间进行通信。\n                    </p>\n                    <h4 data-nodeid=\"8662\">postMessage</h4>\n                    <p data-nodeid=\"8663\">\n                      HTML5 推出了一个新的函数 postMessage()\n                      用来实现父子页面之间通信，而且不论这两个页面是否同源。\n                    </p>\n                    <p data-nodeid=\"8664\">\n                      举例来说，如果父页面\n                      <a href=\"https://lagou.com\" data-nodeid=\"8800\"\n                        >https://lagou.com</a\n                      >\n                      要向子页面\n                      <a href=\"https://kaiwu.lagou.com\" data-nodeid=\"8804\"\n                        >https://kaiwu.lagou.com</a\n                      >\n                      发消息，可以通过下面的代码实现。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// https://lagou.com</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> child = <span class=\"hljs-built_in\">window</span>.open(<span class=\"hljs-string\">'https://kaiwu.lagou.com'</span>);\n</div></li><li><div class=\"code-word\">child.postMessage(<span class=\"hljs-string\">'hi'</span>, <span class=\"hljs-string\">'https://kaiwu.lagou.com'</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8666\">\n                      上面的代码通过 window.open() 函数打开了子页面，然后调用\n                      child.postMessage() 函数发送了字符串数据“hi”给子页面。\n                    </p>\n                    <p data-nodeid=\"8667\">\n                      在子页面中，只需要监听“message”事件即可得到父页面的数据。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// https://kaiwu.lagou.com</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-built_in\">console</span>.log(e.data);\n</div></li><li><div class=\"code-word\">},<span class=\"hljs-literal\">false</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"8669\">\n                      同样的，父页面也可以监听“message”事件来接收子页面发送的数据。子页面发送数据时则要通过\n                      window.opener 对象来调用 postMessage() 函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// https://kaiwu.lagou.com</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">window</span>.opener.postMessage(<span class=\"hljs-string\">'hello'</span>, <span class=\"hljs-string\">'https://lagou.com'</span>);\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"8671\">改域</h4>\n                    <p data-nodeid=\"8672\">\n                      对于主域名相同，子域名不同的情况，可以通过修改\n                      document.domain\n                      的值来进行跨域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。\n                    </p>\n                    <p data-nodeid=\"8673\">\n                      比如，有一个页面，它的地址是\n                      <a\n                        href=\"https://www.lagou.com/parent.html\"\n                        data-nodeid=\"8814\"\n                        >https://www.lagou.com/parent.html</a\n                      >，在这个页面里面有一个 iframe，其 src 是\n                      <a\n                        href=\"http://kaiwu.lagou.com/child.html\"\n                        data-nodeid=\"8818\"\n                        >http://kaiwu.lagou.com/child.html</a\n                      >。\n                    </p>\n                    <p data-nodeid=\"8674\">\n                      这时只要把\n                      <a\n                        href=\"http://www.lagou.com/parent.html\"\n                        data-nodeid=\"8823\"\n                        >http://www.lagou.com/parent.html</a\n                      >\n                      和\n                      <a\n                        href=\"http://kaiwu.lagou.com/child.html\"\n                        data-nodeid=\"8827\"\n                        >http://kaiwu.lagou.com/child.html</a\n                      >\n                      这两个页面的 document.domain\n                      都设成相同的域名，那么父子页面之间就可以进行跨域通信了，同时还可以共享\n                      cookie。\n                    </p>\n                    <p data-nodeid=\"8675\">\n                      但要注意的是，只能把 document.domain\n                      设置成更高级的父域才有效果，例如在&nbsp;\n                      <a\n                        href=\"http://kaiwu.lagou.com/child.html\"\n                        data-nodeid=\"8832\"\n                        >http://kaiwu.lagou.com/child.html</a\n                      >\n                      中可以将 document.domain 设置成&nbsp;lagou.com。\n                    </p>\n                    <h3 data-nodeid=\"8676\">总结</h3>\n                    <p data-nodeid=\"8677\">\n                      本课时介绍了浏览器的同源策略，并分别从请求跨域与页面跨域两个方向介绍了几种常用的跨域方案。\n                    </p>\n                    <p data-nodeid=\"8678\">\n                      对于请求跨域，包括跨域资源共享、JSONP、Websocket、代理转发\n                      4\n                      种方式，推荐优先使用代理转发和跨域资源共享。对于页面跨域，包括\n                      postMessage 和改域 2\n                      种方式，使用频率没有请求跨域那么高，记住 2\n                      种方式实现原理就好。\n                    </p>\n                    <p data-nodeid=\"8679\">\n                      最后布置一道思考题：说一说你还知道浏览器的哪些安全策略？\n                    </p>\n                    <p data-nodeid=\"8680\" class=\"\">\n                      OK，这一课时就讲到这里啦，如果你觉得这个内容对你有所启发，欢迎分享给你的朋友或者同事探讨学习。\n                    </p>\n            "}