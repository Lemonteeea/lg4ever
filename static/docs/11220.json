{"title":"18 | 对比 Koa 和 Redux：分析前端中的中间件理念","context":"\n                    <p data-nodeid=\"83997\" class=\"\">\n                      上一讲，我们通过分析 axios\n                      源码，延伸了“如何设计一个请求公共库”，其中提到了不同层次级别的分层理念。这一讲，我们继续讨论代码设计这一话题，聚焦中间件化和插件化理念。并通过实现一个中间件化的请求库和上一节内容融会贯通。\n                    </p>\n                    <h3 data-nodeid=\"83998\">\n                      以 Koa 为代表的 Node.js 中间件化设计\n                    </h3>\n                    <p data-nodeid=\"83999\">\n                      说到中间件，很多开发者都会想到\n                      Koa.js，其中间件设计无疑是前端中间件思想的典型代表之一。我们先来剖析\n                      Koa.js 的设计和实现。\n                    </p>\n                    <p data-nodeid=\"84000\">\n                      先来看一下 Koa.js 中间件的实现和应用：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 最外层中间件，可以用于兜底 Koa 全局错误</span>\n</div></li><li><div class=\"code-word\">app.use(async (ctx, next) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// console.log('中间件 1 开始执行')</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 执行下一个中间件</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">await <span class=\"hljs-title\">next</span><span class=\"hljs-params\">()</span></span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// console.log('中间件 1 执行结束')</span>\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">catch</span> (error) {\n</div></li><li><div class=\"code-word\">    console.log(\\`[koa error]: ${error.message}\\`)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 第二层中间件，可以用于日志记录</span>\n</div></li><li><div class=\"code-word\">app.use(async (ctx, next) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// console.log('中间件 2 开始执行')</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> { req } = ctx;\n</div></li><li><div class=\"code-word\">  console.log(\\`req is ${JSON.stringify(req)}\\`);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">await <span class=\"hljs-title\">next</span><span class=\"hljs-params\">()</span></span>;\n</div></li><li><div class=\"code-word\">  console.log(\\`res is ${JSON.stringify(ctx.res)}\\`);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// console.log('中间件 2 执行结束')</span>\n</div></li><li><div class=\"code-word\">});\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84002\">\n                      如上代码，我们看 Koa 实例，通过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84120\"\n                        >use</code\n                      >方法注册和串联中间件，其源码实现部分精简表述为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">use(fn) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.middleware.push(fn);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84004\">\n                      如上代码，我们的中间件被存储进<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84123\"\n                        >this.middleware</code\n                      >数组中，那么中间件是如何被执行的呢？参考下面源码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 通过 createServer 方法启动一个 Node.js 服务</span>\n</div></li><li><div class=\"code-word\">listen(...args) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-keyword\">this</span>.callback());\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> server.listen(...args);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84006\">\n                      Koa 框架通过\n                      <code data-backticks=\"1\" data-nodeid=\"84126\">http</code>\n                      模块的\n                      <code data-backticks=\"1\" data-nodeid=\"84128\"\n                        >createServer</code\n                      >\n                      方法创建一个 Node.js 服务，并传入 this.callback() 方法，\n                      this.callback() 方法源码精简实现如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">callback() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 从 this.middleware 数组中，组合中间件</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> fn = compose(<span class=\"hljs-keyword\">this</span>.middleware);\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// handleRequest 方法作为 \\`http\\` 模块的 \\`createServer\\` 方法参数，该方法通过 \\`createContext\\` 封装了 \\`http.createServer\\` 中的 \\`request\\` 和 \\`response\\`对象，并将这两个对象放到 ctx 中</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> handleRequest = (req, res) =&gt; {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> ctx = <span class=\"hljs-keyword\">this</span>.createContext(req, res);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 将 ctx 和组合后的中间件函数 fn 传递给 this.handleRequest 方法</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.handleRequest(ctx, fn);\n</div></li><li><div class=\"code-word\">    };\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> handleRequest;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">handleRequest(ctx, fnMiddleware) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> res = ctx.res;\n</div></li><li><div class=\"code-word\">    res.statusCode = <span class=\"hljs-number\">404</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> onerror = err =&gt; ctx.onerror(err);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> handleResponse = () =&gt; respond(ctx);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// on-finished npm 包提供的方法，该方法在一个 HTTP 请求 closes，finishes 或者 errors 时执行</span>\n</div></li><li><div class=\"code-word\">    onFinished(res, onerror);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将 ctx 对象传递给中间件函数 fnMiddleware</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> fnMiddleware(ctx).then(handleResponse).<span class=\"hljs-keyword\">catch</span>(onerror);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84008\">\n                      如上代码，我们将 Koa\n                      一个中间件组合和执行流程梳理为以下步骤。\n                    </p>\n                    <ol data-nodeid=\"84009\">\n                      <li data-nodeid=\"84010\">\n                        <p data-nodeid=\"84011\">\n                          通过<code data-backticks=\"1\" data-nodeid=\"84132\"\n                            >compose</code\n                          >方法组合各种中间件，返回一个中间件组合函数<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84134\"\n                            >fnMiddleware</code\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84012\">\n                        <p data-nodeid=\"84013\">\n                          请求过来时，会先调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84136\"\n                            >handleRequest</code\n                          >方法，该方法完成：\n                        </p>\n                        <ul data-nodeid=\"84014\">\n                          <li data-nodeid=\"84015\">\n                            <p data-nodeid=\"84016\">\n                              调用<code data-backticks=\"1\" data-nodeid=\"84139\"\n                                >createContext</code\n                              >方法，对该次请求封装出一个<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"84141\"\n                                >ctx</code\n                              >对象；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"84017\">\n                            <p data-nodeid=\"84018\">\n                              接着调用<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"84144\"\n                                >this.handleRequest(ctx, fnMiddleware)</code\n                              >处理该次请求。\n                            </p>\n                          </li>\n                        </ul>\n                      </li>\n                      <li data-nodeid=\"84019\">\n                        <p data-nodeid=\"84020\">\n                          通过<code data-backticks=\"1\" data-nodeid=\"84147\"\n                            >fnMiddleware(ctx).then(handleResponse).catch(onerror)</code\n                          >执行中间件。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"84021\">\n                      其中，一个核心过程就是使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84150\"\n                        >compose</code\n                      >方法组合各种中间件，其源码实现精简为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">compose</span><span class=\"hljs-params\">(middleware)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里返回的函数，就是上文中的 fnMiddleware</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> function (context, next) {\n</div></li><li><div class=\"code-word\">        let index = -<span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> dispatch(<span class=\"hljs-number\">0</span>)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-function\">function <span class=\"hljs-title\">dispatch</span><span class=\"hljs-params\">(i)</span> </span>{\n</div></li><li><div class=\"code-word\">        \t  <span class=\"hljs-comment\">// </span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (i &lt;= index) <span class=\"hljs-keyword\">return</span> Promise.reject(<span class=\"hljs-keyword\">new</span> Error(<span class=\"hljs-string\">'next() called multiple times'</span>))\n</div></li><li><div class=\"code-word\">            index = i\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 取出第 i 个中间件为 fn</span>\n</div></li><li><div class=\"code-word\">            let fn = middleware[i]\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (i === middleware.length) fn = next\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 已经取到了最后一个中间件，直接返回一个 Promise 实例，进行串联</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 这一步的意义是保证最后一个中间件调用 next 方法时，也不会报错</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (!fn) <span class=\"hljs-keyword\">return</span> Promise.resolve()\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 把 ctx 和 next 方法传入到中间件 fn 中，并将执行结果使用 Promise.resolve 包装</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-comment\">// 这里可以发现，我们在一个中间件中调用的 next 方法，其实就是dispatch.bind(null, i + 1)，即调用下一个中间件</span>\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> Promise.resolve(fn(context, dispatch.bind(<span class=\"hljs-keyword\">null</span>, i + <span class=\"hljs-number\">1</span>)));\n</div></li><li><div class=\"code-word\">            } <span class=\"hljs-keyword\">catch</span> (err) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> Promise.reject(err)\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84023\">\n                      源码实现中我已加入了相关注释，如果对于你来说还是晦涩难懂，不妨看一下下面这个\n                      hard coding 的例子，通过下面代码，表示三个 Koa\n                      中间件的执行情况：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">async function <span class=\"hljs-title\">middleware1</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">  await (<span class=\"hljs-function\">async function <span class=\"hljs-title\">middleware2</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    ...\n</div></li><li><div class=\"code-word\">    await (<span class=\"hljs-function\">async function <span class=\"hljs-title\">middleware3</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">      ...\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">    ...\n</div></li><li><div class=\"code-word\">  });\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84025\">这里我们来做一个简单的总结：</p>\n                    <ul data-nodeid=\"84026\">\n                      <li data-nodeid=\"84027\">\n                        <p data-nodeid=\"84028\">\n                          Koa 的中间件机制被社区形象地总结为洋葱模型；\n                        </p>\n                      </li>\n                    </ul>\n                    <blockquote data-nodeid=\"84029\">\n                      <p data-nodeid=\"84030\">\n                        所谓洋葱模型，就是指每一个 Koa\n                        中间件都是一层洋葱圈，它即可以掌管请求进入，也可以掌管响应返回。换句话说：外层的中间件可以影响内层的请求和响应阶段，内层的中间件只能影响外层的响应阶段。\n                      </p>\n                    </blockquote>\n                    <ul data-nodeid=\"84031\">\n                      <li data-nodeid=\"84032\">\n                        <p data-nodeid=\"84033\">\n                          <code data-backticks=\"1\" data-nodeid=\"84156\"\n                            >dispatch(n)</code\n                          >对应第 n 个中间件的执行，第 n 个中间件可以通过<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84158\"\n                            >await next()</code\n                          >来执行下一个中间件，同时在最后一个中间件执行完成后，依然有恢复执行的能力。即，通过洋葱模型，<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84160\"\n                            >await next()</code\n                          >控制调用 “下游”中间件，直到\n                          “下游”没有中间件且堆栈执行完毕，最终流回“上游”中间件。这种方式有个优点，特别是<strong\n                            data-nodeid=\"84166\"\n                            >对于日志记录以及错误处理等需要非常友好</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"84034\">\n                      这里我们稍微做一下扩展，引申出 Koa v1\n                      版本中中间件的实现，Koa1 的中间件实现利用了\n                      <strong data-nodeid=\"84176\">Generator 函数 + co 库</strong\n                      >（一种基于 Promise 的 Generator\n                      函数流程管理工具），来实现协程运行。本质上，Koa v1\n                      版本中间件和 Koa v2 版本中间件思想是类似的，只不过 Koa v2\n                      主要是用了\n                      <strong data-nodeid=\"84177\">Async/Await</strong> 来替换\n                      Generator 函数 + co\n                      库，整体实现更加巧妙，代码更加优雅、简易。\n                    </p>\n                    <h3 data-nodeid=\"84035\">对比 Express，再谈 Koa 中间件</h3>\n                    <p data-nodeid=\"84036\">\n                      说起 Node.js 框架，我们自然忘不了\n                      Express.js。它的中间件机制同样值得我们学习、比对。Express\n                      不同于 Koa，它继承了<strong data-nodeid=\"84188\"\n                        >路由、静态服务器和模板引擎等功能</strong\n                      >，因此看上去比 Koa 更像是一个框架。通过学习\n                      <a\n                        href=\"https://github.com/expressjs/express\"\n                        data-nodeid=\"84186\"\n                        >Express 源码</a\n                      >，我们可以总结出它的工作机制。\n                    </p>\n                    <ol data-nodeid=\"84037\">\n                      <li data-nodeid=\"84038\">\n                        <p data-nodeid=\"84039\">\n                          通过<code data-backticks=\"1\" data-nodeid=\"84190\"\n                            >app.use</code\n                          >方法注册中间件。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84040\">\n                        <p data-nodeid=\"84041\">\n                          一个中间件可以理解为一个 Layer\n                          对象，其中包含了当前路由匹配的正则信息以及 handle\n                          方法。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84042\">\n                        <p data-nodeid=\"84043\">\n                          所有中间件（Layer 对象）使用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84194\"\n                            >stack</code\n                          >数组存储起来。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84044\">\n                        <p data-nodeid=\"84045\">\n                          因此，每个 Router 对象都是通过一个<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84197\"\n                            >stack</code\n                          >数组，存储了相关中间件函数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84046\">\n                        <p data-nodeid=\"84047\">\n                          当一个请求过来时，会从 REQ 中获取请求 path，根据 path\n                          从<code data-backticks=\"1\" data-nodeid=\"84200\"\n                            >stack</code\n                          >中找到匹配的 Layer，具体匹配过程由<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84202\"\n                            >router.handle</code\n                          >函数实现。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84048\">\n                        <p data-nodeid=\"84049\">\n                          <code data-backticks=\"1\" data-nodeid=\"84204\"\n                            >router.handle</code\n                          >函数通过<code data-backticks=\"1\" data-nodeid=\"84206\"\n                            >next()</code\n                          >方法遍历每一个 layer 进行比对：\n                        </p>\n                        <ol data-nodeid=\"84050\">\n                          <li data-nodeid=\"84051\">\n                            <p data-nodeid=\"84052\">\n                              <code data-backticks=\"1\" data-nodeid=\"84208\"\n                                >next()</code\n                              >方法通过闭包维持了对于 Stack Index\n                              游标的引用，当调用<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"84210\"\n                                >next()</code\n                              >方法时，就会从下一个中间件开始查找；\n                            </p>\n                          </li>\n                          <li data-nodeid=\"84053\">\n                            <p data-nodeid=\"84054\">\n                              如果比对结果为 true，则调用<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"84213\"\n                                >layer.handle_request</code\n                              >方法，<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"84215\"\n                                >layer.handle_request</code\n                              >方法中会调用<code\n                                data-backticks=\"1\"\n                                data-nodeid=\"84217\"\n                                >next()</code\n                              >方法 ，实现中间件的执行。\n                            </p>\n                          </li>\n                        </ol>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"84055\">\n                      我们将上述过程总结为下图，帮助你理解：\n                    </p>\n                    <p data-nodeid=\"84333\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/03/C9/Cgp9HWAfsPuAMXAzAAIE4xCY0WY258.png\"\n                        alt=\"202127-92025.png\"\n                        data-nodeid=\"84337\"\n                      />\n                    </p>\n                    <div data-nodeid=\"84334\">\n                      <p style=\"text-align: center\">Express 工作机制</p>\n                    </div>\n\n                    <p data-nodeid=\"84058\">\n                      通过上述内容，我们可以看到，Express 的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84224\"\n                        >next()</code\n                      >方法维护了遍历中间件列表的 Index\n                      游标，中间件每次调用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84226\"\n                        >next()</code\n                      >方法时，会通过<strong data-nodeid=\"84232\"\n                        >增加 Index 游标的方式</strong\n                      >找到下一个中间件并执行。我们采用类似的 hard coding\n                      形式帮助大家理解 Express 插件作用机制：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">((req, res) =&gt; {\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'第一个中间件'</span>);\n</div></li><li><div class=\"code-word\">  ((req, res) =&gt; {\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'第二个中间件'</span>);\n</div></li><li><div class=\"code-word\">    (async(req, res) =&gt; {\n</div></li><li><div class=\"code-word\">      console.log(<span class=\"hljs-string\">'第三个中间件 =&gt; 是一个 route 中间件，处理 /api/test1'</span>);\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\">await <span class=\"hljs-title\">sleep</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2000</span>)</span>\n</span></div></li><li><div class=\"code-word\">      res.<span class=\"hljs-title\">status</span><span class=\"hljs-params\">(<span class=\"hljs-number\">200</span>)</span>.<span class=\"hljs-title\">send</span><span class=\"hljs-params\">(<span class=\"hljs-string\">'hello'</span>)</span>\n</div></li><li><div class=\"code-word\">    })<span class=\"hljs-params\">(req, res)</span>\n</div></li><li><div class=\"code-word\">    console.<span class=\"hljs-title\">log</span><span class=\"hljs-params\">(<span class=\"hljs-string\">'第二个中间件调用结束'</span>)</span>;\n</div></li><li><div class=\"code-word\">  })(req, res)\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">'第一个中间件调用结束'</span>)\n</div></li><li><div class=\"code-word\">})(req, res)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84060\">\n                      如上代码，Express\n                      中间件设计并不是一个洋葱模型，它是基于回调实现的线形模型，不利于组合，不利于互操，在设计上并不像\n                      Koa 一样简单。如果想实现一个记录请求响应的中间件，就需要：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">var express = require('express')\n</div></li><li><div class=\"code-word\">var app = express()\n</div></li><li><div class=\"code-word\">var requestTime = function (req, res, next) {\n</div></li><li><div class=\"code-word\">  req.requestTime = Date.now()\n</div></li><li><div class=\"code-word\">  next()\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">app.use(requestTime)\n</div></li><li><div class=\"code-word\">app.get('/', function (req, res) {\n</div></li><li><div class=\"code-word\">  var responseText = 'Hello World!&lt;br&gt;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">'\n</div></li><li><div class=\"code-word\">  responseText += '&lt;small&gt;Requested at: ' + req.requestTime + '&lt;/small&gt;'\n</div></li><li><div class=\"code-word\">  res.send(responseText)\n</div></li><li><div class=\"code-word\">})\n</div></li><li><div class=\"code-word\">app.listen(3000)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84062\">\n                      我们可以看到，上述实现就对业务代码有一定程度的侵扰，甚至会造成不同中间件间的耦合。\n                    </p>\n                    <p data-nodeid=\"84063\">\n                      我们回退到“上帝视角”发现，毫无疑问 Koa\n                      的洋葱模型更加先进，而<strong data-nodeid=\"84240\"\n                        >Express 的线形机制不容易实现拦截处理逻辑</strong\n                      >：比如异常处理和统计响应时间——这在 Koa\n                      里，一般只需要一个中间件就能全部搞定。\n                    </p>\n                    <p data-nodeid=\"84064\">\n                      当然，Koa 本身只提供了 HTTP\n                      模块和洋葱模型的最小封装，Express\n                      是一种更高形式的抽象，其设计思路和面向目标也有不同。\n                    </p>\n                    <h3 data-nodeid=\"84065\">Redux 中间件设计和实现</h3>\n                    <p data-nodeid=\"84066\">\n                      通过前文，我们了解了 Node.js\n                      两个当红框架的中间件设计，我们再换一个角度：从 Redux\n                      这个状态管理方案的中间件设计，了解更全面的中间件系统。\n                    </p>\n                    <p data-nodeid=\"84067\">\n                      类似 Koa 中的 koa-compose 实现，Redux 也实现了一个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84245\"\n                        >compose</code\n                      >方法，完成中间件的注册和串联：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">compose</span><span class=\"hljs-params\">(...funcs: Function[])</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)));\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84069\">\n                      <code data-backticks=\"1\" data-nodeid=\"84247\">compose</code\n                      >方法的执行效果如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">compose([fn1, fn2, fn3])(args)\n</div></li><li><div class=\"code-word\">=&gt;\n</div></li><li><div class=\"code-word\">compose(fn1, fn2, fn3) (...args) = &gt; fn1(fn2(fn3(...args)))\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84071\">\n                      简单来说，<code data-backticks=\"1\" data-nodeid=\"84250\"\n                        >compose</code\n                      >方法是一种高阶聚合，先执行 fn3，并将执行结果作为参数传给\n                      fn2，以此类推。我们使用 Redux 创建一个 store\n                      时，完成对<code data-backticks=\"1\" data-nodeid=\"84252\"\n                        >compose</code\n                      >方法的调用，Redux 精简源码类比为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 这是一个简单的打日志中间件</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">logger</span><span class=\"hljs-params\">({ getState, dispatch })</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// next 代表下一个中间件包装过后的 dispatch 方法，action 表示当前接收到的动作</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> next =&gt; action =&gt; {\n</div></li><li><div class=\"code-word\">        console.log(<span class=\"hljs-string\">\"before change\"</span>, action);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 调用下一个中间件包装的 dispatch </span>\n</div></li><li><div class=\"code-word\">        let val = next(action);\n</div></li><li><div class=\"code-word\">        console.log(<span class=\"hljs-string\">\"after change\"</span>, getState(), val);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> val;\n</div></li><li><div class=\"code-word\">    };\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 logger 中间件，创建一个增强的 store</span>\n</div></li><li><div class=\"code-word\">let createStoreWithMiddleware = Redux.applyMiddleware(logger)(Redux.createStore)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">applyMiddleware</span><span class=\"hljs-params\">(...middlewares)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// middlewares 为中间件列表，返回一个接受原始 createStore 方法（Redux.createStore）作为参数的函数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> createStore =&gt; (...args) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 创建原始的 store</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> store = createStore(...args)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 每个中间件都会被传入 middlewareAPI 对象，作为中间件参数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> middlewareAPI = {\n</div></li><li><div class=\"code-word\">      getState: store.getState,\n</div></li><li><div class=\"code-word\">      dispatch: (...args) =&gt; dispatch(...args)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 给每个中间件传入 middlewareAPI 参数</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 中间件的统一模板为 next =&gt; action =&gt; next(action) 格式</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// chain 中保存的都是 next =&gt; action =&gt; {next(action)} 的方法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 传入最原始 store.dispatch 方法，作为 compose 二级参数，compose 方法最终返回一个增强的dispatch 方法</span>\n</div></li><li><div class=\"code-word\">    dispatch = compose(...chain)(store.dispatch)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">      ...store,\n</div></li><li><div class=\"code-word\">      dispatch  <span class=\"hljs-comment\">// 返回一个增强版的 dispatch</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84073\">\n                      如上代码，我们将 Redux 中间件特点总结为：\n                    </p>\n                    <ul data-nodeid=\"84074\">\n                      <li data-nodeid=\"84075\">\n                        <p data-nodeid=\"84076\">\n                          Redux 中间件接收<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84256\"\n                            >getState</code\n                          >和<code data-backticks=\"1\" data-nodeid=\"84258\"\n                            >dispatch</code\n                          >两个方法组成的对象作为参数；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84077\">\n                        <p data-nodeid=\"84078\">\n                          Redux 中间件返回一个函数，该函数接收下一个<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84261\"\n                            >next</code\n                          >方法作为参数，并返回一个接收 action 的新的<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84263\"\n                            >dispatch</code\n                          >方法；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84079\">\n                        <p data-nodeid=\"84080\">\n                          Redux 中间件通过手动调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84266\"\n                            >next(action)</code\n                          >方法，执行下一个中间件。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"84081\">\n                      我们将 Redux 的中间件作用机制总结为下图：\n                    </p>\n                    <p data-nodeid=\"85010\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/03/C9/Cgp9HWAfsQuABGmXAAGNk0fcn-c946.png\"\n                        alt=\"202127-92020.png\"\n                        data-nodeid=\"85014\"\n                      />\n                    </p>\n                    <div data-nodeid=\"85011\">\n                      <p style=\"text-align: center\">Redux 的中间件作用机制</p>\n                    </div>\n\n                    <p data-nodeid=\"84084\">\n                      看上去也像是一个洋葱圈模型，但是对于同步调用和异步调用稍有不同，以三个中间件为例。\n                    </p>\n                    <ul data-nodeid=\"84085\">\n                      <li data-nodeid=\"84086\">\n                        <p data-nodeid=\"84087\">\n                          三个中间件均是正常同步调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84274\"\n                            >next(action)</code\n                          >，则执行顺序为：中间件 1 before next → 中间件 2\n                          before next → 中间件 3 before next → dispatch 方法调用\n                          → 中间件 3 after next → 中间件 2 after next → 中间件 1\n                          after next。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84088\">\n                        <p data-nodeid=\"84089\">\n                          第二个中间件没有调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84277\"\n                            >next(action)</code\n                          >，则执行顺序为：中间件 1 befoe next → 中间件 2 逻辑 →\n                          中间件 1 after next，注意<strong data-nodeid=\"84283\"\n                            >此时中间件 3 没有被执行</strong\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84090\">\n                        <p data-nodeid=\"84091\">\n                          第二个中间件异步调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84285\"\n                            >next(action)</code\n                          >，其他中间件均是正常同步调用<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"84287\"\n                            >nextt(action)</code\n                          >，则执行顺序为：中间件 1 before next → 中间件 2\n                          同步代码部分 → 中间件 1 after next → 中间件 2\n                          异步代码部分 before next → 中间件 3 before next →\n                          dispatch 方法调用 → 中间件 3 after next → 中间件 2\n                          异步代码部分 after next。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"84092\">\n                      利用中间件思想，实现一个中间件化的 Fetch 库\n                    </h3>\n                    <p data-nodeid=\"84093\">\n                      上面我们分析了前端中的中间件化思想，这一部分，我们活学活用，利用中间件思路，结合上一讲内容，实现一个中间件化的\n                      Fetch 库。\n                    </p>\n                    <p data-nodeid=\"84094\">\n                      我们先来思考一个中间件化的 Fetch 库有哪些优点呢？Fetch\n                      库的核心实现请求的发送，而各种业务逻辑以中间件化的插件模式进行增强，这样一来，实现了特定业务需求和请求库的解耦，更加灵活，也是一种分层思想的体现。具体来说，一个中间件化的\n                      Fetch 库：\n                    </p>\n                    <ul data-nodeid=\"84095\">\n                      <li data-nodeid=\"84096\">\n                        <p data-nodeid=\"84097\">\n                          支持业务方递归扩展底层 Fetch API 能力；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"84098\">\n                        <p data-nodeid=\"84099\">方便测试；</p>\n                      </li>\n                      <li data-nodeid=\"84100\">\n                        <p data-nodeid=\"84101\">\n                          一个中间件化的 Fetch 库，天然支持各类型的 Fetch\n                          封装（比如 Native\n                          Fetch、fetch-ponyfill、fetch-polyfill 等）。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"84102\">\n                      我们给这个中间件化的 Fetch 库取名为：fetch-wrap，借助\n                      <a\n                        href=\"https://github.com/benjamine/fetch-wrap\"\n                        data-nodeid=\"84298\"\n                        >fetch-wrap</a\n                      >\n                      的实现，预期使用方式为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> fetchWrap = require(<span class=\"hljs-string\">'fetch-wrap'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 这里可以接入自己的核心 Fetch 底层实现，比如使用原生 Fetch，或同构的 isomorphic-fetch 等</span>\n</div></li><li><div class=\"code-word\">let fetch = require(<span class=\"hljs-string\">'isomorphic-fetch'</span>);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 扩展 Fetch 中间件</span>\n</div></li><li><div class=\"code-word\">fetch = fetchWrap(fetch, [\n</div></li><li><div class=\"code-word\">  middleware1,\n</div></li><li><div class=\"code-word\">  middleware2,\n</div></li><li><div class=\"code-word\">  middleware3,\n</div></li><li><div class=\"code-word\">]);\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 一个典型的中间件</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">middleware1</span><span class=\"hljs-params\">(url, options, innerFetch)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 业务扩展</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> innerFetch(url, options);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 一个更改 URL 的中间件</span>\n</div></li><li><div class=\"code-word\">function(url, options, fetch) {\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// modify url or options</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> fetch(url.replace(/^(http:)?/, <span class=\"hljs-string\">'https:'</span>), options);\n</div></li><li><div class=\"code-word\">},\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 一个修改返回结果的中间件</span>\n</div></li><li><div class=\"code-word\">function(url, options, fetch) {\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> fetch(url, options).then(function(response) {\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">if</span> (!response.ok) {\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(result.status + <span class=\"hljs-string\">' '</span> + result.statusText);\n</div></li><li><div class=\"code-word\">\t  }\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">if</span> (/application\\/json/.test(result.headers.get(<span class=\"hljs-string\">'content-type'</span>))) {\n</div></li><li><div class=\"code-word\">\t    <span class=\"hljs-keyword\">return</span> response.json();\n</div></li><li><div class=\"code-word\">\t  }\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">return</span> response.text();\n</div></li><li><div class=\"code-word\">\t});\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 一个做错误处理的中间件</span>\n</div></li><li><div class=\"code-word\">function(url, options, fetch) {\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// catch errors</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> fetch(url, options).<span class=\"hljs-keyword\">catch</span>(function(err) {\n</div></li><li><div class=\"code-word\">\t  console.error(err);\n</div></li><li><div class=\"code-word\">\t  <span class=\"hljs-keyword\">throw</span> err;\n</div></li><li><div class=\"code-word\">\t});\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84104\">\n                      核心实现也不困难，观察<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84301\"\n                        >fetchWrap</code\n                      >使用方式，我们实现源码为：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 接受第一个参数为基础 Fetch，第二个参数为中间件数组或单个中间件</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = <span class=\"hljs-function\">function <span class=\"hljs-title\">fetchWrap</span><span class=\"hljs-params\">(fetch, middleware)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 没有使用中间件，则返回原生 fetch</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">if</span> (!middleware || middleware.length &lt; <span class=\"hljs-number\">1</span>) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">return</span> fetch;\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 递归调用 extend 方法，每次递归时剔除出 middleware 数组中的首项</span>\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">var</span> innerFetch = middleware.length === <span class=\"hljs-number\">1</span> ? fetch : fetchWrap(fetch, middleware.slice(<span class=\"hljs-number\">1</span>));\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">var</span> next = middleware[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">\t\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">function <span class=\"hljs-title\">extendedFetch</span><span class=\"hljs-params\">(url, options)</span> </span>{\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">\t\t  <span class=\"hljs-comment\">// 每一个 Fetch 中间件通过 Promsie 来串联</span>\n</div></li><li><div class=\"code-word\">\t\t  <span class=\"hljs-keyword\">return</span> Promise.resolve(next(url, options || {}, innerFetch));\n</div></li><li><div class=\"code-word\">\t\t} <span class=\"hljs-keyword\">catch</span> (err) {\n</div></li><li><div class=\"code-word\">\t\t  <span class=\"hljs-keyword\">return</span> Promise.reject(err);\n</div></li><li><div class=\"code-word\">\t\t}\n</div></li><li><div class=\"code-word\">\t};\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84106\">\n                      我们可以看到，每一个中间件都接收一个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84304\"\n                        >url</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"84306\"\n                        >options</code\n                      >参数，因此具有了改写<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84308\"\n                        >url</code\n                      >和<code data-backticks=\"1\" data-nodeid=\"84310\"\n                        >options</code\n                      >的能力；同时接收一个<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84312\"\n                        >innerFetch</code\n                      >方法，<code data-backticks=\"1\" data-nodeid=\"84314\"\n                        >innerFetch</code\n                      >为上一个中间件包装过的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84316\"\n                        >fetch</code\n                      >方法，而每一个中间件也都返回一个包装过的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"84318\"\n                        >fetch</code\n                      >方法，将各个中间件依次调用串联。\n                    </p>\n                    <p data-nodeid=\"84107\">\n                      另外，社区上的\n                      <a\n                        href=\"https://www.npmjs.com/package/umi-request\"\n                        data-nodeid=\"84323\"\n                        >umi-request</a\n                      >\n                      的中间件机制也是类似的，其核心代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Onion</span> </span>{\n</div></li><li><div class=\"code-word\">  constructor() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.middlewares = [];\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 存储中间件</span>\n</div></li><li><div class=\"code-word\">  use(newMiddleware) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.middlewares.push(newMiddleware);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 执行中间件</span>\n</div></li><li><div class=\"code-word\">  execute(params = <span class=\"hljs-keyword\">null</span>) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> fn = compose(<span class=\"hljs-keyword\">this</span>.middlewares);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> fn(params);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">export <span class=\"hljs-keyword\">default</span> function <span class=\"hljs-title\">compose</span><span class=\"hljs-params\">(middlewares)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">function <span class=\"hljs-title\">wrapMiddlewares</span><span class=\"hljs-params\">(params)</span> </span>{\n</div></li><li><div class=\"code-word\">    let index = -<span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">function <span class=\"hljs-title\">dispatch</span><span class=\"hljs-params\">(i)</span> </span>{\n</div></li><li><div class=\"code-word\">      index = i;\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> fn = middlewares[i];\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (!fn) <span class=\"hljs-keyword\">return</span> Promise.resolve();\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> Promise.resolve(fn(params, () =&gt; dispatch(i + <span class=\"hljs-number\">1</span>)));\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> dispatch(<span class=\"hljs-number\">0</span>);\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"84109\">\n                      我们可以看到，上述源码更像 Koa\n                      的实现了，但其实道理和上面的 fetch-wrap\n                      大同小异。至此，相信你已经了解了中间件的思想，也能够体会洋葱模型的精妙设计。\n                    </p>\n                    <h3 data-nodeid=\"84110\">总结</h3>\n                    <p data-nodeid=\"84111\">\n                      这一讲，我们通过分析前端不同框架的中间件设计，剖析了中间件化这一重要思想。中间件化意味着插件化，这也是上一讲提到的分层思想的一种实现，同时，这种实现思路灵活且扩展能力强，能够和核心逻辑相解耦，需要你细心体会。\n                    </p>\n                    <p data-nodeid=\"84112\">本讲主要内容如下：</p>\n                    <p data-nodeid=\"84113\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/94/A4/CgqCHmAY-AqAIZqkAAO1O62z-y4965.png\"\n                        alt=\"Drawing 2.png\"\n                        data-nodeid=\"84331\"\n                      />\n                    </p>\n                    <p data-nodeid=\"84114\" class=\"\">\n                      在下一讲中，我们将继续围绕着代码设计中的灵活性和定制性这一话题展开，同时也给大家留一个思考题：你在平时开发中，见过或者使用过哪些插件化的工程或技术呢？欢迎在留言区和我分享你的观点，我们下一讲再见。\n                    </p>\n            "}