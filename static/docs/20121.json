{"title":"16 | HTTP 协议面试通关：强制缓存和协商缓存的区别是？","context":"\n                    <p data-nodeid=\"3\">\n                      超文本传输协议（HyperText Transfer\n                      Protocol，HTTP）是目前使用最广泛的应用层协议。在网站、App、开放接口中都可以看到它。HTTP\n                      协议设计非常简单，但是涵盖的内容很多。相信你平时工作中已经多多少少接触过这个协议，这一讲我们会挑选其中一部分重点介绍，比如高频面试内容，以及容易产生理解误区的内容，帮助你深入学习\n                      HTTP 协议。\n                    </p>\n                    <h3 data-nodeid=\"4\">WWW</h3>\n                    <p data-nodeid=\"5\">\n                      1990 年蒂姆·伯纳斯·李开发了第一个浏览器，书写了第一个 Web\n                      服务器程序和第一张网页。网页用的语言后来被称作<strong\n                        data-nodeid=\"70\"\n                        >超文本标记语言（HTML）</strong\n                      >，而在服务器和客户端之间传输网页的时候，伯纳斯·李没有直接使用传输层协议，而是在\n                      TCP 的基础上构造了一个应用层协议，这个就是<strong\n                        data-nodeid=\"71\"\n                        >超文本传输协议 HTTP</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"6\">\n                      万维网（World Wide Web，\n                      WWW）是伯纳斯·李对这一系列发明，包括 Web 服务、HTTP\n                      协议、HTML 语言等一个体系的综合。\n                    </p>\n                    <h3 data-nodeid=\"7\">请求响应和长连接</h3>\n                    <p data-nodeid=\"8\">\n                      HTTP 协议采用请求/返回模型。客户端（通常是浏览器）发起\n                      HTTP 请求，然后 Web 服务端收到请求后将数据回传。\n                    </p>\n                    <p data-nodeid=\"9\">\n                      HTTP 的请求和响应都是文本，你可以简单认为 HTTP 协议利用\n                      TCP\n                      协议传输文本。当用户想要看一张网页的时候，就发送一个文本请求到\n                      Web 服务器，Web\n                      服务器解析了这段文本，然后给浏览器将网页回传。\n                    </p>\n                    <p data-nodeid=\"10\">\n                      <strong data-nodeid=\"80\"\n                        >那么这里有一个问题，是不是每次发送一个请求，都建立一个\n                        TCP 连接呢</strong\n                      >？\n                      当然不能这样，为了节省握手、挥手的时间。当浏览器发送一个请求到\n                      Web 服务器的时候，Web\n                      服务器内部就设置一个定时器。在一定范围的时间内，如果客户端继续发送请求，那么服务器就会重置定时器。如果在一定范围的时间内，服务器没有收到请求，就会将连接断开。这样既防止浪费握手、挥手的资源，同时又避免一个连接占用时间过长无法回收导致内存使用效率下降。\n                    </p>\n                    <p data-nodeid=\"11\">\n                      这个能力可以利用 HTTP 协议头进行配置，比如下面这条请求头：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">Keep-Alive: timeout=<span class=\"hljs-number\">5</span>s\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"13\">\n                      会告诉 Web 服务器连接的持续时间是 5s，如果 5s\n                      内没有请求，那么连接就会断开。\n                    </p>\n                    <h3 data-nodeid=\"14\">HTTP 2.0 的多路复用</h3>\n                    <p data-nodeid=\"15\">\n                      Keep-Alive 并不是伯纳斯·李设计 HTTP\n                      协议时就有的能力。伯纳斯·李设计的第一版 HTTP 协议是 0.9\n                      版，后来随着协议逐渐完善，有了 1.0 版。而 Keep-Alive 是\n                      HTTP 1.1\n                      版增加的功能，目的是应对越来越复杂的网页资源加载。从 HTTP\n                      协议诞生以来，网页中需要的资源越来越丰富，打开一张页面需要发送的请求越来越多，于是就产生了\n                      Keep-Alive 的设计。\n                    </p>\n                    <p data-nodeid=\"16\">\n                      同样，当一个网站需要加载的资源较多时，浏览器会尝试并发发送请求（利用多线程技术）。浏览器会限制同时发送并发请求的数量，通常是\n                      6\n                      个，这样做一方面是对用户本地体验的一种保护，防止浏览器抢占太多网络资源；另一方面也是对站点服务的保护，防止瞬时流量过大。\n                    </p>\n                    <p data-nodeid=\"17\">\n                      在 HTTP 2.0 之后，增加了多路复用能力。和之前我们讲 RPC\n                      框架时提到的多路复用类似，请求、返回会被拆分成切片，然后混合传输。这样请求、返回之间就不会阻塞。你可以思考，对于一个\n                      TCP 连接，在 HTTP 1.1 的 Keep-Alive\n                      设计中，第二个请求，必须等待第一个请求返回。如果第一个请求阻塞了，那么后续所有的请求都会阻塞。而\n                      HTTP 2.0\n                      的多路复用，将请求返回都切分成小片，这样利用同一个连接，请求相当于并行的发出，互相之间不会有干扰。\n                    </p>\n                    <h3 data-nodeid=\"18\">HTTP 方法和 RestFul 架构</h3>\n                    <p data-nodeid=\"19\">\n                      伴随着 HTTP 发展，也诞生了一些著名的架构，比如\n                      RestFul。在面试中，经常会遇到 RestFul，RestFul 是 3\n                      个单词的合并缩写：\n                    </p>\n                    <ul data-nodeid=\"20\">\n                      <li data-nodeid=\"21\">\n                        <p data-nodeid=\"22\">Re（Representational）</p>\n                      </li>\n                      <li data-nodeid=\"23\">\n                        <p data-nodeid=\"24\">st（State）</p>\n                      </li>\n                      <li data-nodeid=\"25\">\n                        <p data-nodeid=\"26\">Ful（Transfer）</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"27\">\n                      这个命名非常有趣，让我联想到 grep 命令的命名，global\n                      regular pattern\n                      match。这是一种非常高端的命名技巧，提取词汇中的一个部分组合成为一个读起来朗朗上口的新词汇，建议你在实战命名的时候也可以考虑试试。\n                    </p>\n                    <p data-nodeid=\"28\">\n                      <strong data-nodeid=\"97\"\n                        >在 RestFul\n                        架构中，状态仅仅存在于服务端，前端无状态</strong\n                      >。状态（State）可以理解为业务的状态，这个状态是由服务端管理的。这个无状态和服务端目前倡导的无状态设计不冲突，现在服务端倡导的无状态设计指的是容器内的服务没有状态，状态全部存到合适的存储中去。所以\n                      Restful 中的 State，是服务端状态。\n                    </p>\n                    <p data-nodeid=\"29\">\n                      <strong data-nodeid=\"102\"\n                        >前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是\n                        Representation</strong\n                      >。比如一个订单，状态存在服务端（数据库中），前端展示订单只需要部分信息，不需要全部信息。前端只需要展示数据，展示数据需要服务端提供。所以服务端提供的不是状态，而是状态的表示。\n                    </p>\n                    <p data-nodeid=\"30\">\n                      前端没有状态，当用户想要改变订单状态的时候，比如支付，这个时候前端就向服务端提交表单，然后服务端触发状态的变化。这个过程我们称为<strong\n                        data-nodeid=\"108\"\n                        >转化（Transfer）</strong\n                      >。从这个角度来看，Restful\n                      讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法。这个方法可以让前后端职责清晰，前端负责渲染，\n                      服务端负责业务。前端不需要业务状态，只需要展示。服务端除了关心状态，还要提供状态的转换接口。\n                    </p>\n                    <h4 data-nodeid=\"31\">HTTP 方法</h4>\n                    <p data-nodeid=\"32\">\n                      在 Restful\n                      架构中，除了约定了上述整体架构方案之外，还约束了一些实现细节，比如用名词性的接口和\n                      HTTP 方法来设计服务端提供的接口。\n                    </p>\n                    <p data-nodeid=\"33\">\n                      我们用 GET\n                      获取数据，或者进行查询。比如下面这个例子，就是在获取 id 为\n                      123 的订单数据：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">GET /order/<span class=\"hljs-number\">123</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"35\">\n                      GET 是 HTTP 方法，/order\n                      是一种名词性质的命名。这样设计语义非常清晰，这个接口是获取订单的数据（也就是订单的\n                      Representation 用的）。\n                    </p>\n                    <p data-nodeid=\"36\">\n                      对于更新数据的场景，按照 HTTP 协议的约定，PUT\n                      是一种幂等的更新行为，POST\n                      是一种非幂等的更新行为。举个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">PUT /order/<span class=\"hljs-number\">123</span> \n</div></li><li><div class=\"code-word\">{...订单数据}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"38\">\n                      上面我们用 PUT 更新订单，如果订单 123\n                      还没有创建，那么这个接口会创建订单。如果 123\n                      已经存在，那么这个接口会更新订单 123\n                      的数据。为什么是这样？因为 PUT\n                      代表幂等，对于一个幂等的接口，请求多少遍最终的状态是一致的，也就是说操作的都是同一笔订单。\n                    </p>\n                    <p data-nodeid=\"39\">如果换成用 POST 更新订单：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">POST /order\n</div></li><li><div class=\"code-word\">{...订单数据}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"41\">\n                      POST 代表非幂等的设计，像上面这种用 POST\n                      提交表单的接口，调用多次往往会产生多个订单。也就是非幂等的设计每次调用结束后都会产生新的状态。\n                    </p>\n                    <p data-nodeid=\"42\">\n                      另外在 HTTP 协议中，还约定了 DELETE\n                      方法用于删除数据。其实还有几个方法，感兴趣的同学可以查询下，比如\n                      OPTIONS、PATCH，然后我们在留言区中讨论。\n                    </p>\n                    <h3 data-nodeid=\"43\">缓存</h3>\n                    <p data-nodeid=\"44\">\n                      在 HTTP 的使用中，我们经常会遇到两种缓存，<strong\n                        data-nodeid=\"124\"\n                        >强制缓存和协商缓存</strong\n                      >，接下来我举两个场景来说明。\n                    </p>\n                    <h4 data-nodeid=\"45\">强制缓存</h4>\n                    <p data-nodeid=\"46\">\n                      你的公司用版本号管理某个对外提供的 JS 文件。比如说\n                      libgo.1.2.3.js，就是 libgo 的 1.2.3 版本。其中 1\n                      是主版本，2 是副版本，3\n                      是补丁编号。每次你们有任何改动，都会更新 libgo\n                      版本号。在这种情况下，当浏览器请求了一次 libgo.1.2.3.js\n                      文件之后，还需要再请求一次吗？\n                    </p>\n                    <p data-nodeid=\"47\">\n                      整理下我们的需求，浏览器在第一次进行了<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"128\"\n                        >GET /libgo.1.2.3.js</code\n                      >这个操作后，如果后续某个网页还用到了这个文件（libgo.1.2.3.js），我们不再发送第二次请求。这个方案要求浏览器将文件缓存到本地，并且设置这个文件的失效时间（或者永久有效）。这种请求过一次不需要再次发送请求的缓存模式，在\n                      HTTP 协议中称为<strong data-nodeid=\"134\">强制缓存</strong\n                      >。当一个文件被强制缓存后，下一次请求会直接使用本地版本，而不会真的发出去。\n                    </p>\n                    <p data-nodeid=\"48\">\n                      <strong data-nodeid=\"139\"\n                        >使用强制缓存时要注意，千万别把需要动态更新的数据强制缓存</strong\n                      >。一个负面例子就是小明把获取用户信息数据的接口设置为强制缓存，导致用户更新了自己的信息后，一直要等到强制缓存失效才能看到这次更新。\n                    </p>\n                    <h4 data-nodeid=\"49\">协商缓存</h4>\n                    <p data-nodeid=\"50\">\n                      我们再说一个场景：小明开发了一个接口，这个接口提供全国省市区的\n                      3\n                      级信息。先问你一个问题，这个场景可以用强制缓存吗？小明一开始觉得强制缓存可以，然后突然有一天接到运营的通知，某市下属的两个县合并了，需要调整接口数据。小明错手不急，更新了接口数据，但是数据要等到强制缓存失效。\n                    </p>\n                    <p data-nodeid=\"51\">\n                      为了应对这种场景，HTTP 协议还设计了<strong\n                        data-nodeid=\"147\"\n                        >协商缓存</strong\n                      >。协商缓存启用后，第一次获取接口数据，会将数据缓存到本地，并存储下数据的摘要。第二次请求时，浏览器检查到本地有缓存，将摘要发送给服务端。服务端会检查服务端数据的摘要和浏览器发送来的是否一致。如果不一致，说明服务端数据发生了更新，服务端会回传全部数据。如果一致，说明数据没有更新，服务端不需要回传数据。\n                    </p>\n                    <p data-nodeid=\"52\">\n                      从这个角度看，协商缓存的方式节省了流量。对于小明开发的这个接口，多数情况下协商缓存会生效。当小明更新了数据后，协商缓存失效，客户端数据可以马上更新。<strong\n                        data-nodeid=\"153\"\n                        >和强制缓存相比，协商缓存的代价是需要多发一次请求</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"53\">总结</h3>\n                    <p data-nodeid=\"54\">\n                      这一讲我们讨论了 HTTP 协议中的一些面试难点和理解误区。目前\n                      HTTP 协议已经发展到了 2.0 版本，不少网站都更新到了 HTTP\n                      2.0。大部分浏览器、CDN 也支持了 HTTP\n                      2.0。如果你感兴趣可以自行查阅更多关于 HTTP 2.0\n                      解决队头阻塞、HPack 压缩算法、Server Push 等资料。\n                    </p>\n                    <p data-nodeid=\"55\">\n                      另外 HTTP 3.0 协议也在建设当中，HTTP 3.0 对 HTTP 2.0\n                      兼容，主要调整发生在网络底层。HTTP 3.0 开始采用 UDP\n                      协议，并在 UDP 协议之上，根据 HTTP\n                      协议的需求特性，研发了网络层、应用层去解决可靠性等问题。\n                    </p>\n                    <p data-nodeid=\"56\">\n                      这一讲就到这里，发现求知的乐趣，我是林䭽。感谢你学习本次课程，下一讲我们将学习《17\n                      | 流媒体技术：直播网站是如何实现的？》，再见！\n                    </p>\n            "}