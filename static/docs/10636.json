{"title":"35 | 中介者模式：如何通过中间层来解决耦合过多的问题？","context":"\n                    <p data-nodeid=\"929\" class=\"\">\n                      中介者模式理解起来并不难，代码实现简单，学习难度也很小，只要合理充分地应用这个模式，往往就能够解决一些意想不到的问题。那这到底是怎样一个模式？多用于什么场景中？为什么使用？该怎么使用？\n                    </p>\n                    <p data-nodeid=\"930\">\n                      话不多说，让我们带着这些问题开始今天的学习吧。\n                    </p>\n                    <h3 data-nodeid=\"931\">模式原理分析</h3>\n                    <p data-nodeid=\"932\">\n                      中介者模式的原始定义是：中介者对象封装了一组对象之间的交互，这组对象会将它们的交互委托给中介者对象，而不是直接交互。\n                    </p>\n                    <p data-nodeid=\"933\">\n                      可以看到，这个定义是难得的简单和明确，中介者对象就是用于处理对象与对象之间的直接交互，封装了多个对象之间的交互细节。\n                    </p>\n                    <p data-nodeid=\"934\">\n                      我们还是先来看看中介者模式的 UML 图：\n                    </p>\n                    <p data-nodeid=\"935\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/4C/23/Cgp9HWDoCCOAYZ9-AAGxdIBEJ1E23.jpeg\"\n                        alt=\"设计模式35（202179-162249）.jpeg\"\n                        data-nodeid=\"1015\"\n                      />\n                    </p>\n                    <div data-nodeid=\"936\">\n                      <p style=\"text-align: center\">中介者模式的 UML 图</p>\n                    </div>\n                    <p data-nodeid=\"937\">\n                      从这个 UML 图中，我们能看出中介者模式包含了四个关键角色。\n                    </p>\n                    <ul data-nodeid=\"938\">\n                      <li data-nodeid=\"939\">\n                        <p data-nodeid=\"940\">\n                          <strong data-nodeid=\"1021\">抽象中介者</strong\n                          >（Mediator）：定义中介者需要执行的方法操作。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"941\">\n                        <p data-nodeid=\"942\">\n                          <strong data-nodeid=\"1026\">具体中介者</strong\n                          >（MediatorImpl）：实现抽象中介者定义的方法操作，同时可以包含更多逻辑。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"943\">\n                        <p data-nodeid=\"944\">\n                          <strong data-nodeid=\"1031\">抽象组件类</strong\n                          >（Component）：定义组件需要执行的方法操作。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"945\">\n                        <p data-nodeid=\"946\">\n                          <strong data-nodeid=\"1036\">具体组件类</strong\n                          >（ComponentA、ComponentB）：继承自抽象组件类，实现具体的组件业务逻辑。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"947\">\n                      下面我们再来看看 UML 对应的代码实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public interface Mediator {\n</div></li><li><div class=\"code-word\">    void apply(String key);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class MediatorImpl implements Mediator{\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void apply(String key) {\n</div></li><li><div class=\"code-word\">        System.out.println(\"最终中介者执行操作，key为：\"+key);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public abstract class Component {\n</div></li><li><div class=\"code-word\">    private Mediator mediator;\n</div></li><li><div class=\"code-word\">    public Component(Mediator mediator) {\n</div></li><li><div class=\"code-word\">        this.mediator = mediator;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    public abstract void exec(String key);\n</div></li><li><div class=\"code-word\">    public Mediator getMediator() {\n</div></li><li><div class=\"code-word\">        return mediator;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class ComponentA extends Component{\n</div></li><li><div class=\"code-word\">    public ComponentA(Mediator mediator) {\n</div></li><li><div class=\"code-word\">        super(mediator);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void exec(String key) {\n</div></li><li><div class=\"code-word\">        System.out.println(\"===在组件A中，通过中介者执行\");\n</div></li><li><div class=\"code-word\">        getMediator().apply(key);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class ComponentB extends Component{\n</div></li><li><div class=\"code-word\">    public ComponentB(Mediator mediator) {\n</div></li><li><div class=\"code-word\">        super(mediator);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void exec(String key) {\n</div></li><li><div class=\"code-word\">        System.out.println(\"===在组件B中，通过中介者的操作\");\n</div></li><li><div class=\"code-word\">        getMediator().apply(key);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class Demo {\n</div></li><li><div class=\"code-word\">    public static void main(String[] args) {\n</div></li><li><div class=\"code-word\">        Mediator mediator = new MediatorImpl();\n</div></li><li><div class=\"code-word\">        Component componentA = new ComponentA(mediator);\n</div></li><li><div class=\"code-word\">        componentA.exec(\"key-A\");\n</div></li><li><div class=\"code-word\">        Component componentB = new ComponentB(mediator);\n</div></li><li><div class=\"code-word\">        componentB.exec(\"key-B\");\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">//输出结果\n</div></li><li><div class=\"code-word\">===在组件A中，通过中介者执行\n</div></li><li><div class=\"code-word\">最终中介者执行操作，key为：key-A\n</div></li><li><div class=\"code-word\">===在组件B中，通过中介者的操作\n</div></li><li><div class=\"code-word\">最终中介者执行操作，key为：key-B\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"949\">\n                      从上面的代码实现中，你会发现中介者模式的关键点就在于<strong\n                        data-nodeid=\"1043\"\n                        >在组件与组件之间加入一个中间对象来进行间接通信</strong\n                      >。虽然多了“一层”会更烦琐些，但是这样就可以在中介者里进行其他的一些操作。\n                    </p>\n                    <h3 data-nodeid=\"950\">使用场景分析</h3>\n                    <p data-nodeid=\"951\">\n                      中介者模式常见的使用场景有以下几种：\n                    </p>\n                    <ul data-nodeid=\"952\">\n                      <li data-nodeid=\"953\">\n                        <p data-nodeid=\"954\">\n                          系统中对象之间存在复杂的引用关系时，比如，聊天系统；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"955\">\n                        <p data-nodeid=\"956\">\n                          通过一个中间对象来封装多个类中的共有行为时，比如，在分层架构中的\n                          DAO 层和数据库 DB\n                          层中间再引入一个读写分离和读写均衡的中间层；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"957\">\n                        <p data-nodeid=\"958\">不想生成太多的子类时。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"959\">\n                      为了帮助你快速理解中介者的适用场景，下面我们还是通过一个简单的例子来讲解和演示。\n                    </p>\n                    <p data-nodeid=\"1629\" class=\"\">\n                      假设我们要设计一个可以让多人参与进去的聊天室，该怎么去实现呢？首先，定义聊天室的接口\n                      ChatRoom，其中包含两个方法 sendMessage 和\n                      addUser，分别代表发送消息和新增用户。这里的 ChatRoom\n                      就是<strong data-nodeid=\"1635\">抽象的中介者类</strong>。\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public interface ChatRoom {\n</div></li><li><div class=\"code-word\">    void sendMessage(String msg, String userId);\n</div></li><li><div class=\"code-word\">    void addUser(User user);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2567\" class=\"te-preview-highlight\">\n                      然后，创建一个 ChatRoom 的<strong data-nodeid=\"2573\"\n                        >实现类</strong\n                      >ChatRoomImpl，使用 addUser\n                      来添加需要聊天的用户对象，同时这里再使用一个Map来保存添加时需要用来进行通信的对象列表，在发送消息\n                      sendMessage 的方法中，我们通过 userId\n                      指定某个对象来接收消息。\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public class ChatRoomImpl implements ChatRoom {\n</div></li><li><div class=\"code-word\">    private Map&lt;String, User&gt; usersMap = new HashMap&lt;&gt;();\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void sendMessage(String msg, String userId) {\n</div></li><li><div class=\"code-word\">        User u = usersMap.get(userId);\n</div></li><li><div class=\"code-word\">        u.receive(msg);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void addUser(User user) {\n</div></li><li><div class=\"code-word\">        this.usersMap.put(user.getId(), user);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"964\">\n                      接下来我们再定义一个<strong data-nodeid=\"1067\"\n                        >抽象组件类 User</strong\n                      >，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public abstract class User {\n</div></li><li><div class=\"code-word\">    private ChatRoom mediator;\n</div></li><li><div class=\"code-word\">    private String id;\n</div></li><li><div class=\"code-word\">    private String name;\n</div></li><li><div class=\"code-word\">    public User(ChatRoom room, String id, String name){\n</div></li><li><div class=\"code-word\">        this.mediator = room;\n</div></li><li><div class=\"code-word\">        this.name = name;\n</div></li><li><div class=\"code-word\">        this.id = id;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    public abstract void send(String msg, String userId);\n</div></li><li><div class=\"code-word\">    public abstract void receive(String msg);\n</div></li><li><div class=\"code-word\">    public ChatRoom getMediator() {\n</div></li><li><div class=\"code-word\">        return mediator;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    public String getId() {\n</div></li><li><div class=\"code-word\">        return id;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    public String getName() {\n</div></li><li><div class=\"code-word\">        return name;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"966\">\n                      继承User实现一个<strong data-nodeid=\"1073\"\n                        >具体的组件类 ChatUser</strong\n                      >，并实现发送消息 send 和接收消息 receive 的方法。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public class ChatUser extends User {\n</div></li><li><div class=\"code-word\">    public ChatUser(ChatRoom room, String id, String name) {\n</div></li><li><div class=\"code-word\">        super(room, id, name);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void send(String msg, String userId) {\n</div></li><li><div class=\"code-word\">        System.out.println(this.getName() + \" :: Sending Message : \" + msg);\n</div></li><li><div class=\"code-word\">        getMediator().sendMessage(msg, userId);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void receive(String msg) {\n</div></li><li><div class=\"code-word\">        System.out.println(this.getName() + \" :: Received Message : \" + msg);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"968\">\n                      最后，我们同样还是运行一段单元测试代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public class Client {\n</div></li><li><div class=\"code-word\">    public static void main(String[] args) {\n</div></li><li><div class=\"code-word\">        ChatRoom chatroom = new ChatRoomImpl();\n</div></li><li><div class=\"code-word\">        User user1 = new ChatUser(chatroom,\"1\", \"Spike\");\n</div></li><li><div class=\"code-word\">        User user2 = new ChatUser(chatroom,\"2\", \"Mia\");\n</div></li><li><div class=\"code-word\">        User user3 = new ChatUser(chatroom,\"3\", \"Max\");\n</div></li><li><div class=\"code-word\">        User user4 = new ChatUser(chatroom,\"4\", \"Mick\");\n</div></li><li><div class=\"code-word\">        chatroom.addUser(user1);\n</div></li><li><div class=\"code-word\">        chatroom.addUser(user2);\n</div></li><li><div class=\"code-word\">        chatroom.addUser(user3);\n</div></li><li><div class=\"code-word\">        chatroom.addUser(user4);\n</div></li><li><div class=\"code-word\">        user1.send(\"Hello man\", \"2\");\n</div></li><li><div class=\"code-word\">        user2.send(\"Hey\", \"1\");\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">//输出结果\n</div></li><li><div class=\"code-word\">Spike :: Sending Message : Hello man\n</div></li><li><div class=\"code-word\">Mia :: Received Message : Hello man\n</div></li><li><div class=\"code-word\">Mia :: Sending Message : Hey\n</div></li><li><div class=\"code-word\">Spike :: Received Message : Hey\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"970\">\n                      到此，我们就完成了一个简单的聊天室程序。从代码实现中能看出，<strong\n                        data-nodeid=\"1080\"\n                        >中介者在使用时需要知道对象之间的交互关系，然后通过封装这些交互关系的变化让对象在使用中介者时变得更简单</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"971\">为什么使用中介者模式？</h3>\n                    <p data-nodeid=\"972\">\n                      分析完中介者模式的原理和使用场景后，我们再来说说使用中介者模式的原因，可总结为以下三个。\n                    </p>\n                    <p data-nodeid=\"973\">\n                      <strong data-nodeid=\"1087\"\n                        >第一个，解决对象之间直接耦合的问题，避免“一处修改多处”的连锁反应出现</strong\n                      >。比如，在上面聊天室的例子中，如果用户与用户之间是直连通信的，那么任何一个用户对象发生变化都会影响到直接聊天的那个用户，而那个用户可能又在跟别的用户聊天，以此类推，用户之间的关系会变得越来越复杂。这样，当我们再修改代码时，就很容易造成“一处修改又引起多处修改”的连锁反应。而使用中介者模式时，用户会通过聊天室和别的用户通信，避免了直接与对方通信，这样修改某个用户对象时并不会影响到其他对象。\n                    </p>\n                    <p data-nodeid=\"974\">\n                      <strong data-nodeid=\"1092\"\n                        >第二个，在结构上作为中转，解耦两个服务或系统之间的直接耦合关系</strong\n                      >。在分层架构中，我们都知道视图层一般不会直接使用 DAO\n                      层，因为一旦直接使用，DAO\n                      层任何一个微小的变动都可能引起视图层的变化，这时通常会引入\n                      Service\n                      层作为中介者来进行请求的转发，以达到解耦的目的，避免了相互之间的直接影响，同时也能在中间层里加入一些特定的逻辑，如性能监控、埋点数据记录等。\n                    </p>\n                    <p data-nodeid=\"975\">\n                      <strong data-nodeid=\"1097\"\n                        >第三个，为了更便捷地统一协同对象之间的通信</strong\n                      >。我们知道在对远程服务器进行调用时，协调网络通信是一件异常复杂和烦琐的事情，这时如果有一个中介者来统一协调，则会大大提升效率，比如，Dubbo\n                      一类的 RPC 框架就是一个完整的中介者模式的体现。对于所有的\n                      Java RPC\n                      调用来说，只需要通过这个中间层来进行通信即可，而不需要知道对方服务器地址以及如何发起网络调用。\n                    </p>\n                    <h3 data-nodeid=\"976\">收益什么？损失什么？</h3>\n                    <p data-nodeid=\"977\">\n                      通过以上分析，我们可以得出中介者模式主要有这样几个优点。\n                    </p>\n                    <ul data-nodeid=\"978\">\n                      <li data-nodeid=\"979\">\n                        <p data-nodeid=\"980\">\n                          <strong data-nodeid=\"1104\"\n                            >减少对象之间的直接交互，间接解耦过多依赖</strong\n                          >。比如，Maven 就是 Java 中引用 jar\n                          包时的中介者，如果我们手动直接引用 jar\n                          包，会容易造成非常混乱的引用关系，而使用 Maven\n                          则能很方便地减少代码直接依赖 jar 包的问题。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"981\">\n                        <p data-nodeid=\"982\">\n                          <strong data-nodeid=\"1109\">减少子类的创建数量</strong\n                          >。比如，在多个用户的会话请求中，我们可以使用一个通用的上下文的中介者来保存会话中一些不变的静态数据，这样就不需要每新增一个会话都需要新增一些静态数据。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"983\">\n                        <p data-nodeid=\"984\">\n                          <strong data-nodeid=\"1114\"\n                            >简化各系统的设计和实现</strong\n                          >。由于中介者能够处理一些共用的通信逻辑，所以其他对象在进行自身业务的处理时可以不用关心共用的通信逻辑，这样就大大减少了系统的实现逻辑。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"985\">\n                        <p data-nodeid=\"986\">\n                          <strong data-nodeid=\"1119\"\n                            >通过新建中间层快速扩展新功能，提升代码扩展性</strong\n                          >。比如，对象通过中间层调用时，我们可以在中间层加入对每一次请求或方法调用的耗时统计，这样就能快速扩展功能。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"987\">同样，中介者模式也有一些缺点。</p>\n                    <ul data-nodeid=\"988\">\n                      <li data-nodeid=\"989\">\n                        <p data-nodeid=\"990\">\n                          <strong data-nodeid=\"1125\"\n                            >中介者类中的交互逻辑可能变得非常复杂且难以维护</strong\n                          >。当中介者类中包含了太多对象之间的交互细节后，中介者就变成了新的复杂对象，使得系统维护成本变高。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"991\">\n                        <p data-nodeid=\"992\">\n                          <strong data-nodeid=\"1130\"\n                            >中介者变成了新的重度依赖对象</strong\n                          >。一旦中介者对象变得复杂后，势必会增加与其他对象之间的耦合度，而这时如果中介者对象发生故障，则依赖的相关对象也会受到影响，修改中介者也会影响关联对象。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"993\">\n                        <p data-nodeid=\"994\">\n                          <strong data-nodeid=\"1135\"\n                            >中介者需要知道所有对象交互的逻辑</strong\n                          >。由于中介者对象承担了交互对象的传输渠道，所以就需要知道对象交互的详细细节，这样无疑增加了中介者对象的学习成本。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"995\">总结</h3>\n                    <p data-nodeid=\"996\">\n                      虽然中介者模式的原理和实现都非常简单，但是中介者在系统中承担的责任却是非常重要的。\n                    </p>\n                    <p data-nodeid=\"997\">中介者通常会承担两方面的职责。</p>\n                    <ul data-nodeid=\"998\">\n                      <li data-nodeid=\"999\">\n                        <p data-nodeid=\"1000\">\n                          一方面是<strong data-nodeid=\"1144\"\n                            >中转作用（结构性）</strong\n                          >。不同对象通过中介者进行中转就意味着不再需要显式直接引用对象，比如聊天中的两个用户。当用户需要和另一个对象进行通信时，只需要通过中介者，而不需要直接和对方建立联系。这样从结构上不再会形成网状结构，而是以某个中介者为中心的星型结构，这样能极大地降低对象的结构耦合性。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1001\">\n                        <p data-nodeid=\"1002\">\n                          另一方面是<strong data-nodeid=\"1150\"\n                            >协调作用（行为性）</strong\n                          >。中介者会在自身内部分装协调逻辑，并对同类型的对象请求进行统一的处理。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1003\">\n                      总结来讲，<strong data-nodeid=\"1156\"\n                        >中介者模式提供了一种减少对象之间耦合度的思路</strong\n                      >。对于一些维护性的旧项目来说，直接修改已有代码通常都会导致系统出现问题，而通过引入中间层，能够起到过渡的作用，同时还能够逐渐解耦原有的强耦合关系，让系统的扩展性变得更强。不过，中介者也可能因此变得异常复杂，一旦中介者出现问题，就会导致所有系统都出现问题，所以在使用时也需要注意设计的度。\n                    </p>\n                    <h3 data-nodeid=\"1004\">课后思考</h3>\n                    <p data-nodeid=\"1005\">\n                      学习了中介者模式后，你有没有发现，随着对象与对象都通过中介者来交互后，通信的效率其实反而变差了，中介者可能承担的职责会变得更多，这样会不会引发新的问题呢？为什么？欢迎你在留言区与我分享你的想法和答案。\n                    </p>\n                    <p data-nodeid=\"1006\" class=\"\">\n                      在下一讲，我会接着与你分享“迭代器模式与实现遍历数据时的职责分离”的相关内容，记得按时来听课！\n                    </p>\n            "}