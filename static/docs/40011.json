{"title":"10 | 与其他框架相比，React 的 diff 算法有何不同？","context":"\n                    <p data-nodeid=\"29600\" class=\"\">\n                      diff 算法通常被认为 React\n                      的核心点，在面试中很受重视。之前，关于 diff\n                      算法的问法仅仅停留在“React 的 diff\n                      算法的流程是什么”。但近几年有所变化，问题开始变得多样了，一个比较常见的场景是对比其他框架进行阐述。这一讲我们来一起探讨下这个问题应该如何回答。\n                    </p>\n                    <h3 data-nodeid=\"29601\">破题</h3>\n                    <p data-nodeid=\"29602\">\n                      这个题目虽然有对比，但本质上仍然是一道原理题。根据我们之前学习的方法论，原理题需要按照“<strong\n                        data-nodeid=\"29740\"\n                        >讲概念</strong\n                      >，<strong data-nodeid=\"29741\">说用途</strong>，<strong\n                        data-nodeid=\"29742\"\n                        >理思路</strong\n                      >，<strong data-nodeid=\"29743\">优缺点</strong>，<strong\n                        data-nodeid=\"29744\"\n                        >列一遍</strong\n                      >”的思路来答题。\n                    </p>\n                    <p data-nodeid=\"29603\">\n                      针对 React 而言，diff 算法是对<strong data-nodeid=\"29761\"\n                        >知识深度的考核</strong\n                      >。面试官考察的不仅仅是你会用就可以，更重要的是你在使用中有没有思考，对\n                      diff\n                      算法有没有透彻的理解，这是本题的第一道关卡。对于前端工程师而言，<strong\n                        data-nodeid=\"29762\"\n                        >这是一道能够快速划分</strong\n                      >“<strong data-nodeid=\"29763\">内功</strong>”<strong\n                        data-nodeid=\"29764\"\n                        >等级的常见题目。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"29604\">\n                      而题目中的“其他框架”，则是在考核你知识面的广度。所以你在回答的时候，务必采取“先分类，后讲述”的方式。切忌语无伦次，没有条理、没有区分度、一股脑地表达。而且，你的分类方式还向面试官透露了对知识点的理解度。\n                    </p>\n                    <p data-nodeid=\"29605\">\n                      那讲到 React，不得不说的其他框架有两个。\n                    </p>\n                    <ul data-nodeid=\"29606\">\n                      <li data-nodeid=\"29607\">\n                        <p data-nodeid=\"29608\">\n                          Vue，因为 React 与 Vue 是国内前端中的主流框架。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29609\">\n                        <p data-nodeid=\"29610\">\n                          类 React 框架，又被称为 React-like 框架，通常是指\n                          Preact、 inferno 等兼容 React API 的框架，它们与 React\n                          设计相似、 使用相似。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"29611\">\n                      所以该讲我们就拿 Vue 和 Preact 与 React 的 diff\n                      算法进行比较。\n                    </p>\n                    <h3 data-nodeid=\"29612\">承题</h3>\n                    <p data-nodeid=\"29613\">\n                      到这里，我们就清楚了本讲考察的两个重点，可以梳理出这样的一个答题框架：\n                    </p>\n                    <ol data-nodeid=\"29614\">\n                      <li data-nodeid=\"29615\">\n                        <p data-nodeid=\"29616\">\n                          就 React diff\n                          算法完成“讲概念，说用途，理思路，优缺点，列一遍”的组合拳；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29617\">\n                        <p data-nodeid=\"29618\">\n                          横向对比 React、React-like 框架及 Vue 的 diff 算法。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"29619\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/55/CgqCHl_qyoCARaC-AABHz3sJYwo329.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"29776\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"29620\">入手</h3>\n                    <h4 data-nodeid=\"29621\">Diff 算法</h4>\n                    <p data-nodeid=\"29622\">\n                      首先主角当然是“diff 算法”，但讨论 diff\n                      算法一定是建立在虚拟 DOM 的基础上的。第 09 讲“Virtual DOM\n                      的工作原理是什么？”讲过，使用虚拟 DOM 而非直接操作真实 DOM\n                      是现代前端框架的一个基本认知。\n                    </p>\n                    <p data-nodeid=\"29623\">\n                      而 diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM\n                      树更新补丁的方式。它通过对比新旧两株虚拟 DOM\n                      树的变更差异，将更新补丁作用于真实\n                      DOM，以最小成本完成视图更新。\n                    </p>\n                    <p data-nodeid=\"29624\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/55/CgqCHl_qyouAAkb9AAB_cmWuZhc920.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"29783\"\n                      />\n                    </p>\n                    <p data-nodeid=\"29625\">具体的流程是这样的：</p>\n                    <ul data-nodeid=\"29626\">\n                      <li data-nodeid=\"29627\">\n                        <p data-nodeid=\"29628\">\n                          真实 DOM 与虚拟 DOM\n                          之间存在一个映射关系。这个映射关系依靠初始化时的 JSX\n                          建立完成；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29629\">\n                        <p data-nodeid=\"29630\">\n                          当虚拟 DOM 发生变化后，就会根据差距计算生成\n                          patch，这个 patch\n                          是一个结构化的数据，内容包含了增加、更新、移除等；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29631\">\n                        <p data-nodeid=\"29632\">\n                          最后再根据 patch 去更新真实的\n                          DOM，反馈到用户的界面上。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"29633\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/55/CgqCHl_qypGAZPuGAADYrK9nkJY878.png\"\n                        alt=\"Drawing 4.png\"\n                        data-nodeid=\"29790\"\n                      />\n                    </p>\n                    <p data-nodeid=\"29634\">举一个简单易懂的例子：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">import React from 'react'\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">export default class ExampleComponent extends React.Component {\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    if(this.props.isVisible) {\n</div></li><li><div class=\"code-word\">       return &lt;div className=\"visible\"&gt;visbile&lt;/div&gt;;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">     return &lt;div className=\"hidden\"&gt;hidden&lt;/div&gt;;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"29636\">\n                      这里，首先我们假定 ExampleComponent\n                      可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM\n                      操作是这样的，React 会创建一个 div 节点。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"> &lt;div class=\"visible\"&gt;visbile&lt;/div&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"29638\">\n                      当把 visbile 的值变为 false 时，就会替换 class 属性为\n                      hidden，并重写内部的 innerText 为 hidden。这样一个<strong\n                        data-nodeid=\"29802\"\n                        >生成补丁</strong\n                      >、<strong data-nodeid=\"29803\">更新差异</strong\n                      >的过程统称为 diff 算法。\n                    </p>\n                    <p data-nodeid=\"29639\">\n                      在整个过程中你需要注意 3 点：<strong data-nodeid=\"29809\"\n                        >更新时机、遍历算法、优化策略</strong\n                      >，这些也是面试官最爱考察的。\n                    </p>\n                    <p data-nodeid=\"29640\">\n                      <strong data-nodeid=\"29813\">更新时机</strong>\n                    </p>\n                    <p data-nodeid=\"29641\">\n                      更新时机就是触发更新、进行差异对比的时机。根据前面的章节内容可以知道，更新发生在setState、Hooks\n                      调用等操作以后。此时，树的结点发生变化，开始进行比对。那这里涉及一个问题，即两株树如何对比差异?\n                    </p>\n                    <p data-nodeid=\"29642\">这里就需要使用遍历算法。</p>\n                    <p data-nodeid=\"29643\">\n                      <strong data-nodeid=\"29819\">遍历算法</strong>\n                    </p>\n                    <p data-nodeid=\"29644\">\n                      遍历算法是指沿着某条搜索路线，依次对树的每个节点做访问。通常分为两种：深度优先遍历和广度优先遍历。\n                    </p>\n                    <ul data-nodeid=\"29645\">\n                      <li data-nodeid=\"29646\">\n                        <p data-nodeid=\"29647\">\n                          深度优先遍历，是从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29648\">\n                        <p data-nodeid=\"29649\">\n                          广度优先遍历，则是从根节点出发，在横向遍历二叉树层段节点的基础上，纵向遍历二叉树的层次。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"29650\">\n                      React 选择了哪一种遍历方式呢？它的 diff\n                      算法采用了深度优先遍历算法。因为广度优先遍历可能会导致组件的生命周期时序错乱，而深度优先遍历算法就可以解决这个问题。\n                    </p>\n                    <p data-nodeid=\"29651\">\n                      <strong data-nodeid=\"29827\">优化策略</strong>\n                    </p>\n                    <p data-nodeid=\"29652\">\n                      优化策略是指 React 对 diff 算法做的优化手段。\n                    </p>\n                    <p data-nodeid=\"29653\">\n                      虽然深度优先遍历保证了组件的生命周期时序不错乱，但传统的\n                      diff 算法也带来了一个严重的性能瓶颈，复杂程度为\n                      O(n^3)(后期备注上角标)，其中 n\n                      表示树的节点总数。正如计算机科学中常见的优化方案一样，React\n                      用了一个非常经典的手法将复杂度降低为 O(n)，也就是<a\n                        href=\"https://leetcode-cn.com/tag/divide-and-conquer/\"\n                        data-nodeid=\"29832\"\n                        >分治</a\n                      >，即通过“分而治之”这一巧妙的思想分解问题。\n                    </p>\n                    <p data-nodeid=\"29654\">\n                      具体而言， React 分别从<strong data-nodeid=\"29847\"\n                        >树</strong\n                      >、<strong data-nodeid=\"29848\">组件</strong>及<strong\n                        data-nodeid=\"29849\"\n                        >元素</strong\n                      >三个层面进行复杂度的优化，并诞生了与之对应的策略。\n                    </p>\n                    <p data-nodeid=\"29655\">\n                      <strong data-nodeid=\"29858\">策略一</strong>：<strong\n                        data-nodeid=\"29859\"\n                        >忽略节点跨层级操作场景，提升比对效率</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"29656\">\n                      这一策略需要进行<strong data-nodeid=\"29865\">树比对</strong\n                      >，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。\n                    </p>\n                    <p data-nodeid=\"29657\">\n                      <strong data-nodeid=\"29882\">策略二</strong>：<strong\n                        data-nodeid=\"29883\"\n                        >如果组件的 class 一致</strong\n                      >，<strong data-nodeid=\"29884\"\n                        >则默认为相似的树结构</strong\n                      >，<strong data-nodeid=\"29885\"\n                        >否则默认为不同的树结构</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"29658\">在组件比对的过程中：</p>\n                    <ul data-nodeid=\"29659\">\n                      <li data-nodeid=\"29660\">\n                        <p data-nodeid=\"29661\">\n                          如果组件是同一类型则进行树比对；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29662\">\n                        <p data-nodeid=\"29663\">如果不是则直接放入补丁中。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"29664\">\n                      只要父组件类型不同，就会被重新渲染。这也就是为什么\n                    </p>\n                    <p data-nodeid=\"29665\">\n                      shouldComponentUpdate、PureComponent 及 React.memo\n                      可以提高性能的原因。\n                    </p>\n                    <p data-nodeid=\"29666\">\n                      <strong data-nodeid=\"29899\"\n                        >策略三：同一层级的子节点</strong\n                      >，<strong data-nodeid=\"29900\"\n                        >可以通过标记 key 的方式进行列表对比</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"29667\">\n                      元素比对主要发生在同层级中，通过<strong\n                        data-nodeid=\"29906\"\n                        >标记节点操作</strong\n                      >生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。\n                    </p>\n                    <p data-nodeid=\"29668\">\n                      通过标记 key 的方式，React 可以直接移动 DOM\n                      节点，降低内耗。操作代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;ul&gt;\n</div></li><li><div class=\"code-word\">  &lt;li key=\"a\"&gt;a&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li key=\"b\"&gt;b&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li key=\"c\"&gt;c&lt;/li&gt;\n</div></li><li><div class=\"code-word\">  &lt;li key=\"d\"&gt;d&lt;/li&gt;\n</div></li><li><div class=\"code-word\">&lt;/ui&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"29670\">\n                      以上是 React Diff 算法最基本的内容，除此以外，由于 React\n                      16 引入<strong data-nodeid=\"29913\">Fiber 设计</strong\n                      >，所以我们还需要了解 Fiber 给 diff 算法带来的影响。\n                    </p>\n                    <p data-nodeid=\"29671\">\n                      Fiber 机制下节点与树分别采用 FiberNode 与 FiberTree\n                      进行重构。FiberNode\n                      使用了双链表的结构，可以直接找到兄弟节点与子节点，使得整个更新过程可以随时暂停恢复。FiberTree\n                      则是通过 FiberNode 构成的树。\n                    </p>\n                    <p data-nodeid=\"29672\">\n                      Fiber 机制下，整个更新过程由 current 与 workInProgress\n                      两株树双缓冲完成。当 workInProgress 更新完成后，通过修改\n                      current\n                      相关指针指向的节点，直接抛弃老树，虽然非常简单粗暴，却非常合理。\n                    </p>\n                    <p data-nodeid=\"29673\">\n                      这些就是 React 中 diff\n                      算法的回答要点，我们再来看看其他框架需要掌握什么。\n                    </p>\n                    <h4 data-nodeid=\"29674\">其他框架</h4>\n                    <p data-nodeid=\"29675\">\n                      <strong data-nodeid=\"29921\">Preact</strong>\n                    </p>\n                    <p data-nodeid=\"29676\">\n                      在众多的 React-like 框架中，<strong data-nodeid=\"29927\"\n                        >Preact 适用范围最广，生命力最强</strong\n                      >。它以仅 3kb\n                      的小巧特点应用于对体积追求非常极致的场景。也正因为体积受限，Preact\n                      在 diff 算法上做了裁剪。\n                    </p>\n                    <p data-nodeid=\"29677\">\n                      以下 Preact 的 diff 算法的图示，可以看到它将 diff\n                      分为了三个类型：Fragment、Component 及 DOM Node。\n                    </p>\n                    <p data-nodeid=\"29678\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8C/4A/Ciqc1F_qyqeAWvpYAAEVYxYrQis686.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"29931\"\n                      />\n                    </p>\n                    <ul data-nodeid=\"29679\">\n                      <li data-nodeid=\"29680\">\n                        <p data-nodeid=\"29681\">\n                          Fragment 对应 React 的树比较；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29682\">\n                        <p data-nodeid=\"29683\">\n                          Component\n                          对应组件比较，它们在原理上是相通的，所以这里我们不再赘述；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"29684\">\n                        <p data-nodeid=\"29685\">\n                          最大的不同在于 DOM Node 这一层，Preact 并没有 Patch\n                          的过程，而是直接更新 DOM 节点属性。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"29686\">\n                      <strong data-nodeid=\"29938\">Vue</strong>\n                    </p>\n                    <p data-nodeid=\"29687\">\n                      Vue 2.0 因为使用了\n                      <a\n                        href=\"https://github.com/snabbdom/snabbdom/tree/8079ba78685b0f0e0e67891782c3e8fb9d54d5b8\"\n                        data-nodeid=\"29942\"\n                        >snabbdom</a\n                      >，所以整体思路与 React\n                      相同。但在元素对比时，如果新旧两个元素是同一个元素，且没有设置\n                      key 时，snabbdom 在 diff 子元素中会一次性对比<strong\n                        data-nodeid=\"29960\"\n                        >旧节点</strong\n                      >、<strong data-nodeid=\"29961\">新节点</strong\n                      >及它们的<strong data-nodeid=\"29962\">首尾元素</strong\n                      >四个节点，以及<strong data-nodeid=\"29963\"\n                        >验证列表</strong\n                      >是否有变化。Vue 3.0 整体变化不大，依然没有引入 Fiber\n                      等设计，也没有时间切片等功能。\n                    </p>\n                    <h3 data-nodeid=\"29688\">答题</h3>\n                    <blockquote data-nodeid=\"29689\">\n                      <p data-nodeid=\"29690\">\n                        在回答有何不同之前，首先需要说明下什么是 diff 算法。\n                      </p>\n                      <p data-nodeid=\"29691\">\n                        diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM\n                        树变化后，更新真实 DOM。所以 diff\n                        算法一定存在这样一个过程：触发更新 → 生成补丁 →\n                        应用补丁。\n                      </p>\n                      <p data-nodeid=\"29692\">\n                        React 的 diff 算法，触发更新的时机主要在 state 变化与\n                        hooks 调用之后。此时触发虚拟 DOM\n                        树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了\n                        3 种类型节点的比对，分别是树、组件及元素，以此提升效率。\n                      </p>\n                      <p data-nodeid=\"29693\">\n                        树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM\n                        树只对同一层次的节点进行比较。\n                      </p>\n                      <p data-nodeid=\"29694\">\n                        组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。\n                      </p>\n                      <p data-nodeid=\"29695\">\n                        元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的\n                        DOM 剪裁操作。\n                      </p>\n                      <p data-nodeid=\"29696\">\n                        以上是经典的 React diff 算法内容。自 React 16 起，引入了\n                        Fiber\n                        架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了\n                        FiberNode 与 FiberTree 进行重构。fiberNode\n                        使用了双链表的结构，可以直接找到兄弟节点与子节点。\n                      </p>\n                      <p data-nodeid=\"29697\">\n                        整个更新过程由 current 与 workInProgress\n                        两株树双缓冲完成。workInProgress 更新完成后，再通过修改\n                        current 相关指针指向新节点。\n                      </p>\n                      <p data-nodeid=\"29698\">\n                        然后拿 Vue 和 Preact 与 React 的 diff 算法进行对比。\n                      </p>\n                      <p data-nodeid=\"29699\">\n                        Preact 的 Diff 算法相较于\n                        React，整体设计思路相似，但最底层的元素采用了真实 DOM\n                        对比操作，也没有采用 Fiber 设计。Vue 的 Diff\n                        算法整体也与 React 相似，同样未实现 Fiber 设计。\n                      </p>\n                      <p data-nodeid=\"29700\">\n                        然后进行横向比较，React 拥有完整的 Diff\n                        算法策略，且拥有随时中断更新的时间切片能力，在大批量节点更新的极端情况下，拥有更友好的交互体验。\n                      </p>\n                      <p data-nodeid=\"29701\">\n                        Preact\n                        可以在一些对性能要求不高，仅需要渲染框架的简单场景下应用。\n                      </p>\n                      <p data-nodeid=\"29702\">\n                        Vue 的整体 diff 策略与 React\n                        对齐，虽然缺乏时间切片能力，但这并不意味着 Vue\n                        的性能更差，因为在 Vue 3\n                        初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在\n                        Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"29703\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/04/31/CgpVE1_q2zGAe9UzAACKAZViwbM237.png\"\n                        alt=\"Diff 算法1.png\"\n                        data-nodeid=\"29980\"\n                      /><br />\n                      这里需要注意的是：对比过程中切忌踩一捧一，容易引发面试官反感。\n                    </p>\n                    <h3 data-nodeid=\"29704\">进阶</h3>\n                    <p data-nodeid=\"29705\">\n                      <strong data-nodeid=\"29988\"\n                        >学习原理的目的就是应用。那如何根据 React diff\n                        算法原理优化代码呢？</strong\n                      >\n                      这个问题其实按优化方式逆向回答即可。\n                    </p>\n                    <blockquote data-nodeid=\"29706\">\n                      <p data-nodeid=\"29707\">\n                        根据 diff 算法的设计原则，应尽量避免跨层级节点移动。\n                      </p>\n                      <p data-nodeid=\"29708\">\n                        通过设置唯一 key\n                        进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题。\n                      </p>\n                      <p data-nodeid=\"29709\">\n                        设置 shouldComponentUpdate 或者 React.pureComponet 减少\n                        diff 次数。\n                      </p>\n                    </blockquote>\n                    <h3 data-nodeid=\"29710\">总结</h3>\n                    <p data-nodeid=\"29711\">\n                      diff 算法一直在 React\n                      中处于核心的位置，所以本讲讲到的内容，你一定要掌握。如果你有什么问题或者想法，欢迎留言与我互动。\n                    </p>\n                    <p data-nodeid=\"29712\">\n                      在下一讲，我会为你讲述 React 的渲染流程，下节课见！\n                    </p>\n                    <hr data-nodeid=\"29713\" />\n                    <p data-nodeid=\"29714\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"29999\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image/M00/72/94/Ciqc1F_EZ0eANc6tAASyC72ZqWw643.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"29998\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"29715\">《大前端高薪训练营》</p>\n                    <p data-nodeid=\"29716\" class=\"te-preview-highlight\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"30004\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}