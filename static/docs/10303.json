{"title":"02 | 为什么 React 16 要更改组件的生命周期？（上）","context":"\n                    <p data-nodeid=\"1389\" class=\"\">\n                      React 生命周期已经是一个老生常谈的话题了，几乎没有哪一门\n                      React\n                      入门教材会省略对组件生命周期的介绍。然而，入门教材在设计上往往追求的是“简单省事、迅速上手”，这就导致许多同学对于生命周期知识的刻板印象为“背就完了、别想太多”。\n                    </p>\n                    <p data-nodeid=\"1390\">\n                      “背就完了”这样简单粗暴的学习方式，或许可以帮助你理解“What\n                      to do”，到达“How to do”，但却不能帮助你去思考和认知“Why to\n                      do”。作为一个专业的 React\n                      开发者，我们必须要求自己在知其然的基础上，知其所以然。\n                    </p>\n                    <p data-nodeid=\"1391\">\n                      在本课时和下一个课时，我将抱着帮你做到“知其所以然”的目的，以\n                      React 的基本原理为引子，<strong data-nodeid=\"1503\"\n                        >对 React 15、React 16\n                        两个版本的生命周期进行探讨、比对和总结，通过搞清楚一个又一个的“Why”，来帮你建立系统而完善的生命周期知识体系</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"1392\">\n                      生命周期背后的设计思想：把握 React 中的“大方向”\n                    </h3>\n                    <p data-nodeid=\"1393\">\n                      在介绍具体的生命周期之前，我想先带你初步理解 React\n                      框架中的一些关键的设计思想，以便为你后续的学习提供不可或缺的“加速度”。\n                    </p>\n                    <p data-nodeid=\"1394\">\n                      如果你经常翻阅 React 官网或者 React\n                      官方的一些文章，你会发现“<strong data-nodeid=\"1515\"\n                        >组件</strong\n                      >”和“<strong data-nodeid=\"1516\">虚拟 DOM</strong\n                      >”这两个词的出镜率是非常高的，它们是 React\n                      基本原理中极为关键的两个概念，也是我们这个小节的学习切入点。\n                    </p>\n                    <h4 data-nodeid=\"1395\">虚拟 DOM：核心算法的基石</h4>\n                    <p data-nodeid=\"1396\">\n                      通过 01 课时的学习，你已经知晓了虚拟 DOM\n                      节点的基本形态，现在我们需要简单了解下虚拟 DOM 在整个\n                      React 工作流中的作用。\n                    </p>\n                    <p data-nodeid=\"1397\">\n                      组件在初始化时，会通过调用生命周期中的 render\n                      方法，<strong data-nodeid=\"1524\">生成虚拟 DOM</strong\n                      >，然后再通过调用 ReactDOM.render 方法，实现虚拟 DOM\n                      到真实 DOM 的转换。\n                    </p>\n                    <p data-nodeid=\"1398\">\n                      当组件更新时，会再次通过调用 render 方法<strong\n                        data-nodeid=\"1534\"\n                        >生成新的虚拟 DOM</strong\n                      >，然后借助\n                      diff（这是一个非常关键的算法，我将在“模块二：核心原理”重点讲解）<strong\n                        data-nodeid=\"1535\"\n                        >定位出两次虚拟 DOM 的差异</strong\n                      >，从而针对发生变化的真实 DOM 作定向更新。\n                    </p>\n                    <p data-nodeid=\"1399\">\n                      以上就是 React\n                      框架核心算法的大致流程。对于这套关键的工作流来说，“虚拟\n                      DOM”是所有操作的大前提，是核心算法的基石。\n                    </p>\n                    <h4 data-nodeid=\"1400\">组件化：工程化思想在框架中的落地</h4>\n                    <p data-nodeid=\"1401\">\n                      组件化是一种优秀的软件设计思想，也是 React\n                      团队在研发效能方面所做的一个重要的努力。\n                    </p>\n                    <p data-nodeid=\"1402\">\n                      在一个 React\n                      项目中，几乎所有的可见/不可见的内容都可以被抽离为各种各样的组件，每个组件既是“封闭”的，也是“开放”的。\n                    </p>\n                    <p data-nodeid=\"1403\">\n                      所谓“封闭”，主要是针对“渲染工作流”（指从<strong\n                        data-nodeid=\"1549\"\n                        >组件数据改变</strong\n                      >到<strong data-nodeid=\"1550\">组件实际更新发生的</strong\n                      >过程）来说的。在组件自身的渲染工作流中，每个组件都只处理它内部的渲染逻辑。在没有数据流交互的情况下，组件与组件之间可以做到“各自为政”。\n                    </p>\n                    <p data-nodeid=\"1404\">\n                      而所谓“开放”，则是针对组件间通信来说的。React\n                      允许开发者基于“单向数据流”的原则完成组件间的通信。而组件之间的通信又将改变通信双方/某一方内部的数据，进而对渲染结果构成影响。所以说在数据这个“红娘”的牵线搭桥之下，组件之间又是彼此开放的，是可以相互影响的。\n                    </p>\n                    <p data-nodeid=\"1405\">\n                      这一“开放”与“封闭”兼具的特性，使得 React 组件<strong\n                        data-nodeid=\"1557\"\n                        >既专注又灵活</strong\n                      >，具备高度的可重用性和可维护性。\n                    </p>\n                    <h4 data-nodeid=\"1406\">\n                      生命周期方法的本质：组件的“灵魂”与“躯干”\n                    </h4>\n                    <p data-nodeid=\"1407\">\n                      之前我曾经在社区读过一篇文章，文中将 render 方法形容为\n                      React\n                      组件的“灵魂”。当时我对这句话产生了非常强烈的共鸣，这里我就想以这个曾经打动过我的比喻为引子，帮助你从宏观上建立对\n                      React 生命周期的感性认知。\n                    </p>\n                    <p data-nodeid=\"1408\">\n                      注意，这里提到的 render 方法，和我们 01 课时所说的\n                      ReactDOM.render 可不是一个东西，它指的是 React\n                      组件内部的这个生命周期方法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LifeCycle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"render方法执行\"</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        this is content\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1410\">\n                      前面咱们介绍了虚拟\n                      DOM、组件化，倘若把这两块知识整合一下，你就会发现这两个概念似乎都在围着\n                      render 这个生命周期打转：虚拟 DOM\n                      自然不必多说，它的生成都要仰仗\n                      render；而组件化概念中所提及的“渲染工作流”，这里指的是从<strong\n                        data-nodeid=\"1570\"\n                        >组件数据改变</strong\n                      >到<strong data-nodeid=\"1571\">组件实际更新发生的</strong\n                      >过程，这个过程的实现同样离不开 render。\n                    </p>\n                    <p data-nodeid=\"1411\">\n                      由此看来，render\n                      方法在整个组件生命周期中确实举足轻重，它担得起“灵魂”这个有分量的比喻。那么如果将\n                      render 方法比作组件的“<strong data-nodeid=\"1581\"\n                        >灵魂</strong\n                      >”，render\n                      之外的生命周期方法就完全可以理解为是组件的“<strong\n                        data-nodeid=\"1582\"\n                        >躯干</strong\n                      >”。\n                    </p>\n                    <p data-nodeid=\"1412\">\n                      “躯干”未必总是会做具体的事情（比如说我们可以选择性地省略对\n                      render\n                      之外的任何生命周期方法内容的编写），而“灵魂”却总是充实的（render\n                      函数却坚决不能省略）；倘若“躯干”做了点什么，往往都会直接或间接地影响到“灵魂”（因为即便是\n                      render 之外的生命周期逻辑，也大部分是在为 render\n                      层面的效果服务）；“躯干”和“灵魂”一起，共同构成了 React\n                      组件完整而不可分割的“生命时间轴”。\n                    </p>\n                    <h3 data-nodeid=\"1413\">\n                      拆解 React 生命周期：从 React 15 说起\n                    </h3>\n                    <p data-nodeid=\"1414\">\n                      我发现时下许多资料在讲解 React 生命周期时，喜欢直接拿\n                      React 16\n                      开刀。这样做虽然省事儿，却也模糊掉了新老生命周期变化背后的“Why”（关于两者的差异，我们会在“03\n                      课时”中详细讲解）。这里为了把这个“Why”拎出来，我将首先带你认识\n                      React 15 的生命周期流程。\n                    </p>\n                    <p data-nodeid=\"1415\">\n                      在 React 15 中，大家需要关注以下几个生命周期方法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">constructor()\n</div></li><li><div class=\"code-word\">componentWillReceiveProps()\n</div></li><li><div class=\"code-word\">shouldComponentUpdate()\n</div></li><li><div class=\"code-word\">componentWillMount()\n</div></li><li><div class=\"code-word\">componentWillUpdate()\n</div></li><li><div class=\"code-word\">componentDidUpdate()\n</div></li><li><div class=\"code-word\">componentDidMount()\n</div></li><li><div class=\"code-word\">render()\n</div></li><li><div class=\"code-word\">componentWillUnmount()\n</div></li></ol></code></pre>\n                    </div>\n                    <blockquote data-nodeid=\"1417\">\n                      <p data-nodeid=\"1418\">\n                        如果你接触 React 足够早，或许会记得还有 getDefaultProps\n                        和 getInitState 这两个方法，它们都是 React.createClass()\n                        模式下初始化数据的方法。由于这种写法在 ES6\n                        普及后已经不常见，这里不再详细展开。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1419\">\n                      这些生命周期方法是如何彼此串联、相互依存的呢？这里我为你总结了一张大图：\n                    </p>\n                    <p data-nodeid=\"1420\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/31/Ciqc1F-GZbGAGNcBAAE775qohj8453.png\"\n                        alt=\"1.png\"\n                        data-nodeid=\"1591\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1421\">\n                      接下来，我就围绕这张大图，分阶段讨论组件生命周期的运作规律。在学习的过程中，下面这个\n                      Demo 可以帮助你具体地验证每个阶段的工作流程：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-dom\"</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 定义子组件</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LifeCycle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">constructor</span>(props) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"进入constructor\"</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">super</span>(props);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// state 可以在 constructor 里初始化</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.state = { <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"子组件的文本\"</span> };\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化渲染时调用</span>\n</div></li><li><div class=\"code-word\">  componentWillMount() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"componentWillMount方法执行\"</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化渲染时调用</span>\n</div></li><li><div class=\"code-word\">  componentDidMount() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"componentDidMount方法执行\"</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 父组件修改组件的props时会调用</span>\n</div></li><li><div class=\"code-word\">  componentWillReceiveProps(nextProps) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"componentWillReceiveProps方法执行\"</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 组件更新时调用</span>\n</div></li><li><div class=\"code-word\">  shouldComponentUpdate(nextProps, nextState) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"shouldComponentUpdate方法执行\"</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 组件更新时调用</span>\n</div></li><li><div class=\"code-word\">  componentWillUpdate(nextProps, nextState) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"componentWillUpdate方法执行\"</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 组件更新后调用</span>\n</div></li><li><div class=\"code-word\">  componentDidUpdate(preProps, preState) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"componentDidUpdate方法执行\"</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 组件卸载时调用</span>\n</div></li><li><div class=\"code-word\">  componentWillUnmount() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"子组件的componentWillUnmount方法执行\"</span>);\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 点击按钮，修改子组件文本内容的方法</span>\n</div></li><li><div class=\"code-word\">  changeText = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"修改后的子组件文本\"</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"render方法执行\"</span>);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.changeText}</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"changeText\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          修改子组件文本内容\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"textContent\"</span>&gt;</span>{this.state.text}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"fatherContent\"</span>&gt;</span>{this.props.text}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 定义 LifeCycle 组件的父组件</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LifeCycleContainer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// state 也可以像这样用属性声明的形式初始化</span>\n</div></li><li><div class=\"code-word\">  state = {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"父组件的文本\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">hideChild</span>: <span class=\"hljs-literal\">false</span>\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 点击按钮，修改父组件文本的方法</span>\n</div></li><li><div class=\"code-word\">  changeText = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"修改后的父组件文本\"</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span>\n</div></li><li><div class=\"code-word\">  hideChild = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">hideChild</span>: <span class=\"hljs-literal\">true</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"fatherContainer\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.changeText}</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"changeText\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          修改父组件文本内容\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.hideChild}</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"hideChild\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          隐藏子组件\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        {this.state.hideChild ? null : <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LifeCycle</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">{this.state.text}</span> /&gt;</span>}\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LifeCycleContainer</span> /&gt;</span></span>, <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"root\"</span>));\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"1423\">\n                      该入口文件对应的 index.html 中预置了 id 为 root 的真实 DOM\n                      节点作为根节点，body 标签内容如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;body&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"root\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/body&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1425\">\n                      这个 Demo 渲染到浏览器上大概是这样的：\n                    </p>\n                    <p data-nodeid=\"1426\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/CC/Ciqc1F-FU-yAMLh0AABeqOeqLek815.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"1597\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1427\">\n                      此处由于我们强调的是对生命周期执行规律的验证，所以样式上从简，你也可以根据自己的喜好添加\n                      CSS 相关的内容。\n                    </p>\n                    <p data-nodeid=\"1428\">\n                      接下来我们就结合这个 Demo\n                      和开头的生命周期大图，一起来看看挂载、更新、卸载这 3\n                      个阶段，React 组件都经历了哪些事情。\n                    </p>\n                    <h4 data-nodeid=\"1429\">\n                      Mounting 阶段：组件的初始化渲染（挂载）\n                    </h4>\n                    <p data-nodeid=\"1430\">\n                      挂载过程在组件的一生中仅会发生一次，在这个过程中，组件被初始化，然后会被渲染到真实\n                      DOM 里，完成所谓的“首次渲染”。\n                    </p>\n                    <p data-nodeid=\"1431\">\n                      在挂载阶段，一个 React\n                      组件会按照顺序经历如下图所示的生命周期：\n                    </p>\n                    <p data-nodeid=\"1432\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/32/Ciqc1F-GZ1OAWETTAAA3Am2CwU0383.png\"\n                        alt=\"3.png\"\n                        data-nodeid=\"1605\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1433\">\n                      首先我们来看 constructor\n                      方法，该方法仅仅在挂载的时候被调用一次，我们可以在该方法中对\n                      this.state 进行初始化：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">constructor(props) {\n</div></li><li><div class=\"code-word\">  console.log(<span class=\"hljs-string\">\"进入constructor\"</span>);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">super</span>(props);\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// state 可以在 constructor 里初始化</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">this</span>.state = { text: <span class=\"hljs-string\">\"子组件的文本\"</span> };\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1435\">\n                      componentWillMount、componentDidMount\n                      方法同样只会在挂载阶段被调用一次。其中 componentWillMount\n                      会在执行 render\n                      方法前被触发，一些同学习惯在这个方法里做一些初始化的操作，但这些操作往往会伴随一些风险或者说不必要性（这一点大家先建立认知，具体原因将在“03\n                      课时”展开讲解）。\n                    </p>\n                    <p data-nodeid=\"1436\">\n                      接下来 render 方法被触发。注意 render\n                      在执行过程中并不会去操作真实\n                      DOM（也就是说不会渲染），它的职能是<strong\n                        data-nodeid=\"1613\"\n                        >把需要渲染的内容返回出来</strong\n                      >。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render\n                      来承接的。\n                    </p>\n                    <p data-nodeid=\"1437\">\n                      componentDidMount 方法在渲染结束后被触发，此时因为真实 DOM\n                      已经挂载到了页面上，我们可以在这个生命周期里执行真实 DOM\n                      相关的操作。此外，类似于异步请求、数据初始化这样的操作也大可以放在这个生命周期来做（侧面印证了\n                      componentWillMount 真的很鸡肋）。\n                    </p>\n                    <p data-nodeid=\"1438\">\n                      这一整个流程对应的其实就是我们 Demo\n                      页面刚刚打开时，组件完成初始化渲染的过程。下图是 Demo 中的\n                      LifeCycle\n                      组件在挂载过程中控制台的输出，你可以用它来验证挂载过程中生命周期顺序的正确性：\n                    </p>\n                    <p data-nodeid=\"1439\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/D8/CgqCHl-FU_6AeWUcAAB8X4bjwqE102.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1618\"\n                      />\n                    </p>\n                    <h4 data-nodeid=\"1440\">Updating 阶段：组件的更新</h4>\n                    <p data-nodeid=\"1441\">\n                      组件的更新分为两种：一种是由父组件更新触发的更新；另一种是组件自身调用自己的\n                      setState\n                      触发的更新。这两种更新对应的生命周期流程如下图所示：\n                    </p>\n                    <p data-nodeid=\"1442\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5E/3C/CgqCHl-GZf-AUjsLAACmOsiQl3M485.png\"\n                        alt=\"2.png\"\n                        data-nodeid=\"1623\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1443\">\n                      <strong data-nodeid=\"1627\"\n                        >componentWillReceiProps 到底是由什么触发的？</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1444\">\n                      从图中你可以明显看出，父组件触发的更新和组件自身的更新相比，多出了这样一个生命周期方法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">componentWillReceiveProps(nextProps)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1446\">\n                      在这个生命周期方法里，nextProps 表示的是接收到新 props\n                      内容，而现有的 props （相对于 nextProps 的“旧\n                      props”）我们可以通过 this.props 拿到，由此便能够感知到\n                      props 的变化。\n                    </p>\n                    <p data-nodeid=\"1447\">\n                      写到这里，就不得不在“变化”这个动作上深挖一下了。我在一些社区文章里，包括一些候选人面试时的回答里，都不约而同地见过/听过这样一种说法：<strong\n                        data-nodeid=\"1634\"\n                        >componentWillReceiveProps 是在组件的 props\n                        内容发生了变化时被触发的。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1448\">\n                      <strong data-nodeid=\"1639\">这种说法不够严谨</strong\n                      >。远的不说，就拿咱们上文给出的 Demo\n                      开刀，该界面的控制台输出在初始化完成后是这样的：\n                    </p>\n                    <p data-nodeid=\"1449\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/CC/Ciqc1F-FVA6AYiD4AADSl2lr-_Q663.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"1642\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1450\">\n                      注意，我们代码里面，LifeCycleContainer\n                      这个父组件传递给子组件 LifeCycle 的 props 只有一个 text：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;LifeCycle text={<span class=\"hljs-keyword\">this</span>.state.text} /&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1452\">\n                      假如我点击“修改父组件文本内容”这个按钮，父组件的\n                      this.state.text 会发生改变，进而带动子组件的\n                      this.props.text 发生改变。此时一定会触发\n                      componentWillReceiveProps 这个生命周期，这是毋庸置疑的：\n                    </p>\n                    <p data-nodeid=\"1453\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/CC/Ciqc1F-FVBWAEqTGAAEdsvX2TAM747.png\"\n                        alt=\"Drawing 6.png\"\n                        data-nodeid=\"1647\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1454\">\n                      但如果我现在对父组件的结构进行一个小小的修改，给它一个和子组件完全无关的\n                      state（this.state.ownText），同时相应地给到一个修改这个\n                      state 的方法（this.changeOwnText），并用一个新的 button\n                      按钮来承接这个触发的动作。\n                    </p>\n                    <p data-nodeid=\"1455\">\n                      改变后的 LifeCycleContainer 如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 定义 LifeCycle 组件的父组件</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LifeCycleContainer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// state 也可以像这样用属性声明的形式初始化</span>\n</div></li><li><div class=\"code-word\">  state = {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"父组件的文本\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 新增的只与父组件有关的 state</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">ownText</span>: <span class=\"hljs-string\">\"仅仅和父组件有关的文本\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">hideChild</span>: <span class=\"hljs-literal\">false</span>\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  changeText = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"修改后的父组件文本\"</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 修改 ownText 的方法</span>\n</div></li><li><div class=\"code-word\">  changeOwnText = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">ownText</span>: <span class=\"hljs-string\">\"修改后的父组件自有文本\"</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  hideChild = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">hideChild</span>: <span class=\"hljs-literal\">true</span>\n</div></li><li><div class=\"code-word\">    });\n</div></li><li><div class=\"code-word\">  };\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"fatherContainer\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        {/* 新的button按钮 */}\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.changeOwnText}</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"changeText\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          修改父组件自有文本内容\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.changeText}</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"changeText\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          修改父组件文本内容\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.hideChild}</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"hideChild\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          隐藏子组件\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> {this.state.ownText} <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">        {this.state.hideChild ? null : <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LifeCycle</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">{this.state.text}</span> /&gt;</span>}\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1457\">新的界面如下图所示：</p>\n                    <p data-nodeid=\"1458\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/CD/Ciqc1F-FVCGAVX_GAAFADHW8-9A107.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"1653\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1459\">\n                      可以看到，this.state.ownText\n                      这个状态和子组件完全无关。但是当我点击“修改父组件自有文本内容”这个按钮的时候，componentReceiveProps\n                      仍然被触发了，效果如下图所示：\n                    </p>\n                    <p data-nodeid=\"1460\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/D8/CgqCHl-FVCqASZNkAAGmF-R62cg649.png\"\n                        alt=\"Drawing 8.png\"\n                        data-nodeid=\"1657\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1461\">\n                      耳听为虚，眼见为实。面对这样的运行结果，我不由得要带你复习一下\n                      React 官方文档中的这句话：\n                    </p>\n                    <p data-nodeid=\"1462\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/E1/Ciqc1F-FaGuADV5vAACZ2YRV6qQ941.png\"\n                        alt=\"图片7.png\"\n                        data-nodeid=\"1661\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1463\">\n                      <strong data-nodeid=\"1666\"\n                        >componentReceiveProps 并不是由 props\n                        的变化触发的，而是由父组件的更新触发的</strong\n                      >，这个结论，请你谨记。\n                    </p>\n                    <p data-nodeid=\"1464\">\n                      <strong data-nodeid=\"1670\"\n                        >组件自身 setState 触发的更新</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1465\">\n                      this.setState()\n                      调用后导致的更新流程，前面大图中已经有体现，这里我直接沿用上一个\n                      Demo 来做演示。若我们点击上一个 Demo\n                      中的“修改子组件文本内容”这个按钮：\n                    </p>\n                    <p data-nodeid=\"1466\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/D8/CgqCHl-FVDWABuVmAADVzZuKCO0699.png\"\n                        alt=\"Drawing 9.png\"\n                        data-nodeid=\"1674\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1467\">\n                      这个动作将会触发子组件 LifeCycle\n                      自身的更新流程，随之被触发的生命周期函数如下图增加的\n                      console 内容所示：\n                    </p>\n                    <p data-nodeid=\"1468\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/CD/Ciqc1F-FVDuASw5bAAEhb9melJQ452.png\"\n                        alt=\"Drawing 10.png\"\n                        data-nodeid=\"1678\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1469\">\n                      先来说说 componentWillUpdate 和 componentDidUpdate\n                      这一对好基友。\n                    </p>\n                    <p data-nodeid=\"1470\">\n                      componentWillUpdate 会在 render 前被触发，它和\n                      componentWillMount 类似，允许你在里面做一些不涉及真实 DOM\n                      操作的准备工作；而 componentDidUpdate\n                      则在组件更新完毕后被触发，和 componentDidMount\n                      类似，这个生命周期也经常被用来处理 DOM\n                      操作。此外，我们也常常将 componentDidUpdate\n                      的执行作为子组件更新完毕的标志通知到父组件。\n                    </p>\n                    <p data-nodeid=\"1471\">\n                      <strong data-nodeid=\"1684\"\n                        >render 与性能：初识 shouldComponentUpdate</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1472\">\n                      这里需要重点提一下 shouldComponentUpdate\n                      这个生命周期方法，它的调用形式如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">shouldComponentUpdate(nextProps, nextState)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1474\">\n                      render 方法由于伴随着对虚拟 DOM\n                      的构建和对比，过程可以说相当耗时。而在 React\n                      当中，很多时候我们会不经意间就频繁地调用了\n                      render。为了避免不必要的 render 操作带来的性能开销，React\n                      为我们提供了 shouldComponentUpdate 这个口子。\n                    </p>\n                    <p data-nodeid=\"1475\">\n                      React 组件会根据 shouldComponentUpdate\n                      的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行<strong\n                        data-nodeid=\"1692\"\n                        >re-render</strong\n                      >（重渲染）。shouldComponentUpdate 的默认值为\n                      true，也就是说“无条件\n                      re-render”。在实际的开发中，我们往往通过手动往\n                      shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入\n                      PureComponent 等最佳实践，来实现“有条件的 re-render”。\n                    </p>\n                    <p data-nodeid=\"1476\">\n                      关于 shouldComponentUpdate 及 PureComponent 对 React\n                      的优化，我们会在后续的性能小节中详细展开。这里你只需要认识到\n                      shouldComponentUpdate 的基本使用及其<strong\n                        data-nodeid=\"1698\"\n                        >与 React 性能之间的关联关系</strong\n                      >即可。\n                    </p>\n                    <h4 data-nodeid=\"1477\">Unmounting 阶段：组件的卸载</h4>\n                    <p data-nodeid=\"1478\">\n                      组件的销毁阶段本身是比较简单的，只涉及一个生命周期，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1479\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/EC/CgqCHl-FaHuAVGc_AABE6JqN9E0073.png\"\n                        alt=\"图片6.png\"\n                        data-nodeid=\"1703\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1480\">\n                      对应上文的 Demo 来看，我们点击“隐藏子组件”后就可以把\n                      LifeCycle\n                      从父组件中移除掉，进而实现卸载的效果。整个过程如下图所示：\n                    </p>\n                    <p data-nodeid=\"1481\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/5D/CD/Ciqc1F-FVFeABZvpAAO9lJVFKhs335.png\"\n                        alt=\"Drawing 12.png\"\n                        data-nodeid=\"1707\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1482\">\n                      这个生命周期本身不难理解，我们重点说说怎么触发它。组件销毁的常见原因有以下两个。\n                    </p>\n                    <ul data-nodeid=\"1483\">\n                      <li data-nodeid=\"1484\">\n                        <p data-nodeid=\"1485\">\n                          组件在父组件中被移除了：这种情况相对比较直观，对应的就是我们上图描述的这个过程。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1486\">\n                        <p data-nodeid=\"1487\">\n                          组件中设置了 key 属性，父组件在 render 的过程中，发现\n                          key 值和上一次不一致，那么这个组件就会被干掉。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1488\">\n                      在本课时，只要能够理解到 1 就可以了。对于 2\n                      这种情况，你只需要先记住有这样一种现象，这就够了。至于组件里面为什么要设置\n                      key，为什么 key\n                      改变后组件就必须被干掉？要回答这个问题，需要你先理解 React\n                      的“调和过程”，而“调和过程”也会是我们第二模块中重点讲解的一个内容。这里我先把这个知识点点出来，方便你定位我们整个知识体系里的<strong\n                        data-nodeid=\"1716\"\n                        >重难点</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"1489\">总结</h3>\n                    <p data-nodeid=\"1490\">\n                      在本课时，我们对 React 设计思想中的“虚拟\n                      DOM”和“组件化”这两个关键概念形成了初步的理解，同时也对\n                      React 15\n                      中的生命周期进行了系统的学习和总结。到这里，你已经了解到了\n                      React 生命周期在很长一段“过去”里的形态。\n                    </p>\n                    <p data-nodeid=\"1491\">\n                      而在 React 16\n                      中，组件的生命周期其实已经发生了一系列的变化。这些变化到底是什么样的，它们背后又蕴含着\n                      React 团队怎样的思量呢？\n                    </p>\n                    <p data-nodeid=\"1492\">\n                      古人说“以史为镜，可以知兴衰”。在下个课时，我们将一起去“照镜子”，对\n                      React 新旧生命周期进行对比，并探求变化的动机。\n                    </p>\n                    <p data-nodeid=\"1493\">\n                      <strong data-nodeid=\"1725\">小编有话说</strong>：\n                    </p>\n                    <p data-nodeid=\"1494\">\n                      作为一名前端开发人员，我相信大家都会有一个明显的感觉：其实前端并没有想象的那么简单。近年来，前端的职责越来越重要，战场越来越多样，应用也越来越复杂。作为现阶段的“入局者”，你是否能够系统地掌握前端的知识体系？你对技术的理解是否触达底层原理？你的能力是否可以受到大厂青睐？\n                    </p>\n                    <p data-nodeid=\"1495\" class=\"\">\n                      为了帮助前端人实现进阶学习，摆脱高不成低不就的困局。拉勾教育不仅开设了前端领域的专栏课，还研发了<a\n                        href=\"https://kaiwu.lagou.com/fe_enhancement.html?utm_source=lagouedu&amp;utm_medium=zhuanlan&amp;utm_campaign=%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%AB%98%E8%96%AA%E8%AE%AD%E7%BB%83%E8%90%A5\"\n                        data-nodeid=\"1730\"\n                        >“大前端高薪训练营”</a\n                      >，从知识体系构建、底层基础夯实、实战项目剖析、面试场景模拟到一线大厂内推，一站式解决前端进阶难题，打造你的核心竞争力。<a\n                        href=\"https://kaiwu.lagou.com/fe_enhancement.html?utm_source=lagouedu&amp;utm_medium=zhuanlan&amp;utm_campaign=%E5%A4%A7%E5%89%8D%E7%AB%AF%E9%AB%98%E8%96%AA%E8%AE%AD%E7%BB%83%E8%90%A5\"\n                        data-nodeid=\"1734\"\n                        >点击链接</a\n                      >，即可了解更多关于前端进阶的内容。\n                    </p>\n            "}