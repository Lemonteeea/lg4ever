{"title":"05 | 数据是如何在 React 组件之间流动的？（下）","context":"\n                    <p data-nodeid=\"1337\" class=\"\">\n                      在上个课时，我们掌握了 React 数据流方案中风格相对“朴素”的\n                      Props\n                      单向数据流方案，以及通用性较强的“发布-订阅”模式。在本课时，我们将一起认识\n                      React 天然具备的全局通信方式“Context API”，并对 Redux\n                      的设计思想和编码形态进行初步的探索。\n                    </p>\n                    <h3 data-nodeid=\"1338\">使用 Context API 维护全局状态</h3>\n                    <p data-nodeid=\"1339\">\n                      Context API 是 React 官方提供的一种组件树全局通信的方式。\n                    </p>\n                    <p data-nodeid=\"1340\">\n                      在 React 16.3 之前，Context API 由于存在种种局限性，并不被\n                      React\n                      官方提倡使用，开发者更多的是把它作为一个概念来探讨。而从 v\n                      16.3.0 开始，React 对 Context API 进行了改进，新的 Context\n                      API 具备更强的可用性。这里我们首先针对 React 16 下 Context\n                      API 的形态进行介绍。\n                    </p>\n                    <h4 data-nodeid=\"1341\">图解 Context API 工作流</h4>\n                    <p data-nodeid=\"1342\">\n                      Context API 有 3\n                      个关键的要素：React.createContext、Provider、Consumer。\n                    </p>\n                    <p data-nodeid=\"1343\">\n                      我们通过调用 React.createContext，可以创建出一组\n                      Provider。Provider\n                      作为数据的提供方，可以将数据下发给自身组件树中任意层级的\n                      Consumer，这三者之间的关系用一张图来表示：\n                    </p>\n                    <p data-nodeid=\"1344\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm7iAQ6ZRAAEW2Me7WVg371.png\"\n                        alt=\"图片3.png\"\n                        data-nodeid=\"1459\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1345\">\n                      注意：Cosumer 不仅能够读取到 Provider 下发的数据，<strong\n                        data-nodeid=\"1465\"\n                        >还能读取到这些数据后续的更新</strong\n                      >。这意味着数据在生产者和消费者之间能够及时同步，这对\n                      Context 这种模式来说至关重要。\n                    </p>\n                    <h4 data-nodeid=\"1346\">从编码的角度认识“三要素”</h4>\n                    <ul data-nodeid=\"1347\">\n                      <li data-nodeid=\"1348\">\n                        <p data-nodeid=\"1349\">\n                          <strong data-nodeid=\"1471\">React.createContext</strong\n                          >，作用是创建一个 context\n                          对象。下面是一个简单的用法示范：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> AppContext = React.createContext()\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1351\">\n                      注意，在创建的过程中，我们可以选择性地传入一个\n                      defaultValue：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> AppContext = React.createContext(defaultValue)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1353\">\n                      从创建出的 context 对象中，我们可以读取到 Provider 和\n                      Consumer：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> { Provider, Consumer } = AppContext\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"1355\">\n                      <li data-nodeid=\"1356\">\n                        <p data-nodeid=\"1357\">\n                          <strong data-nodeid=\"1478\">Provider</strong\n                          >，可以理解为“数据的 Provider（提供者）”。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1358\">\n                      我们使用 Provider\n                      对组件树中的根组件进行包裹，然后传入名为“value”的属性，这个\n                      value 就是后续在组件树中流动的“数据”，它可以被 Consumer\n                      消费。使用示例如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">&lt;Provider value={title: this.state.title, content: this.state.content}&gt;\n</div></li><li><div class=\"code-word\">  &lt;Title /&gt;\n</div></li><li><div class=\"code-word\">  &lt;Content /&gt;\n</div></li><li><div class=\"code-word\"> &lt;/Provider&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"1360\">\n                      <li data-nodeid=\"1361\">\n                        <p data-nodeid=\"1362\">\n                          <strong data-nodeid=\"1484\">Consumer</strong\n                          >，顾名思义就是“数据的消费者”，它可以读取 Provider\n                          下发下来的数据。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1363\">\n                      其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。像这样：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;Consumer&gt;\n</div></li><li><div class=\"code-word\">  {value =&gt; <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{value.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>}\n</div></li><li><div class=\"code-word\">&lt;/Consumer&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1365\">\n                      注意，当 Consumer 没有对应的 Provider 时，value\n                      参数会直接取创建 context 时传递给 createContext 的\n                      defaultValue。\n                    </p>\n                    <h4 data-nodeid=\"1366\">新的 Context API 解决了什么问题</h4>\n                    <p data-nodeid=\"1367\">\n                      想要知道新的 Context API 解决了什么问题，先要知道过时的\n                      Context API 存在什么问题。\n                    </p>\n                    <p data-nodeid=\"1368\">\n                      <strong data-nodeid=\"1492\"\n                        >我们先从编码角度认识“过时的”Context API</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1369\">\n                      “过时的”是 React 官方对旧的 &nbsp;Context API\n                      的描述，由于个人和团队在实际项目中都并不会考虑去使用旧\n                      Context API 来解决问题，这里我直接引用<a\n                        href=\"https://zh-hans.reactjs.org/docs/legacy-context.html\"\n                        data-nodeid=\"1496\"\n                        >过时的文档</a\n                      >中的 Context API 使用示例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> PropTypes <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'prop-types'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Button</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{background:</span> <span class=\"hljs-attr\">this.context.color</span>}}&gt;</span>\n</span></div></li><li><div class=\"code-word\">        {this.props.children}\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">Button.contextTypes = {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-attr\">color</span>: PropTypes.string\n</div></li><li><div class=\"code-word\">};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Message</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        {this.props.text} <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span>&gt;</span>Delete<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  getChildContext() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">\"purple\"</span>};\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> children = <span class=\"hljs-keyword\">this</span>.props.messages.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">message</span>) =&gt;</span>\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Message</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">{message.text}</span> /&gt;</span></span>\n</div></li><li><div class=\"code-word\">    );\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{children}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">MessageList.childContextTypes = {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-attr\">color</span>: PropTypes.string\n</div></li><li><div class=\"code-word\">};\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1371\">\n                      为了方便你理解，我将上述代码对应的组织结构梳理到一张图里，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1372\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/62/8C/Ciqc1F-Sm8qAMOB0AAEcBeEv_vs533.png\"\n                        alt=\"图片4.png\"\n                        data-nodeid=\"1501\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1373\">\n                      借着这张图，我们来理解旧的 Context API 的工作过程：\n                    </p>\n                    <ul data-nodeid=\"1374\">\n                      <li data-nodeid=\"1375\">\n                        <p data-nodeid=\"1376\">\n                          首先，通过给 MessageList 设置 childContextTypes 和\n                          getChildContext，可以使其承担起 context\n                          的生产者的角色；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1377\">\n                        <p data-nodeid=\"1378\">\n                          然后，MessageList\n                          的组件树内部所有层级的组件都可以通过定义 contextTypes\n                          来成为数据的消费者，进而通过 this.context 访问到\n                          MessageList 提供的数据。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1379\">\n                      现在回过头来，我们再从编码角度审视一遍“过时的” Context API\n                      的用法。\n                    </p>\n                    <p data-nodeid=\"1380\">\n                      首先映入眼帘的第一个问题是<strong data-nodeid=\"1511\"\n                        >代码不够优雅</strong\n                      >：一眼望去，你很难迅速辨别出谁是 Provider、谁是\n                      Consumer。同时这琐碎的属性设置和 API\n                      编写过程，也足够我们写代码的时候“喝一壶了”。总而言之，从编码形态的角度来说，“过时的”\n                      Context API 和新 Context API 相去甚远。\n                    </p>\n                    <p data-nodeid=\"1381\">\n                      不过，这还不是最要命的，最要命的弊端我们从编码层面暂时感知不出来，但是一旦你感知到它，麻烦就大了——前面我们特别提到过，“Cosumer\n                      不仅能够读取到 Provider 下发的数据，<strong\n                        data-nodeid=\"1517\"\n                        >还能够读取到这些数据后续的更新”</strong\n                      >。数据在生产者和消费者之间的及时同步，这一点对于 Context\n                      这种模式来说是至关重要的，但旧的 Conext API\n                      无法保证这一点：\n                    </p>\n                    <blockquote data-nodeid=\"1382\">\n                      <p data-nodeid=\"1383\">\n                        如果组件提供的一个Context发生了变化，而中间父组件的\n                        shouldComponentUpdate 返回 false，<strong\n                          data-nodeid=\"1527\"\n                          >那么使用到该值的后代组件不会进行更新</strong\n                        >。使用了 Context\n                        的组件则完全失控，所以基本上没有办法能够可靠的更新\n                        Context。<a\n                          href=\"https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076\"\n                          data-nodeid=\"1525\"\n                          >这篇博客文章</a\n                        >很好地解释了为何会出现此类问题，以及你该如何规避它。\n                        &nbsp;——React 官方\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1384\">\n                      新的 Context API 改进了这一点：<strong data-nodeid=\"1537\"\n                        >即便组件的 shouldComponentUpdate 返回\n                        false，它仍然可以“穿透”组件继续向后代组件进行传播</strong\n                      >，<strong data-nodeid=\"1538\"\n                        >进而确保了数据生产者和数据消费者之间数据的一致性</strong\n                      >。再加上更加“好看”的语义化的声明式写法，新版 Context API\n                      终于顺利地摘掉了“试验性 API”的帽子，成了一种确实可行的\n                      React 组件间通信解决方案。\n                    </p>\n                    <p data-nodeid=\"1385\">\n                      理解了 Context API 的前世今生，接下来我们继续来串联 React\n                      组件间通信的解决方案。\n                    </p>\n                    <h3 data-nodeid=\"1386\">\n                      第三方数据流框架“课代表”：初探 Redux\n                    </h3>\n                    <p data-nodeid=\"1387\">\n                      对于简单的跨层级组件通信，我们可以使用发布-订阅模式或者\n                      Context API\n                      来搞定。但是随着应用的复杂度不断提升，需要维护的状态越来越多，组件间的关系也越来越难以处理的时候，我们就需要请出\n                      Redux 来帮忙了。\n                    </p>\n                    <h4 data-nodeid=\"1388\">什么是 Redux</h4>\n                    <p data-nodeid=\"1389\">\n                      我们先来看一下官方对 Redux 的描述：\n                    </p>\n                    <blockquote data-nodeid=\"1390\">\n                      <p data-nodeid=\"1391\">\n                        Redux 是 JavaScript 状态容器，它提供可预测的状态管理。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1392\">我们一起品品这句话背后的深意：</p>\n                    <ul data-nodeid=\"1393\">\n                      <li data-nodeid=\"1394\">\n                        <p data-nodeid=\"1395\">\n                          Redux 是为<strong data-nodeid=\"1551\"\n                            >JavaScript</strong\n                          >应用而生的，也就是说它不是 React 的专利，React\n                          可以用，Vue 可以用，原生 JavaScript 也可以用；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1396\">\n                        <p data-nodeid=\"1397\">\n                          Redux 是一个<strong data-nodeid=\"1557\"\n                            >状态容器</strong\n                          >，什么是状态容器？这里我举个例子。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1398\">\n                      假如把一个 React 项目里面的所有组件拉进一个钉钉群，那么\n                      Redux\n                      就充当了这个群里的“群文件”角色，所有的组件都可以把需要在组件树里流动的数据存储在群文件里。当某个数据改变的时候，其他组件都能够通过下载最新的群文件来获取到数据的最新值。这就是“状态容器”的含义——存放公共数据的仓库。\n                    </p>\n                    <p data-nodeid=\"1399\">\n                      读懂了这个比喻之后，你对 Redux、数据和 React\n                      组件的关系想必已经形成了一个初步的认知。这里我帮你把这层关系总结进一张图里：\n                    </p>\n                    <p data-nodeid=\"1400\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm9qASdHXAAEjhh30y4s113.png\"\n                        alt=\"图片5.png\"\n                        data-nodeid=\"1562\"\n                      />\n                    </p>\n                    <h4 data-nodeid=\"1401\">\n                      Redux 是如何帮助 React 管理数据的\n                    </h4>\n                    <p data-nodeid=\"1402\">\n                      Redux 主要由三部分组成：store、reducer 和\n                      action。我们先来看看它们各自代表什么：\n                    </p>\n                    <ul data-nodeid=\"1403\">\n                      <li data-nodeid=\"1404\">\n                        <p data-nodeid=\"1405\">\n                          store 就好比组件群里的“群文件”，它是一个<strong\n                            data-nodeid=\"1570\"\n                            >单一的数据源</strong\n                          >，而且是只读的；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1406\">\n                        <p data-nodeid=\"1407\">\n                          action 人如其名，是“动作”的意思，它是<strong\n                            data-nodeid=\"1576\"\n                            >对变化的描述</strong\n                          >。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1408\">\n                      举个例子，下面这个对象就是一个 action：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> action = {\n</div></li><li><div class=\"code-word\">  type: <span class=\"hljs-string\">\"ADD_ITEM\"</span>,\n</div></li><li><div class=\"code-word\">  payload: <span class=\"hljs-string\">'&lt;li&gt;text&lt;/li&gt;'</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"1410\">\n                      <li data-nodeid=\"1411\">\n                        <p data-nodeid=\"1412\">\n                          reducer 是一个函数，它负责<strong data-nodeid=\"1583\"\n                            >对变化进行分发和处理，</strong\n                          >\n                          最终将新的数据返回给 store。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1413\">\n                      store、action 和 reducer 三者紧密配合，便形成了 Redux\n                      独树一帜的工作流：\n                    </p>\n                    <p data-nodeid=\"1414\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm-yADE6PAACSEywFSaA197.png\"\n                        alt=\"图片6.png\"\n                        data-nodeid=\"1587\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1415\">\n                      从上图中，我们首先读出的是数据的流向规律：<strong\n                        data-nodeid=\"1593\"\n                        >在 Redux 的整个工作过程中，数据流是严格单向的</strong\n                      >。这一点一定一定要背下来，面试的时候也一定一定要记得说——不管面试官问的是\n                      Redux\n                      的设计思想还是工作流还是别的什么概念性的知识，开局先放这句话，准没错。\n                    </p>\n                    <p data-nodeid=\"1416\">\n                      接下来仍然是围绕上图，我们来一起看看 Redux 是如何帮助\n                      React 管理数据流的。对于一个 React\n                      应用来说，视图（View）层面的所有数据（state）都来自\n                      store（再一次诠释了单一数据源的原则）。\n                    </p>\n                    <p data-nodeid=\"1417\">\n                      如果你想对数据进行修改，只有一种途径：派发 action。action\n                      会被 reducer 读取，进而根据 action\n                      内容的不同对数据进行修改、生成新的 state（状态），这个新的\n                      state 会更新到 store\n                      对象里，进而驱动视图层面做出对应的改变。\n                    </p>\n                    <p data-nodeid=\"1418\">\n                      对于组件来说，任何组件都可以通过约定的方式从 store\n                      读取到全局的状态，任何组件也都可以通过合理地派发 action\n                      来修改全局的状态。<strong data-nodeid=\"1601\"\n                        >Redux\n                        通过提供一个统一的状态容器，使得数据能够自由而有序地在任意组件之间穿梭</strong\n                      >，这就是 Redux 实现组件间通信的思路。\n                    </p>\n                    <h4 data-nodeid=\"1419\">从编码的角度理解 Redux 工作流</h4>\n                    <p data-nodeid=\"1420\">\n                      到这里，你已经了解了 Redux\n                      的设计思想和要素关系。接下来我们将站在编码的角度，探讨\n                      Redux 的工作流，将上文中所提及的各个要素和流程具象化。\n                    </p>\n                    <p data-nodeid=\"1421\">\n                      <strong data-nodeid=\"1609\"\n                        >1. 使用 createStore 来完成 store 对象的创建</strong\n                      >\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 引入 redux</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { createStore } from <span class=\"hljs-string\">'redux'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 创建 store</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> store = createStore(\n</div></li><li><div class=\"code-word\">    reducer,\n</div></li><li><div class=\"code-word\">    initial_state,\n</div></li><li><div class=\"code-word\">    applyMiddleware(middleware1, middleware2, ...)\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1423\">\n                      createStore 方法是一切的开始，它接收三个入参：\n                    </p>\n                    <ul data-nodeid=\"1424\">\n                      <li data-nodeid=\"1425\">\n                        <p data-nodeid=\"1426\">reducer；</p>\n                      </li>\n                      <li data-nodeid=\"1427\">\n                        <p data-nodeid=\"1428\">初始状态内容；</p>\n                      </li>\n                      <li data-nodeid=\"1429\">\n                        <p data-nodeid=\"1430\">指定中间件（这个你先不用管）。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1431\">\n                      这其中一般来说，只有 reducer\n                      是你不得不传的。下面我们就看看 reducer\n                      的编码形态是什么样的。\n                    </p>\n                    <p data-nodeid=\"1432\">\n                      <strong data-nodeid=\"1620\"\n                        >2. reducer 的作用是将新的 state 返回给 store</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1433\">\n                      一个 reducer\n                      一定是一个纯函数，它可以有各种各样的内在逻辑，但它最终一定要返回一个\n                      state：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> reducer = (state, action) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 此处是各种样的 state处理逻辑</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> new_state\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1435\">\n                      当我们基于某个 reducer 去创建 store 的时候，其实就是给这个\n                      store 指定了一套更新规则：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 更新规则全都写在 reducer 里 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> store = createStore(reducer)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1437\">\n                      <strong data-nodeid=\"1628\"\n                        >3. action 的作用是通知 reducer “让改变发生”</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1438\">\n                      如何在浩如烟海的 store\n                      状态库中，准确地命中某个我们希望它发生改变的 state\n                      呢？reducer 内部的逻辑虽然不尽相同，但其本质工作都是“将\n                      action\n                      与和它对应的更新动作对应起来，并处理这个更新”。所以说<strong\n                        data-nodeid=\"1634\"\n                        >要想让 state 发生改变，就必须用正确的 action\n                        来驱动这个改变</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1439\">\n                      前面我们已经介绍过 action\n                      的形态，这里再提点一下。首先，action\n                      是一个大致长这样的对象：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> action = {\n</div></li><li><div class=\"code-word\">  type: <span class=\"hljs-string\">\"ADD_ITEM\"</span>,\n</div></li><li><div class=\"code-word\">  payload: <span class=\"hljs-string\">'&lt;li&gt;text&lt;/li&gt;'</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1441\">\n                      action 对象中允许传入的属性有多个，<strong\n                        data-nodeid=\"1641\"\n                        >但只有 type 是必传的</strong\n                      >。type 是 action 的唯一标识，reducer 正是通过不同的 type\n                      来识别出需要更新的不同的\n                      state，由此才能够实现精准的“定向更新”。\n                    </p>\n                    <p data-nodeid=\"1442\">\n                      <strong data-nodeid=\"1647\"\n                        >4. 派发 action，靠的是 dispatch</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"1443\">\n                      action 本身只是一个对象，要想让 reducer 感知到\n                      action，还需要“派发 action”这个动作，这个动作是由\n                      store.dispatch 完成的。这里我简单地示范一下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { createStore } from <span class=\"hljs-string\">'redux'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 创建 reducer</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> reducer = (state, action) =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 此处是各种样的 state处理逻辑</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> new_state\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 基于 reducer 创建 state</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> store = createStore(reducer)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 创建一个 action，这个 action 用 “ADD_ITEM” 来标识 </span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> action = {\n</div></li><li><div class=\"code-word\">  type: <span class=\"hljs-string\">\"ADD_ITEM\"</span>,\n</div></li><li><div class=\"code-word\">  payload: <span class=\"hljs-string\">'&lt;li&gt;text&lt;/li&gt;'</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新</span>\n</div></li><li><div class=\"code-word\">store.dispatch(action)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2338\">\n                      以上这段代码，是从编码角度对 Redux\n                      主要工作流的概括，这里我同样为你总结了一张对应的流程图：\n                    </p>\n                    <p data-nodeid=\"3019\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/81/9F/CgqCHl_Rii2AVvUbAADn4s_6rB8369.png\"\n                        alt=\"图片7.png\"\n                        data-nodeid=\"3023\"\n                      />\n                    </p>\n                    <p data-nodeid=\"3020\">\n                      注意：先别急着死磕。本课时并不要求你掌握 Redux\n                      中涉及的所有概念和原理，只需要你跟着我的思路走，大致理解\n                      Redux 中几个关键角色之间的关系，进而明白 Redux\n                      是如何驱动数据在 React 组件间流动、如何帮助我们实现<strong\n                        data-nodeid=\"3029\"\n                        >灵活的组件间通信</strong\n                      >的，这就够了。关于更多 Redux\n                      的技术细节，我将在专栏的第三个大模块慢慢推敲。\n                    </p>\n\n                    <h3 data-nodeid=\"1448\">总结</h3>\n                    <p data-nodeid=\"1449\" class=\"\">\n                      在 04 和 05\n                      课时，我讲解的知识点覆盖面广、跨度大。面试场景下，考察此类问题的目的也主要是对候选人的知识广度进行检验。因此对于这两节的内容，你应抱着梳理“<strong\n                        data-nodeid=\"1669\"\n                        >知识地图</strong\n                      >”的目的去学习，以<strong data-nodeid=\"1670\"\n                        >构建知识体系</strong\n                      >为第一要务。完成第一要务后，再带着一个完整的上下文，去攻克某个具体的薄弱点。\n                    </p>\n            "}