{"title":"23 | npm script：打造一体化的构建和部署流程","context":"\n                    <p data-nodeid=\"1261\" class=\"\">\n                      之前我们提到过，一个顺畅的基建流程离不开 npm scripts。npm\n                      scripts\n                      将工程化的各个环节串联起来，相信任何一个现代化的项目都有自己的\n                      npm scripts\n                      设计。那么作为架构师或资深开发者，我们如何设计并实现项目配套的\n                      npm scripts 呢？关于 npm scripts\n                      我们如何进行封装抽象，做到复用或基建统一呢？\n                    </p>\n                    <p data-nodeid=\"1262\">\n                      这一讲，我们就围绕如何使用 npm\n                      scripts，打造一体化的构建和部署流程展开。\n                    </p>\n                    <h3 data-nodeid=\"1263\">npm scripts 原理介绍</h3>\n                    <p data-nodeid=\"1264\">\n                      这一部分，我们将对 npm scripts\n                      是什么，以及其核心原理进行讲解。\n                    </p>\n                    <h4 data-nodeid=\"1265\">npm scripts 是什么</h4>\n                    <p data-nodeid=\"1266\">\n                      我们先来系统地了解一下 npm scripts。Node.js 在设计 npm\n                      之初，允许开发者在 package.json 文件中，通过 scripts\n                      字段来自定义项目的脚本。比如我们可以在 package.json\n                      中这样使用：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"build\"</span>: <span class=\"hljs-string\">\"node build.js\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"dev\"</span>: <span class=\"hljs-string\">\"node dev.js\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"test\"</span>: <span class=\"hljs-string\">\"node test.js\"</span>,\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1268\">\n                      对应上述代码，我们在项目中可以使用命令行执行相关的脚本：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$ npm run build\n</div></li><li><div class=\"code-word\">$ npm run dev\n</div></li><li><div class=\"code-word\">$ npm run test\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1270\">\n                      其中<code data-backticks=\"1\" data-nodeid=\"1367\"\n                        >build.js</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"1369\"\n                        >dev.js</code\n                      >、<code data-backticks=\"1\" data-nodeid=\"1371\"\n                        >test.js</code\n                      >三个 Node.js\n                      模块分别对应上面三个命令行执行命令。这样的设计，可以方便我们统计和集中维护项目工程化或基建相关的所有脚本/命令，也可以利用\n                      npm 很多辅助功能，例如下面几个功能。\n                    </p>\n                    <ul data-nodeid=\"1271\">\n                      <li data-nodeid=\"1272\">\n                        <p data-nodeid=\"1273\">\n                          使用 npm 钩子，比如<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"1374\"\n                            >pre</code\n                          >、<code data-backticks=\"1\" data-nodeid=\"1376\"\n                            >post</code\n                          >，对应命令<code data-backticks=\"1\" data-nodeid=\"1378\"\n                            >npm run build</code\n                          >的钩子命令就是：<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"1380\"\n                            >prebuild</code\n                          >和<code data-backticks=\"1\" data-nodeid=\"1382\"\n                            >postbuild</code\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1274\">\n                        <p data-nodeid=\"1275\">\n                          开发者使用<code data-backticks=\"1\" data-nodeid=\"1385\"\n                            >npm run build</code\n                          >时，会默认自动先执行<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"1387\"\n                            >npm run prebuild</code\n                          >再执行<code data-backticks=\"1\" data-nodeid=\"1389\"\n                            >npm run build</code\n                          >，最后执行<code data-backticks=\"1\" data-nodeid=\"1391\"\n                            >npm run postbuild</code\n                          >，对此我们可以自定义：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">    {\n</div></li><li><div class=\"code-word\">    \t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">\"prebuild\"</span>: <span class=\"hljs-string\">\"node prebuild.js\"</span>,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">\"build\"</span>: <span class=\"hljs-string\">\"node build.js\"</span>,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">\"postbuild\"</span>: <span class=\"hljs-string\">\"node postbuild.js\"</span>,\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"1277\">\n                      <li data-nodeid=\"1278\">\n                        <p data-nodeid=\"1279\">\n                          使用 npm 提供的<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"1394\"\n                            >process.env.npm_lifecycle_event</code\n                          >等环境变量。通过<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"1396\"\n                            >process.env.npm_lifecycle_event</code\n                          >，可以在相关 npm scripts\n                          脚本中获得当前运行的脚本名称。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1280\">\n                        <p data-nodeid=\"1281\">\n                          使用 npm 提供的<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"1399\"\n                            >npm_package_</code\n                          >能力，获取 package.json 中的相关字段，比如下面代码：\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取 package.json 中的 name 字段值</span>\n</div></li><li><div class=\"code-word\">  console.log(process.env.npm_package_name)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 获取 package.json 中的 version 字段值</span>\n</div></li><li><div class=\"code-word\">  console.log(process.env.npm_package_version)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1283\">\n                      更多 npm 为 npm scripts\n                      提供的“黑魔法”，我们不再一一列举了。你可以前往\n                      <a href=\"https://docs.npmjs.com/\" data-nodeid=\"1404\"\n                        >https://docs.npmjs.com/</a\n                      >\n                      进行了解。\n                    </p>\n                    <h4 data-nodeid=\"1284\">npm scripts 原理</h4>\n                    <p data-nodeid=\"1285\">\n                      其实，npm scripts 原理比较简单。我们依靠<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1408\"\n                        >npm run xxx</code\n                      >来执行一个 npm scripts，那么核心奥秘就在于<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1410\"\n                        >npm run</code\n                      >了。<code data-backticks=\"1\" data-nodeid=\"1412\"\n                        >npm run</code\n                      >会自动创建一个 Shell（实际使用的 Shell\n                      会根据系统平台而不同，类 UNIX 系统里，如 macOS 或 Linux\n                      中指代的是 /bin/sh， 在 Windows 中使用的是\n                      cmd.exe），我们的 npm scripts 脚本就在这个新创建的 Shell\n                      中被运行。这样一来，我们可以得出几个关键结论：\n                    </p>\n                    <ul data-nodeid=\"1286\">\n                      <li data-nodeid=\"1287\">\n                        <p data-nodeid=\"1288\">\n                          只要是 Shell 可以运行的命令，都可以作为 npm scripts\n                          脚本；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1289\">\n                        <p data-nodeid=\"1290\">\n                          npm 脚本的退出码，也自然遵守 Shell 脚本规则；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1291\">\n                        <p data-nodeid=\"1292\">\n                          如果我们的系统里安装了 Python，可以将 Python 脚本作为\n                          npm scripts；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1293\">\n                        <p data-nodeid=\"1294\">\n                          npm scripts 脚本可以使用 Shell 通配符等常规能力。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1295\">比如这样的代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">  \t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">\"lint\"</span>: <span class=\"hljs-string\">\"eslint **/*.js\"</span>,\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1297\">\n                      <code data-backticks=\"1\" data-nodeid=\"1419\">*</code\n                      >表示任意文件名，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1421\"\n                        >**</code\n                      >表示任意一层子目录，在执行<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1423\"\n                        >npm run lint</code\n                      >后，就可以对当前目录下，任意一层子目录的 js 文件进行 lint\n                      审查。\n                    </p>\n                    <p data-nodeid=\"1298\">\n                      另外，请你思考：<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1426\"\n                        >npm run</code\n                      >创建出来的 Shell 有什么特别之处呢？\n                    </p>\n                    <p data-nodeid=\"1299\">\n                      我们知道，<code data-backticks=\"1\" data-nodeid=\"1429\"\n                        >node_modules/.bin</code\n                      >子目录中的所有脚本都<strong data-nodeid=\"1435\"\n                        >可以直接以脚本名的形式调用，而不必写出完整路径</strong\n                      >，比如下面代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"build\"</span>: <span class=\"hljs-string\">\"webpack\"</span>,\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1301\">\n                      在 package.json 中直接写<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1437\"\n                        >webpack</code\n                      >即可，而不需要写成：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"build\"</span>: <span class=\"hljs-string\">\"./node_modules/.bin/webpack\"</span>,\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1303\">的形式。这是为什么呢？</p>\n                    <p data-nodeid=\"1304\">\n                      实际上，<code data-backticks=\"1\" data-nodeid=\"1441\"\n                        >npm run</code\n                      >创建出来的 Shell 需要<strong data-nodeid=\"1452\"\n                        >将当前目录的</strong\n                      ><code data-backticks=\"1\" data-nodeid=\"1446\"\n                        >node_modules/.bin</code\n                      >子目录加入<strong data-nodeid=\"1453\">PATH 变量中</strong\n                      >，在 npm scripts 执行完成后，再将 PATH 变量恢复。\n                    </p>\n                    <h4 data-nodeid=\"1305\">npm scripts 使用技巧</h4>\n                    <p data-nodeid=\"1306\">\n                      这里我们简单讲解两个常见场景，以此介绍 npm scripts\n                      的关键使用技巧。\n                    </p>\n                    <p data-nodeid=\"1307\">\n                      <strong data-nodeid=\"1459\">传递参数</strong>\n                    </p>\n                    <p data-nodeid=\"1308\">\n                      任何命令脚本，都需要进行参数传递。在 npm scripts\n                      中，可以使用<code data-backticks=\"1\" data-nodeid=\"1461\"\n                        >--</code\n                      >标记参数。比如下面代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$ webpack --profile --json &gt; stats.json\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1310\">\n                      另外一种传参的方式是通过 package.json，比如下面代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"build\"</span>: <span class=\"hljs-string\">\"webpack --profile --json &gt; stats.json\"</span>,\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1312\">\n                      <strong data-nodeid=\"1467\">串行/并行执行脚本</strong>\n                    </p>\n                    <p data-nodeid=\"1313\">\n                      在一个项目中，任意 npm scripts\n                      可能彼此之间都有会依赖关系，我们可以通过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1469\"\n                        >&amp;&amp;</code\n                      >符号来串行执行脚本。比如下面代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">$ npm run pre.js &amp;&amp; npm run post.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1315\">\n                      如果需要并行执行，可以使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"1472\"\n                        >&amp;</code\n                      >符号，如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">npm run scriptA.js &amp; npm run scriptB.js\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"1317\">\n                      这两种串行/并行执行方式其实是 Bash\n                      的能力，社区里也封装了很多串行/并行执行脚本的公共包供开发者选用，比如：<a\n                        href=\"https://github.com/mysticatea/npm-run-all\"\n                        data-nodeid=\"1477\"\n                        >npm-run-all</a\n                      >\n                      就是一个常用的例子。\n                    </p>\n                    <p data-nodeid=\"1318\">\n                      <strong data-nodeid=\"1482\">最后的提醒</strong>\n                    </p>\n                    <p data-nodeid=\"1319\">最后，特别强调两点注意事项。</p>\n                    <p data-nodeid=\"1320\">\n                      首先，<strong data-nodeid=\"1501\"\n                        >npm scripts 可以和 git-hooks 相结合</strong\n                      >，为项目提供更顺畅、自然的能力。比如\n                      <a\n                        href=\"https://github.com/observing/pre-commit\"\n                        data-nodeid=\"1491\"\n                        >pre-commit</a\n                      >、<a\n                        href=\"https://github.com/typicode/husky\"\n                        data-nodeid=\"1495\"\n                        >husky</a\n                      >、<a\n                        href=\"https://github.com/okonet/lint-staged\"\n                        data-nodeid=\"1499\"\n                        >lint-staged</a\n                      >\n                      这类工具，支持 Git Hooks 各种种类，在必要的 git\n                      操作节点，执行我们的 npm scripts。\n                    </p>\n                    <p data-nodeid=\"1321\">\n                      同时需要注意的是，我们编写的 npm scripts 应该考虑<strong\n                        data-nodeid=\"1511\"\n                        >不同操作系统上兼容性的问题</strong\n                      >，因为 npm scripts 理论上在任何系统都应该 just\n                      work。社区为我们提供了很多跨平台的方案，比如\n                      <a\n                        href=\"https://www.npmjs.com/package/run-script-os\"\n                        data-nodeid=\"1509\"\n                        >un-script-os</a\n                      >\n                      允许我们针对不同平台进行不同的定制化脚本，如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"test\"</span>: <span class=\"hljs-string\">\"run-script-os\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"test:win32\"</span>: <span class=\"hljs-string\">\"echo 'del whatever you want in Windows 32/64'\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"test:darwin:linux\"</span>: <span class=\"hljs-string\">\"echo 'You can combine OS tags and rm all the things!'\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"test:default\"</span>: <span class=\"hljs-string\">\"echo 'This will run on any platform that does not have its own script'\"</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1323\">\n                      再比如，更加常见的<a\n                        href=\"https://www.npmjs.com/package/cross-env\"\n                        data-nodeid=\"1515\"\n                        >https://www.npmjs.com/package/cross-env</a\n                      >，可以为我们自动在不同的平台设置环境变量。\n                    </p>\n                    <p data-nodeid=\"1324\">\n                      好了，接下来我们从一个实例出发，打造一个\n                      lucas-scripts，实践操作 npm\n                      scripts，同时丰富我们的工程化经验。\n                    </p>\n                    <h3 data-nodeid=\"1325\">打造一个 lucas-scripts</h3>\n                    <p data-nodeid=\"1326\">\n                      lucas-scripts 其实是我设想的一个 npm scripts\n                      插件集合，通过 Monorepo 风格的项目，借助 npm\n                      抽象“自己常用的”npm scripts\n                      脚本，以在多个项目中达到复用的目的。\n                    </p>\n                    <p data-nodeid=\"1327\">\n                      其设计思想其实源于 Kent C.Dodds（<a\n                        href=\"https://kentcdodds.com/blog/tools-without-config/\"\n                        data-nodeid=\"1523\"\n                        >https://kentcdodds.com/blog</a\n                      >）的：Tools without config 思想。事实上，在 PayPal\n                      公司内部，有一个 paypal-scripts（未开源），借助\n                      paypal-scripts 的设计思路，就有了\n                      lucas-scripts。我们先从设计思想上分析，不管是\n                      paypal-scripts 还是\n                      lucas-scripts，它们主要解决了哪类问题。\n                    </p>\n                    <p data-nodeid=\"1328\">\n                      谈到前端开发，各种工具配置着实令人头大，而对于一个企业级团队来说，维护统一的企业级工具配置或设计，对工程效率的提升至关重要。这些工具包括但不限于：\n                    </p>\n                    <ul data-nodeid=\"1329\">\n                      <li data-nodeid=\"1330\">\n                        <p data-nodeid=\"1331\">测试工具及方案</p>\n                      </li>\n                      <li data-nodeid=\"1332\">\n                        <p data-nodeid=\"1333\">Client 端打包工具及方案</p>\n                      </li>\n                      <li data-nodeid=\"1334\">\n                        <p data-nodeid=\"1335\">Linting 工具及方案</p>\n                      </li>\n                      <li data-nodeid=\"1336\">\n                        <p data-nodeid=\"1337\">Babel 工具及方案</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1338\">\n                      等等，这些工具及方案的背后往往是烦琐的配置，同时，这些配置的设计却至关重要。比如我们的\n                      Webpack\n                      可以工作，但是它的配置设计却经常经不起推敲；Linters\n                      经常过时，跟不上语言的发展，使得我们的构建流程无比脆弱而容易中断。\n                    </p>\n                    <p data-nodeid=\"1339\">\n                      在此背景下，lucas-scripts\n                      负责维护和掌管工程基建中的种种工具及方案，同时它的使命不仅仅是\n                      Bootstrap\n                      一个项目，而是长期维护基建方案，可以随时升级，随时插拔。\n                    </p>\n                    <p data-nodeid=\"1340\">\n                      这很类似我们熟悉的\n                      <a\n                        href=\"https://github.com/facebook/create-react-app\"\n                        data-nodeid=\"1535\"\n                        >create-react-app</a\n                      >，create-react-app 可以帮助 React\n                      开发者迅速启动一个项目，它以黑盒的方式维护了 Webpack\n                      构建以及 Jest 测试、Eslint 等能力。开发者只需要使用\n                      react-scripts\n                      就能够满足构建和测试等需求，开发者只需要关心业务开发。lucas-scripts\n                      的理念相同：开发者只需要使用\n                      lucas-scripts，就可以使用开箱即用的各类型 npm scripts\n                      插件，npm scripts 插件提供基础工具的配置和方案设计。\n                    </p>\n                    <p data-nodeid=\"1341\">\n                      但需要注意的是，<a\n                        href=\"https://github.com/facebook/create-react-app\"\n                        data-nodeid=\"1540\"\n                        >create-react-app</a\n                      >\n                      官方并不允许开发者自定义这些工具的配置及方案设计，而我们的\n                      lucas-scripts\n                      理应实现更灵活的配置能力。如何做到开发者自定义配置的能力呢？设计上，我们支持<strong\n                        data-nodeid=\"1547\"\n                        >开发者在项目中添加</strong\n                      ><code data-backticks=\"1\" data-nodeid=\"1545\"\n                        >.babelrc</code\n                      >或在项目的 package.json 中添加相应的 babel\n                      配置项，lucas-scripts\n                      在运行时读取这些信息，并采用开发者自定义的配置即可。\n                    </p>\n                    <p data-nodeid=\"1342\">\n                      比如，我们支持项目中 package.json 配置：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">\"babel\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"presets\"</span>: [<span class=\"hljs-string\">\"lucas-scripts/babel\"</span>],\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"plugins\"</span>: [<span class=\"hljs-string\">\"glamorous-displayname\"</span>]\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1344\">\n                      上述代码可以做到使用 lucas-scripts 定义的 Babel\n                      预设，同时支持开发者使用名为 glamorous-displayname 的\n                      Babel 插件。\n                    </p>\n                    <p data-nodeid=\"1345\">\n                      下面，我们就以 lucas-scripts 中封装的 Babel\n                      配置进行详细讲解。\n                    </p>\n                    <p data-nodeid=\"1346\">\n                      在使用 lucas-scripts 的 Babel 方案时，我们提供了默认的一套\n                      Babel 设计方案，具体代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 browserslist 包进行降级目标设置</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> browserslist = require(<span class=\"hljs-string\">'browserslist'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> semver = require(<span class=\"hljs-string\">'semver'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 几个工具包，这里不再一一展开</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">  ifDep,\n</div></li><li><div class=\"code-word\">  ifAnyDep,\n</div></li><li><div class=\"code-word\">  ifTypescript,\n</div></li><li><div class=\"code-word\">  parseEnv,\n</div></li><li><div class=\"code-word\">  appDirectory,\n</div></li><li><div class=\"code-word\">  pkg,\n</div></li><li><div class=\"code-word\">} = require(<span class=\"hljs-string\">'../utils'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取环境变量</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> {BABEL_ENV, NODE_ENV, BUILD_FORMAT} = process.env\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 几个关键变量的判断</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isTest = (BABEL_ENV || NODE_ENV) === <span class=\"hljs-string\">'test'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isPreact = parseEnv(<span class=\"hljs-string\">'BUILD_PREACT'</span>, <span class=\"hljs-keyword\">false</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isRollup = parseEnv(<span class=\"hljs-string\">'BUILD_ROLLUP'</span>, <span class=\"hljs-keyword\">false</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isUMD = BUILD_FORMAT === <span class=\"hljs-string\">'umd'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isCJS = BUILD_FORMAT === <span class=\"hljs-string\">'cjs'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isWebpack = parseEnv(<span class=\"hljs-string\">'BUILD_WEBPACK'</span>, <span class=\"hljs-keyword\">false</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> isMinify = parseEnv(<span class=\"hljs-string\">'BUILD_MINIFY'</span>, <span class=\"hljs-keyword\">false</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> treeshake = parseEnv(<span class=\"hljs-string\">'BUILD_TREESHAKE'</span>, isRollup || isWebpack)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> alias = parseEnv(<span class=\"hljs-string\">'BUILD_ALIAS'</span>, isPreact ? {react: <span class=\"hljs-string\">'preact'</span>} : <span class=\"hljs-keyword\">null</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否使用 @babel/runtime</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> hasBabelRuntimeDep = Boolean(\n</div></li><li><div class=\"code-word\">  pkg.dependencies &amp;&amp; pkg.dependencies[<span class=\"hljs-string\">'@babel/runtime'</span>],\n</div></li><li><div class=\"code-word\">)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> RUNTIME_HELPERS_WARN =\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'You should add @babel/runtime as dependency to your package. It will allow reusing \"babel helpers\" from node_modules rather than bundling their copies into your files.'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 强制使用 @babel/runtime，以减少编译后代码体积等</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (!treeshake &amp;&amp; !hasBabelRuntimeDep &amp;&amp; !isTest) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(RUNTIME_HELPERS_WARN)\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (treeshake &amp;&amp; !isUMD &amp;&amp; !hasBabelRuntimeDep) {\n</div></li><li><div class=\"code-word\">  console.warn(RUNTIME_HELPERS_WARN)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取用户的 browserslist 配置，默认给一个 ie 10 和 ios 7 配置</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> browsersConfig = browserslist.loadConfig({path: appDirectory}) || [\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'ie 10'</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'ios 7'</span>,\n</div></li><li><div class=\"code-word\">]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取 envTargets</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> envTargets = isTest\n</div></li><li><div class=\"code-word\">  ? {node: <span class=\"hljs-string\">'current'</span>}\n</div></li><li><div class=\"code-word\">  : isWebpack || isRollup\n</div></li><li><div class=\"code-word\">  ? {browsers: browsersConfig}\n</div></li><li><div class=\"code-word\">  : {node: getNodeVersion(pkg)}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// @babel/preset-env 配置，默认使用以下配置项</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> envOptions = {modules: <span class=\"hljs-keyword\">false</span>, loose: <span class=\"hljs-keyword\">true</span>, targets: envTargets}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// babel 默认方案</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = () =&gt; ({\n</div></li><li><div class=\"code-word\">  presets: [\n</div></li><li><div class=\"code-word\">    [require.resolve(<span class=\"hljs-string\">'@babel/preset-env'</span>), envOptions],\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果存在 react 或 preact 依赖，则补充 @babel/preset-react</span>\n</div></li><li><div class=\"code-word\">    ifAnyDep(\n</div></li><li><div class=\"code-word\">      [<span class=\"hljs-string\">'react'</span>, <span class=\"hljs-string\">'preact'</span>],\n</div></li><li><div class=\"code-word\">      [\n</div></li><li><div class=\"code-word\">        require.resolve(<span class=\"hljs-string\">'@babel/preset-react'</span>),\n</div></li><li><div class=\"code-word\">        {pragma: isPreact ? ifDep(<span class=\"hljs-string\">'react'</span>, <span class=\"hljs-string\">'React.h'</span>, <span class=\"hljs-string\">'h'</span>) : undefined},\n</div></li><li><div class=\"code-word\">      ],\n</div></li><li><div class=\"code-word\">    ),\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果使用 Typescript，则补充 @babel/preset-typescript</span>\n</div></li><li><div class=\"code-word\">    ifTypescript([require.resolve(<span class=\"hljs-string\">'@babel/preset-typescript'</span>)]),\n</div></li><li><div class=\"code-word\">  ].filter(Boolean),\n</div></li><li><div class=\"code-word\">  plugins: [\n</div></li><li><div class=\"code-word\">    [\n</div></li><li><div class=\"code-word\">    \t<span class=\"hljs-comment\">// 强制使用 @babel/plugin-transform-runtime </span>\n</div></li><li><div class=\"code-word\">      require.resolve(<span class=\"hljs-string\">'@babel/plugin-transform-runtime'</span>),\n</div></li><li><div class=\"code-word\">      {useESModules: treeshake &amp;&amp; !isCJS},\n</div></li><li><div class=\"code-word\">    ],\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 使用 babel-plugin-macros</span>\n</div></li><li><div class=\"code-word\">    require.resolve(<span class=\"hljs-string\">'babel-plugin-macros'</span>),\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 别名配置</span>\n</div></li><li><div class=\"code-word\">    alias\n</div></li><li><div class=\"code-word\">      ? [\n</div></li><li><div class=\"code-word\">          require.resolve(<span class=\"hljs-string\">'babel-plugin-module-resolver'</span>),\n</div></li><li><div class=\"code-word\">          {root: [<span class=\"hljs-string\">'./src'</span>], alias},\n</div></li><li><div class=\"code-word\">        ]\n</div></li><li><div class=\"code-word\">      : <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 是否编译为 UMD 规范</span>\n</div></li><li><div class=\"code-word\">    isUMD\n</div></li><li><div class=\"code-word\">      ? require.resolve(<span class=\"hljs-string\">'babel-plugin-transform-inline-environment-variables'</span>)\n</div></li><li><div class=\"code-word\">      : <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 强制使用 @babel/plugin-proposal-class-properties</span>\n</div></li><li><div class=\"code-word\">    [require.resolve(<span class=\"hljs-string\">'@babel/plugin-proposal-class-properties'</span>), {loose: <span class=\"hljs-keyword\">true</span>}],\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 是否进行压缩</span>\n</div></li><li><div class=\"code-word\">    isMinify\n</div></li><li><div class=\"code-word\">      ? require.resolve(<span class=\"hljs-string\">'babel-plugin-minify-dead-code-elimination'</span>)\n</div></li><li><div class=\"code-word\">      : <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    treeshake\n</div></li><li><div class=\"code-word\">      ? <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">      : require.resolve(<span class=\"hljs-string\">'@babel/plugin-transform-modules-commonjs'</span>),\n</div></li><li><div class=\"code-word\">  ].filter(Boolean),\n</div></li><li><div class=\"code-word\">})\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取 node 版本</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">getNodeVersion</span><span class=\"hljs-params\">({engines: {node: nodeVersion = <span class=\"hljs-string\">'10.13'</span>} = {}})</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> oldestVersion = semver\n</div></li><li><div class=\"code-word\">    .validRange(nodeVersion)\n</div></li><li><div class=\"code-word\">    .replace(/[&gt;=&lt;|]/g, <span class=\"hljs-string\">' '</span>)\n</div></li><li><div class=\"code-word\">    .split(<span class=\"hljs-string\">' '</span>)\n</div></li><li><div class=\"code-word\">    .filter(Boolean)\n</div></li><li><div class=\"code-word\">    .sort(semver.compare)[<span class=\"hljs-number\">0</span>]\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!oldestVersion) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(\n</div></li><li><div class=\"code-word\">      \\`Unable to determine the oldest version in the range in your <span class=\"hljs-keyword\">package</span>.json at engines.node: <span class=\"hljs-string\">\"${nodeVersion}\"</span>. Please attempt to make it less ambiguous.\\`,\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> oldestVersion\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1348\">\n                      通过上面代码，我们将 Babel\n                      方案强制使用了一些最佳实践，比如使用了特定 loose、moudles\n                      设置的 @babel/preset-env 配置项，使用了\n                      @babel/plugin-transform-runtime，使用了\n                      @babel/plugin-proposal-class-properties，各种原理我们已经在\n                      07 讲《<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=584#/detail/pc?id=5912\"\n                        data-nodeid=\"1555\"\n                        >梳理混乱的 Babel，不再被编译报错困扰</a\n                      >》中有所涉及。\n                    </p>\n                    <p data-nodeid=\"1349\">\n                      了解了 Babel 的设计方案，我们在使用 lucas-scripts\n                      时是如何调用设计方案并执行 Babel\n                      编译的呢？我们看看相关逻辑源码，如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> path = require(<span class=\"hljs-string\">'path'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 支持使用 DEFAULT_EXTENSIONS，具体见：https://www.babeljs.cn/docs/babel-core#default_extensions</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> {DEFAULT_EXTENSIONS} = require(<span class=\"hljs-string\">'@babel/core'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> spawn = require(<span class=\"hljs-string\">'cross-spawn'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> yargsParser = require(<span class=\"hljs-string\">'yargs-parser'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> rimraf = require(<span class=\"hljs-string\">'rimraf'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> glob = require(<span class=\"hljs-string\">'glob'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 工具方法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">  hasPkgProp,\n</div></li><li><div class=\"code-word\">  fromRoot,\n</div></li><li><div class=\"code-word\">  resolveBin,\n</div></li><li><div class=\"code-word\">  hasFile,\n</div></li><li><div class=\"code-word\">  hasTypescript,\n</div></li><li><div class=\"code-word\">  generateTypeDefs,\n</div></li><li><div class=\"code-word\">} = require(<span class=\"hljs-string\">'../../utils'</span>)\n</div></li><li><div class=\"code-word\">let args = process.argv.slice(<span class=\"hljs-number\">2</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> here = p =&gt; path.join(__dirname, p)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 解析命令行参数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> parsedArgs = yargsParser(args)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否使用 lucas-scripts 提供的默认 babel 方案</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> useBuiltinConfig =\n</div></li><li><div class=\"code-word\">  !args.includes(<span class=\"hljs-string\">'--presets'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasFile(<span class=\"hljs-string\">'.babelrc'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasFile(<span class=\"hljs-string\">'.babelrc.js'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasFile(<span class=\"hljs-string\">'babel.config.js'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasPkgProp(<span class=\"hljs-string\">'babel'</span>)\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 lucas-scripts 提供的默认 babel 方案，读取相关配置</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> config = useBuiltinConfig\n</div></li><li><div class=\"code-word\">  ? [<span class=\"hljs-string\">'--presets'</span>, here(<span class=\"hljs-string\">'../../config/babelrc.js'</span>)]\n</div></li><li><div class=\"code-word\">  : []\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否使用 babel-core 所提供的 DEFAULT_EXTENSIONS 能力</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> extensions =\n</div></li><li><div class=\"code-word\">  args.includes(<span class=\"hljs-string\">'--extensions'</span>) || args.includes(<span class=\"hljs-string\">'--x'</span>)\n</div></li><li><div class=\"code-word\">    ? []\n</div></li><li><div class=\"code-word\">    : [<span class=\"hljs-string\">'--extensions'</span>, [...DEFAULT_EXTENSIONS, <span class=\"hljs-string\">'.ts'</span>, <span class=\"hljs-string\">'.tsx'</span>]]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 忽略某些文件夹，不进行编译</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> builtInIgnore = <span class=\"hljs-string\">'**/__tests__/**,**/__mocks__/**'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ignore = args.includes(<span class=\"hljs-string\">'--ignore'</span>) ? [] : [<span class=\"hljs-string\">'--ignore'</span>, builtInIgnore]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否复制文件</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> copyFiles = args.includes(<span class=\"hljs-string\">'--no-copy-files'</span>) ? [] : [<span class=\"hljs-string\">'--copy-files'</span>]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否使用特定的 output 文件夹</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> useSpecifiedOutDir = args.includes(<span class=\"hljs-string\">'--out-dir'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 默认的 output 文件夹名为 dist</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> builtInOutDir = <span class=\"hljs-string\">'dist'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> outDir = useSpecifiedOutDir ? [] : [<span class=\"hljs-string\">'--out-dir'</span>, builtInOutDir]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> noTypeDefinitions = args.includes(<span class=\"hljs-string\">'--no-ts-defs'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 编译开始前，是否先清理 output 文件夹</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (!useSpecifiedOutDir &amp;&amp; !args.includes(<span class=\"hljs-string\">'--no-clean'</span>)) {\n</div></li><li><div class=\"code-word\">  rimraf.sync(fromRoot(<span class=\"hljs-string\">'dist'</span>))\n</div></li><li><div class=\"code-word\">} <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">  args = args.filter(a =&gt; a !== <span class=\"hljs-string\">'--no-clean'</span>)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (noTypeDefinitions) {\n</div></li><li><div class=\"code-word\">  args = args.filter(a =&gt; a !== <span class=\"hljs-string\">'--no-ts-defs'</span>)\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 入口编译流程</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">go</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 使用 spawn.sync 方式，调用 @babel/cli </span>\n</div></li><li><div class=\"code-word\">  let result = spawn.sync(\n</div></li><li><div class=\"code-word\">    resolveBin(<span class=\"hljs-string\">'@babel/cli'</span>, {executable: <span class=\"hljs-string\">'babel'</span>}),\n</div></li><li><div class=\"code-word\">    [\n</div></li><li><div class=\"code-word\">      ...outDir,\n</div></li><li><div class=\"code-word\">      ...copyFiles,\n</div></li><li><div class=\"code-word\">      ...ignore,\n</div></li><li><div class=\"code-word\">      ...extensions,\n</div></li><li><div class=\"code-word\">      ...config,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'src'</span>,\n</div></li><li><div class=\"code-word\">    ].concat(args),\n</div></li><li><div class=\"code-word\">    {stdio: <span class=\"hljs-string\">'inherit'</span>},\n</div></li><li><div class=\"code-word\">  )\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果 status 不为 0，返回编译状态</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (result.status !== <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> result.status\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> pathToOutDir = fromRoot(parsedArgs.outDir || builtInOutDir)\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 使用 Typescript，并产出 type 类型</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (hasTypescript &amp;&amp; !noTypeDefinitions) {\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'Generating TypeScript definitions'</span>)\n</div></li><li><div class=\"code-word\">    result = generateTypeDefs(pathToOutDir)\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'TypeScript definitions generated'</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (result.status !== <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> result.status\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 因为 babel 目前仍然会拷贝一份需要忽略不进行编译的文件，所以我们将这些文件手动进行清理</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> ignoredPatterns = (parsedArgs.ignore || builtInIgnore)\n</div></li><li><div class=\"code-word\">    .split(<span class=\"hljs-string\">','</span>)\n</div></li><li><div class=\"code-word\">    .map(pattern =&gt; path.join(pathToOutDir, pattern))\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> ignoredFiles = ignoredPatterns.reduce(\n</div></li><li><div class=\"code-word\">    (all, pattern) =&gt; [...all, ...glob.sync(pattern)],\n</div></li><li><div class=\"code-word\">    [],\n</div></li><li><div class=\"code-word\">  )\n</div></li><li><div class=\"code-word\">  ignoredFiles.forEach(ignoredFile =&gt; {\n</div></li><li><div class=\"code-word\">    rimraf.sync(ignoredFile)\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> result.status\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">process.exit(go())\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1351\">\n                      通过上面代码，我们就可以将 lucas-script 的 Babel\n                      方案融会贯通了。\n                    </p>\n                    <p data-nodeid=\"1352\">\n                      整体设计思路我 fork 了\n                      <a\n                        href=\"https://github.com/kentcdodds/kcd-scripts\"\n                        data-nodeid=\"1562\"\n                        >https://github.com/kentcdodds/kcd-scripts</a\n                      >，并进行部分优化和改动，你可以在<a\n                        href=\"https://github.com/HOUCe/kcd-scripts\"\n                        data-nodeid=\"1566\"\n                        >https://github.com/HOUCe/kcd-scripts</a\n                      >中进一步学习。\n                    </p>\n                    <h3 data-nodeid=\"1353\">总结</h3>\n                    <p data-nodeid=\"1354\">\n                      这一讲我们先介绍了 npm scripts 的重要性，接着分析了 npm\n                      scripts 的原理；后半部分，从实践出发，分析了 lucas-scripts\n                      的设计理念，以此进一步巩固 npm scripts 相关知识。\n                    </p>\n                    <p data-nodeid=\"1355\">本讲内容总结如下：</p>\n                    <p data-nodeid=\"1356\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/0A/8E/Cgp9HWA3ZvSAGD15AAITBEgOZ_c039.png\"\n                        alt=\"npm scripts：打造一体化的构建和部署流程.png\"\n                        data-nodeid=\"1573\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1357\">\n                      说到底，npm scripts 就是一个\n                      Shell，我们以前端开发者所熟悉的 Node.js 来实现 npm\n                      scripts，当然这还不够。事实上，npm scripts\n                      的背后是对一整套工程化体系的理解，比如我们需要通过 npm\n                      scripts 来抽象 Babel 方案、抽象 Rollup\n                      方案等。相信通过这一讲的学习，你会有所收获。\n                    </p>\n                    <p data-nodeid=\"1358\" class=\"\">\n                      下一讲，我们将深入工程化体系的一个重点细节——自动化代码检查，并反过来使用\n                      lucas-scripts 再实现一套智能的代码 Lint\n                      脚本，请你继续学习。\n                    </p>\n            "}