{"title":"24 | 自动化代码检查：剖析 Lint 工具和工程化接入&amp;优化方案","context":"\n                    <p data-nodeid=\"9577\">\n                      不管是团队的扩张还是业务的发展，都会导致项目代码量出现爆炸式增长。为了防止“野蛮生长”现象，我们需要有一个良好的技术选型和成熟的架构做支撑，也需要团队中每一个开发者都能用心维护项目。在此方向上，除了人工\n                      code review 以外，相信大家对于一些规范工具并不陌生。\n                    </p>\n                    <p data-nodeid=\"9578\">\n                      作为一名前端工程师，<strong data-nodeid=\"9739\"\n                        >在使用现代化工具的基础上，如何尽可能发挥其能量？在必要的情况下，如何开发适合自己团队需求的工具</strong\n                      >？这一讲，我们将围绕这些问题展开。\n                    </p>\n                    <h3 data-nodeid=\"9579\">自动化工具巡礼</h3>\n                    <p data-nodeid=\"9580\">\n                      现代前端开发，“武器”都已经非常自动化了。不同工具的分工不同，我们的目标是合理结合各种工具，打造一条完善的自动化流水线，以高效率、低投入的方式，为我们的代码质量提供有效保障。\n                    </p>\n                    <h4 data-nodeid=\"9581\">Prettier</h4>\n                    <p data-nodeid=\"9582\">\n                      首先从 Prettier 说起，英文单词 prettier 是 pretty\n                      的比较级，pretty 译为“漂亮、美化”。顾名思义，Prettier\n                      这个工具能够美化我们的代码，或者说<strong\n                        data-nodeid=\"9752\"\n                        >格式化、规范化代码</strong\n                      >，使其更加工整。它一般不会检查我们代码具体的写法，而是在“<strong\n                        data-nodeid=\"9753\"\n                        >可读性</strong\n                      >”上做文章。目前支持包括\n                      JavaScript、JSX、Angular、Vue、Flow、TypeScript、CSS（Less、SCSS）、JSON\n                      等多种语言、数据交换格式、语法规范扩展。\n                    </p>\n                    <p data-nodeid=\"9583\">\n                      总的来说，它能够将原始代码风格移除，并替换为团队统一配置的代码风格。虽然几乎所有团队都在使用这款工具，这里我们还是简单分析一下使用它的原因：\n                    </p>\n                    <ul data-nodeid=\"9584\">\n                      <li data-nodeid=\"9585\">\n                        <p data-nodeid=\"9586\">构建并统一代码风格</p>\n                      </li>\n                      <li data-nodeid=\"9587\">\n                        <p data-nodeid=\"9588\">帮助团队新成员快速融入团队</p>\n                      </li>\n                      <li data-nodeid=\"9589\">\n                        <p data-nodeid=\"9590\">\n                          开发者可以完全聚焦业务开发，不必在代码整理上花费过多心思\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9591\">\n                        <p data-nodeid=\"9592\">\n                          方便，低成本灵活接入，并快速发挥作用\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9593\">\n                        <p data-nodeid=\"9594\">清理并规范已有代码</p>\n                      </li>\n                      <li data-nodeid=\"9595\">\n                        <p data-nodeid=\"9596\">减少潜在 Bug</p>\n                      </li>\n                      <li data-nodeid=\"9597\">\n                        <p data-nodeid=\"9598\">丰富强大的社区支持</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"12124\" class=\"\">\n                      当然，Prettier\n                      也可以与编辑器结合，在开发者保存后立即进行美化，也可以集成到\n                      CI 环境中，或者 Git pre-commit 的 hook 阶段。比如使用\n                      <a\n                        href=\"https://www.npmjs.com/package/pretty-quick\"\n                        data-nodeid=\"12128\"\n                        >pretty-quick</a\n                      >：\n                    </p>\n\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">yarn add prettier pretty-quick husky --dev\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9601\">并在 package.json 中配置：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"husky\"</span>: {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">\"hooks\"</span>: {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-string\">\"pre-commit\"</span>: <span class=\"hljs-string\">\"pretty-quick --staged\"</span>\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9603\">\n                      在 husky 中，定义 pre-commit 阶段，对变化的文件运行\n                      Prettier，--staged 参数表示 pre-commit 模式：只对 staged\n                      的文件进行格式化。\n                    </p>\n                    <p data-nodeid=\"13584\" class=\"te-preview-highlight\">\n                      这里我们使用了官方推荐的\n                      <a\n                        href=\"https://www.npmjs.com/package/pretty-quick\"\n                        data-nodeid=\"13588\"\n                        >pretty-quick</a\n                      >\n                      来实现 pre-commit\n                      阶段的美化。这只是实现方式之一，还可以通过 lint-staged\n                      来实现，我们会在下面 ESLint 和 husky 部分介绍。\n                    </p>\n\n                    <p data-nodeid=\"9605\">\n                      通过 Demo 我们能看出，Prettier\n                      确实很灵活，且自动化程度很高，接入项目也十分方便。\n                    </p>\n                    <h4 data-nodeid=\"9606\">ESLint</h4>\n                    <p data-nodeid=\"9607\">\n                      下面来看一下以 ESLint 为代表的 Linter。Code Linting\n                      表示<strong data-nodeid=\"9781\"\n                        >基于静态分析代码原理，找出代码反模式</strong\n                      >的过程。多数编程语言都有\n                      Linter，它们往往被集成在编译阶段，完成 Coding Linting\n                      的任务。\n                    </p>\n                    <p data-nodeid=\"9608\">\n                      对于 JavaScript\n                      这种动态、宽松类型的语言来说，开发者更容易犯错。由于\n                      JavaScript 不具备先天编译流程，往往会在运行时暴露错误，而\n                      Linter，尤其最具代表性的 ESLint\n                      的出现，允许开发者在执行前发现代码错误或不合理的写法。\n                    </p>\n                    <p data-nodeid=\"9609\">ESLint 最重要的几点哲学思想：</p>\n                    <ul data-nodeid=\"9610\">\n                      <li data-nodeid=\"9611\">\n                        <p data-nodeid=\"9612\">所有规则都插件化</p>\n                      </li>\n                      <li data-nodeid=\"9613\">\n                        <p data-nodeid=\"9614\">所有规则都可插拔（随时开关）</p>\n                      </li>\n                      <li data-nodeid=\"9615\">\n                        <p data-nodeid=\"9616\">所有设计都透明化</p>\n                      </li>\n                      <li data-nodeid=\"9617\">\n                        <p data-nodeid=\"9618\">\n                          使用 Espree 进行 JavaScript 解析\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9619\">\n                        <p data-nodeid=\"9620\">使用 AST 分析语法</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9621\">\n                      想要顺利执行 ESLint，还需要安装应用规则插件。\n                    </p>\n                    <p data-nodeid=\"9622\">\n                      那么如何声明并应用规则呢？在根目录中打开 .eslintrc\n                      配置文件，我们在该文件中加入：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"rules\"</span>: {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">\"semi\"</span>: [<span class=\"hljs-string\">\"error\"</span>, <span class=\"hljs-string\">\"always\"</span>],\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">\"quote\"</span>: [<span class=\"hljs-string\">\"error\"</span>, <span class=\"hljs-string\">\"double\"</span>]\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9624\">\n                      semi、quote 就是 ESLint\n                      规则的名称，其值对应的数组第一项可以为：off/0、warn/1、error/2，分别表示关闭规则、以\n                      warning 形式打开规则、以 error 形式打开规则。\n                    </p>\n                    <ul data-nodeid=\"9625\">\n                      <li data-nodeid=\"9626\">\n                        <p data-nodeid=\"9627\">off/0：关闭规则</p>\n                      </li>\n                      <li data-nodeid=\"9628\">\n                        <p data-nodeid=\"9629\">\n                          warn/1：以 warning 形式打开规则\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9630\">\n                        <p data-nodeid=\"9631\">error/2：以 error 形式打开规则</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9632\">\n                      同样我们还会在 .eslintrc 文件中发现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-string\">\"extends\"</span>: <span class=\"hljs-string\">\"eslint:recommended\"</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9634\">\n                      这行表示 ESLint\n                      默认的规则都将会被打开。当然，我们也可以选取其他规则集合，比较出名的有：\n                    </p>\n                    <ul data-nodeid=\"9635\">\n                      <li data-nodeid=\"9636\">\n                        <p data-nodeid=\"9637\">\n                          <a\n                            href=\"https://google.github.io/styleguide/jsguide.html\"\n                            data-nodeid=\"9799\"\n                            >Google JavaScript Style Guide</a\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9638\">\n                        <p data-nodeid=\"9639\">\n                          <a\n                            href=\"https://github.com/airbnb/javascript#table-of-contents\"\n                            data-nodeid=\"9802\"\n                            >Airbnb JavaScript Style Guide</a\n                          >\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9640\">\n                      我们继续拆分 .eslintrc 文件，其实它主要由六个字段组成：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = { \n</div></li><li><div class=\"code-word\">   env: {}, \n</div></li><li><div class=\"code-word\">   extends: {}, \n</div></li><li><div class=\"code-word\">   plugins: {}, \n</div></li><li><div class=\"code-word\">   parser: {}, \n</div></li><li><div class=\"code-word\">   parserOptions: {}, \n</div></li><li><div class=\"code-word\">   rules: {},\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <ul data-nodeid=\"9642\">\n                      <li data-nodeid=\"9643\">\n                        <p data-nodeid=\"9644\">env：表示指定想启用的环境。</p>\n                      </li>\n                      <li data-nodeid=\"9645\">\n                        <p data-nodeid=\"9646\">\n                          extends：指定额外配置的选项，如 ['airbnb'] 表示使用\n                          Airbnb 的 Linting 规则。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9647\">\n                        <p data-nodeid=\"9648\">plugins：设置规则插件。</p>\n                      </li>\n                      <li data-nodeid=\"9649\">\n                        <p data-nodeid=\"9650\">\n                          parser：默认情况下 ESLint 使用 Espree 进行解析。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9651\">\n                        <p data-nodeid=\"9652\">\n                          parserOptions：如果将默认解析器更改，需要制定\n                          parserOptions。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9653\">\n                        <p data-nodeid=\"9654\">\n                          rules：定义拓展并通过插件添加的所有规则。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9655\">\n                      注意，上文中 .eslintrc 文件我们<strong data-nodeid=\"9821\"\n                        >采用了 .eslintrc.js 的 JavaScript 文件格式</strong\n                      >，此外还可以采用 .yaml、.json、yml\n                      等格式。如果项目中含有多种配置文件格式，优先级顺序为：\n                    </p>\n                    <ul data-nodeid=\"9656\">\n                      <li data-nodeid=\"9657\">\n                        <p data-nodeid=\"9658\">.eslintrc.js</p>\n                      </li>\n                      <li data-nodeid=\"9659\">\n                        <p data-nodeid=\"9660\">.eslintrc.yaml</p>\n                      </li>\n                      <li data-nodeid=\"9661\">\n                        <p data-nodeid=\"9662\">.eslintrc.yml</p>\n                      </li>\n                      <li data-nodeid=\"9663\">\n                        <p data-nodeid=\"9664\">.eslintrc.json</p>\n                      </li>\n                      <li data-nodeid=\"9665\">\n                        <p data-nodeid=\"9666\">.eslintrc</p>\n                      </li>\n                      <li data-nodeid=\"9667\">\n                        <p data-nodeid=\"9668\">package.json</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9669\">\n                      最终，我们在 package.json 中可以添加 script：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"lint\"</span>: <span class=\"hljs-string\">\"eslint --debug src/\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"lint:write\"</span>: <span class=\"hljs-string\">\"eslint --debug src/ --fix\"</span>\n</div></li><li><div class=\"code-word\"> },\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9671\">\n                      我们对上述 npm script 进行分析，如下：\n                    </p>\n                    <ul data-nodeid=\"9672\">\n                      <li data-nodeid=\"9673\">\n                        <p data-nodeid=\"9674\">\n                          lint\n                          这个命令将遍历所有文件，并在每个找到错误的文件中提供详细日志，但<strong\n                            data-nodeid=\"9835\"\n                            >需要开发者手动打开这些文件并更正错误</strong\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9675\">\n                        <p data-nodeid=\"9676\">\n                          lint:write 与 lint\n                          命令类似，但这个命令可以自动纠正错误。\n                        </p>\n                      </li>\n                    </ul>\n                    <h4 data-nodeid=\"9677\">Linter VS Prettier</h4>\n                    <p data-nodeid=\"9678\">\n                      我们应该如何对比以 ESLint 为代表的 Linter 和 Prettier\n                      呢，它们到底是什么关系？就像开篇提到的那样，它们解决不同的问题，定位不同，但是又可以相辅相成。\n                    </p>\n                    <p data-nodeid=\"9679\">\n                      所有的 Linter 类似 ESLint，其规则都可以划分为两类。\n                    </p>\n                    <ul data-nodeid=\"9680\">\n                      <li data-nodeid=\"9681\">\n                        <p data-nodeid=\"9682\">格式化规则（Formatting Rules）</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9683\">\n                      这类“格式化规则”典型的有\n                      max-len、no-mixed-spaces-and-tabs、keyword-spacing、comma-style，它们“限制一行的最大长度”“禁止使用空格和\n                      Tab\n                      混合缩进”等代码格式方面的规范。事实上，即便开发者写出的代码违反了这类规则，如果在\n                      Lint 阶段前，先经过 Prettier 处理，这些问题会<strong\n                        data-nodeid=\"9846\"\n                        >在 Prettier 阶段被纠正，因此 Linter\n                        不会抛出提醒</strong\n                      >，非常省心，这也是 Linter 和 Prettier 重叠的地方。\n                    </p>\n                    <ul data-nodeid=\"9684\">\n                      <li data-nodeid=\"9685\">\n                        <p data-nodeid=\"9686\">\n                          代码质量规则（Code Quality Rules）\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9687\">\n                      这类“代码质量规则”类似\n                      no-unused-vars、no-extra-bind、no-implicit-globals、prefer-promise-reject-errors，它们限制“声明未使用变量”“不必要的函数绑定”等代码写法规范。这个时候，Prettier\n                      对这些规则无能为力，而这些规则对于代码质量和强健性至关重要，还是需要\n                      Linter 来保障的。\n                    </p>\n                    <p data-nodeid=\"9688\">\n                      如同 Prettier，ESLint 也可以集成到编辑器或者 Git\n                      pre-commit 阶段。前文已经演示过了 Prettier 搭配\n                      husky，下面我们来介绍一下 husky 到底是什么。\n                    </p>\n                    <h4 data-nodeid=\"9689\">husky 和 lint-staged</h4>\n                    <p data-nodeid=\"9690\">\n                      其实，husky 就是 Git 的一个钩子，在 Git\n                      进行到某一时段时，可以交给开发者完成某些特定的操作。比如每次提交（commit\n                      阶段）或者推送（push 阶段）代码时，就可以执行相关 npm\n                      脚本。需要注意的是，<strong data-nodeid=\"9856\"\n                        >在整个项目上运行 Lint\n                        会很慢，我们一般只想对更改的文件进行检查，此时就需要使用到\n                        lint-staged</strong\n                      >。比如如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-string\">\"scripts\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"lint\"</span>: <span class=\"hljs-string\">\"eslint --debug src/\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"lint:write\"</span>: <span class=\"hljs-string\">\"eslint --debug src/ --fix\"</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"prettier\"</span>: <span class=\"hljs-string\">\"prettier --write src/**/*.js\"</span>\n</div></li><li><div class=\"code-word\">},\n</div></li><li><div class=\"code-word\"><span class=\"hljs-string\">\"husky\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"hooks\"</span>: {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-string\">\"pre-commit\"</span>: <span class=\"hljs-string\">\"lint-staged\"</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">},\n</div></li><li><div class=\"code-word\"><span class=\"hljs-string\">\"lint-staged\"</span>: {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-string\">\"*.(js|jsx)\"</span>: [<span class=\"hljs-string\">\"npm run lint:write\"</span>, <span class=\"hljs-string\">\"npm run prettier\"</span>, <span class=\"hljs-string\">\"git add\"</span>]\n</div></li><li><div class=\"code-word\">},\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9692\">\n                      上述代码表示在 pre-commit 阶段对于 js 或者 jsx\n                      后缀且修改的文件执行 ESLint 和 Prettier\n                      操作，通过之后再进行 git add 添加到暂存区。\n                    </p>\n                    <h3 data-nodeid=\"9693\">\n                      lucas-scripts 中的 Lint 配置最佳实践\n                    </h3>\n                    <p data-nodeid=\"9694\">\n                      结合上一讲内容，我们可以扩充 lucas-scripts 项目关于 Lint\n                      的抽象设计。相关脚本：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> path = require(<span class=\"hljs-string\">'path'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> spawn = require(<span class=\"hljs-string\">'cross-spawn'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> yargsParser = require(<span class=\"hljs-string\">'yargs-parser'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> {hasPkgProp, resolveBin, hasFile, fromRoot} = require(<span class=\"hljs-string\">'../utils'</span>)\n</div></li><li><div class=\"code-word\">let args = process.argv.slice(<span class=\"hljs-number\">2</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> here = p =&gt; path.join(__dirname, p)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> hereRelative = p =&gt; here(p).replace(process.cwd(), <span class=\"hljs-string\">'.'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> parsedArgs = yargsParser(args)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否使用默认 eslint 配置</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> useBuiltinConfig =\n</div></li><li><div class=\"code-word\">  !args.includes(<span class=\"hljs-string\">'--config'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasFile(<span class=\"hljs-string\">'.eslintrc'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasFile(<span class=\"hljs-string\">'.eslintrc.js'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasPkgProp(<span class=\"hljs-string\">'eslintConfig'</span>)\n</div></li><li><div class=\"code-word\">  \n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取默认 eslintrc.js</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> config = useBuiltinConfig\n</div></li><li><div class=\"code-word\">  ? [<span class=\"hljs-string\">'--config'</span>, hereRelative(<span class=\"hljs-string\">'../config/eslintrc.js'</span>)]\n</div></li><li><div class=\"code-word\">  : []\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> defaultExtensions = <span class=\"hljs-string\">'js,ts,tsx'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ext = args.includes(<span class=\"hljs-string\">'--ext'</span>) ? [] : [<span class=\"hljs-string\">'--ext'</span>, defaultExtensions]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> extensions = (parsedArgs.ext || defaultExtensions).split(<span class=\"hljs-string\">','</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> useBuiltinIgnore =\n</div></li><li><div class=\"code-word\">  !args.includes(<span class=\"hljs-string\">'--ignore-path'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasFile(<span class=\"hljs-string\">'.eslintignore'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">  !hasPkgProp(<span class=\"hljs-string\">'eslintIgnore'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ignore = useBuiltinIgnore\n</div></li><li><div class=\"code-word\">  ? [<span class=\"hljs-string\">'--ignore-path'</span>, hereRelative(<span class=\"hljs-string\">'../config/eslintignore'</span>)]\n</div></li><li><div class=\"code-word\">  : []\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 是否使用 --no-cache</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> cache = args.includes(<span class=\"hljs-string\">'--no-cache'</span>)\n</div></li><li><div class=\"code-word\">  ? []\n</div></li><li><div class=\"code-word\">  : [\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'--cache'</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-string\">'--cache-location'</span>,\n</div></li><li><div class=\"code-word\">      fromRoot(<span class=\"hljs-string\">'node_modules/.cache/.eslintcache'</span>),\n</div></li><li><div class=\"code-word\">    ]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> filesGiven = parsedArgs._.length &gt; <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> filesToApply = filesGiven ? [] : [<span class=\"hljs-string\">'.'</span>]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">if</span> (filesGiven) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 筛选出需要进行 lint 的相关文件</span>\n</div></li><li><div class=\"code-word\">  args = args.filter(\n</div></li><li><div class=\"code-word\">    a =&gt; !parsedArgs._.includes(a) || extensions.some(e =&gt; a.endsWith(e)),\n</div></li><li><div class=\"code-word\">  )\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 使用 spawn.sync 执行 eslint</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> result = spawn.sync(\n</div></li><li><div class=\"code-word\">  resolveBin(<span class=\"hljs-string\">'eslint'</span>),\n</div></li><li><div class=\"code-word\">  [...config, ...ext, ...ignore, ...cache, ...args, ...filesToApply],\n</div></li><li><div class=\"code-word\">  {stdio: <span class=\"hljs-string\">'inherit'</span>},\n</div></li><li><div class=\"code-word\">)\n</div></li><li><div class=\"code-word\">process.exit(result.status)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9696\">\n                      npm-script 的 eslintrc.js\n                      就比较简单了，我们默认使用以下配置：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> {ifAnyDep} = require(<span class=\"hljs-string\">'../utils'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n</div></li><li><div class=\"code-word\">  extends: [\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 选用一种 eslint 规则即可</span>\n</div></li><li><div class=\"code-word\">    require.resolve(<span class=\"hljs-string\">'XXXX'</span>),\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 对于 react 相关环境，选用一种 eslint 规则即可</span>\n</div></li><li><div class=\"code-word\">    ifAnyDep(<span class=\"hljs-string\">'react'</span>, require.resolve(<span class=\"hljs-string\">'XXX'</span>)),\n</div></li><li><div class=\"code-word\">  ].filter(Boolean),\n</div></li><li><div class=\"code-word\">  rules: {},\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9698\">\n                      上述代码中的规则配置，我们可以采用自定义的 eslint\n                      config，也可以选用社区上流行的 config。\n                    </p>\n                    <p data-nodeid=\"9699\">\n                      具体流程执行原理上一讲中已经梳理，我们不再展开。下面，我们从\n                      AST 的层面，深入 Lint\n                      原理，并根据其实现和扩展能力，开发更加灵活的工具集。\n                    </p>\n                    <h3 data-nodeid=\"9700\">工具背后的技术原理和设计</h3>\n                    <p data-nodeid=\"9701\">\n                      我们挑选实现更为复杂精妙的 ESLint\n                      来分析。你应该很清楚，ESLint 是<strong data-nodeid=\"9869\"\n                        >基于静态语法分析</strong\n                      >（AST）进行工作的，AST 已经不是一个新鲜话题。ESLint 使用\n                      Espree 来解析 JavaScript 语句，生成 AST。\n                    </p>\n                    <p data-nodeid=\"9702\">\n                      有了完整的解析树，我们就可以基于解析树，对代码进行检测和修改。ESLint\n                      的灵魂是每一条\n                      rule，每条规则都是独立且插件化的，我们挑一个比较简单的“<strong\n                        data-nodeid=\"9875\"\n                        >禁止块级注释规则</strong\n                      >”源码来分析：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n</div></li><li><div class=\"code-word\">  meta: {\n</div></li><li><div class=\"code-word\">    docs: {\n</div></li><li><div class=\"code-word\">      description: <span class=\"hljs-string\">'禁止块级注释'</span>,\n</div></li><li><div class=\"code-word\">      category: <span class=\"hljs-string\">'Stylistic Issues'</span>,\n</div></li><li><div class=\"code-word\">      recommended: <span class=\"hljs-keyword\">true</span>    \n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  create (context) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> sourceCode = context.getSourceCode()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">      Program () {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> comments = sourceCode.getAllComments()\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> blockComments = comments.filter(({ type }) =&gt; type === <span class=\"hljs-string\">'Block'</span>)\n</div></li><li><div class=\"code-word\">        blockComments.length &amp;&amp; context.report({\n</div></li><li><div class=\"code-word\">          message: <span class=\"hljs-string\">'No block comments'</span>\n</div></li><li><div class=\"code-word\">        })\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9704\">\n                      从中我们看出，一条规则就是一个 node 模块，它由 meta 和\n                      create 组成。meta 包含了该条规则的文档描述，相对简单。而\n                      create 接受一个 context 参数，返回一个对象，如下代码：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">{\n</div></li><li><div class=\"code-word\">    meta: {\n</div></li><li><div class=\"code-word\">        docs: {\n</div></li><li><div class=\"code-word\">            description: <span class=\"hljs-string\">'禁止块级注释'</span>,\n</div></li><li><div class=\"code-word\">            category: <span class=\"hljs-string\">'Stylistic Issues'</span>,\n</div></li><li><div class=\"code-word\">            recommended: <span class=\"hljs-keyword\">true</span> \n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    create (context) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9706\">\n                      从 context\n                      对象上我们可以取得当前执行扫描到的代码，并通过选择器获取当前需要的内容。如上代码，我们获取代码的所有\n                      comments（sourceCode.getAllComments()），如果\n                      blockComments 长度大于 0，则 report No block comments\n                      信息。了解了这些，相信你也能写出 no-alert、no-debugger\n                      的规则内容。\n                    </p>\n                    <p data-nodeid=\"9707\">\n                      虽然 ESLint 背后的技术内容比较复杂，但是基于 AST\n                      技术，它已经给开发者提供了较为成熟的\n                      APIs。写一条自己的规则并不是很难，只需要开发者找到相关的\n                      AST 选择器。更多的选择器可以参考：<a\n                        href=\"https://eslint.org/docs/developer-guide/selectors\"\n                        data-nodeid=\"9881\"\n                        >Selectors - ESLint - Pluggable JavaScript linter</a\n                      >，熟练掌握选择器，将是我们开发插件扩展的关键。\n                    </p>\n                    <p data-nodeid=\"9708\">\n                      当然，更复杂的场景远不止这么简单，比如，多条规则是如何串联起来生效的？\n                    </p>\n                    <h4 data-nodeid=\"9709\">多条规则串联生效</h4>\n                    <p data-nodeid=\"9710\">\n                      事实上，<strong data-nodeid=\"9889\"\n                        >规则可以从多个源来定义，比如代码的注释当中，或者配置文件当中。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"9711\">\n                      ESLint\n                      首先收集到所有规则配置源，将所有规则归并之后，进行多重遍历：遍历由源码生成的\n                      AST，将语法节点传入队列当中；之后遍历所有应用规则，采用<strong\n                        data-nodeid=\"9899\"\n                        >事件发布订阅模式</strong\n                      >（类似 Webpack Tapable），为所有规则的选择器<strong\n                        data-nodeid=\"9900\"\n                        >添加监听事件</strong\n                      >；在触发事件时执行，如果发现有问题，会将 report message\n                      记录下来。最终记录下来的问题信息将会被输出。\n                    </p>\n                    <p data-nodeid=\"9712\">\n                      请你再思考，我们的程序中免不了有各种条件语句、循环语句，因此<strong\n                        data-nodeid=\"9906\"\n                        >代码的执行是非顺序的</strong\n                      >。相关规则比如：“检测定义但未使用变量”“switch-case\n                      中避免执行多条 case 语句”，这些规则的实现，就涉及 ESLint\n                      更高级的 Code Path Analysis 概念等。ESLint 将 Code Path\n                      抽象为 5 个事件：\n                    </p>\n                    <ul data-nodeid=\"9713\">\n                      <li data-nodeid=\"9714\">\n                        <p data-nodeid=\"9715\">onCodePathStart</p>\n                      </li>\n                      <li data-nodeid=\"9716\">\n                        <p data-nodeid=\"9717\">onCodePathEnd</p>\n                      </li>\n                      <li data-nodeid=\"9718\">\n                        <p data-nodeid=\"9719\">onCodePathSegmentStart</p>\n                      </li>\n                      <li data-nodeid=\"9720\">\n                        <p data-nodeid=\"9721\">onCodePathSegmentEnd</p>\n                      </li>\n                      <li data-nodeid=\"9722\">\n                        <p data-nodeid=\"9723\">onCodePathSegmentLoop</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9724\">\n                      利用这 5 个事件，我们可以<strong data-nodeid=\"9925\"\n                        >更加精确地控制检测范围和粒度</strong\n                      >。更多的 ESLint rule 实现，你可以翻看<a\n                        href=\"https://github.com/eslint/eslint/\"\n                        data-nodeid=\"9919\"\n                        >源码</a\n                      >进行学习，总之根据这 5\n                      种事件，我们可以监测非顺序性代码，其核心原理还是<strong\n                        data-nodeid=\"9926\"\n                        >事件机制</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9725\">\n                      这种优秀的插件扩展机制对于设计一个库，尤其是设计一个规范工具来说，是非常值得借鉴的模式。事实上，Prettier\n                      也会在新的版本中引入插件机制，目前已经在 Beta\n                      版引入，感兴趣的读者可以<a\n                        href=\"https://prettier.io/docs/en/plugins.html#docsNav\"\n                        data-nodeid=\"9930\"\n                        >尝鲜</a\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"9726\">总结</h3>\n                    <p data-nodeid=\"9727\">\n                      这一讲我们深入工程化体系的重点细节自动化代码检查，并反过来使用\n                      lucas-scripts 实现了一套智能的代码 Lint\n                      脚本，建议你结合上一讲内容共同学习。\n                    </p>\n                    <p data-nodeid=\"9728\">本讲内容总结如下：</p>\n                    <p data-nodeid=\"10668\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/0A/AA/CioPOWA3hxWAW7B4AAJMTIIarOQ990.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"10671\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"9730\">\n                      在规范化的道路上，只有你想不到，没有你做不到。简单的规范化工具用起来非常清爽，但是背后的实现却蕴含了很深的设计与技术细节，值得我们深入学习。同时，作为前端工程师，我们应该从平时开发的痛点和效率瓶颈入手，敢于尝试，不断探索。保证团队开发的自动化程度，就能减少不必要的麻烦。\n                    </p>\n                    <p data-nodeid=\"9731\">\n                      在工程化基建当中，除了项目管理和规范相对“偏硬”的强制规范手段；一些“软方向”，比如团队氛围、code\n                      review\n                      等，也直接决定着团队的代码质量。进阶的工程师不仅需要在技术上成长，在团队建设上更需要主动交流。下一讲我们换一个方向，深入一个更具体的方案——前端+移动端离线包设计，请继续学习！\n                    </p>\n            "}