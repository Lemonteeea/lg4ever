{"title":"18 | 真题案例（三）：力扣真题训练","context":"\n                    <p data-nodeid=\"1785\" class=\"\">\n                      在备战公司面试的时候，相信你一定也刷过力扣（leetcode）的题目吧。力扣的题目种类多样，而且有虚拟社区功能，因此很多同学都喜欢在上面分享习题答案。\n                    </p>\n                    <p data-nodeid=\"1786\">\n                      毫无疑问，如果你完整地刷过力扣题库，在一定程度上能够提高你面试通过的可能性。因此，在本课时，我选择了不同类型、不同层次的力扣真题，我会通过这些题目进一步讲述和分析解决数据结构问题的方法。\n                    </p>\n                    <h3 data-nodeid=\"1787\">力扣真题训练</h3>\n                    <p data-nodeid=\"1788\">\n                      在看真题前，我们再重复一遍通用的解题方法论，它可以分为以下\n                      4 个步骤：\n                    </p>\n                    <ol data-nodeid=\"1789\">\n                      <li data-nodeid=\"1790\">\n                        <p data-nodeid=\"1791\">\n                          <strong data-nodeid=\"1905\">复杂度分析</strong\n                          >。估算问题中复杂度的上限和下限。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1792\">\n                        <p data-nodeid=\"1793\">\n                          <strong data-nodeid=\"1910\">定位问题</strong\n                          >。根据问题类型，确定采用何种算法思维。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1794\">\n                        <p data-nodeid=\"1795\">\n                          <strong data-nodeid=\"1915\">数据操作分析</strong\n                          >。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1796\">\n                        <p data-nodeid=\"1797\">\n                          <strong data-nodeid=\"1920\">编码实现</strong>。\n                        </p>\n                      </li>\n                    </ol>\n                    <h4 data-nodeid=\"1798\">例题 1：删除排序数组中的重复项</h4>\n                    <p data-nodeid=\"1799\">\n                      <strong data-nodeid=\"1926\">【题目】</strong>\n                      给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后的数组和新的长度，你不需要考虑数组中超出新长度后面的元素。\n                    </p>\n                    <p data-nodeid=\"1800\">\n                      要求：空间复杂度为 O(1)，即不要使用额外的数组空间。\n                    </p>\n                    <p data-nodeid=\"1801\">\n                      例如，给定数组 nums = [1,1,2]，函数应该返回新的长度\n                      2，并且原数组 nums 的前两个元素被修改为 1, 2。又如，给定\n                      nums = [0,0,1,1,1,2,2,3,3,4]，函数应该返回新的长度\n                      5，并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n                    </p>\n                    <p data-nodeid=\"1802\">\n                      <strong data-nodeid=\"1941\">【解析】</strong>\n                      这个题目比较简单，应该是送分题。不过，面试过程中的送分题也是送命题。这是因为，如果送分题没有拿下，就会显得非常说不过去。\n                    </p>\n                    <p data-nodeid=\"1803\">\n                      <strong data-nodeid=\"1946\">我们先来看一下复杂度</strong\n                      >。这里并没有限定时间复杂度，仅仅是要求了空间上不能定义新的数组。\n                    </p>\n                    <p data-nodeid=\"1804\">\n                      <strong data-nodeid=\"1951\">然后我们来定位问题</strong\n                      >。显然这是一个数据去重的问题。\n                    </p>\n                    <p data-nodeid=\"1805\">\n                      <strong data-nodeid=\"1956\"\n                        >按照解题步骤，接下来我们需要做数据操作分析。</strong\n                      >\n                      在一个去重问题中，每次遍历的新的数据，都需要与已有的不重复数据进行对比。这时候，就需要查找了。整体来看，遍历嵌套查找，就是\n                      O(n²)\n                      的复杂度。如果要降低时间复杂度，那么可以在查找上入手，比如使用哈希表。不过很可惜，使用了哈希表之后，空间复杂度就是\n                      O(n)。幸运的是，原数组是有序的，这就可以让查找的动作非常简单了。\n                    </p>\n                    <p data-nodeid=\"1806\">\n                      因此，解决方案上就是，一次循环嵌套查找完成。查找不可使用哈希表，但由于数组有序，时间复杂度是\n                      O(1)。因此整体的时间复杂度就是 O(n)。\n                    </p>\n                    <p data-nodeid=\"1807\">\n                      我们来看一下具体方案。既然是一次循环，那么就需要一个 for\n                      循环对整个数组进行遍历。每轮遍历的动作是查找 nums[i]\n                      是否已经出现过。因为数组有序，因此只需要去对比 nums[i]\n                      和当前去重数组的最大值是否相等即可。我们用一个 temp\n                      变量保存去重数组的最大值。\n                    </p>\n                    <p data-nodeid=\"1808\">\n                      如果二者不等，则说明是一个新的数据。我们就需要把这个新数据放到去重数组的最后，并且修改\n                      temp 变量的值，再修改当前去重数组的长度变量\n                      len。直到遍历完，就得到了结果。\n                    </p>\n                    <p data-nodeid=\"1809\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/32/E8/CgqCHl8O4AaAIRWPAATuBR6nG1c878.gif\"\n                        alt=\"1.gif\"\n                        data-nodeid=\"1970\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1810\">\n                      <strong data-nodeid=\"1975\"\n                        >最后，我们按照上面的思路进行编码开发，代码如下</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] nums = {<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>};\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> temp = nums[<span class=\"hljs-number\">0</span>];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> len = <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; nums.length; i++) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (nums[i] != temp) {\n</div></li><li><div class=\"code-word\">            nums[len] = nums[i];\n</div></li><li><div class=\"code-word\">            temp = nums[i];\n</div></li><li><div class=\"code-word\">            len++;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    System.out.println(len);\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++) {\n</div></li><li><div class=\"code-word\">        System.out.println(nums[i]);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1812\">\n                      <strong data-nodeid=\"1980\">我们对代码进行解读。</strong>\n                      在这段代码中，第 3～4 行进行了初始化，得到的 temp\n                      变量是数组第一个元素，len 变量为 1。\n                    </p>\n                    <p data-nodeid=\"1813\">\n                      接着进入 for 循环。如果当前元素与去重的最大值不等（第 6\n                      行），则新元素放入去重数组中（第 7\n                      行），并且更新去重数组的最大值（第 8\n                      行），再让去重数组的长度加 1（第 9\n                      行）。最后得到结果后，再打印出来，第 12～15 行。\n                    </p>\n                    <h4 data-nodeid=\"1814\">\n                      例题 2：查找两个有序数组合并后的中位数\n                    </h4>\n                    <p data-nodeid=\"1815\">\n                      <strong data-nodeid=\"1987\">【题目】</strong>\n                      两个有序数组查找合并之后的中位数。给定两个大小为 m 和 n\n                      的正序（从小到大）数组 nums1 和\n                      nums2。请你找出这两个正序数组合在一起之后的中位数，并且要求算法的时间复杂度为\n                      O(log(m + n))。\n                    </p>\n                    <p data-nodeid=\"1816\">\n                      你可以假设 nums1 和 nums2\n                      不会同时为空，所有的数字全都不相等。还可以再假设，如果数字个数为偶数个，中位数就是中间偏左的那个元素。\n                    </p>\n                    <p data-nodeid=\"1817\">例如：nums1 = [1, 3, 5, 7, 9]</p>\n                    <p data-nodeid=\"1818\">nums2 = [2, 4, 8, 12]</p>\n                    <p data-nodeid=\"1819\">输出 5。</p>\n                    <p data-nodeid=\"1820\">\n                      <strong data-nodeid=\"2002\">【解析】</strong>\n                      这个题目是我个人非常喜欢的，原因是，它所有的解法和思路，都隐含在了题目的描述中。如果你具备很强的分析和解决问题的能力，那么一定可以找到最优解法。\n                    </p>\n                    <p data-nodeid=\"1821\">\n                      <strong data-nodeid=\"2007\"\n                        >我们先看一下复杂度的分析</strong\n                      >。这里的 nums1 和 nums2\n                      都是有序的，这让我们第一时间就想到了归并排序。方法很简单，我们把两个数组合并，就得到了合在一起后的有序数组。这个动作的时间复杂度是\n                      O(m+n)。接着，我们从数组中就可以直接取出中位数了。很可惜，这并不满足题目的时间复杂度\n                      O(log(m + n)) 的要求。\n                    </p>\n                    <p data-nodeid=\"1822\">\n                      <strong data-nodeid=\"2012\"\n                        >接着，我们来看一下这个问题的定位</strong\n                      >。题目中有一个关键字，那就是“找出”。很显然，我们要找的目标就藏在\n                      nums1 或 nums2\n                      中。这明显就是一个查找问题。而在查找问题中，我们学过的知识是分治法下的二分查找。\n                    </p>\n                    <p data-nodeid=\"1823\">\n                      回想一下，二分查找适用的重要条件就是，原数组有序。恰好，在这个问题中\n                      nums1 和 nums2 分别都是有序的。而且二分查找的时间复杂度是\n                      O(logn)，这和题目中给出的时间复杂度 O(log(m + n))\n                      的要求也是不谋而合。因此，经过分析，我们可以大胆猜测，此题极有可能要用到二分查找。\n                    </p>\n                    <p data-nodeid=\"1824\">\n                      <strong data-nodeid=\"2018\"\n                        >我们再来看一下数据结构方面</strong\n                      >。如果要用二分查找，就需要用到若干个指针，去约束查找范围。除此以外，并不需要去定义复杂的数据结构。也就是说，空间复杂度是\n                      O(1) 。\n                    </p>\n                    <p data-nodeid=\"1825\">\n                      好了，接下来，我们就来看一下二分查找如何能解决这个问题。二分查找需要一个分裂点，去把原来的大问题，拆分成两个部分，并在其中一部分继续执行二分查找。既然是查找中位数，我们不妨先试试以中位数作为切分点，看看会产生什么结果。如下图所示：\n                    </p>\n                    <p data-nodeid=\"1826\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/32/DD/Ciqc1F8O4BWAJgOUAABMJW6Ihfk508.png\"\n                        alt=\"2.png\"\n                        data-nodeid=\"2022\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1827\">\n                      经过切分后，两个数组分别被拆分为 3 个部分，合在一起是 6\n                      个部分。二分查找的思路是，需要从这 6\n                      个部分中，剔除掉一些，让查找的范围缩小。那么，我们来思考一个问题，在这\n                      6 个部分中，目标中位数一定不会发生在哪几个部分呢？\n                    </p>\n                    <p data-nodeid=\"1828\">\n                      <strong data-nodeid=\"2028\"\n                        >中位数有一个重要的特质，那就是比中位数小的数字个数，和比中位数大的数字个数，是相等的</strong\n                      >。围绕这个性质来看，中位数就一定不会发生在 C 和 D\n                      的区间。\n                    </p>\n                    <p data-nodeid=\"1829\">\n                      如果中位数在 C 部分，那么在 nums1\n                      中，比中位数小的数字就会更多一些。因为 4 &lt; 5（nums2\n                      的中位数小于 nums1 的中位数），所以在 nums2\n                      中，比中位数小的数字也会更多一些（最不济也就是一样多）。因此，整体来看，中位数不可能在\n                      C 部分。同理，中位数也不会发生在 D 部分。\n                    </p>\n                    <p data-nodeid=\"1830\">\n                      接下来，我们就可以在查找范围内，剔除掉 C\n                      部分（永远比中位数大的数字）和 D\n                      部分（永远比中位数小的数字），这样我们就成功地完成了一次二分动作，缩小了查找范围。然而这样并没结束。剔除掉了\n                      C 和 D 之后，中位数有可能发生改变。这是因为，C\n                      部分的数字个数和 D\n                      部分数字的个数是不相等的。剔除不相等数量的“小数”和“大数”后，会造成中位数的改变。\n                    </p>\n                    <p data-nodeid=\"1831\">\n                      为了解决这个问题，我们需要对剔除的策略进行修改。一个可行的方法是，如果\n                      C 部分数字更少为 p 个，则剔除 C 部分；并只剔除 D 部分中的\n                      p\n                      个数字。这样就能保证，经过一次二分后，剔除之后的数组的中位数不变。\n                    </p>\n                    <p data-nodeid=\"1832\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/32/E8/CgqCHl8O4CKAd3GfAAA88tCPFHQ522.png\"\n                        alt=\"3.png\"\n                        data-nodeid=\"2036\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1833\">\n                      应该剔除 C 部分和 D 部分。但 D 部分更少，因此剔除 D 和 C\n                      中的 9。\n                    </p>\n                    <p data-nodeid=\"1834\" class=\"\">\n                      二分查找还需要考虑终止条件。对于这个题目，终止条件必然是某个数组小到无法继续二分的时候。这是因为，每次二分剔除掉的是更少的那个部分。因此，在终止条件中，查找范围应该是一个大数组和一个只有\n                      1～2\n                      个元素的小数组。这样就需要根据大数组的奇偶性和小数组的数量，拆开\n                      4 个可能性：\n                    </p>\n                    <p data-nodeid=\"1835\">\n                      <strong data-nodeid=\"2055\">可能性一</strong>：nums1\n                      奇数个，nums2 只有 1 个元素。例如，nums1 = [a, b,\n                      <strong data-nodeid=\"2056\">c</strong>, d, e]，nums2 =\n                      [m]。此时，有以下 3 种可能性：\n                    </p>\n                    <ol data-nodeid=\"1836\">\n                      <li data-nodeid=\"1837\">\n                        <p data-nodeid=\"1838\">如果 m &lt; b，则结果为 b；</p>\n                      </li>\n                      <li data-nodeid=\"1839\">\n                        <p data-nodeid=\"1840\">\n                          如果 b &lt; m &lt; c，则结果为 m；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1841\">\n                        <p data-nodeid=\"1842\" class=\"\">\n                          如果 m &gt; c，则结果为 c。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1843\" class=\"\">\n                      这 3 个情况，可以利用 \"A?B:C\" 合并为一个表达式，即 m &lt;\n                      b ? b : (m &lt; c ? m : c)。\n                    </p>\n                    <p data-nodeid=\"1844\">\n                      <strong data-nodeid=\"2091\">可能性二</strong>：nums1\n                      偶数个，nums2 只有 1 个元素。例如，nums1 = [a, b,\n                      <strong data-nodeid=\"2092\">c</strong>, d, e, f]，nums2 =\n                      [m]。此时，有以下 3 种可能性：\n                    </p>\n                    <ol data-nodeid=\"1845\">\n                      <li data-nodeid=\"1846\">\n                        <p data-nodeid=\"1847\">如果 m &lt; c，则结果为 c；</p>\n                      </li>\n                      <li data-nodeid=\"1848\">\n                        <p data-nodeid=\"1849\">\n                          如果 c &lt; m &lt; d，则结果为 m；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1850\">\n                        <p data-nodeid=\"1851\" class=\"\">\n                          如果m &gt; d，则结果为 d。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1852\">\n                      这 3 个情况，可以利用\"A?B:C\"合并为一个表达式，即 m &lt; c\n                      ? c : (m &lt; d? m : d)。\n                    </p>\n                    <p data-nodeid=\"1853\">\n                      <strong data-nodeid=\"2130\">可能性三</strong>：nums1\n                      奇数个，nums2 有 2 个元素。例如，nums1 = [a, b,\n                      <strong data-nodeid=\"2131\">c</strong>, d, e]，nums2 =\n                      [<strong data-nodeid=\"2132\">m</strong>,n]。此时，有以下 6\n                      种可能性：\n                    </p>\n                    <ol data-nodeid=\"1854\">\n                      <li data-nodeid=\"1855\">\n                        <p data-nodeid=\"1856\">如果 n &lt; b，则结果为 b；</p>\n                      </li>\n                      <li data-nodeid=\"1857\">\n                        <p data-nodeid=\"1858\">\n                          如果 b &lt; n &lt; c，则结果为 n；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1859\">\n                        <p data-nodeid=\"1860\">\n                          如果 c &lt; n &lt; d，则结果为 max(c,m)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1861\">\n                        <p data-nodeid=\"1862\">\n                          如果 n &gt; d，m &lt; c，则结果为 c；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1863\">\n                        <p data-nodeid=\"1864\">\n                          如果 n &gt; d，c &lt; m &lt; d，则结果为 m；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1865\">\n                        <p data-nodeid=\"1866\">\n                          如果 n &gt; d，m &gt; d，则结果为 d。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1867\">\n                      其中，4～6 可以合并为，如果 n &gt; d，则返回 m &lt; c ? c\n                      : (m &lt; d ? m : d)。\n                    </p>\n                    <p data-nodeid=\"1868\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/32/6C/Ciqc1F8Odd-AdDghAAAd2xZYP1g802.png\"\n                        alt=\"image (4).png\"\n                        data-nodeid=\"2162\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1869\">\n                      <strong data-nodeid=\"2182\">可能性四</strong>：nums1\n                      偶数个，nums2 有 2 个元素。例如，nums1 = [a, b,\n                      <strong data-nodeid=\"2183\">c</strong>, d, e, f]，nums2 =\n                      [<strong data-nodeid=\"2184\">m</strong>,n]。此时，有以下 6\n                      种可能性：\n                    </p>\n                    <ol data-nodeid=\"1870\">\n                      <li data-nodeid=\"1871\">\n                        <p data-nodeid=\"1872\">如果 n &lt; b，则结果为 b；</p>\n                      </li>\n                      <li data-nodeid=\"1873\">\n                        <p data-nodeid=\"1874\" class=\"\">\n                          如果 b &lt; n &lt; c，则结果为 n；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1875\">\n                        <p data-nodeid=\"1876\" class=\"\">\n                          如果 c &lt; n &lt; d，则结果为 max(c,m)；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1877\">\n                        <p data-nodeid=\"1878\" class=\"\">\n                          如果 n &gt; d，m &lt; c，则结果为 c；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1879\">\n                        <p data-nodeid=\"1880\">\n                          如果 n &gt; d，c &lt; m &lt; d，则结果为 m；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1881\">\n                        <p data-nodeid=\"1882\">\n                          如果 n &gt; d，m &gt; d，则结果为 d。与可能性 3\n                          完全一致。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"1883\">\n                      不难发现，终止条件都是 if 和 else\n                      的判断，虽然逻辑有点复杂，但时间复杂度是 O(1)\n                      。为了简便，我们可以假定，nums1 的数字数量永远是不少于\n                      nums2 的数字数量。\n                    </p>\n                    <p data-nodeid=\"1884\">\n                      <strong data-nodeid=\"2212\"\n                        >因此，我们可以编写如下的代码</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] nums1 = {<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>};\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] nums2 = {<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>};\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> median = getMedian(nums1,<span class=\"hljs-number\">0</span>, nums1.length-<span class=\"hljs-number\">1</span>, nums2, <span class=\"hljs-number\">0</span>, nums2.length-<span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    System.out.println(median);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMedian</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> begina, <span class=\"hljs-keyword\">int</span> enda, <span class=\"hljs-keyword\">int</span>[] b, <span class=\"hljs-keyword\">int</span> beginb, <span class=\"hljs-keyword\">int</span> endb )</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (enda - begina == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> a[begina] &gt; b[beginb] ? b[beginb] : a[begina];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (enda - begina == <span class=\"hljs-number\">1</span>){\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (a[begina] &lt; b[beginb]) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> b[beginb] &gt; a[enda] ? a[enda] : b[beginb];\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> a[begina] &lt; b[endb] ? a[begina] : b[endb];\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (endb-beginb &lt; <span class=\"hljs-number\">2</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> ((endb - beginb == <span class=\"hljs-number\">0</span>) &amp;&amp; (enda - begina)%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> m = b[beginb];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> bb = a[(enda + begina)/<span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> c = a[(enda + begina)/<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> (m &lt; bb) ? bb : (m &lt; c ? m : c);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> ((endb - beginb == <span class=\"hljs-number\">0</span>) &amp;&amp; (enda - begina)%<span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> m = b[beginb];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> c = a[(enda + begina)/<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> d = a[(enda + begina)/<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> m &lt; c ? c : (m &lt; d ? m : d);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> m = b[beginb];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> n = b[endb];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> bb = a[(enda + begina)/<span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> c = a[(enda + begina)/<span class=\"hljs-number\">2</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> d = a[(enda + begina)/<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (n&lt;bb) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> bb;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (n&gt;bb &amp;&amp; n &lt; c) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> n;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (n &gt; c &amp;&amp; n &lt; d) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> m &gt; c ? m : c;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span> m &lt; c ? c : (m&lt;d ? m : d);\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> mida = (enda + begina)/<span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> midb = (endb + beginb)/<span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (a[mida] &lt; b[midb]) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> step = endb - midb;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> getMedian(a,begina + step, enda, b, beginb, endb - step);\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">int</span> step = midb - beginb;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> getMedian(a,begina,enda - step, b, beginb+ step, endb );\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"1886\">\n                      <strong data-nodeid=\"2217\">我们对代码进行解读</strong\n                      >。在第 1～6 行是主函数，进入 getMedian() 中，入参分别是\n                      nums1 数组，nums1 数组搜索范围的起止索引；nums2\n                      数组，nums2 数组搜索范围的起止索引。并进入第 8\n                      行的函数中。\n                    </p>\n                    <p data-nodeid=\"1887\">\n                      在 getMedian() 函数中，第 53～64 行是二分策略，第 9～52\n                      行是终止条件。我们先看二分部分。通过第 56 行，判断 a 和 b\n                      的中位数的大小关系，决策剔除哪个部分。并在第 58 行和 62\n                      行，递归地执行二分动作缩小范围。\n                    </p>\n                    <p data-nodeid=\"1888\">\n                      终止条件的第一种可能性在第 21～26 行，第二种可能性在\n                      27～32 行，第三种和第四种可能性完全一致，在 33～52\n                      行。另外，在 9～19 行中处理了两个特殊情况，分别是第 9～11\n                      行，处理了两个数组都只剩 1 个元素的情况；第 12～19\n                      行，处理了两个数组都只剩 2 个元素的情况。\n                    </p>\n                    <p data-nodeid=\"1889\">\n                      这段代码的逻辑并不复杂，但写起来还是有很多情况需要考虑的。希望你能认真阅读。\n                    </p>\n                    <h3 data-nodeid=\"1890\">\n                      <strong data-nodeid=\"2224\">总结</strong>\n                    </h3>\n                    <p data-nodeid=\"1891\">\n                      综合来看，力扣的题目还是比较受到行业的认可的。一方面是它的题库内题目数量多，另一方面是很多人会在上面提交相同题目的不同解法和答案。但对初学者来说，它还是有一些不友好的。这主要在于，它的定位只是题库，并不能提供完整的解决问题的思维逻辑和方法论。\n                    </p>\n                    <p data-nodeid=\"1892\">\n                      本课时，虽然我们只是举了两个例题，但其背后解题的思考方法是通用的。建议你能围绕本课程学到的解题方法，利用空闲时间去把力扣热门的题目都练习一遍。\n                    </p>\n                    <h3 data-nodeid=\"1893\">练习题</h3>\n                    <p data-nodeid=\"1894\">\n                      最后，我们再给出一道练习题。给定一个链表，删除链表的倒数第\n                      n 个节点。\n                    </p>\n                    <p data-nodeid=\"1895\">\n                      例如，给定一个链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, 和\n                      n = 2。当删除了倒数第二个节点后，链表变为 1 -&gt; 2 -&gt;\n                      3 -&gt; 5。\n                    </p>\n                    <p data-nodeid=\"1896\" class=\"\">\n                      你可以假设，给定的 n\n                      是有效的。额外要求就是，要在一趟扫描中实现，即时间复杂度是\n                      O(n)。这里给你一个提示，可以采用快慢指针的方法。\n                    </p>\n            "}