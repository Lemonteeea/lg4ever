{"title":"18 | 揭秘 Redux 设计思想与工作原理（上）","context":"\n                    <p data-nodeid=\"1353\" class=\"\">\n                      Redux 相信大家或多或少都接触过，关于 Redux 的基础知识，第\n                      05 讲已经有过铺垫。从本讲开始，我们将在此基础上，针对\n                      Redux 进行更加系统和深入的学习。\n                    </p>\n                    <blockquote data-nodeid=\"1354\">\n                      <p data-nodeid=\"1355\">\n                        注：如果你没有接触过 Redux，点击<a\n                          href=\"https://www.redux.org.cn/\"\n                          data-nodeid=\"1474\"\n                          >这里</a\n                        >可以快速上手。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1356\">\n                      <strong data-nodeid=\"1484\">何谓“系统”的学习</strong\n                      >？系统的一个前提就是<strong data-nodeid=\"1485\"\n                        >建立必要的学习上下文</strong\n                      >，尝试理解事情的来龙去脉。\n                    </p>\n                    <p data-nodeid=\"1357\">\n                      这些年不管是面试、还是帮读者答疑，我有一个很强烈的感受：很多人对\n                      Redux\n                      的基本操作很熟悉，甚至对它的运作机制也有所了解，但就是不明白为什么要用\n                      Redux，更不清楚 Redux\n                      到底解决了什么问题。因此在讲源码和原理之前，我们首先需要说清楚的是\n                      Redux 的问题背景和架构思想。\n                    </p>\n                    <h3 data-nodeid=\"1358\">\n                      Redux 背后的架构思想——认识 Flux 架构\n                    </h3>\n                    <p data-nodeid=\"1359\">\n                      Redux 的设计在很大程度上受益于 Flux 架构，我们可以认为\n                      Redux 是 Flux 的一种实现形式（虽然它并不严格遵循 Flux\n                      的设定），理解 Flux 将帮助你更好地从抽象层面把握 Redux。\n                    </p>\n                    <p data-nodeid=\"1360\">\n                      Flux 并不是一个具体的框架，它是一套由 Facebook\n                      技术团队提出的应用架构，这套架构约束的是<strong\n                        data-nodeid=\"1494\"\n                        >应用处理数据的模式</strong\n                      >。在 Flux 架构中，一个应用将被拆分为以下 4 个部分。\n                    </p>\n                    <ul data-nodeid=\"1361\">\n                      <li data-nodeid=\"1362\">\n                        <p data-nodeid=\"1363\">\n                          <strong data-nodeid=\"1507\">View</strong>（<strong\n                            data-nodeid=\"1508\"\n                            >视图层</strong\n                          >）：用户界面。该用户界面可以是以任何形式实现出来的，React\n                          组件是一种形式，Vue、Angular 也完全 OK。<strong\n                            data-nodeid=\"1509\"\n                            >Flux 架构与 React 之间并不存在耦合关系</strong\n                          >。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1364\">\n                        <p data-nodeid=\"1365\">\n                          <strong data-nodeid=\"1518\">Action</strong>（<strong\n                            data-nodeid=\"1519\"\n                            >动作</strong\n                          >）：也可以理解为视图层发出的“消息”，它会触发应用状态的改变。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1366\">\n                        <p data-nodeid=\"1367\">\n                          <strong data-nodeid=\"1524\">Dispatcher</strong\n                          >（派发器）：它负责对 action 进行分发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1368\">\n                        <p data-nodeid=\"1369\">\n                          <strong data-nodeid=\"1529\">Store</strong\n                          >（数据层）：它是存储应用状态的“仓库”，此外还会定义修改状态的逻辑。store\n                          的变化最终会映射到 view 层上去。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1370\">\n                      这 4\n                      个部分之间的协作将通过下图所示的工作流规则来完成配合：\n                    </p>\n                    <p data-nodeid=\"1691\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/D2/CgqCHl_PX4iAVQDeAABqpNRcHXQ065.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"1694\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"1372\">\n                      一个典型的 Flux 工作流是这样的：用户与 View\n                      之间产生交互，通过 View 发起一个 Action；Dispatcher\n                      会把这个 Action 派发给 Store，通知 Store\n                      进行相应的状态更新。Store 状态更新完成后，会进一步通知\n                      View 去更新界面。\n                    </p>\n                    <blockquote data-nodeid=\"1373\">\n                      <p data-nodeid=\"1374\">\n                        值得注意的是，图中所有的箭头都是单向的，这也正是 Flux\n                        架构最核心的一个特点——<strong data-nodeid=\"1540\"\n                          >单向数据流</strong\n                        >。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1375\">\n                      那么 Flux 架构的出现到底是为了解决什么问题呢？\n                    </p>\n                    <h3 data-nodeid=\"1376\">Flux 架构到底解决了什么问题</h3>\n                    <p data-nodeid=\"1377\">\n                      Flux\n                      的核心特征是单向数据流，要想完全了解单向数据流的好处，我们需要先了解双向数据流带来了什么问题。\n                    </p>\n                    <h4 data-nodeid=\"1378\">MVC 模式在前端场景下的局限性</h4>\n                    <p data-nodeid=\"1379\">\n                      双向数据流最为典型的代表就是<strong data-nodeid=\"1550\"\n                        >前端场景下的 MVC 架构</strong\n                      >，该架构的示意图如下图所示：\n                    </p>\n                    <p data-nodeid=\"1380\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/C5/CgqCHl_PVeKAMZaHAACLXZ2Co3Q900.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1553\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1381\">\n                      除了允许用户通过 View 层交互来触发流程以外，MVC\n                      架构还有另外一种形式，即允许用户通过直接触发 Controller\n                      逻辑来触发流程，这种模式下的架构关系如下图所示：\n                    </p>\n                    <p data-nodeid=\"1382\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/BA/Ciqc1F_PVe2AaJt5AACCt5hpXUM704.png\"\n                        alt=\"Drawing 5.png\"\n                        data-nodeid=\"1557\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1383\">在 MVC 应用中，会涉及这 3 个部分：</p>\n                    <ul data-nodeid=\"1384\">\n                      <li data-nodeid=\"1385\">\n                        <p data-nodeid=\"1386\">\n                          Model（模型），程序需要操作的数据或信息；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1387\">\n                        <p data-nodeid=\"1388\">View（视图），用户界面；</p>\n                      </li>\n                      <li data-nodeid=\"1389\">\n                        <p data-nodeid=\"1390\">\n                          Controller（控制器），用于连接 View 和 Model，管理\n                          Model 与 View 之间的逻辑。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1391\">\n                      原则上来说，三者的关系应该像上图一样，用户操作 View 后，由\n                      Controller 来处理逻辑（或者直接触发 Controller\n                      的逻辑），经过 Controller 将改变应用到 Model\n                      中，最终再反馈到 View\n                      上。在这个过程中，数据流应该是单向的。\n                    </p>\n                    <p data-nodeid=\"1392\">\n                      <strong data-nodeid=\"1567\"\n                        >事实上，在许多服务端的 MVC\n                        应用中，数据流确实能够保持单向。但是在前端场景下，实际的\n                        MVC\n                        应用要复杂不少，前端应用/框架往往出于交互的需要，允许\n                        View 和 Model 直接通信</strong\n                      >。此时的架构关系就会变成下图这样：\n                    </p>\n                    <p data-nodeid=\"1393\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/BA/Ciqc1F_PVfWAMialAACIyVXJabE467.png\"\n                        alt=\"Drawing 7.png\"\n                        data-nodeid=\"1570\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1394\">\n                      这就允许了双向数据流的存在。当业务复杂度较高时，数据流会变得非常混乱，出现类似下图这种情况：\n                    </p>\n                    <p data-nodeid=\"1395\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/C5/CgqCHl_PVgWAcAkZAAFInClVHRM354.png\"\n                        alt=\"Drawing 11.png\"\n                        data-nodeid=\"1574\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1396\">\n                      图中我们的示例只有一个\n                      Controller，但考虑到一个应用中还可能存在多个\n                      Controller，实际的情况应该比上图还要复杂得多（尽管图示本身已经够复杂了）。\n                    </p>\n                    <p data-nodeid=\"1397\">\n                      在如此复杂的依赖关系下，再小的项目变更也将伴随着不容小觑的风险——或许一个小小的改动，就会对整个项目造成“蝴蝶效应”般的巨大影响。如此混乱的修改来源，将会使得我们连\n                      Bug\n                      排查都无从下手，因为你很难区分出一个数据的变化到底是由哪个\n                      Controller 或者哪个 View 引发的。\n                    </p>\n                    <p data-nodeid=\"1398\">\n                      此时再回头看下 Flux\n                      的架构模式，你应该多少能感受到其中的妙处。这里我们再来回顾一下\n                      Flux 中的数据流模式，请看下图：\n                    </p>\n                    <p data-nodeid=\"2371\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/D2/CgqCHl_PX5mAYUWaAABqpNRcHXQ626.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"2374\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"1400\">\n                      Flux 最核心的地方在于<strong data-nodeid=\"1590\"\n                        >严格的单向数据流</strong\n                      >，在单向数据流下，<strong data-nodeid=\"1591\"\n                        >状态的变化是可预测的</strong\n                      >。如果 store\n                      中的数据发生了变化，那么有且仅有一个原因，那就是由\n                      Dispatcher 派发 Action\n                      来触发的。这样一来，就从根本上避免了混乱的数据关系，使整个流程变得清晰简单。\n                    </p>\n                    <p data-nodeid=\"1401\">\n                      不过这并不意味着 Flux 是完美的。事实上，Flux\n                      对数据流的约束背后是不可忽视的成本：除了开发者的学习成本会提升外，Flux\n                      架构还意味着项目中代码量的增加。\n                    </p>\n                    <p data-nodeid=\"1402\">\n                      Flux\n                      架构往往在复杂的项目中才会体现出它的优势和必要性。如果项目中的数据关系并不复杂，其实完全轮不到\n                      Flux 登场，这一点对于 Redux 来说也是一样的。\n                    </p>\n                    <p data-nodeid=\"1403\">\n                      现在你不妨结合 Flux 架构的特性，再去品味一遍 Redux\n                      官方给出的这个定义：\n                    </p>\n                    <blockquote data-nodeid=\"1404\">\n                      <p data-nodeid=\"1405\">\n                        Redux 是 JavaScript 状态容器，它提供可预测的状态管理。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1406\">\n                      此时的你，想必更加能够体会“<strong data-nodeid=\"1601\"\n                        >可预测</strong\n                      >”这三个字背后的深意。\n                    </p>\n                    <h3 data-nodeid=\"1407\">Redux 关键要素与工作流回顾</h3>\n                    <p data-nodeid=\"1408\">\n                      Redux 库和 Flux 架构之间可以说是“你侬我侬”，虽然 Redux\n                      在实现层面并没有按照 Flux 那一套来（比如 Flux 中允许多个\n                      Store 存在，而 Redux 中只有一个 Store 等），但 Redux\n                      在设计思想上确实和 Flux 一脉相承。\n                    </p>\n                    <p data-nodeid=\"1409\">\n                      前面我们介绍的 Flux\n                      架构的特征、解决问题的思路，包括使用场景方面的注意事项，完全可以迁移到\n                      Redux 上来用。基于 Flux 的思想背景去理解 Redux\n                      这个落地产物，你的学习曲线将会更加平滑一些。\n                    </p>\n                    <p data-nodeid=\"1410\">\n                      接下来我们在介绍 Redux\n                      的实现原理之前，先简单回顾一下它的关键要素与工作流。Redux\n                      主要由 3 部分组成：Store、Reducer 和 Action。\n                    </p>\n                    <ul data-nodeid=\"1411\">\n                      <li data-nodeid=\"1412\">\n                        <p data-nodeid=\"1413\">\n                          Store：它是一个单一的数据源，而且是只读的。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1414\">\n                        <p data-nodeid=\"1415\">\n                          Action 人如其名，是“动作”的意思，它是对变化的描述。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1416\">\n                        <p data-nodeid=\"1417\">\n                          Reducer 是一个函数，它负责<strong data-nodeid=\"1613\"\n                            >对变化进行分发和处理</strong\n                          >，最终将新的数据返回给 Store。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1418\">\n                      Store、Action 和 Reducer 三者紧密配合，便形成了 Redux\n                      独树一帜的工作流，如下图所示：\n                    </p>\n                    <p data-nodeid=\"1419\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/C6/CgqCHl_PVh-ATfOGAAB089LdYcY341.png\"\n                        alt=\"Drawing 13.png\"\n                        data-nodeid=\"1617\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1420\">\n                      在 Redux 的整个工作过程中，<strong data-nodeid=\"1627\"\n                        >数据流是严格单向的</strong\n                      >。如果你想对数据进行修改，只有一种途径：<strong\n                        data-nodeid=\"1628\"\n                        >派发 Action</strong\n                      >。Action 会被 Reducer 读取，Reducer 将根据 Action\n                      内容的不同执行不同的计算逻辑，最终生成新的\n                      state（状态），这个新的 state 会更新到 Store\n                      对象里，进而驱动视图层面作出对应的改变。\n                    </p>\n                    <p data-nodeid=\"1421\">\n                      对于组件来说，任何组件都可以以约定的方式从 Store\n                      读取到全局的状态，任何组件也都可以通过合理地派发 Action\n                      来修改全局的状态。<strong data-nodeid=\"1634\"\n                        >Redux 通过提供一个统一的状态容器</strong\n                      >，使得数据能够自由而有序地在任意组件之间穿梭。\n                    </p>\n                    <p data-nodeid=\"1422\">\n                      复习完 Redux\n                      的工作流，下面我们来结合源码看看这套工作流到底是如何实现的。\n                    </p>\n                    <h3 data-nodeid=\"1423\">Redux 是如何工作的</h3>\n                    <p data-nodeid=\"1424\">\n                      我们先来看一下 Redux 的源码文件夹结构，如下图所示：<br />\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/C6/CgqCHl_PVieAeMfAAABARscWp8o305.png\"\n                        alt=\"Drawing 14.png\"\n                        data-nodeid=\"1641\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1425\">\n                      其中，utils 是工具方法库；index.js\n                      作为入口文件，用于对功能模块进行收敛和导出。真正“干活”的是功能模块本身，也就是下面这几个文件：\n                    </p>\n                    <ul data-nodeid=\"1426\">\n                      <li data-nodeid=\"1427\">\n                        <p data-nodeid=\"1428\">applyMiddleware.js</p>\n                      </li>\n                      <li data-nodeid=\"1429\">\n                        <p data-nodeid=\"1430\">bindActionCreators.js</p>\n                      </li>\n                      <li data-nodeid=\"1431\">\n                        <p data-nodeid=\"1432\">combineReducers.js</p>\n                      </li>\n                      <li data-nodeid=\"1433\">\n                        <p data-nodeid=\"1434\">compose.js</p>\n                      </li>\n                      <li data-nodeid=\"1435\">\n                        <p data-nodeid=\"1436\">createStore.js</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1437\">\n                      applyMiddleware 是中间件模块，它的独立性较强，我们将在第\n                      20 讲中单独讲解。\n                    </p>\n                    <p data-nodeid=\"1438\">\n                      而 bindActionCreators（用于将传入的 actionCreator 与\n                      dispatch\n                      方法相结合，揉成一个新的方法，感兴趣的同学可以点击<a\n                        href=\"https://cn.redux.js.org/docs/api/bindActionCreators.html\"\n                        data-nodeid=\"1652\"\n                        >这里</a\n                      >了解它的使用场景）、combineReducers（用于将多个\n                      &nbsp;reducer\n                      合并起来）、compose（用于把接收到的函数从右向左进行组合）这三个方法均为工具性质的方法。\n                    </p>\n                    <p data-nodeid=\"1439\">\n                      如果你对这三个工具方法感到陌生，也不用急着去搜索，因为它们均独立于\n                      Redux 主流程之外，属于“非必须使用”的<strong\n                        data-nodeid=\"1663\"\n                        >辅助 API</strong\n                      >，不熟悉这些 API 并不影响你理解 Redux 本身。理解 Redux\n                      实现原理，真正需要我们关注的模块其实只有一个——<strong\n                        data-nodeid=\"1664\"\n                        >createStore</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1440\">\n                      <strong data-nodeid=\"1669\"\n                        >createStore 方法是我们在使用 Redux\n                        时最先调用的方法，它是整个流程的入口，也是 Redux\n                        中最核心的 API</strong\n                      >。接下来我们就从 createStore 入手，顺藤摸瓜揪出 Redux\n                      源码的主流程。\n                    </p>\n                    <h4 data-nodeid=\"1441\">故事的开始：createStore</h4>\n                    <p data-nodeid=\"1442\">\n                      使用 Redux 的第一步，我们就需要调用 createStore\n                      方法。单纯从使用感上来说，这个方法做的事情似乎就是创建一个\n                      store 对象出来，像这样：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">// 引入 redux\n</div></li><li><div class=\"code-word\">import { createStore } from 'redux'\n</div></li><li><div class=\"code-word\">// 创建 store\n</div></li><li><div class=\"code-word\">const store = createStore(\n</div></li><li><div class=\"code-word\">    reducer,\n</div></li><li><div class=\"code-word\">    initial_state,\n</div></li><li><div class=\"code-word\">    applyMiddleware(middleware1, middleware2, ...)\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1444\">\n                      createStore 方法可以接收以下 3 个入参：\n                    </p>\n                    <ul data-nodeid=\"1445\">\n                      <li data-nodeid=\"1446\">\n                        <p data-nodeid=\"1447\">reducer</p>\n                      </li>\n                      <li data-nodeid=\"1448\">\n                        <p data-nodeid=\"1449\">初始状态内容</p>\n                      </li>\n                      <li data-nodeid=\"1450\">\n                        <p data-nodeid=\"1451\">指定中间件</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1452\">\n                      从拿到入参到返回出 store\n                      的过程中，到底都发生了什么呢？这里我为你提取了 createStore\n                      中主体逻辑的源码（解析在注释里）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">createStore</span><span class=\"hljs-params\">(reducer, preloadedState, enhancer)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (typeof preloadedState === <span class=\"hljs-string\">'function'</span> &amp;&amp; typeof enhancer === <span class=\"hljs-string\">'undefined'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 此时第二个参数会被认为是 enhancer（中间件）</span>\n</div></li><li><div class=\"code-word\">        enhancer = preloadedState;\n</div></li><li><div class=\"code-word\">        preloadedState = undefined;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (typeof enhancer !== <span class=\"hljs-string\">'undefined'</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> enhancer(createStore)(reducer, preloadedState);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录当前的 reducer，因为 replaceReducer 会修改 reducer 的内容</span>\n</div></li><li><div class=\"code-word\">    let currentReducer = reducer;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 记录当前的 state</span>\n</div></li><li><div class=\"code-word\">    let currentState = preloadedState;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 声明 listeners 数组，这个数组用于记录在 subscribe 中订阅的事件</span>\n</div></li><li><div class=\"code-word\">    let currentListeners = [];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// nextListeners 是 currentListeners 的快照</span>\n</div></li><li><div class=\"code-word\">    let nextListeners = currentListeners;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 该变量用于记录当前是否正在进行 dispatch</span>\n</div></li><li><div class=\"code-word\">    let isDispatching = <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 该方法用于确认快照是 currentListeners 的副本，而不是 currentListeners 本身</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">function <span class=\"hljs-title\">ensureCanMutateNextListeners</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (nextListeners === currentListeners) {\n</div></li><li><div class=\"code-word\">            nextListeners = currentListeners.slice();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 我们通过调用 getState 来获取当前的状态</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">function <span class=\"hljs-title\">getState</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> currentState;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// subscribe 订阅方法，它将会定义 dispatch 最后执行的 listeners 数组的内容</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">function <span class=\"hljs-title\">subscribe</span><span class=\"hljs-params\">(listener)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 校验 listener 的类型</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (typeof listener !== <span class=\"hljs-string\">'function'</span>) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(<span class=\"hljs-string\">'Expected the listener to be a function.'</span>)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 禁止在 reducer 中调用 subscribe</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (isDispatching) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-string\">'You may not call store.subscribe() while the reducer is executing. '</span> +\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-string\">'If you would like to be notified after the store has been updated, subscribe from a '</span> +\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-string\">'component and invoke store.getState() in the callback to access the latest state. '</span> +\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-string\">'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'</span>\n</div></li><li><div class=\"code-word\">          )\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 该变量用于防止调用多次 unsubscribe 函数</span>\n</div></li><li><div class=\"code-word\">        let isSubscribed = <span class=\"hljs-keyword\">true</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 确保 nextListeners 与 currentListeners 不指向同一个引用</span>\n</div></li><li><div class=\"code-word\">        ensureCanMutateNextListeners(); \n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 注册监听函数</span>\n</div></li><li><div class=\"code-word\">        nextListeners.push(listener); \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 返回取消订阅当前 listener 的方法</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">function <span class=\"hljs-title\">unsubscribe</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">if</span> (!isSubscribed) {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">            isSubscribed = <span class=\"hljs-keyword\">false</span>;\n</div></li><li><div class=\"code-word\">            ensureCanMutateNextListeners();\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> index = nextListeners.indexOf(listener);\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-comment\">// 将当前的 listener 从 nextListeners 数组中删除 </span>\n</div></li><li><div class=\"code-word\">            nextListeners.splice(index, <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">        };\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 定义 dispatch 方法，用于派发 action </span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">function <span class=\"hljs-title\">dispatch</span><span class=\"hljs-params\">(action)</span> </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 校验 action 的数据格式是否合法</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (!isPlainObject(action)) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-string\">'Actions must be plain objects. '</span> +\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-string\">'Use custom middleware for async actions.'</span>\n</div></li><li><div class=\"code-word\">          )\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 约束 action 中必须有 type 属性作为 action 的唯一标识 </span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (typeof action.type === <span class=\"hljs-string\">'undefined'</span>) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-string\">'Actions may not have an undefined \"type\" property. '</span> +\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-string\">'Have you misspelled a constant?'</span>\n</div></li><li><div class=\"code-word\">          )\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (isDispatching) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> Error(<span class=\"hljs-string\">'Reducers may not dispatch actions.'</span>)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 执行 reducer 前，先\"上锁\"，标记当前已经存在 dispatch 执行流程</span>\n</div></li><li><div class=\"code-word\">          isDispatching = <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 调用 reducer，计算新的 state </span>\n</div></li><li><div class=\"code-word\">          currentState = currentReducer(currentState, action)\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">finally</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-comment\">// 执行结束后，把\"锁\"打开，允许再次进行 dispatch </span>\n</div></li><li><div class=\"code-word\">          isDispatching = <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 触发订阅</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> listeners = (currentListeners = nextListeners);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i &lt; listeners.length; i++) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> listener = listeners[i];\n</div></li><li><div class=\"code-word\">            listener();\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> action;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// replaceReducer 可以更改当前的 reducer</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">function <span class=\"hljs-title\">replaceReducer</span><span class=\"hljs-params\">(nextReducer)</span> </span>{\n</div></li><li><div class=\"code-word\">        currentReducer = nextReducer;\n</div></li><li><div class=\"code-word\">        dispatch({ type: ActionTypes.REPLACE });\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> store;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 初始化 state，当派发一个 type 为 ActionTypes.INIT 的 action，每个 reducer 都会返回</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 它的初始值</span>\n</div></li><li><div class=\"code-word\">    dispatch({ type: ActionTypes.INIT });\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// observable 方法可以忽略，它在 redux 内部使用，开发者一般不会直接接触</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\">function <span class=\"hljs-title\">observable</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// observable 方法的实现</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 将定义的方法包裹在 store 对象里返回</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">      dispatch,\n</div></li><li><div class=\"code-word\">      subscribe,\n</div></li><li><div class=\"code-word\">      getState,\n</div></li><li><div class=\"code-word\">      replaceReducer,\n</div></li><li><div class=\"code-word\">      [$$observable]: observable\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1454\">\n                      通过阅读源码会发现，createStore\n                      从外面看只是一个简单的创建动作，但在内部却别有洞天，涵盖了所有\n                      Redux 主流程中核心方法的定义。\n                    </p>\n                    <p data-nodeid=\"1455\">\n                      接下来我将 createStore\n                      内部逻辑总结进一张大图中，这张图涵盖了每个核心方法的工作内容，它将帮助你快速把握\n                      createStore 的逻辑框架。\n                    </p>\n                    <p data-nodeid=\"1456\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/7E/BB/Ciqc1F_PVkCAST4AAAJfMvoaI4Q803.png\"\n                        alt=\"Drawing 15.png\"\n                        data-nodeid=\"1681\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1457\">\n                      在 createStore 导出的方法中，与 Redux\n                      主流程强相关的，同时也是我们平时使用中最常打交道的几个方法，分别是：\n                    </p>\n                    <ul data-nodeid=\"1458\">\n                      <li data-nodeid=\"1459\">\n                        <p data-nodeid=\"1460\">getState</p>\n                      </li>\n                      <li data-nodeid=\"1461\">\n                        <p data-nodeid=\"1462\">subscribe</p>\n                      </li>\n                      <li data-nodeid=\"1463\">\n                        <p data-nodeid=\"1464\">dispatch</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1465\">\n                      其中 getState\n                      的源码内容比较简单，我们在逐行分析的过程中已经对它有了充分的认识。而\n                      subscribe 和 dispatch 则分别代表了 Redux\n                      独有的“发布-订阅”模式以及主流程中最为关键的分发动作，在下一讲，我们会重点讲解。\n                    </p>\n                    <h3 data-nodeid=\"1466\">总结</h3>\n                    <p data-nodeid=\"1467\">\n                      在本讲，我们首先学习了 Redux\n                      的架构思想，梳理了“单向数据流”这一核心特征的来龙去脉，真正理解了\n                      Redux 定义中“可预测”这 3 个字背后的深意。\n                    </p>\n                    <p data-nodeid=\"1468\">\n                      随后，在复习 Redux\n                      关键要素与工作流程的基础上，我们尝试对其源码进行拆解，认识了\n                      Redux 源码的基本构成与主要模块，并选取了 createStore\n                      这个核心模块作为发力点，提取出了 Redux\n                      源码中值得我们格外深入的两个方法——subscribe 和 dispatch。\n                    </p>\n                    <p data-nodeid=\"1469\" class=\"\">\n                      那么 subscribe 和 dispatch\n                      中到底藏着什么样的玄机，值得我们继续深入学习呢？我们下一讲见分晓！\n                    </p>\n            "}