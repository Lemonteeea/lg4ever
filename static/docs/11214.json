{"title":"12 | 如何理解 AST 实现和编译原理？","context":"\n                    <p data-nodeid=\"27419\">\n                      经常留意前端开发技术的同学一定对 AST 技术不陌生。AST\n                      技术是现代化前端基建和工程化建设的基石：Babel、Webpack、ESLint、代码压缩工具等耳熟能详的工程化基建工具或流程，都离不开\n                      AST 技术；Vue、React 等经典前端框架，也离不开基于 AST\n                      技术的编译。\n                    </p>\n                    <p data-nodeid=\"27420\">\n                      目前社区上不乏 Babel 插件、Webpack\n                      插件等知识的讲解，但是涉及 AST\n                      的部分，往往都是使用现成工具转载模版代码。这一讲，我们就从\n                      AST 基础理念讲起，并实现一个简单的 AST 实战脚本。\n                    </p>\n                    <h3 data-nodeid=\"27421\">AST 基础知识</h3>\n                    <p data-nodeid=\"27422\">\n                      我们先对 AST 下一个定义，AST 是 Abstract Syntax Tree\n                      的缩写，表示抽象语法树：\n                    </p>\n                    <blockquote data-nodeid=\"27423\">\n                      <p data-nodeid=\"27424\">\n                        在计算机科学中，抽象语法树（Abstract Syntax\n                        Tree，AST），或简称语法树（Syntax\n                        Tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似\n                        if-condition-then\n                        这样的条件跳转语句，可以使用带有三个分支的节点来表示。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"27425\">\n                      AST\n                      的应用场景经常出现在源代码的编译过程中：一般语法分析器创建出\n                      AST，然后 AST 在语义分析阶段添加一些信息，甚至修改 AST\n                      内容，最终产出编译后代码。\n                    </p>\n                    <h4 data-nodeid=\"27426\">AST 初体验</h4>\n                    <p data-nodeid=\"27427\">\n                      了解了 AST 基本概念，我们对 AST\n                      进行一个“感官认知”。这里提供给你一个平台：<a\n                        href=\"https://astexplorer.net/\"\n                        data-nodeid=\"27534\"\n                        >AST explorer</a\n                      >，在这个平台中，可以实时看到 JavaScript 代码转换为 AST\n                      之后的产出结果。如下图所示：\n                    </p>\n                    <p data-nodeid=\"29395\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/06/ED/Cip5yGAGmb2ABDuIAAE1iKphCso409.png\"\n                        alt=\"Drawing 0.png\"\n                        data-nodeid=\"29399\"\n                      />\n                    </p>\n                    <div data-nodeid=\"29396\">\n                      <p style=\"text-align: center\">AST 在线分析结果图</p>\n                    </div>\n\n                    <p data-nodeid=\"27430\">\n                      可以看到，经过 AST 转换，我们的 JavaScript\n                      代码（左侧）变成了一种 ESTree\n                      规范的数据结构（右侧），这种数据结构就是 AST。\n                    </p>\n                    <p data-nodeid=\"30526\" class=\"\">\n                      这个平台实际使用了\n                      <a\n                        href=\"https://github.com/acornjs/acorn\"\n                        data-nodeid=\"30530\"\n                        >acorn</a\n                      >\n                      作为 AST 解析器。下面我们就来介绍一下\n                      acorn，本节内容我们将要实现的脚本，也会依赖 acorn 的能力。\n                    </p>\n\n                    <h4 data-nodeid=\"27432\">acorn 解析</h4>\n                    <p data-nodeid=\"27433\">\n                      实际上，社区上多项著名项目都依赖的 acorn 的能力（比如\n                      ESLint、Babel、Vue.js 等），acorn 的介绍为：\n                    </p>\n                    <blockquote data-nodeid=\"27434\">\n                      <p data-nodeid=\"27435\">\n                        A tiny, fast JavaScript parser, written completely in\n                        JavaScript.\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"27436\">\n                      由此可知，acorn 是一个完全使用 JavaScript\n                      实现的、小型且快速的 JavaScript\n                      解析器。基本用法非常简单，代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">let acorn = require(<span class=\"hljs-string\">'acorn'</span>)\n</div></li><li><div class=\"code-word\">let code = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">console.log(acorn.parse(code))\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"27438\">\n                      更多使用方式我们不再一一列举。你可以结合<a\n                        href=\"https://github.com/acornjs/acorn\"\n                        data-nodeid=\"27553\"\n                        >相关源码</a\n                      >进一步学习。\n                    </p>\n                    <p data-nodeid=\"27439\">\n                      我们将视线更多地聚焦 acorn\n                      的内部实现中。对所有语法解析器来说，实现流程上很简单，如下图所示：\n                    </p>\n                    <p data-nodeid=\"31651\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/06/EE/Cip5yGAGmc2AAm_DAADuYazKZ4U044.png\"\n                        alt=\"Lark20210119-163409.png\"\n                        data-nodeid=\"31655\"\n                      />\n                    </p>\n                    <div data-nodeid=\"31652\">\n                      <p style=\"text-align: center\">acorn 工作流程图</p>\n                    </div>\n\n                    <p data-nodeid=\"27442\">\n                      源代码经过词法分析，即分词得到 Token 序列，对 Token\n                      序列进行语法分析，得到最终 AST 结果。但 acorn\n                      稍有不同的是：<strong data-nodeid=\"27565\"\n                        >acorn\n                        将词法分析和语法分析交替进行，只需要扫描一遍代码即可得到最终\n                        AST 结果</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"27443\">\n                      acorn 的 Parser 类<a\n                        href=\"https://github.com/acornjs/acorn/blob/master/acorn/src/state.js\"\n                        data-nodeid=\"27569\"\n                        >源码</a\n                      >形如：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Parser</span> </span>{\n</div></li><li><div class=\"code-word\">  constructor(options, input, startPos) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  parse() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 判断所处 context</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">get <span class=\"hljs-title\">inFunction</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; <span class=\"hljs-number\">0</span> }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">get <span class=\"hljs-title\">inGenerator</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; <span class=\"hljs-number\">0</span> }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">get <span class=\"hljs-title\">inAsync</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; <span class=\"hljs-number\">0</span> }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">get <span class=\"hljs-title\">allowSuper</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.currentThisScope().flags &amp; SCOPE_SUPER) &gt; <span class=\"hljs-number\">0</span> }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">get <span class=\"hljs-title\">allowDirectSuper</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; <span class=\"hljs-number\">0</span> }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">get <span class=\"hljs-title\">treatFunctionsAsVar</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.treatFunctionsAsVarInScope(<span class=\"hljs-keyword\">this</span>.currentScope()) }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">get <span class=\"hljs-title\">inNonArrowFunction</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span>.currentThisScope().flags &amp; SCOPE_FUNCTION) &gt; <span class=\"hljs-number\">0</span> }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-title\">extend</span><span class=\"hljs-params\">(...plugins)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 解析入口</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-title\">parse</span><span class=\"hljs-params\">(input, options)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>(options, input).parse()\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-title\">parseExpressionAt</span><span class=\"hljs-params\">(input, pos, options)</span> </span>{\n</div></li><li><div class=\"code-word\">    let parser = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>(options, input, pos)\n</div></li><li><div class=\"code-word\">    parser.nextToken()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> parser.parseExpression()\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 分词入口</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-title\">tokenizer</span><span class=\"hljs-params\">(input, options)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>(options, input)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"27445\">我们稍做解释：</p>\n                    <ul data-nodeid=\"27446\">\n                      <li data-nodeid=\"27447\">\n                        <p data-nodeid=\"27448\">type 表示当前 Token 类型；</p>\n                      </li>\n                      <li data-nodeid=\"27449\">\n                        <p data-nodeid=\"27450\">\n                          pos 表示当前 Token 所在源代码中的位置；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"27451\">\n                        <p data-nodeid=\"27452\">\n                          startNode 方法返回当前 AST 节点；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"27453\">\n                        <p data-nodeid=\"27454\">\n                          nextToken 方法从源代码中读取下一个 Token；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"27455\">\n                        <p data-nodeid=\"27456\">\n                          parseTopLevel 方法实现递归向下组装 AST 树。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"27457\">\n                      这是 acorn 实现解析 AST\n                      的入口骨架，实际的分词环节主要解决以下问题。\n                    </p>\n                    <ol data-nodeid=\"27458\">\n                      <li data-nodeid=\"27459\">\n                        <p data-nodeid=\"27460\">明确需要分析哪些 Token 类型。</p>\n                      </li>\n                    </ol>\n                    <ul data-nodeid=\"27461\">\n                      <li data-nodeid=\"27462\">\n                        <p data-nodeid=\"27463\">\n                          关键字：import，function，return 等\n                        </p>\n                      </li>\n                      <li data-nodeid=\"27464\">\n                        <p data-nodeid=\"27465\">变量名称</p>\n                      </li>\n                      <li data-nodeid=\"27466\">\n                        <p data-nodeid=\"27467\">运算符号</p>\n                      </li>\n                      <li data-nodeid=\"27468\">\n                        <p data-nodeid=\"27469\">结束符号</p>\n                      </li>\n                    </ul>\n                    <ol start=\"2\" data-nodeid=\"27470\">\n                      <li data-nodeid=\"27471\">\n                        <p data-nodeid=\"27472\">\n                          状态机：简单来讲就是消费每一个源代码中的字符，对字符意义进行状态机判断。以“我们对于<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27584\"\n                            >/</code\n                          >的处理”为例，对于<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27586\"\n                            >3/10</code\n                          >的源代码，<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27588\"\n                            >/</code\n                          >就表示一个运算符号；对于<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27590\"\n                            >var re = /ab+c/</code\n                          >源代码来说，<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27592\"\n                            >/</code\n                          >就表示正则运算的起始字符了。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"27473\">\n                      在分词过程中，实现者往往使用一个 Context\n                      来表达一个上下文，实际上<strong data-nodeid=\"27603\"\n                        >Context 是一个栈数据结果</strong\n                      >（这一部分源码你可以点击<a\n                        href=\"https://github.com/acornjs/acorn/tree/master/acorn/src\"\n                        data-nodeid=\"27601\"\n                        >这里</a\n                      >阅读）。\n                    </p>\n                    <p data-nodeid=\"27474\">\n                      acorn 在语法解析阶段主要完成 AST\n                      的封装以及错误抛出。在这个过程中，需要你了解，一段源代码可以用：\n                    </p>\n                    <ul data-nodeid=\"27475\">\n                      <li data-nodeid=\"27476\">\n                        <p data-nodeid=\"27477\">Program——整个程序</p>\n                      </li>\n                      <li data-nodeid=\"27478\">\n                        <p data-nodeid=\"27479\">Statement——语句</p>\n                      </li>\n                      <li data-nodeid=\"27480\">\n                        <p data-nodeid=\"27481\">Expression——表达式</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"27482\">来描述。</p>\n                    <p data-nodeid=\"27483\">\n                      当然，<strong data-nodeid=\"27614\"\n                        >Program 包含了多段 Statement，Statement 又由多个\n                        Expression 或者 Statement 组成</strong\n                      >。这三种大元素，就构成了遵循 ESTree 规范的 AST。最终的\n                      AST\n                      产出，也是这三种元素的数据结构拼合。具体实现代码我们不再探究。\n                    </p>\n                    <p data-nodeid=\"27484\">\n                      下面我们通过 acorn 以及一个脚本，来实现非常简易的 Tree\n                      Shaking 能力。\n                    </p>\n                    <h3 data-nodeid=\"27485\">\n                      AST 实战演练——实现一个简易 Tree Shaking 脚本\n                    </h3>\n                    <p data-nodeid=\"27486\">\n                      上一讲我们介绍了 Tree Shaking\n                      技术的方方面面。下面，我们就基于本节内容的主题——AST，来实现一个简单的\n                      DCE（dead code elimination）。\n                    </p>\n                    <p data-nodeid=\"27487\">\n                      目标如下，实现一个 Node.js 脚本 treeShaking.js，执行命令：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">node treeShaking test.js\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"27489\">\n                      可以将<code data-backticks=\"1\" data-nodeid=\"27620\"\n                        >test.js</code\n                      >中的 dead code 消除。我们使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27622\"\n                        >test.js</code\n                      >测试代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(a, b)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> a + b\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">multiple</span><span class=\"hljs-params\">(a, b)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> a * b\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> firstOp = <span class=\"hljs-number\">9</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">var</span> secondOp = <span class=\"hljs-number\">10</span>\n</div></li><li><div class=\"code-word\">add(firstOp, secondOp)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"27491\">\n                      理论上讲，上述代码中的<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27625\"\n                        >multiple</code\n                      >方法可以被“摇掉”。\n                    </p>\n                    <p data-nodeid=\"27492\">\n                      我们进入实现环节，首先请看下图，了解整体架构流程：\n                    </p>\n                    <p data-nodeid=\"32771\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8F/0E/CgqCHmAGmeCARZ9QAAKowCLHfGk667.png\"\n                        alt=\"Lark20210119-163411.png\"\n                        data-nodeid=\"32775\"\n                      />\n                    </p>\n                    <div data-nodeid=\"32772\">\n                      <p style=\"text-align: center\">\n                        基于 AST 的 tree-shaking 简易实现\n                      </p>\n                    </div>\n\n                    <p data-nodeid=\"27495\">\n                      设计 JSEmitter 类，用于根据 AST 产出 JavaScript\n                      代码（js-emitter.js 文件内容）：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JSEmitter</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 访问变量声明，以下都是工具方法</span>\n</div></li><li><div class=\"code-word\">    visitVariableDeclaration(node) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        str += node.kind + <span class=\"hljs-string\">' '</span>\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNodes(node.declarations)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str + <span class=\"hljs-string\">'\\n'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitVariableDeclarator(node, kind) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        str += kind ? kind + <span class=\"hljs-string\">' '</span> : str\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNode(node.id)\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-string\">'='</span>\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNode(node.init)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str + <span class=\"hljs-string\">';'</span> + <span class=\"hljs-string\">'\\n'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitIdentifier(node) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> node.name\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitLiteral(node) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> node.raw\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitBinaryExpression(node) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNode(node.left)\n</div></li><li><div class=\"code-word\">        str += node.operator\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNode(node.right)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str + <span class=\"hljs-string\">'\\n'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitFunctionDeclaration(node) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">'function '</span>\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNode(node.id)\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-string\">'('</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (let param = <span class=\"hljs-number\">0</span>; param &lt; node.params.length; param++) {\n</div></li><li><div class=\"code-word\">            str += <span class=\"hljs-keyword\">this</span>.visitNode(node.params[param])\n</div></li><li><div class=\"code-word\">            str += ((node.params[param] == undefined) ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">','</span>)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        str = str.slice(<span class=\"hljs-number\">0</span>, str.length - <span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-string\">'){'</span>\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNode(node.body)\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-string\">'}'</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str + <span class=\"hljs-string\">'\\n'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitBlockStatement(node) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNodes(node.body)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitCallExpression(node) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> callee = <span class=\"hljs-keyword\">this</span>.visitIdentifier(node.callee)\n</div></li><li><div class=\"code-word\">        str += callee + <span class=\"hljs-string\">'('</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> arg of node.arguments) {\n</div></li><li><div class=\"code-word\">            str += <span class=\"hljs-keyword\">this</span>.visitNode(arg) + <span class=\"hljs-string\">','</span>\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        str = str.slice(<span class=\"hljs-number\">0</span>, str.length - <span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-string\">');'</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str + <span class=\"hljs-string\">'\\n'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitReturnStatement(node) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">'return '</span>;\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNode(node.argument)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str + <span class=\"hljs-string\">'\\n'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitExpressionStatement(node) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.visitNode(node.expression)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    visitNodes(nodes) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> node of nodes) {\n</div></li><li><div class=\"code-word\">            str += <span class=\"hljs-keyword\">this</span>.visitNode(node)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 根据类型，执行相关处理函数</span>\n</div></li><li><div class=\"code-word\">    visitNode(node) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">switch</span> (node.type) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'VariableDeclaration'</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitVariableDeclaration(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'VariableDeclarator'</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitVariableDeclarator(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'Literal'</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitLiteral(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'Identifier'</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitIdentifier(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'BinaryExpression'</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitBinaryExpression(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'FunctionDeclaration'</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitFunctionDeclaration(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'BlockStatement'</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitBlockStatement(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"CallExpression\"</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitCallExpression(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"ReturnStatement\"</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitReturnStatement(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"ExpressionStatement\"</span>:\n</div></li><li><div class=\"code-word\">                str += <span class=\"hljs-keyword\">this</span>.visitExpressionStatement(node)\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 入口</span>\n</div></li><li><div class=\"code-word\">    run(body) {\n</div></li><li><div class=\"code-word\">        let str = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">        str += <span class=\"hljs-keyword\">this</span>.visitNodes(body)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> str\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = JSEmitter\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"27497\">\n                      我们来具体分析一下，JSEmitter 类中创建了很多 visitXXX\n                      方法，他们最终都会产出 JavaScript 代码。我们继续结合<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27634\"\n                        >treeShaking.js</code\n                      >的实现来理解：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> acorn = require(<span class=\"hljs-string\">\"acorn\"</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> l = console.log\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> JSEmitter = require(<span class=\"hljs-string\">'./js-emitter'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> fs = require(<span class=\"hljs-string\">'fs'</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 获取命令行参数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> args = process.argv[<span class=\"hljs-number\">2</span>]\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> buffer = fs.readFileSync(args).toString()\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> body = acorn.parse(buffer).body\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> jsEmitter = <span class=\"hljs-keyword\">new</span> JSEmitter()\n</div></li><li><div class=\"code-word\">let decls = <span class=\"hljs-keyword\">new</span> Map()\n</div></li><li><div class=\"code-word\">let calledDecls = []\n</div></li><li><div class=\"code-word\">let code = []\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 遍历处理</span>\n</div></li><li><div class=\"code-word\">body.forEach(function(node) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (node.type == <span class=\"hljs-string\">\"FunctionDeclaration\"</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> code = jsEmitter.run([node])\n</div></li><li><div class=\"code-word\">        decls.set(jsEmitter.visitNode(node.id), code)\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (node.type == <span class=\"hljs-string\">\"ExpressionStatement\"</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (node.expression.type == <span class=\"hljs-string\">\"CallExpression\"</span>) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> callNode = node.expression\n</div></li><li><div class=\"code-word\">            calledDecls.push(jsEmitter.visitIdentifier(callNode.callee))\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> args = callNode.<span class=\"hljs-function\">arguments\n</span></div></li><li><div class=\"code-word\">            <span class=\"hljs-title\">for</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> arg of args)</span> {\n</div></li><li><div class=\"code-word\">                <span class=\"hljs-keyword\">if</span> (arg.type == <span class=\"hljs-string\">\"Identifier\"</span>) {\n</div></li><li><div class=\"code-word\">                    calledDecls.push(jsEmitter.visitNode(arg))\n</div></li><li><div class=\"code-word\">                }\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (node.type == <span class=\"hljs-string\">\"VariableDeclaration\"</span>) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> kind = node.<span class=\"hljs-function\">kind\n</span></div></li><li><div class=\"code-word\">        <span class=\"hljs-title\">for</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> decl of node.declarations)</span> {\n</div></li><li><div class=\"code-word\">            decls.set(jsEmitter.visitNode(decl.id), jsEmitter.visitVariableDeclarator(decl, kind))\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (node.type == <span class=\"hljs-string\">\"Identifier\"</span>) {\n</div></li><li><div class=\"code-word\">        calledDecls.push(node.name)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    code.push(jsEmitter.run([node]))\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 生成 code</span>\n</div></li><li><div class=\"code-word\">code = calledDecls.map(c =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> decls.get(c)\n</div></li><li><div class=\"code-word\">}).concat([code]).join(<span class=\"hljs-string\">''</span>)\n</div></li><li><div class=\"code-word\">fs.writeFileSync(<span class=\"hljs-string\">'test.shaked.js'</span>, code)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"27499\">\n                      对于上面代码分析，首先我们通过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27637\"\n                        >process.argv</code\n                      >获取到目标文件，对于目标文件通过<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27639\"\n                        >fs.readFileSync()</code\n                      >方法读出字符串形式的内容<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27641\"\n                        >buffer</code\n                      >，对于这个<code data-backticks=\"1\" data-nodeid=\"27643\"\n                        >buffer</code\n                      >变量，我们使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27645\"\n                        >acorn.parse</code\n                      >进行解析，并对产出内容进行遍历。\n                    </p>\n                    <p data-nodeid=\"27500\">\n                      在遍历过程中，<strong data-nodeid=\"27652\"\n                        >对于不同的节点类型，调用 JS Emitter\n                        实例不同的处理方法</strong\n                      >。在整个过程中，我们维护了：\n                    </p>\n                    <ul data-nodeid=\"27501\">\n                      <li data-nodeid=\"27502\">\n                        <p data-nodeid=\"27503\">decls——Map 类型</p>\n                      </li>\n                      <li data-nodeid=\"27504\">\n                        <p data-nodeid=\"27505\">calledDecls——数组类型</p>\n                      </li>\n                      <li data-nodeid=\"27506\">\n                        <p data-nodeid=\"27507\">code——数组类型</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"27508\">\n                      三个关键变量。<code data-backticks=\"1\" data-nodeid=\"27657\"\n                        >decls</code\n                      >存储所有的函数或变量声明类型节点，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27659\"\n                        >calledDecls</code\n                      >则存储了代码中真正使用到的数或变量声明，<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27661\"\n                        >code</code\n                      >存储了其他所有没有被节点类型匹配的 AST 部分。\n                    </p>\n                    <p data-nodeid=\"27509\">下面我们来分析具体的遍历过程。</p>\n                    <ul data-nodeid=\"27510\">\n                      <li data-nodeid=\"27511\">\n                        <p data-nodeid=\"27512\">\n                          在遍历过程中，我们<strong data-nodeid=\"27670\"\n                            >对所有函数和变量的声明，都维护到</strong\n                          ><code data-backticks=\"1\" data-nodeid=\"27668\"\n                            >decls</code\n                          >中。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"27513\">\n                        <p data-nodeid=\"27514\">\n                          接着，我们<strong data-nodeid=\"27682\"\n                            >对所有的 CallExpression 和 IDentifier\n                            进行检测</strong\n                          >。因为 CallExpression 代表了一次函数调用，因此在该 if\n                          条件分支内，将相关函数节点调用情况推入到<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27676\"\n                            >calledDecls</code\n                          >数组中，同时我们对于该函数的参数变量也推入到<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27678\"\n                            >calledDecls</code\n                          >数组。因为 IDentifier\n                          代表了一个变量的取值，我们也推入到<code\n                            data-backticks=\"1\"\n                            data-nodeid=\"27680\"\n                            >calledDecls</code\n                          >数组。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"27515\">\n                      经过整个 AST 遍历，我们就可以只遍历<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27684\"\n                        >calledDecls</code\n                      >数组，并从<code data-backticks=\"1\" data-nodeid=\"27686\"\n                        >decls</code\n                      >变量中获取使用到的变量和函数声明，最终使用<code\n                        data-backticks=\"1\"\n                        data-nodeid=\"27688\"\n                        >concat</code\n                      >方法合并带入<code data-backticks=\"1\" data-nodeid=\"27690\"\n                        >code</code\n                      >变量中，使用<code data-backticks=\"1\" data-nodeid=\"27692\"\n                        >join</code\n                      >方法转化为字符串类型。\n                    </p>\n                    <p data-nodeid=\"27516\">\n                      至此，我们的简易版 Tree Shaking\n                      实现就完成了，建议你结合实际代码，多调试，相信会有更多收获。\n                    </p>\n                    <h3 data-nodeid=\"27517\">总结</h3>\n                    <p data-nodeid=\"27518\">\n                      这一讲，我们聚焦了 AST 这一热点话题。说 AST\n                      是热点，是因为当前前端基础建设、工程化建设中越来越离不开\n                      AST 技术的支持，AST\n                      在前端中扮演的重要角色也越来越广为人知。\n                    </p>\n                    <p data-nodeid=\"27519\">\n                      但事实上，AST\n                      是计算机领域中一个历经多年的基础概念，每一名开发者也都应该循序渐进地了解\n                      AST 相关技术以及编译原理。\n                    </p>\n                    <p data-nodeid=\"33332\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8F/0F/CgqCHmAGmfaAD2geAAY6xJPW71s609.png\"\n                        alt=\"Lark20210119-163405.png\"\n                        data-nodeid=\"33335\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"27521\">\n                      这一讲，我们先从基本概念入手，然后借助了 acorn\n                      的能力，动手实现了一个真实的 AST 落地场景——实现简易 Tree\n                      Shaking，正好又和上一章节内容相扣。由此可见，前端基建和工程化是一张网，网上的每一个技术点，都能由点及面，绘制出一张前端知识图谱。\n                    </p>\n            "}