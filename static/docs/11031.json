{"title":"第28讲：你都了解过哪些编程方式？","context":"\n                    <p data-nodeid=\"315946\">\n                      程序代码虽然在机器上运行，但终究是由人来编写和维护的，因此代码的可读性、可维护性在软件开发中尤为重要。所以我们在编写代码的时候通常会遵循一些编码规范或风格，比如\n                      Google 提出了最著名的关于主流语言的<a\n                        href=\"https://zh-google-styleguide.readthedocs.io/en/latest/\"\n                        data-nodeid=\"316009\"\n                        >风格指南</a\n                      >，但这些都比较微观和具体，如果宏观且抽象地来看，编码风格可以上升为<strong\n                        data-nodeid=\"316015\"\n                        >编程范式</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"315947\">\n                      编程范式（Programming\n                      Paradigm）也称“编程泛型”或“程序设计法”，是对代码编写方式的一种抽象，体现出了开发者对程序执行的看法。例如，在面向对象编程中，开发者认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。常见的编程范式有\n                      2 种：命令式编程和声明式编程。\n                    </p>\n                    <h3 data-nodeid=\"315948\">\n                      命令式编程（Imperative Programming）\n                    </h3>\n                    <p data-nodeid=\"315949\">\n                      命令式编程是一种古老的编程范式，它的出现与冯·诺依曼架构（现代计算机的基础，一种将程序指令存储器和数据存储器合并在一起的电脑设计结构）有紧密关系。冯·诺依曼架构的基本工作原理是通过赋值语句来更改程序状态，然后根据这些状态来逐步执行任务。而命令式编程方式就是对这个工作过程的抽象，主要关注点是如何通过具体步骤得到计算结果。\n                    </p>\n                    <p data-nodeid=\"315950\">\n                      命令式编程比较重要的子类有 2 个：面向过程、面向对象。\n                    </p>\n                    <h4 data-nodeid=\"315951\">\n                      面向过程（Procedural Programming）\n                    </h4>\n                    <p data-nodeid=\"315952\">\n                      面向过程是一种以过程为中心的编程思想，在编程过程中分析出解决问题所需要的步骤，然后再按照执行过程编写代码。\n                      这种编程范式比较具象，很符合人的直觉思维，我们在入门学习\n                      JavaScript\n                      的时候就已经学会了。比如，下面的代码就是一个面向过程的例子，calc()\n                      函数接收两个参数，第一个是待遍历的数组\n                      arr，第二个是计算类型 type：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">calc</span>(<span class=\"hljs-params\">arr, type</span>) </span>{\n</div></li><li><div class=\"code-word\">&nbsp; <span class=\"hljs-keyword\">switch</span>(type) {\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'add'</span>:\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> arr.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, cur</span>) =&gt;</span> acc + cur, <span class=\"hljs-number\">0</span>)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'multiple'</span>:\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> arr.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, cur</span>) =&gt;</span> acc * cur, <span class=\"hljs-number\">1</span>)\n</div></li><li><div class=\"code-word\">&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">&nbsp; }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"315954\">\n                      这种编程范式流程明确，也不需要像面向对象那样生成实例，占用额外的存储空间，但它有个问题，就是代码的可扩展性不够。比如现在要加一个操作类型，那么又要修改\n                      calc() 函数，添加一个逻辑分支。\n                    </p>\n                    <h4 data-nodeid=\"315955\">\n                      面向对象（Object-oriented Programming）\n                    </h4>\n                    <p data-nodeid=\"315956\">\n                      面向过程的编程范式要求按照流程步骤逐个地分析每个问题。很显然，并不是所有问题都适合这种过程化的思维方式，这也就导致了其他编程范式的出现，比如面向对象。\n                    </p>\n                    <p data-nodeid=\"315957\">\n                      面向对象的核心是对象，它不是把问题抽象成流程步骤，而是抽象成对象，对象是程序代码中的基本单位，对应代码中的类或类的实例，对象内部封装了数据和方法。这种编程范式主要包含\n                      3 个特性：封装、继承、多态。\n                    </p>\n                    <h5 data-nodeid=\"318457\" class=\"\">\n                      1. 封装（Encapsulation）\n                    </h5>\n\n                    <p data-nodeid=\"315959\">\n                      封装是通过限制只有特定类的对象可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。简单说，就是给类的属性设定“权限”，将类的属性分为\n                      3\n                      类：公有成员、私有成员和受保护成员。公有成员可以由外部调用，私有成员只能在类内部访问，受保护的成员也只能在类内部或由子类访问。\n                    </p>\n                    <p data-nodeid=\"315960\">\n                      下面两段代码分别是使用 JavaScript （ES5）和 TypeScript\n                      实现封装特性的例子。在 JavaScript\n                      中需要通过函数作用域来实现私有变量，在\n                      TypeScript中则和面向对象语言 Java\n                      的写法比较相近，通过关键字 private 和 public 声明即可。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// ES5 写法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Animal</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">this</span>.setName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a</span>) </span>{\n</div></li><li><div class=\"code-word\">    name = a\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">this</span>.getName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> name\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// TypeScript 写法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Animal {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">private</span> name:<span class=\"hljs-built_in\">string</span>;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> setName(name:<span class=\"hljs-built_in\">string</span>):<span class=\"hljs-built_in\">void</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-built_in\">this</span>.name = name\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> getName():<span class=\"hljs-built_in\">string</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.name\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h5 data-nodeid=\"320383\" class=\"\">\n                      2. 继承（Inheritance）\n                    </h5>\n\n                    <p data-nodeid=\"315963\">\n                      继承这个概念和生物学中的遗传有些类似，在创建子类的时候，会默认获得父类的一些非私有属性和方法。\n                    </p>\n                    <p data-nodeid=\"315964\">\n                      下面两段代码分别是使用 JavaScript （ES5）和 TypeScript\n                      实现继承特性的例子。\n                    </p>\n                    <p data-nodeid=\"315965\">\n                      在 JavaScript 中需要通过原型对象 prototype 来实现继承，在\n                      TypeScript中则和面向对象语言 Java 的写法比较相近，通过\n                      extends 来继承父类。虽然在 JavaScript/TypeScript\n                      都能实现基础的继承，但对于继承自多个父类的情况，实现起来会比较复杂。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"typescript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// ES5 写法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Dog</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">this</span>.bark = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'wang wang wang!!!'</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">Dog.prototype = <span class=\"hljs-keyword\">new</span> Animal()\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// TypeScript 写法</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">class</span> Dog <span class=\"hljs-keyword\">extends</span> Animal {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">public</span> bark():<span class=\"hljs-built_in\">string</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'wang wang wang!!!'</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h5 data-nodeid=\"323491\" class=\"\">\n                      3. 多态（Polymorphism）\n                    </h5>\n\n                    <p data-nodeid=\"315968\">\n                      多态是指由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应。JavaScript/TypeScript\n                      对多态的支持是不友好的，只能在函数内部通过判断参数类型来实现。\n                    </p>\n                    <p data-nodeid=\"315969\">下面是一个简单的例子：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Cat</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-built_in\">this</span>.bark = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">sound</span>) </span>{\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-literal\">undefined</span> !== sound &amp;&amp; <span class=\"hljs-literal\">null</span> !== sound) {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> sound\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'...'</span>\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"315971\">\n                      声明式编程（Declarative Programming）\n                    </h3>\n                    <p data-nodeid=\"315972\">\n                      在计算机科学中，声明式编程是一种构建程序的样式，该表达式表示计算逻辑而无须谈论其控制流程。它通常将程序视为某种逻辑理论，可以简化编写并行程序的过程。重点是需要完成的工作，而不是应该如何完成。它只是声明我们想要的结果，而并不关注这个结果如何产生，这是命令式（如何做）和声明式（做什么）编程范式之间的唯一区别。\n                    </p>\n                    <p data-nodeid=\"315973\">\n                      声明式编程也有一些子类，常见的包括：逻辑式编程、数据驱动编程和函数式编程。\n                    </p>\n                    <h4 data-nodeid=\"315974\">\n                      逻辑式编程（Logic Programming）\n                    </h4>\n                    <p data-nodeid=\"315975\">\n                      逻辑式编程通过设置答案须符合的规则来解决问题，而非设置步骤来解决问题。\n                    </p>\n                    <p data-nodeid=\"315976\">\n                      这种风格很符合数学家和哲学家分析问题的方式，当我们需要解答一个新的问题时，先提出一个新的假设，然后再证明它跟现在的理论无冲突。逻辑提供了一个证明问题是真还是假的方法，创建证明的方法是人所皆知的，故逻辑是解答问题的可靠方法。逻辑式编程系统则自动化了这个程序，人工智能在逻辑式编程的发展中发挥了重要的影响。\n                    </p>\n                    <p data-nodeid=\"315977\">\n                      逻辑式编程在 Web 开发中并不常见，<a\n                        href=\"https://www.ruanyifeng.com/blog/2019/01/prolog.html\"\n                        data-nodeid=\"316066\"\n                        >有兴趣的同学可以查阅阮一峰老师介绍逻辑编程语言 Prolog\n                        的文章</a\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"315978\">\n                      数据驱动编程（Data-driven Programming）\n                    </h4>\n                    <p data-nodeid=\"315979\">\n                      这种编程方法基于数​​据，程序语句由数据定义而非执行步骤。\n                    </p>\n                    <p data-nodeid=\"315980\">\n                      数据库程序是业务信息系统的核心，并提供文件创建、数据输入、更新、查询和报告功能。有几种主要针对数据库应用程序开发的编程语言，比如\n                      SQL，它应用于结构化数据流，以进行过滤、转换、聚合（如计算统计信息）或调用其他程序。\n                    </p>\n                    <h4 data-nodeid=\"315981\">\n                      函数式编程（Functional Programming）\n                    </h4>\n                    <p data-nodeid=\"315982\">\n                      函数式编程范式来源于数学而非编程语言，它的关键原理是通过执行一系列的数学函数来得到结果。核心依赖是用于某些特定计算的功能，而非数据结构，也就是说，数据与函数是松散耦合的，甚至严格说，数据应该是不可见的，因为它隐藏在函数的实现内部。\n                    </p>\n                    <p data-nodeid=\"315983\">它主要有下面几个核心概念。</p>\n                    <h5 data-nodeid=\"325223\" class=\"\">1. 纯函数</h5>\n\n                    <p data-nodeid=\"315985\">\n                      若一个函数符合幂等性且无副作用那么就可以称为<strong\n                        data-nodeid=\"316085\"\n                        >纯函数</strong\n                      >。幂等性是指在相同的输入值时，需产生相同的输出，与函数的输出和输入值以外的其他隐藏信息或状态无关。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 非幂等</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rand</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.random()\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 幂等</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">zero</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"315987\">\n                      副作用是指除了返回函数值之外，还对调用函数产生附加的影响。例如，修改全局变量（函数外的变量）、修改参数或改变外部存储。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"javascript\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 无副作用</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">a, b</span>)</span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> a + b\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 有副作用</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setAddition</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n</div></li><li><div class=\"code-word\">  localstorage.setItem(<span class=\"hljs-string\">'sum'</span>, a + b)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"315989\">\n                      从上面的例子我们还可以看出纯函数的输出可以不用和所有的输入值有关，甚至可以与所有的输入值都无关。\n                    </p>\n                    <p data-nodeid=\"315990\">\n                      纯函数会带来很多优点。首先它是无状态的，这也就意味着函数内部不需要额外的存储空间来保存数据；其次具有高度的可测试性，在前端框架中体现比较明显，之前用\n                      jQuery\n                      这类库来开发项目时，代码测试非常困难，因为很多函数是不纯的，内部可能涉及\n                      DOM 操作、AJAX 请求、浏览器存储等各种副作用操作。\n                    </p>\n                    <p data-nodeid=\"315991\">\n                      纯函数的使用也比较广泛，JavaScript 一些原生函数，例如\n                      JSON.stringify() 就是纯函数，React\n                      中也有与之对应的函数式组件。\n                    </p>\n                    <h5 data-nodeid=\"326895\" class=\"\">2. 高阶函数</h5>\n\n                    <p data-nodeid=\"315993\">\n                      高阶函数是指接收一个函数作为参数，然后返回另一个函数的函数。它体现的是一种高级的抽象思维，使用场景也比较多，例如\n                      TypeScript 提供的装饰器功能来扩展函数，以及 React\n                      中使用高阶组件来扩展组件行为。\n                    </p>\n                    <h5 data-nodeid=\"328507\" class=\"\">3. 柯里化</h5>\n\n                    <p data-nodeid=\"315995\">\n                      柯里化可以翻译成卡瑞化或加里化，是指把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数。这种处理函数的方式由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名。\n                    </p>\n                    <p data-nodeid=\"315996\">\n                      简单来说，就是在一个函数中预先填充几个参数，这个函数返回另一个函数，这个返回的新函数将其参数和预先填充的参数进行合并，再执行函数逻辑。\n                    </p>\n                    <p data-nodeid=\"315997\">\n                      具体例子在“<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=180#/detail/pc?id=3179\"\n                        data-nodeid=\"316108\"\n                        >第 08 讲：为什么说函数是 JavaScript 的一等公民？</a\n                      >”中已经提到了，这里就不再重复举例了。\n                    </p>\n                    <h3 data-nodeid=\"315998\">总结</h3>\n                    <p data-nodeid=\"315999\">\n                      编程范式指的是编程风格，使用合理的编程范式能提升代码的可维护性。\n                    </p>\n                    <p data-nodeid=\"316000\">\n                      编程范式可分为声明式和命令式。声明式更关注结果而非具体实现，在其子类中，前端工程师最需要关注的是函数式编程及其重要概念：纯函数、高阶函数、柯里化，这种编程方式和\n                      JavaScript\n                      最为贴合。命令式编程更关注具体实现，比较常用的有面向过程和面向对象，其中面向对象有\n                      3 个重要特性：封装、继承、多态。\n                    </p>\n                    <p data-nodeid=\"316001\">\n                      大家平常在编写代码时应该多思考，通过合理地使用各种编程范式来提升代码质量。\n                    </p>\n                    <p data-nodeid=\"316460\">\n                      最后布置一道思考题：你还用过哪些编程范式？\n                    </p>\n            "}