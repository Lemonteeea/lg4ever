{"title":"第03讲：3 个使用场景助你用好 DOM 事件","context":"\n                    <p data-nodeid=\"2847\" class=\"\">\n                      这一课时我们将一起探究 DOM 事件。\n                    </p>\n                    <p data-nodeid=\"2848\">\n                      DOM\n                      事件数量非常多，即使分类也有十多种，比如键盘事件、鼠标事件、表单事件等，而且不同事件对象属性也有差异，这带来了一定的学习难度。\n                    </p>\n                    <p data-nodeid=\"2849\">\n                      但页面要与用户交互，接收用户输入，就离不开监听元素事件，所以，DOM\n                      事件是前端工程师必须掌握的重要内容，同时也是 DOM\n                      的重要组成部分。\n                    </p>\n                    <p data-nodeid=\"2850\">\n                      下面我们就从防抖、节流、代理 3 个场景出发，详细了解 DOM\n                      事件。\n                    </p>\n                    <h4 data-nodeid=\"2851\">防抖</h4>\n                    <p data-nodeid=\"2852\">\n                      试想这样的一个场景，有一个搜索输入框，为了提升用户体验，希望在用户输入后可以立即展现搜索结果，而不是每次输入完后还要点击搜索按钮。最基本的实现方式应该很容易想到，那就是绑定\n                      input 元素的键盘事件，然后在监听函数中发送 AJAX\n                      请求。伪代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ipt = document.querySelector(<span class=\"hljs-string\">'input'</span>)\n</div></li><li><div class=\"code-word\">ipt.addEventListener(<span class=\"hljs-string\">'input'</span>, e =&gt; {\n</div></li><li><div class=\"code-word\">  search(e.target.value).then(resp =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  }, e =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2854\">\n                      但其实这样的写法很容易造成性能问题。比如当用户在搜索“lagou”这个词的时候，每一次输入都会触发搜索：\n                    </p>\n                    <ol data-nodeid=\"2855\">\n                      <li data-nodeid=\"2856\">\n                        <p data-nodeid=\"2857\">搜索“l”</p>\n                      </li>\n                      <li data-nodeid=\"2858\">\n                        <p data-nodeid=\"2859\">搜索“la”</p>\n                      </li>\n                      <li data-nodeid=\"2860\">\n                        <p data-nodeid=\"2861\">搜索“lag”</p>\n                      </li>\n                      <li data-nodeid=\"2862\">\n                        <p data-nodeid=\"2863\">搜索“lago”</p>\n                      </li>\n                      <li data-nodeid=\"2864\">\n                        <p data-nodeid=\"2865\">搜索“lagou”</p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"2866\">\n                      而实际上，只有最后一次搜索结果是用户想要的，前面进行了 4\n                      次无效查询，浪费了网络带宽和服务器资源。\n                    </p>\n                    <p data-nodeid=\"2867\">\n                      所以对于这类连续触发的事件，需要添加一个**“防抖”功能**，为函数的执行设置一个合理的时间间隔，避免事件在时间间隔内频繁触发，同时又保证用户输入后能即时看到搜索结果。\n                    </p>\n                    <p data-nodeid=\"2868\">\n                      要实现这样一个功能我们很容易想到使用 setTimeout()\n                      函数来让函数延迟执行。就像下面的伪代码，当每次调用函数时，先判断\n                      timeout\n                      实例是否存在，如果存在则销毁，然后创建一个新的定时器。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 代码1</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ipt = document.querySelector(<span class=\"hljs-string\">'input'</span>)\n</div></li><li><div class=\"code-word\">let timeout = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">ipt.addEventListener(<span class=\"hljs-string\">'input'</span>, e =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span>(timeout) {\n</div></li><li><div class=\"code-word\">    clearTimeout(timeout)\n</div></li><li><div class=\"code-word\">    timeout = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  timeout = setTimeout(() =&gt; {\n</div></li><li><div class=\"code-word\">    search(e.target.value).then(resp =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">    }, e =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }, <span class=\"hljs-number\">500</span>)\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2870\">\n                      问题确实是解决了，但这并不是最优答案，或者说我们需对这个防抖操作进行一些“优化”。\n                    </p>\n                    <p data-nodeid=\"2871\">\n                      试想一下，如果另一个搜索框也需要添加防抖，是不是也要把\n                      timeout\n                      相关的代码再编写一次？而其实这个操作是完全可以抽取成<strong\n                        data-nodeid=\"2947\"\n                        >公共函数</strong\n                      >的。\n                    </p>\n                    <p data-nodeid=\"2872\">\n                      在抽取成公共函数的同时，还需要考虑更复杂的情况：\n                    </p>\n                    <ul data-nodeid=\"2873\">\n                      <li data-nodeid=\"2874\">\n                        <p data-nodeid=\"2875\">参数和返回值如何传递？</p>\n                      </li>\n                      <li data-nodeid=\"2876\">\n                        <p data-nodeid=\"2877\">\n                          防抖化之后的函数是否可以立即执行？\n                        </p>\n                      </li>\n                      <li data-nodeid=\"2878\">\n                        <p data-nodeid=\"2879\">防抖化的函数是否可以手动取消？</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"2880\">\n                      具体代码如下所示，首先将原函数作为参数传入 debounce()\n                      函数中，同时指定延迟等待时间，返回一个新的函数，这个函数包含\n                      cancel 属性，用来取消原函数执行。flush\n                      属性用来立即调用原函数，同时将原函数的执行结果以 Promise\n                      的形式返回。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 代码2</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> debounce = (func, wait = <span class=\"hljs-number\">0</span>) =&gt; {\n</div></li><li><div class=\"code-word\">  let timeout = <span class=\"hljs-function\"><span class=\"hljs-keyword\">null</span>\n</span></div></li><li><div class=\"code-word\">  let args\n</div></li><li><div class=\"code-word\">  function <span class=\"hljs-title\">debounced</span><span class=\"hljs-params\">(...arg)</span> {\n</div></li><li><div class=\"code-word\">    args = <span class=\"hljs-function\">arg\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-title\">if</span><span class=\"hljs-params\">(timeout)</span> {\n</div></li><li><div class=\"code-word\">      clearTimeout(timeout)\n</div></li><li><div class=\"code-word\">      timeout = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 以Promise的形式返回函数执行结果</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Promise((res, rej) =&gt; {\n</div></li><li><div class=\"code-word\">      timeout = setTimeout(async () =&gt; {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">const</span> result = await func.apply(<span class=\"hljs-keyword\">this</span>, args)\n</div></li><li><div class=\"code-word\">          res(result)\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span>(e) {\n</div></li><li><div class=\"code-word\">          rej(e)\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }, wait)\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 允许取消</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">function <span class=\"hljs-title\">cancel</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    clearTimeout(timeout)\n</div></li><li><div class=\"code-word\">    timeout = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 允许立即执行</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">function <span class=\"hljs-title\">flush</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    cancel()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> func.apply(<span class=\"hljs-keyword\">this</span>, args)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  debounced.cancel = cancel\n</div></li><li><div class=\"code-word\">  debounced.flush = flush\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> debounced\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 防抖处理之后的事件绑定</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ipt = document.querySelector(<span class=\"hljs-string\">'input'</span>)\n</div></li><li><div class=\"code-word\">ipt.addEventListener(<span class=\"hljs-string\">'input'</span>, debounce(e =&gt; {\n</div></li><li><div class=\"code-word\">  search(e.target.value).then(resp =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  }, e =&gt; {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">  })\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-number\">500</span>))\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"2882\">\n                      我们在写代码解决当前问题的时候，最初只能写出像代码 1\n                      那样满足需求的代码。但要成为高级工程师，就一定要将问题再深想一层，比如代码如何抽象成公共函数，才能得到较为完善的代码\n                      2，从而自身得到成长。\n                    </p>\n                    <p data-nodeid=\"2883\">\n                      关于防抖函数还有功能更丰富的版本，比如\n                      <a\n                        href=\"https://github.com/lodash/lodash\"\n                        data-nodeid=\"2957\"\n                        >lodash</a\n                      >\n                      的\n                      <a\n                        href=\"https://github.com/lodash/lodash/blob/master/debounce.js\"\n                        data-nodeid=\"2961\"\n                        >debounce</a\n                      >() 函数，有兴趣的话可以到 GitHub 上查阅资料。\n                    </p>\n                    <h4 data-nodeid=\"2884\">节流</h4>\n                    <p data-nodeid=\"2885\">\n                      现在来考虑另外一个场景，一个左右两列布局的查看文章页面，左侧为文章大纲结构，右侧为文章内容。现在需要添加一个功能，就是当用户滚动阅读右侧文章内容时，左侧大纲相对应部分高亮显示，提示用户当前阅读位置。\n                    </p>\n                    <p data-nodeid=\"2886\">\n                      这个功能的实现思路比较简单，滚动前先记录大纲中各个章节的垂直距离，然后监听\n                      scroll\n                      事件的滚动距离，根据距离的比较来判断需要高亮的章节。伪代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 监听scroll事件</span>\n</div></li><li><div class=\"code-word\">wrap.addEventListener(<span class=\"hljs-string\">'scroll'</span>, e =&gt; {\n</div></li><li><div class=\"code-word\">  let highlightId = <span class=\"hljs-string\">''</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 遍历大纲章节位置，与滚动距离比较，得到当前高亮章节id</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">for</span> (let id in offsetMap) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (e.target.scrollTop &lt;= offsetMap[id].offsetTop) {\n</div></li><li><div class=\"code-word\">      highlightId = id\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">break</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> lastDom = document.querySelector(<span class=\"hljs-string\">'.highlight'</span>)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> currentElem = document.querySelector(\\`a[href=<span class=\"hljs-string\">\"#${highlightId}\"</span>]\\`)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 修改高亮样式</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (lastDom &amp;&amp; lastDom.id !== highlightId) {\n</div></li><li><div class=\"code-word\">    lastDom.classList.remove(<span class=\"hljs-string\">'highlight'</span>)\n</div></li><li><div class=\"code-word\">    currentElem.classList.add(<span class=\"hljs-string\">'highlight'</span>)\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    currentElem.classList.add(<span class=\"hljs-string\">'highlight'</span>)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2888\">\n                      功能是实现了，但这并不是最优方法，因为滚动事件的触发频率是很高的，持续调用判断函数很可能会影响渲染性能。实际上也不需要过于频繁地调用，因为当鼠标滚动\n                      1\n                      像素的时候，很有可能当前章节的阅读并没有发生变化。所以我们可以设置在指定一段时间内只调用一次函数，从而降低函数调用频率，这种方式我们称之为“<strong\n                        data-nodeid=\"2971\"\n                        >节流</strong\n                      >”。\n                    </p>\n                    <p data-nodeid=\"2889\">\n                      实现节流函数的过程和防抖函数有些类似，只是对于节流函数而言，有两种执行方式，在调用函数时执行最先一次调用还是最近一次调用，所以需要设置时间戳加以判断。我们可以基于\n                      debounce() 函数加以修改，代码如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> throttle = (func, wait = <span class=\"hljs-number\">0</span>, execFirstCall) =&gt; {\n</div></li><li><div class=\"code-word\">  let timeout = <span class=\"hljs-function\"><span class=\"hljs-keyword\">null</span>\n</span></div></li><li><div class=\"code-word\">  let args\n</div></li><li><div class=\"code-word\">  let firstCallTimestamp\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  function <span class=\"hljs-title\">throttled</span><span class=\"hljs-params\">(...arg)</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!firstCallTimestamp) firstCallTimestamp = <span class=\"hljs-keyword\">new</span> Date().getTime()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (!execFirstCall || !args) {\n</div></li><li><div class=\"code-word\">      console.log(<span class=\"hljs-string\">'set args:'</span>, arg)\n</div></li><li><div class=\"code-word\">      args = arg\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (timeout) {\n</div></li><li><div class=\"code-word\">      clearTimeout(timeout)\n</div></li><li><div class=\"code-word\">      timeout = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 以Promise的形式返回函数执行结果</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Promise(async(res, rej) =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span> Date().getTime() - firstCallTimestamp &gt;= wait) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">const</span> result = await func.apply(<span class=\"hljs-keyword\">this</span>, args)\n</div></li><li><div class=\"code-word\">          res(result)\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">          rej(e)\n</div></li><li><div class=\"code-word\">        } <span class=\"hljs-keyword\">finally</span> {\n</div></li><li><div class=\"code-word\">          cancel()\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        timeout = setTimeout(async () =&gt; {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">const</span> result = await func.apply(<span class=\"hljs-keyword\">this</span>, args)\n</div></li><li><div class=\"code-word\">            res(result)\n</div></li><li><div class=\"code-word\">          } <span class=\"hljs-keyword\">catch</span> (e) {\n</div></li><li><div class=\"code-word\">            rej(e)\n</div></li><li><div class=\"code-word\">          } <span class=\"hljs-keyword\">finally</span> {\n</div></li><li><div class=\"code-word\">            cancel()\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }, firstCallTimestamp + wait - <span class=\"hljs-keyword\">new</span> Date().getTime())\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 允许取消</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">function <span class=\"hljs-title\">cancel</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    clearTimeout(timeout)\n</div></li><li><div class=\"code-word\">    args = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">    timeout = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">    firstCallTimestamp = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 允许立即执行</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">function <span class=\"hljs-title\">flush</span><span class=\"hljs-params\">()</span> </span>{\n</div></li><li><div class=\"code-word\">    cancel()\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> func.apply(<span class=\"hljs-keyword\">this</span>, args)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  throttled.cancel = cancel\n</div></li><li><div class=\"code-word\">  throttled.flush = flush\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> throttled\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2891\">\n                      节流与防抖都是通过延迟执行，减少调用次数，来优化频繁调用函数时的性能。不同的是，对于一段时间内的频繁调用，防抖是延迟执行后一次调用，节流是延迟定时多次调用。\n                    </p>\n                    <h4 data-nodeid=\"2892\">代理</h4>\n                    <p data-nodeid=\"2893\">\n                      下面的 HTML\n                      代码是一个简单的无序列表，现在希望点击每个项目的时候调用\n                      getInfo() 函数，当点击“编辑”时，调用一个 edit()\n                      函数，当点击“删除”时，调用一个 del() 函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"html\"><ol><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list\"</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"item1\"</span>&gt;</span>项目1<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"edit\"</span>&gt;</span>编辑<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"delete\"</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"item2\"</span>&gt;</span>项目2<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"edit\"</span>&gt;</span>编辑<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"delete\"</span> &gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"item3\"</span>&gt;</span>项目3<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"edit\"</span>&gt;</span>编辑<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"delete\"</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  ...\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2895\">\n                      要实现这个功能并不难，只需要对列表中每一项，分别监听 3\n                      个元素的 click 事件即可。\n                    </p>\n                    <p data-nodeid=\"2896\">\n                      但如果数据量一旦增大，事件绑定占用的内存以及执行时间将会成线性增加，而其实这些事件监听函数逻辑一致，只是参数不同而已。此时我们可以以<strong\n                        data-nodeid=\"2986\"\n                        >事件代理</strong\n                      >或<strong data-nodeid=\"2987\">事件委托</strong\n                      >来进行优化。不过在此之前，我们必须先复习一下 DOM\n                      事件的触发流程。\n                    </p>\n                    <p data-nodeid=\"2897\">\n                      事件触发流程如图 1 所示，主要分为 3 个阶段：\n                    </p>\n                    <ul data-nodeid=\"2898\">\n                      <li data-nodeid=\"2899\">\n                        <p data-nodeid=\"2900\">\n                          <strong data-nodeid=\"2993\">捕获</strong>，事件对象\n                          Window 传播到目标的父对象，图 1 的红色过程；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"2901\">\n                        <p data-nodeid=\"2902\">\n                          <strong data-nodeid=\"2998\">目标</strong\n                          >，事件对象到达事件对象的事件目标，图 1 的蓝色过程；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"2903\">\n                        <p data-nodeid=\"2904\">\n                          <strong data-nodeid=\"3003\">冒泡</strong\n                          >，事件对象从目标的父节点开始传播到 Window，图 1\n                          的绿色过程。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"2905\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/0C/D6/Ciqc1F7DSJ6AEL__AAFZ8Y41LLM325.png\"\n                        alt=\"1.png\"\n                        data-nodeid=\"3006\"\n                      />\n                    </p>\n                    <p data-nodeid=\"2906\">\n                      例如，在下面的代码中，虽然我们第二次进行事件监听时设置为捕获阶段，但点击事件时仍会按照监听顺序进行执行。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"html\"><ol><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>click<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'button'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'bubble'</span>)\n</div></li><li><div class=\"code-word\">})\n</div></li><li><div class=\"code-word\"><span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'button'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'capture'</span>)\n</div></li><li><div class=\"code-word\">}, <span class=\"hljs-literal\">true</span>)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 执行结果</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// buble</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// capture</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2908\">\n                      我们再回到事件代理，事件代理的实现原理就是利用上述 DOM\n                      事件的触发流程来对一类事件进行统一处理。比如对于上面的列表，我们在\n                      ul\n                      元素上绑定事件统一处理，通过得到的事件对象来获取参数，调用对应的函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> ul = document.querySelector(<span class=\"hljs-string\">'.list'</span>)\n</div></li><li><div class=\"code-word\">ul.addEventListener(<span class=\"hljs-string\">'click'</span>, e =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> t = e.target || e.<span class=\"hljs-function\">srcElement\n</span></div></li><li><div class=\"code-word\">  <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(t.classList.contains(<span class=\"hljs-string\">'item'</span>)</span>) {\n</div></li><li><div class=\"code-word\">    getInfo(t.id)\n</div></li><li><div class=\"code-word\">  } <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    id = t.parentElement.<span class=\"hljs-function\">id\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(t.classList.contains(<span class=\"hljs-string\">'edit'</span>)</span>) {\n</div></li><li><div class=\"code-word\">      edit(id)\n</div></li><li><div class=\"code-word\">    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (t.classList.contains(<span class=\"hljs-string\">'delete'</span>)) {\n</div></li><li><div class=\"code-word\">      del(id)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2910\">\n                      虽然这里我们选择了默认在冒泡阶段监听事件，但和捕获阶段监听并没有区别。对于其他情况还需要具体情况具体细分析，比如有些列表项目需要在目标阶段进行一些预处理操作，那么可以选择冒泡阶段进行事件代理。\n                    </p>\n                    <h4 data-nodeid=\"2911\">补充：关于 DOM 事件标准</h4>\n                    <p data-nodeid=\"2912\">\n                      你知道下面 3 种事件监听方式的区别吗？\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 方式1</span>\n</div></li><li><div class=\"code-word\">&lt;input type=<span class=\"hljs-string\">\"text\"</span> onclick=<span class=\"hljs-string\">\"click()\"</span>/&gt;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 方式2</span>\n</div></li><li><div class=\"code-word\">document.querySelector(<span class=\"hljs-string\">'input'</span>).onClick = function(e) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// ...</span>\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-comment\">// 方式3</span>\n</div></li><li><div class=\"code-word\">document.querySelector(<span class=\"hljs-string\">'input'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, function(e) {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">//...</span>\n</div></li><li><div class=\"code-word\">})\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"2914\">\n                      方式 1 和方式 2 同属于 DOM0\n                      标准，通过这种方式进行事件监会覆盖之前的事件监听函数。\n                    </p>\n                    <p data-nodeid=\"2915\">\n                      方式 3 属于 DOM2\n                      标准，推荐使用这种方式。同一元素上的事件监听函数互不影响，而且可以独立取消，调用顺序和监听顺序一致。\n                    </p>\n                    <h4 data-nodeid=\"2916\">总结</h4>\n                    <p data-nodeid=\"2917\">\n                      最后布置一道思考题：你还能举出关于事件代理在开源项目中使用的例子吗？\n                    </p>\n                    <p data-nodeid=\"2918\">\n                      <a\n                        href=\"https://github.com/yalishizhude/course/tree/master/03\"\n                        data-nodeid=\"3018\"\n                        >点击这里</a\n                      >下载示例代码。\n                    </p>\n                    <p data-nodeid=\"2919\" class=\"\">\n                      如果你觉得这个内容对你有所启发，欢迎分享给你的朋友或者同事探讨学习。\n                    </p>\n            "}