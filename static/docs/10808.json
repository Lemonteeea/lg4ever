{"title":"04 | Setup：组件渲染前的初始化过程是怎样的？","context":"\n                    <p data-nodeid=\"208752\" class=\"\">\n                      Vue.js 3.0 允许我们在编写组件的时候添加一个 setup\n                      启动函数，它是 Composition API\n                      逻辑组织的入口，本节课我们就来分析一下这个函数。\n                    </p>\n                    <p data-nodeid=\"208753\">\n                      我们先通过一段代码认识它，在这里编写一个 button 组件：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"increment\"</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    Count is: {{ state.count }}, double is: {{ state.double }}\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { reactive, computed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">  setup() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> state = reactive({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">double</span>: computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>)\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">increment</span>(<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">      state.count++\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">      state,\n</div></li><li><div class=\"code-word\">      increment\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208755\">\n                      可以看到，这段代码和 Vue.js 2.x 组件的写法相比，多了一个\n                      setup 启动函数，另外组件中也没有定义 props、data、computed\n                      这些 options。\n                    </p>\n                    <p data-nodeid=\"208756\">\n                      在 setup 函数内部，定义了一个响应式对象 state，它是通过\n                      reactive API 创建的。state 对象有 count 和 double\n                      两个属性，其中 count 对应一个数字属性的值；而double 通过\n                      computed API 创建，对应一个计算属性的值。reactive API 和\n                      computed API\n                      不是我们关注的重点，在后续响应式章节我会详细介绍。\n                    </p>\n                    <p data-nodeid=\"208757\">\n                      这里需要注意的是，<strong data-nodeid=\"208881\"\n                        >模板中引用到的变量 state 和 increment 包含在 setup\n                        函数的返回对象中，那么它们是如何建立联系的呢？</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"208758\">\n                      我们先来回想一下 Vue.js 2.x 编写组件的时候，会在\n                      props、data、methods、computed 等 options\n                      中定义一些变量。在组件初始化阶段，Vue.js 内部会处理这些\n                      options，即把定义的变量添加到了组件实例上。等模板编译成\n                      render 函数的时候，内部通过 with(this){}\n                      的语法去访问在组件实例中的变量。\n                    </p>\n                    <p data-nodeid=\"208759\">\n                      那么到了 Vue.js 3.0，既支持组件定义 setup 函数，而且在模板\n                      render 的时候，又可以访问到 setup\n                      函数返回的值，这是如何实现的？我们来一探究竟。\n                    </p>\n                    <h3 data-nodeid=\"208760\">创建和设置组件实例</h3>\n                    <p data-nodeid=\"208761\">\n                      首先，我们来回顾一下组件的渲染流程：创建 vnode 、渲染\n                      vnode 和生成 DOM。\n                    </p>\n                    <p data-nodeid=\"208762\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/35/74/Ciqc1F8VZpKAVYWOAABLt08AfuQ883.png\"\n                        alt=\"4.png\"\n                        data-nodeid=\"208888\"\n                      />\n                    </p>\n                    <p data-nodeid=\"208763\">\n                      其中渲染 vnode 的过程主要就是在挂载组件：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建组件实例</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 设置组件实例</span>\n</div></li><li><div class=\"code-word\">  setupComponent(instance)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 设置并运行带副作用的渲染函数</span>\n</div></li><li><div class=\"code-word\">  setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208765\">\n                      可以看到，这段挂载组件的代码主要做了三件事情：创建组件实例、设置组件实例和设置并运行带副作用的渲染函数。前两个流程就跟我们今天提到的问题息息相关，所以这一节课我们将重点分析它们。\n                    </p>\n                    <p data-nodeid=\"208766\">\n                      先看<strong data-nodeid=\"208896\">创建组件实例</strong\n                      >的流程，我们要关注 createComponentInstance 方法的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">createComponentInstance</span> <span class=\"hljs-params\">(vnode, parent, suspense)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 继承父组件实例上的 appContext，如果是根组件，则直接从根 vnode 中取。</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> instance = {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 组件唯一 id</span>\n</div></li><li><div class=\"code-word\">    uid: uid++,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 组件 vnode</span>\n</div></li><li><div class=\"code-word\">    vnode,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 父组件实例</span>\n</div></li><li><div class=\"code-word\">    parent,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// app 上下文</span>\n</div></li><li><div class=\"code-word\">    appContext,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// vnode 节点类型</span>\n</div></li><li><div class=\"code-word\">    type: vnode.type,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 根组件实例</span>\n</div></li><li><div class=\"code-word\">    root: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 新的组件 vnode</span>\n</div></li><li><div class=\"code-word\">    next: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 子节点 vnode</span>\n</div></li><li><div class=\"code-word\">    subTree: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 带副作用更新函数</span>\n</div></li><li><div class=\"code-word\">    update: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 渲染函数</span>\n</div></li><li><div class=\"code-word\">    render: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 渲染上下文代理</span>\n</div></li><li><div class=\"code-word\">    proxy: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 带有 with 区块的渲染上下文代理</span>\n</div></li><li><div class=\"code-word\">    withProxy: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 响应式相关对象</span>\n</div></li><li><div class=\"code-word\">    effects: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 依赖注入相关</span>\n</div></li><li><div class=\"code-word\">    provides: parent ? parent.provides : Object.create(appContext.provides),\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 渲染代理的属性访问缓存</span>\n</div></li><li><div class=\"code-word\">    accessCache: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 渲染缓存</span>\n</div></li><li><div class=\"code-word\">    renderCache: [],\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 渲染上下文</span>\n</div></li><li><div class=\"code-word\">    ctx: EMPTY_OBJ,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// data 数据</span>\n</div></li><li><div class=\"code-word\">    data: EMPTY_OBJ,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// props 数据</span>\n</div></li><li><div class=\"code-word\">    props: EMPTY_OBJ,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 普通属性</span>\n</div></li><li><div class=\"code-word\">    attrs: EMPTY_OBJ,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 插槽相关</span>\n</div></li><li><div class=\"code-word\">    slots: EMPTY_OBJ,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 组件或者 DOM 的 ref 引用</span>\n</div></li><li><div class=\"code-word\">    refs: EMPTY_OBJ,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// setup 函数返回的响应式结果</span>\n</div></li><li><div class=\"code-word\">    setupState: EMPTY_OBJ,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// setup 函数上下文数据</span>\n</div></li><li><div class=\"code-word\">    setupContext: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注册的组件</span>\n</div></li><li><div class=\"code-word\">    components: Object.create(appContext.components),\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 注册的指令</span>\n</div></li><li><div class=\"code-word\">    directives: Object.create(appContext.directives),\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// suspense 相关</span>\n</div></li><li><div class=\"code-word\">    suspense,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// suspense 异步依赖</span>\n</div></li><li><div class=\"code-word\">    asyncDep: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// suspense 异步依赖是否都已处理</span>\n</div></li><li><div class=\"code-word\">    asyncResolved: <span class=\"hljs-keyword\">false</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 是否挂载</span>\n</div></li><li><div class=\"code-word\">    isMounted: <span class=\"hljs-keyword\">false</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 是否卸载</span>\n</div></li><li><div class=\"code-word\">    isUnmounted: <span class=\"hljs-keyword\">false</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 是否激活</span>\n</div></li><li><div class=\"code-word\">    isDeactivated: <span class=\"hljs-keyword\">false</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，before create</span>\n</div></li><li><div class=\"code-word\">    bc: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，created</span>\n</div></li><li><div class=\"code-word\">    c: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，before mount</span>\n</div></li><li><div class=\"code-word\">    bm: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，mounted</span>\n</div></li><li><div class=\"code-word\">    m: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，before update</span>\n</div></li><li><div class=\"code-word\">    bu: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，updated</span>\n</div></li><li><div class=\"code-word\">    u: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，unmounted</span>\n</div></li><li><div class=\"code-word\">    um: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期，before unmount</span>\n</div></li><li><div class=\"code-word\">    bum: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期, deactivated</span>\n</div></li><li><div class=\"code-word\">    da: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期 activated</span>\n</div></li><li><div class=\"code-word\">    a: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期 render triggered</span>\n</div></li><li><div class=\"code-word\">    rtg: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期 render tracked</span>\n</div></li><li><div class=\"code-word\">    rtc: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期 error captured</span>\n</div></li><li><div class=\"code-word\">    ec: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 派发事件方法</span>\n</div></li><li><div class=\"code-word\">    emit: <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化渲染上下文</span>\n</div></li><li><div class=\"code-word\">  instance.ctx = { _: instance }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化根组件指针</span>\n</div></li><li><div class=\"code-word\">  instance.root = parent ? parent.root : instance\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化派发事件方法</span>\n</div></li><li><div class=\"code-word\">  instance.emit = emit.bind(<span class=\"hljs-keyword\">null</span>, instance)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> instance\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208768\">\n                      从上述代码中可以看到，组件实例 instance\n                      上定义了很多属性，你千万不要被这茫茫多的属性吓到，因为其中一些属性是为了实现某个场景或者某个功能所定义的，你只需要通过我在代码中的注释大概知道它们是做什么的即可。\n                    </p>\n                    <p data-nodeid=\"208769\">\n                      Vue.js 2.x 使用 new Vue 来初始化一个组件的实例，到了\n                      Vue.js\n                      3.0，我们直接通过创建对象去创建组件的实例。这两种方式并无本质的区别，都是引用一个对象，在整个组件的生命周期中去维护组件的状态数据和上下文环境。\n                    </p>\n                    <p data-nodeid=\"208770\">\n                      创建好 instance\n                      实例后，接下来就是设置它的一些属性。目前已完成了组件的上下文、根组件指针以及派发事件方法的设置。我们在后面会继续分析更多\n                      instance 实例属性的设置逻辑。\n                    </p>\n                    <p data-nodeid=\"208771\">\n                      接着是<strong data-nodeid=\"208905\"\n                        >组件实例的设置流程</strong\n                      >，对 setup 函数的处理就在这里完成，我们来看一下\n                      setupComponent 方法的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">setupComponent</span> <span class=\"hljs-params\">(instance, isSSR = <span class=\"hljs-keyword\">false</span>)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> { props, children, shapeFlag } = instance.vnode\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 判断是否是一个有状态的组件</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> isStateful = shapeFlag &amp; <span class=\"hljs-number\">4</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化 props</span>\n</div></li><li><div class=\"code-word\">  initProps(instance, props, isStateful, isSSR)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 初始化 插槽</span>\n</div></li><li><div class=\"code-word\">  initSlots(instance, children)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 设置有状态的组件实例</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> setupResult = isStateful\n</div></li><li><div class=\"code-word\">    ? setupStatefulComponent(instance, isSSR)\n</div></li><li><div class=\"code-word\">    : undefined\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> setupResult\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208773\">\n                      可以看到，我们从组件 vnode 中获取了\n                      props、children、shapeFlag 等属性，然后分别对 props\n                      和插槽进行初始化，这两部分逻辑在后续的章节再详细分析。根据\n                      shapeFlag\n                      的值，我们可以判断这是不是一个有状态组件，如果是则要进一步去设置有状态组件的实例。\n                    </p>\n                    <p data-nodeid=\"208774\">\n                      接下来我们要关注到 setupStatefulComponent\n                      函数，它主要做了三件事：创建渲染上下文代理、判断处理 setup\n                      函数和完成组件实例设置。它代码如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">setupStatefulComponent</span> <span class=\"hljs-params\">(instance, isSSR)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> Component = instance.type\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建渲染代理的属性访问缓存</span>\n</div></li><li><div class=\"code-word\">  instance.accessCache = {}\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 创建渲染上下文代理</span>\n</div></li><li><div class=\"code-word\">  instance.proxy = <span class=\"hljs-keyword\">new</span> Proxy(instance.ctx, PublicInstanceProxyHandlers)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 判断处理 setup 函数</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> { setup } = <span class=\"hljs-function\">Component\n</span></div></li><li><div class=\"code-word\">  <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(setup)</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果 setup 函数带参数，则创建一个 setupContext</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> setupContext = (instance.setupContext =\n</div></li><li><div class=\"code-word\">      setup.length &gt; <span class=\"hljs-number\">1</span> ? createSetupContext(instance) : <span class=\"hljs-keyword\">null</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 执行 setup 函数，获取结果</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> setupResult = callWithErrorHandling(setup, instance, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 处理 setup 执行结果</span>\n</div></li><li><div class=\"code-word\">    handleSetupResult(instance, setupResult)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 完成组件实例设置</span>\n</div></li><li><div class=\"code-word\">    finishComponentSetup(instance)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h3 data-nodeid=\"208776\">创建渲染上下文代理</h3>\n                    <p data-nodeid=\"208777\">\n                      首先是创建渲染上下文代理的流程，它主要对 instance.ctx\n                      做了代理。在分析实现前，我们需要思考一个问题，这里为什么需要代理呢？\n                    </p>\n                    <p data-nodeid=\"208778\">\n                      其实在 Vue.js 2.x 中，也有类似的数据代理逻辑，比如 props\n                      求值后的数据，实际上存储在 this._props 上，而 data\n                      中定义的数据存储在 this._data 上。举个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">  data() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208780\">\n                      在初始化组件的时候，data 中定义的 msg 在组件内部是存储在\n                      this._data 上的，而模板渲染的时候访问\n                      this.msg，实际上访问的是 this._data.msg，这是因为 Vue.js\n                      2.x 在初始化 data 的时候，做了一层 proxy 代理。\n                    </p>\n                    <p data-nodeid=\"208781\">\n                      到了 Vue.js\n                      3.0，为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到\n                      setupState、ctx、data、props\n                      中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文\n                      instance.ctx 中的属性，所以我们也要做一层\n                      proxy，对渲染上下文 instance.ctx\n                      属性的访问和修改，代理到对 setupState、ctx、data、props\n                      中的数据的访问和修改。\n                    </p>\n                    <p data-nodeid=\"208782\">\n                      明确了代理的需求后，我们接下来就要分析 proxy 的几个方法：\n                      get、set 和 has。\n                    </p>\n                    <p data-nodeid=\"208783\">\n                      当我们<strong data-nodeid=\"208931\"\n                        >访问 instance.ctx 渲染上下文中的属性</strong\n                      >时，就会<strong data-nodeid=\"208932\"\n                        >进入 get 函数</strong\n                      >。我们来看一下它的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PublicInstanceProxyHandlers = {\n</div></li><li><div class=\"code-word\">  get ({ _: instance }, key) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> { ctx, setupState, data, props, accessCache, type, appContext } = <span class=\"hljs-function\">instance\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(key[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'$'</span>)</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// setupState / data / props / ctx</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 渲染代理的属性访问缓存中</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> n = accessCache[key]\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (n !== undefined) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 从缓存中取</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">switch</span> (n) {\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\">/* SETUP */</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> setupState[key]\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span> :<span class=\"hljs-comment\">/* DATA */</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> data[key]\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span> :<span class=\"hljs-comment\">/* CONTEXT */</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> ctx[key]\n</div></li><li><div class=\"code-word\">          <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>: <span class=\"hljs-comment\">/* PROPS */</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-keyword\">return</span> props[key]\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) {\n</div></li><li><div class=\"code-word\">        accessCache[key] = <span class=\"hljs-number\">0</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 从 setupState 中取数据</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> setupState[key]\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {\n</div></li><li><div class=\"code-word\">        accessCache[key] = <span class=\"hljs-number\">1</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 从 data 中取数据</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> data[key]\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (\n</div></li><li><div class=\"code-word\">        type.props &amp;&amp;\n</div></li><li><div class=\"code-word\">        hasOwn(normalizePropsOptions(type.props)[<span class=\"hljs-number\">0</span>], key)) {\n</div></li><li><div class=\"code-word\">        accessCache[key] = <span class=\"hljs-number\">2</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 从 props 中取数据</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> props[key]\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {\n</div></li><li><div class=\"code-word\">        accessCache[key] = <span class=\"hljs-number\">3</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 从 ctx 中取数据</span>\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> ctx[key]\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 都取不到</span>\n</div></li><li><div class=\"code-word\">        accessCache[key] = <span class=\"hljs-number\">4</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> publicGetter = publicPropertiesMap[key]\n</div></li><li><div class=\"code-word\">    let cssModule, globalProperties\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 公开的 $xxx 属性或方法</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (publicGetter) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> publicGetter(instance)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// css 模块，通过 vue-loader 编译的时候注入</span>\n</div></li><li><div class=\"code-word\">      (cssModule = type.__cssModules) &amp;&amp;\n</div></li><li><div class=\"code-word\">      (cssModule = cssModule[key])) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> cssModule\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 用户自定义的属性，也用 \\`$\\` 开头</span>\n</div></li><li><div class=\"code-word\">      accessCache[key] = <span class=\"hljs-number\">3</span>\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> ctx[key]\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 全局定义的属性</span>\n</div></li><li><div class=\"code-word\">      ((globalProperties = appContext.config.globalProperties),\n</div></li><li><div class=\"code-word\">        hasOwn(globalProperties, key))) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> globalProperties[key]\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> ((process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">      currentRenderingInstance &amp;&amp; key.indexOf(<span class=\"hljs-string\">'__v'</span>) !== <span class=\"hljs-number\">0</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (data !== EMPTY_OBJ &amp;&amp; key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">'$'</span> &amp;&amp; hasOwn(data, key)) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 如果在 data 中定义的数据以 $ 开头，会报警告，因为 $ 是保留字符，不会做代理</span>\n</div></li><li><div class=\"code-word\">        warn(\\`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved \\` +\n</div></li><li><div class=\"code-word\">          \\`character and is not proxied on the render context.\\`)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 在模板中使用的变量如果没有定义，报警告</span>\n</div></li><li><div class=\"code-word\">        warn(\\`Property ${JSON.stringify(key)} was accessed during render \\` +\n</div></li><li><div class=\"code-word\">          \\`but is not defined on instance.\\`)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208785\">\n                      可以看到，函数首先判断 key 不以 $\n                      开头的情况，这部分数据可能是 setupState、data、props、ctx\n                      中的一种，其中 data、props 我们已经很熟悉了；setupState\n                      就是 setup 函数返回的数据，稍后我们会详细说；ctx\n                      包括了计算属性、组件方法和用户自定义的一些数据。\n                    </p>\n                    <p data-nodeid=\"208786\">\n                      如果 key 不以 $ 开头，那么就依次判断\n                      setupState、data、props、ctx 中是否包含这个\n                      key，如果包含就返回对应值。<strong data-nodeid=\"208943\"\n                        >注意这个判断顺序很重要</strong\n                      >，<strong data-nodeid=\"208944\"\n                        >在 key 相同时它会决定数据获取的优先级</strong\n                      >，举个例子：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{msg}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    data() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'msg from data'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    setup() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> msg = ref(<span class=\"hljs-string\">'msg from setup'</span>)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        msg\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208788\">\n                      我们在 data 和 setup 中都定义了 msg\n                      变量，但最终输出到界面上的是\"msg from setup\"，这是因为\n                      setupState 的判断优先级要高于 data。\n                    </p>\n                    <p data-nodeid=\"208789\">\n                      再回到 get 函数中，我们可以看到这里定义了 accessCache\n                      作为渲染代理的属性访问缓存，它具体是干什么的呢？组件在渲染时会经常访问数据进而触发\n                      get 函数，这其中最昂贵的部分就是多次调用 hasOwn 去判断 key\n                      在不在某个类型的数据中，但是在普通对象上执行简单的属性访问相对要快得多。所以在第一次获取\n                      key 对应的数据后，我们利用 accessCache[key]\n                      去缓存数据，下一次再次根据 key\n                      查找数据，我们就可以直接通过 accessCache[key]\n                      获取对应的值，就不需要依次调用 hasOwn\n                      去判断了。这也是一个性能优化的小技巧。\n                    </p>\n                    <p data-nodeid=\"208790\">\n                      如果 key 以 $\n                      开头，那么接下来又会有一系列的判断，首先判断是不是 Vue.js\n                      内部公开的 $xxx 属性或方法（比如 $parent）；然后判断是不是\n                      vue-loader 编译注入的 css 模块内部的\n                      key；接着判断是不是用户自定义以 $ 开头的\n                      key；最后判断是不是全局属性。如果都不满足，就剩两种情况了，即在非生产环境下就会报两种类型的警告，第一种是在\n                      data 中定义的数据以 $ 开头的警告，因为 $\n                      是保留字符，不会做代理；第二种是在模板中使用的变量没有定义的警告。\n                    </p>\n                    <p data-nodeid=\"208791\">\n                      接下来是 set 代理过程，当我们<strong data-nodeid=\"208969\"\n                        >修改 instance.ctx 渲染上下文中的属性</strong\n                      >的时候，就会<strong data-nodeid=\"208970\"\n                        >进入 set 函数</strong\n                      >。我们来看一下 set 函数的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PublicInstanceProxyHandlers = {\n</div></li><li><div class=\"code-word\">  set ({ _: instance }, key, value) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> { data, setupState, ctx } = <span class=\"hljs-function\">instance\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)</span>) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 给 setupState 赋值</span>\n</div></li><li><div class=\"code-word\">      setupState[key] = value\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 给 data 赋值</span>\n</div></li><li><div class=\"code-word\">      data[key] = value\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key in instance.props) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 不能直接给 props 赋值</span>\n</div></li><li><div class=\"code-word\">      (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">      warn(\\`Attempting to mutate prop <span class=\"hljs-string\">\"${key}\"</span>. Props are readonly.\\`, instance)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (key[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">'$'</span> &amp;&amp; key.slice(<span class=\"hljs-number\">1</span>) in instance) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 不能给 Vue 内部以 $ 开头的保留属性赋值</span>\n</div></li><li><div class=\"code-word\">      (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp;\n</div></li><li><div class=\"code-word\">      warn(\\`Attempting to mutate <span class=\"hljs-keyword\">public</span> property <span class=\"hljs-string\">\"${key}\"</span>. \\` +\n</div></li><li><div class=\"code-word\">        \\`Properties starting with $ are reserved and readonly.\\`, instance)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 用户自定义数据赋值</span>\n</div></li><li><div class=\"code-word\">      ctx[key] = value\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208793\">\n                      结合代码来看，函数主要做的事情就是对渲染上下文\n                      instance.ctx\n                      中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和\n                      get 一样，优先判断 setupState，然后是 data，接着是 props。\n                    </p>\n                    <p data-nodeid=\"208794\">\n                      我们对之前的例子做点修改，添加一个方法：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"random\"</span>&gt;</span>Random msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    data() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'msg from data'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    setup() {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> msg = ref(<span class=\"hljs-string\">'msg from setup'</span>)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        msg\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">methods</span>: {\n</div></li><li><div class=\"code-word\">      random() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-built_in\">Math</span>.random()\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208796\">\n                      我们点击按钮会执行 random 函数，这里的 this 指向的就是\n                      instance.ctx，我们修改 this.msg 会触发 set\n                      函数，所以最终修改的是 setupState 中的 msg 对应的值。\n                    </p>\n                    <p data-nodeid=\"208797\">\n                      注意，如果我们直接对 props\n                      中的数据赋值，在非生产环境中会收到一条警告，这是因为直接修改\n                      props 不符合数据单向流动的设计思想；如果对 Vue.js 内部以 $\n                      开头的保留属性赋值，同样也会收到一条警告。\n                    </p>\n                    <p data-nodeid=\"208798\">\n                      如果是用户自定义的数据，比如在 created\n                      生命周期内定义的数据，它仅用于组件上下文的共享，如下所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">  created() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.userMsg = <span class=\"hljs-string\">'msg from user'</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208800\">\n                      当执行 this.userMsg 赋值的时候，会触发 set 函数，最终\n                      userMsg 会被保留到 ctx 中。\n                    </p>\n                    <p data-nodeid=\"208801\">\n                      最后是 has 代理过程，当我们<strong data-nodeid=\"208990\"\n                        >判断属性是否存在于 instance.ctx 渲染上下文中</strong\n                      >时，就<strong data-nodeid=\"208991\"\n                        >会进入 has 函数</strong\n                      >，这个在平时项目中用的比较少，同样来举个例子，当执行\n                      created 钩子函数中的 'msg' in this 时，就会触发 has 函数。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">  created () {\n</div></li><li><div class=\"code-word\">    console.log(<span class=\"hljs-string\">'msg'</span> in <span class=\"hljs-keyword\">this</span>)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208803\">\n                      下面我们来看一下 has 函数的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> PublicInstanceProxyHandlers = {\n</div></li><li><div class=\"code-word\">  has\n</div></li><li><div class=\"code-word\">    ({ _: { data, setupState, accessCache, ctx, type, appContext } }, key) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 依次判断</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (accessCache[key] !== undefined ||\n</div></li><li><div class=\"code-word\">      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||\n</div></li><li><div class=\"code-word\">      (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) ||\n</div></li><li><div class=\"code-word\">      (type.props &amp;&amp; hasOwn(normalizePropsOptions(type.props)[<span class=\"hljs-number\">0</span>], key)) ||\n</div></li><li><div class=\"code-word\">      hasOwn(ctx, key) ||\n</div></li><li><div class=\"code-word\">      hasOwn(publicPropertiesMap, key) ||\n</div></li><li><div class=\"code-word\">      hasOwn(appContext.config.globalProperties, key))\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208805\">\n                      这个函数的实现很简单，依次判断 key 是否存在于\n                      accessCache、data、setupState、props\n                      、用户数据、公开属性以及全局属性中，然后返回结果。\n                    </p>\n                    <p data-nodeid=\"208806\">\n                      至此，我们就搞清楚了创建上下文代理的过程，让我们回到\n                      setupStatefulComponent\n                      函数中，接下来分析第二个流程——判断处理 setup 函数。\n                    </p>\n                    <h3 data-nodeid=\"208807\">判断处理 setup 函数</h3>\n                    <p data-nodeid=\"208808\">我们看一下整个逻辑涉及的代码：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-comment\">// 判断处理 setup 函数</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> { setup } = <span class=\"hljs-function\">Component\n</span></div></li><li><div class=\"code-word\"><span class=\"hljs-title\">if</span> <span class=\"hljs-params\">(setup)</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 如果 setup 函数带参数，则创建一个 setupContext</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> setupContext = (instance.setupContext =\n</div></li><li><div class=\"code-word\">    setup.length &gt; <span class=\"hljs-number\">1</span> ? createSetupContext(instance) : <span class=\"hljs-keyword\">null</span>)\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 执行 setup 函数获取结果</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> setupResult = callWithErrorHandling(setup, instance, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 setup 执行结果</span>\n</div></li><li><div class=\"code-word\">  handleSetupResult(instance, setupResult)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208810\">\n                      如果我们在组件中定义了 setup 函数，接下来就是处理 setup\n                      函数的流程，主要是三个步骤：创建 setup 函数上下文、执行\n                      setup 函数并获取结果和处理 setup\n                      函数的执行结果。接下来我们就逐个来分析。\n                    </p>\n                    <p data-nodeid=\"208811\">\n                      首先<strong data-nodeid=\"209011\"\n                        >判断 setup 函数的参数长度</strong\n                      >，<strong data-nodeid=\"209012\">如果大于 1</strong\n                      >，<strong data-nodeid=\"209013\"\n                        >则创建 setupContext 上下文</strong\n                      >。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> setupContext = (instance.setupContext =\n</div></li><li><div class=\"code-word\">    setup.length &gt; <span class=\"hljs-number\">1</span> ? createSetupContext(instance) : <span class=\"hljs-keyword\">null</span>)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208813\">\n                      举个例子，我们有个 HelloWorld 子组件，如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span>Toggle<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">props</span>: {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-built_in\">String</span>\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    setup (props, { emit }) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">        emit(<span class=\"hljs-string\">'toggle'</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        onClick\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208815\">我们在父组件引用这个组件：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;template&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HelloWorld</span> @<span class=\"hljs-attr\">toggle</span>=<span class=\"hljs-string\">\"toggle\"</span> <span class=\"hljs-attr\">:msg</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">HelloWorld</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">&lt;/template&gt;\n</div></li><li><div class=\"code-word\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n</span></span></div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> HelloWorld <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./components/HelloWorld\"</span>;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">components</span>: { HelloWorld },\n</div></li><li><div class=\"code-word\">    setup () {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">const</span> msg = ref(<span class=\"hljs-string\">'Hello World'</span>)\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toggle</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">        msg.value = msg.value === <span class=\"hljs-string\">'Hello World'</span> ? <span class=\"hljs-string\">'Hello Vue'</span> : <span class=\"hljs-string\">'Hello World'</span>\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> {\n</div></li><li><div class=\"code-word\">        toggle,\n</div></li><li><div class=\"code-word\">        msg\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208817\">\n                      可以看到，HelloWorld 子组件的 setup\n                      函数接收两个参数，第一个参数 props 对应父组件传入的 props\n                      数据，第二个参数 emit 是一个对象，实际上就是\n                      setupContext。\n                    </p>\n                    <p data-nodeid=\"208818\">\n                      下面我们来看一下用 createSetupContext 函数来创建\n                      setupContext：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">function createSetupContext (instance) {\n</div></li><li><div class=\"code-word\">  return {\n</div></li><li><div class=\"code-word\">    attrs: instance.attrs,\n</div></li><li><div class=\"code-word\">    slots: instance.slots,\n</div></li><li><div class=\"code-word\">    emit: instance.emit\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208820\">\n                      这里返回了一个对象，包括 attrs、slots 和 emit\n                      三个属性。setupContext 让我们在 setup\n                      函数内部可以获取到组件的属性、插槽以及派发事件的方法\n                      emit。\n                    </p>\n                    <p data-nodeid=\"208821\">\n                      可以预见的是，这个 setupContext 对应的就是 setup\n                      函数第二个参数，我们接下来看一下 setup\n                      函数具体是如何执行的。\n                    </p>\n                    <p data-nodeid=\"208822\">\n                      我们通过下面这行代码来<strong data-nodeid=\"209025\"\n                        >执行 setup 函数并获取结果</strong\n                      >：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> setupResult = callWithErrorHandling(setup, instance, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208824\">\n                      我们具体来看一下 callWithErrorHandling 函数的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">callWithErrorHandling</span> <span class=\"hljs-params\">(fn, instance, type, args)</span> </span>{\n</div></li><li><div class=\"code-word\">  let res\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">try</span> {\n</div></li><li><div class=\"code-word\">    res = args ? fn(...args) : fn()\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">catch</span> (err) {\n</div></li><li><div class=\"code-word\">    handleError(err, instance, type)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> res\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208826\">\n                      可以看到，它其实就是对 fn 做的一层包装，内部还是执行了\n                      fn，并在有参数的时候传入参数，所以 setup 的第一个参数是\n                      instance.props，第二个参数是\n                      setupContext。函数执行过程中如果有 JavaScript\n                      执行错误就会捕获错误，并执行 handleError 函数来处理。\n                    </p>\n                    <p data-nodeid=\"208827\">\n                      执行 setup 函数并拿到了返回的结果，那么接下来就要<strong\n                        data-nodeid=\"209033\"\n                        >用 handleSetupResult 函数来处理结果</strong\n                      >。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">handleSetupResult(instance, setupResult)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208829\">\n                      我们详细看一下 handleSetupResult 函数的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">handleSetupResult</span><span class=\"hljs-params\">(instance, setupResult)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (isFunction(setupResult)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// setup 返回渲染函数</span>\n</div></li><li><div class=\"code-word\">    instance.render = setupResult\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isObject(setupResult)) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 把 setup 返回结果变成响应式</span>\n</div></li><li><div class=\"code-word\">    instance.setupState = reactive(setupResult)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  finishComponentSetup(instance)\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208831\">\n                      可以看到，当 setupResult\n                      是一个对象的时候，我们把它变成了响应式并赋值给\n                      instance.setupState，这样在模板渲染的时候，依据前面的代理规则，instance.ctx\n                      就可以从 instance.setupState 上获取到对应的数据，这就在\n                      setup 函数与模板渲染间建立了联系。\n                    </p>\n                    <p data-nodeid=\"208832\">\n                      另外 setup\n                      不仅仅支持返回一个对象，也可以返回一个函数作为组件的渲染函数。我们可以改写前面的示例，来看一下这时的情况：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;script&gt;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">import</span> { h } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-attr\">props</span>: {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-built_in\">String</span>\n</div></li><li><div class=\"code-word\">    },\n</div></li><li><div class=\"code-word\">    setup (props, { emit }) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick</span> (<span class=\"hljs-params\"></span>) </span>{\n</div></li><li><div class=\"code-word\">        emit(<span class=\"hljs-string\">'toggle'</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">ctx</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> [\n</div></li><li><div class=\"code-word\">          h(<span class=\"hljs-string\">'p'</span>, <span class=\"hljs-literal\">null</span>, ctx.msg),\n</div></li><li><div class=\"code-word\">          h(<span class=\"hljs-string\">'button'</span>, { <span class=\"hljs-attr\">onClick</span>: onClick }, <span class=\"hljs-string\">'Toggle'</span>)\n</div></li><li><div class=\"code-word\">        ]\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">&lt;/script&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208834\">\n                      这里，我们删除了 HelloWorld 子组件的 template 部分，并把\n                      setup\n                      函数的返回结果改成了函数，也就是说它会作为组件的渲染函数，一切运行正常。\n                    </p>\n                    <p data-nodeid=\"208835\">\n                      在 handleSetupResult 的最后，会执行 finishComponentSetup\n                      函数完成组件实例的设置，其实这个函数和 setup\n                      函数的执行结果已经没什么关系了，提取到外面放在\n                      handleSetupResult 函数后面执行更合理一些。\n                    </p>\n                    <p data-nodeid=\"208836\">\n                      另外当组件没有定义的 setup 的时候，也会执行\n                      finishComponentSetup 函数去完成组件实例的设置。\n                    </p>\n                    <h3 data-nodeid=\"208837\">完成组件实例设置</h3>\n                    <p data-nodeid=\"208838\">\n                      接下来我们来看一下 finishComponentSetup 函数的实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">finishComponentSetup</span> <span class=\"hljs-params\">(instance)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> Component = instance.type\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 对模板或者渲染函数的标准化</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">if</span> (!instance.render) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (compile &amp;&amp; Component.template &amp;&amp; !Component.render) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 运行时编译</span>\n</div></li><li><div class=\"code-word\">      Component.render = compile(Component.template, {\n</div></li><li><div class=\"code-word\">        isCustomElement: instance.appContext.config.isCustomElement || NO\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">      Component.render._rc = <span class=\"hljs-keyword\">true</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> ((process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp; !Component.render) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">if</span> (!compile &amp;&amp; Component.template) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 只编写了 template 但使用了 runtime-only 的版本</span>\n</div></li><li><div class=\"code-word\">        warn(\\`Component provided template option but \\` +\n</div></li><li><div class=\"code-word\">          \\`runtime compilation is not supported in <span class=\"hljs-keyword\">this</span> build of Vue.\\` +\n</div></li><li><div class=\"code-word\">          (\\` Configure your bundler to alias <span class=\"hljs-string\">\"vue\"</span> to <span class=\"hljs-string\">\"vue/dist/vue.esm-bundler.js\"</span>.\\`\n</div></li><li><div class=\"code-word\">          ) <span class=\"hljs-comment\">/* should not happen */</span>)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 既没有写 render 函数，也没有写 template 模板</span>\n</div></li><li><div class=\"code-word\">        warn(\\`Component is missing template or render function.\\`)\n</div></li><li><div class=\"code-word\">      }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 组件对象的 render 函数赋值给 instance</span>\n</div></li><li><div class=\"code-word\">    instance.render = (Component.render || NOOP)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (instance.render._rc) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-comment\">// 对于使用 with 块的运行时编译的渲染函数，使用新的渲染上下文的代理</span>\n</div></li><li><div class=\"code-word\">      instance.withProxy = <span class=\"hljs-keyword\">new</span> Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 兼容 Vue.js 2.x Options API</span>\n</div></li><li><div class=\"code-word\">  {\n</div></li><li><div class=\"code-word\">    currentInstance = <span class=\"hljs-function\">instance\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-title\">applyOptions</span><span class=\"hljs-params\">(instance, Component)</span>\n</div></li><li><div class=\"code-word\">    currentInstance = <span class=\"hljs-keyword\">null</span>\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208840\">\n                      函数主要做了两件事情：<strong data-nodeid=\"209047\"\n                        >标准化模板或者渲染函数和兼容 Options API</strong\n                      >。接下来我们详细分析这两个流程。\n                    </p>\n                    <h4 data-nodeid=\"208841\">标准化模板或者渲染函数</h4>\n                    <p data-nodeid=\"208842\">\n                      在分析这个过程之前，我们需要了解一些背景知识。组件最终通过运行\n                      render 函数生成子树 vnode，但是我们很少直接去编写 render\n                      函数，通常会使用两种方式开发组件。\n                    </p>\n                    <p data-nodeid=\"208843\">\n                      <strong data-nodeid=\"209054\"\n                        >第一种是使用 SFC（Single File\n                        Components）单文件的开发方式来开发组件</strong\n                      >，即通过编写组件的 template 模板去描述一个组件的 DOM\n                      结构。我们知道 .vue 类型的文件无法在 Web\n                      端直接加载，因此在 webpack 的编译阶段，它会通过 vue-loader\n                      编译生成组件相关的 JavaScript 和 CSS，并把 template\n                      部分转换成 render 函数添加到组件对象的属性中。\n                    </p>\n                    <p data-nodeid=\"208844\">\n                      <strong data-nodeid=\"209063\">另外一种开发方式</strong\n                      >是不借助 webpack 编译，<strong data-nodeid=\"209064\"\n                        >直接引入 Vue.js</strong\n                      >，开箱即用，我们直接在组件对象 template\n                      属性中编写组件的模板，然后在运行阶段编译生成 render\n                      函数，这种方式通常用于有一定历史包袱的古老项目。\n                    </p>\n                    <p data-nodeid=\"208845\">\n                      因此 Vue.js 在 Web 端有两个版本：runtime-only 和\n                      runtime-compiled。我们更推荐用 runtime-only 版本的\n                      Vue.js，因为相对而言它体积更小，而且在运行时不用编译，不仅耗时更少而且性能更优秀。遇到一些不得已的情况比如上述提到的古老项目，我们也可以选择\n                      runtime-compiled 版本。\n                    </p>\n                    <p data-nodeid=\"208846\">\n                      runtime-only 和 runtime-compiled\n                      的主要区别在于是否注册了这个 compile 方法。\n                    </p>\n                    <p data-nodeid=\"208847\">\n                      在 Vue.js 3.0 中，compile 方法是通过外部注册的：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\">let compile;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">registerRuntimeCompiler</span><span class=\"hljs-params\">(_compile)</span> </span>{\n</div></li><li><div class=\"code-word\">    compile = _compile;\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208849\">\n                      回到标准化模板或者渲染函数逻辑，我们先看 instance.render\n                      是否存在，如果不存在则开始标准化流程，这里主要需要处理以下三种情况。\n                    </p>\n                    <ol data-nodeid=\"208850\">\n                      <li data-nodeid=\"208851\">\n                        <p data-nodeid=\"208852\">\n                          <strong data-nodeid=\"209077\"\n                            >compile 和组件 template 属性存在</strong\n                          >，<strong data-nodeid=\"209078\"\n                            >render 方法不存在的情况</strong\n                          >。此时， runtime-compiled 版本会在 JavaScript\n                          运行时进行模板编译，生成 render 函数。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"208853\">\n                        <p data-nodeid=\"208854\">\n                          <strong data-nodeid=\"209083\"\n                            >compile 和 render 方法不存在，组件 template\n                            属性存在的情况</strong\n                          >。此时由于没有 compile，这里用的是 runtime-only\n                          的版本，因此要报一个警告来告诉用户，想要运行时编译得使用\n                          runtime-compiled 版本的 Vue.js。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"208855\">\n                        <p data-nodeid=\"208856\">\n                          <strong data-nodeid=\"209088\"\n                            >组件既没有写 render 函数，也没有写 template\n                            模板</strong\n                          >，此时要报一个警告，告诉用户组件缺少了 render\n                          函数或者 template 模板。\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"208857\">\n                      处理完以上情况后，就要把组件的 render 函数赋值给\n                      instance.render。到了组件渲染的时候，就可以运行\n                      instance.render 函数生成组件的子树 vnode 了。\n                    </p>\n                    <p data-nodeid=\"208858\">\n                      另外对于使用 with\n                      块运行时编译的渲染函数，渲染上下文的代理是\n                      RuntimeCompiledPublicInstanceProxyHandlers，它是在之前渲染上下文代理\n                      PublicInstanceProxyHandlers 的基础上进行的扩展，主要对 has\n                      函数的实现做了优化：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> RuntimeCompiledPublicInstanceProxyHandlers = {\n</div></li><li><div class=\"code-word\">  ...PublicInstanceProxyHandlers,\n</div></li><li><div class=\"code-word\">  get(target, key) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (key === Symbol.unscopables) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> PublicInstanceProxyHandlers.get(target, key, target)\n</div></li><li><div class=\"code-word\">  },\n</div></li><li><div class=\"code-word\">  has(_, key) {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 如果 key 以 _ 开头或者 key 在全局变量白名单内，则 has 为 false</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> has = key[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'_'</span> &amp;&amp; !isGloballyWhitelisted(key)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> ((process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &amp;&amp; !has &amp;&amp; PublicInstanceProxyHandlers.has(_, key)) {\n</div></li><li><div class=\"code-word\">      warn(\\`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix <span class=\"hljs-keyword\">for</span> Vue internals.\\`)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> has\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208860\">\n                      这里如果 key 以 _ 开头，或者 key 在全局变量的白名单内，则\n                      has 为\n                      false，此时则直接命中警告，不用再进行之前那一系列的判断了。\n                    </p>\n                    <p data-nodeid=\"208861\">\n                      了解完标准化模板或者渲染函数流程，我们来看完成组件实例设置的最后一个流程——兼容\n                      Vue.js 2.x 的 Options API。\n                    </p>\n                    <h4 data-nodeid=\"208862\">Options API：兼容 Vue.js 2.x</h4>\n                    <p data-nodeid=\"208863\">\n                      我们知道 Vue.js 2.x\n                      是通过组件对象的方式去描述一个组件，之前我们也说过，Vue.js\n                      3.0 仍然支持 Vue.js 2.x Options API 的写法，这主要就是通过\n                      applyOptions方法实现的。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\">function <span class=\"hljs-title\">applyOptions</span><span class=\"hljs-params\">(instance, options, deferredData = [], deferredWatch = [], asMixin = <span class=\"hljs-keyword\">false</span>)</span> </span>{\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 组合</span>\n</div></li><li><div class=\"code-word\">    mixins, extends: extendsOptions,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 数组状态</span>\n</div></li><li><div class=\"code-word\">    props: propsOptions, data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 组件和指令</span>\n</div></li><li><div class=\"code-word\">    components, directives,\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 生命周期</span>\n</div></li><li><div class=\"code-word\">    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured } = options;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// instance.proxy 作为 this</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> publicThis = instance.proxy;\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">const</span> ctx = instance.ctx;\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理全局 mixin</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 extend</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理本地 mixins</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// props 已经在外面处理过了</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 inject</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 方法</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 data</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理计算属性</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 watch</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理 provide</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理组件</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理指令</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-comment\">// 处理生命周期 option</span>\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"208865\">\n                      由于 applyOptions\n                      的代码特别长，所以这里我用注释列出了它主要做的事情，感兴趣的同学可以去翻阅它的源码。\n                    </p>\n                    <h3 data-nodeid=\"208866\">总结</h3>\n                    <p data-nodeid=\"208867\">\n                      这节课我们主要分析了组件的初始化流程，主要包括创建组件实例和设置组件实例。通过进一步细节的深入，我们也了解了渲染上下文的代理过程；了解了\n                      Composition API 中的 setup\n                      启动函数执行的时机，以及如何建立 setup\n                      返回结果和模板渲染之间的联系；了解了组件定义的模板或者渲染函数的标准化过程；了解了如何兼容\n                      Vue.js 2.x 的 Options API。\n                    </p>\n                    <p data-nodeid=\"208868\">\n                      我们通过一张图再直观感受一下 Vue.js 3.0 组件的初始化流程：\n                    </p>\n                    <p data-nodeid=\"208869\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/35/74/Ciqc1F8VZvaAYCgKAAHVSzimXjw614.png\"\n                        alt=\"3.png\"\n                        data-nodeid=\"209103\"\n                      />\n                    </p>\n                    <p data-nodeid=\"208870\">\n                      最后，给你留一道思考题目，在执行 setup\n                      函数并获取结果的时候，我们使用 callWithErrorHandling 把\n                      setup 包装了一层，它有哪些好处？欢迎你在留言区与我分享。\n                    </p>\n                    <blockquote data-nodeid=\"208871\">\n                      <p data-nodeid=\"208872\" class=\"te-preview-highlight\">\n                        <strong data-nodeid=\"209116\"\n                          >本节课的相关代码在源代码中的位置如下：</strong\n                        ><br />\n                        packages/runtime-core/src/renderer.ts<br />\n                        packages/runtime-core/src/component.ts<br />\n                        packages/runtime-core/src/componentProxy.ts<br />\n                        packages/runtime-core/src/errorHandling.ts\n                      </p>\n                    </blockquote>\n            "}