{"title":"18 | 性能演进：RN、Flutter、小程序和 Enhance Hybrid","context":"\n                    <p data-nodeid=\"741\" class=\"\">\n                      前面讲的性能优化方案，基本都立足于\n                      Hybrid。这一讲我们来聊聊多端场景下的性能优化方案——RN、Flutter\n                      和小程序。\n                    </p>\n                    <p data-nodeid=\"742\">\n                      RN 即 ReactNative，是 Facebook\n                      开发的开源移动应用架构，它可以让开发者基于 Javascript 和\n                      React.js 开发跨平台移动应用。近一年 RN\n                      非常火，其优势之一是多端开发，另一个最大特点就是渲染性能，我曾使用\n                      RN 做了一个个人中心解决方案，首屏性能可以提升 50%。\n                    </p>\n                    <p data-nodeid=\"743\">\n                      Flutter 是一个由 Google 开发的开源移动方案，与 RN\n                      类似，主要为 Android、IOS\n                      系统开发应用。它的技术架构屏蔽了平台的概念，把多端优势在更底层解决掉了，同时渲染性能更好一点。\n                    </p>\n                    <p data-nodeid=\"744\">\n                      除此之外，Flutter\n                      最大的优势在于提升了开发效率。我曾在实际项目中实验过，相对于\n                      iOS 和 Android 两端开发，它可以降低 40% 的开发成本。\n                    </p>\n                    <p data-nodeid=\"745\">\n                      小程序则是一种不需要下载安装即可在微信平台上使用的程序，它主要为开发者在微信平台上提供服务。使用小程序进行优化时，不像\n                      RN 和 Flutter\n                      拥有良好的性能，需要我们额外做一些事情。下面我就一一为你详细介绍下。\n                    </p>\n                    <h3 data-nodeid=\"746\">RN 原理及其性能优化</h3>\n                    <p data-nodeid=\"747\">\n                      一般在移动端开发中，我们会使用原生应用或者\n                      H5，但它们都有不能忽视的缺点。如果使用原生开发的话，由于客户端发版和版本审核，迭代周期会比较长；而使用\n                      H5\n                      的话，它的性能体验又比较差，不如原生应用流畅。所以，为了解决这两个问题，RN\n                      就出现了。\n                    </p>\n                    <p data-nodeid=\"748\">\n                      RN 会把应用的 JS 代码（包括依赖的 framework）编译成一个\n                      buddle.js（如 iOS 下\n                      index.ios.bundle.js），它整体框架的目的就是解释运行这个 js\n                      文件。如果是 js 扩展的 API，则通过调用 bridge 方法来调用\n                      native 方法。在这个框架下，上线周期和 Hybrid 类似，\n                    </p>\n                    <p data-nodeid=\"749\">\n                      但因为框架层负责跨平台的渲染，渲染效率比 Hybrid\n                      好得多，前端开发者只需要关心如何编写 JS 代码即可。\n                    </p>\n                    <p data-nodeid=\"750\">\n                      有关 RN\n                      的环境搭建和基础使用，我就不多介绍了，这里重点来聊聊 RN\n                      下的性能优化问题。\n                    </p>\n                    <p data-nodeid=\"751\">\n                      2016 年初我使用 RN 改造个人中心页面，当时遇到了两个难题：\n                    </p>\n                    <ol data-nodeid=\"752\">\n                      <li data-nodeid=\"753\">\n                        <p data-nodeid=\"754\">\n                          <strong data-nodeid=\"834\"\n                            >Listview\n                            无限下拉列表初始渲染慢，滚动过程中卡顿体验差的问题；</strong\n                          >\n                        </p>\n                      </li>\n                      <li data-nodeid=\"755\">\n                        <p data-nodeid=\"756\">\n                          <strong data-nodeid=\"838\"\n                            >用户在拍照时，遇到的卡死的问题，根源是调用拍照控件时出现卡顿。</strong\n                          >\n                        </p>\n                      </li>\n                    </ol>\n                    <p data-nodeid=\"757\">\n                      第一个是 RN 的老大难问题了，我最初是通过官方提供的\n                      Flatlist 来解决，但由于 Flatlist\n                      追求比较一致的滑动体验，使用空白的 view\n                      组件进行占位，如果你滑动比较快，会来不及渲染就会出现白屏。后来，我做了技术调研后，在\n                      Native 侧封装了一个原生的<strong data-nodeid=\"844\"\n                        >ListView</strong\n                      >，通过 RN 层来调用解决了这个问题。\n                    </p>\n                    <p data-nodeid=\"758\">\n                      第二个问题，调起照片控件时出现卡顿，后来定位发现，原来是\n                      JS 调用 Native 照片预览时，出现了延迟。\n                    </p>\n                    <p data-nodeid=\"759\">为什么会这样呢？</p>\n                    <p data-nodeid=\"760\">\n                      目前的 RN 框架，是基于大量 JSON\n                      消息序列化和反序列化来进行通信的。它的大致逻辑包括以下两段；\n                    </p>\n                    <ul data-nodeid=\"761\">\n                      <li data-nodeid=\"762\">\n                        <p data-nodeid=\"763\">\n                          从 JS 到 Native 通信，即当 JS 调用 RN 控件时，JS\n                          会把它需要调用的 NativeModule 函数和 NativeModule\n                          对应的名称参数用 JSON 序列化后，传递给 Native，Native\n                          接着会提取并调用对应的 NativeModule 的方法；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"764\">\n                        <p data-nodeid=\"765\">\n                          从 Native 返回向 JS 通信，Native 先通过 CreateInstance\n                          将数据处理成 JSON，再传递给 JS ，JS 完成调用\n                          JSModule，以实现 Native调用 JS 组件的能力。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"766\">\n                      在通讯过程中，如果出现调用延迟，会导致操作后没反应情况的发生。\n                    </p>\n                    <p data-nodeid=\"767\">\n                      <strong data-nodeid=\"855\"\n                        >这就需要通过周期性调用类似 ping\n                        的方式来检测是否出现延迟</strong\n                      >。具体来说，在调用 ping\n                      指令后对时间进行记录，如果时间超过某个阈值，就认为出现延迟了，阻塞延迟后，需要等待该进程结束，而非持续排队调用。\n                    </p>\n                    <p data-nodeid=\"768\">解决过程中，还需要注意两点：</p>\n                    <ul data-nodeid=\"769\">\n                      <li data-nodeid=\"770\">\n                        <p data-nodeid=\"771\">\n                          原有 Hybrid 工程迁移到 RN\n                          过程中，会发现很多新旧功能兼容问题，此时我们可以重新根据\n                          RN 下的体验去设计页面功能，而不是盲目做功能拷贝；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"772\">\n                        <p data-nodeid=\"773\">\n                          提前做好 RN 基础建设，打包编译和热更新流程，尽量和\n                          Hybrid 下的基建体系保持统一。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"774\">Flutter 及其性能优化</h3>\n                    <p data-nodeid=\"775\">\n                      当我们使用 RN 开发移动端应用时，会因为要适配 Android 和\n                      iOS 两端，导致代码复杂度特别高的情况。而使用 Flutter\n                      可以避免这一情况。为什么呢？因为 Flutter\n                      自带的渲染引擎和视图，可以帮我们完成组件层的闭环渲染，避免了像\n                      RN 一样还要在组件层和渲染层分别实现。\n                    </p>\n                    <p data-nodeid=\"776\">请看下方 Flutter 架构实现图。</p>\n                    <p data-nodeid=\"2038\" class=\"te-preview-highlight\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/33/CioPOWB-eO6AeAyPAAC8SpzlFUM337.png\"\n                        alt=\"图片1.png\"\n                        data-nodeid=\"2041\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"778\">\n                      Flutter 框架整体上使用 Dart\n                      语言来实现，并且有着清晰的分层架构。这个分层架构除了让我们调用\n                      Flutter 时更便捷之外，还可以分层调用甚至修改每次层的实现。\n                    </p>\n                    <p data-nodeid=\"779\">\n                      架构图中的 Foundation\n                      层，提供了最基础的绘图、界面刷新，触屏等事件；Rendering\n                      层由 Animation、Painting、Gestures\n                      这几个子模块组成，它对外实现了完整的布局绘制功能，<strong\n                        data-nodeid=\"870\"\n                        >正是这一层让 RN 具备了跨平台渲染能力。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"780\">\n                      在它上一层是 Widgets\n                      ，它是开发者最常接触的一层，也是实现跨平台能力的一层，主要包括文本、图片、输入框动画等。在\n                      Flutter\n                      中，通过这一层可以组合嵌套不同的控件，可以构建出任意功能，任意复杂度的界面。\n                    </p>\n                    <p data-nodeid=\"781\">\n                      最上面的 Material + Cupertino 层提供了一系列控件（如\n                      Material Design 和 iOS style\n                      的控件），它主要用来保证两个平台（IOS 和\n                      Android）上用户体验的一致性。\n                    </p>\n                    <p data-nodeid=\"782\">\n                      正是通过这一层层架构，Flutter\n                      内部闭环实现了跨平台组件、渲染等流程。\n                    </p>\n                    <p data-nodeid=\"783\">\n                      那么，使用 Flutter\n                      ，前端的性能问题一般会出现在哪里呢？我们该如何进行优化？\n                    </p>\n                    <p data-nodeid=\"784\">\n                      用户在使用 Flutter 业务中，遇到的性能问题主要有两大类：\n                    </p>\n                    <ul data-nodeid=\"785\">\n                      <li data-nodeid=\"786\">\n                        <p data-nodeid=\"787\">\n                          用户滑动操作不流畅，因为丢帧导致的卡顿；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"788\">\n                        <p data-nodeid=\"789\">\n                          操作流程被中断，陷入等待，也就是页面资源加载时间过长。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"790\">\n                      为了解决上述问题，我们选定页面滑动的<strong\n                        data-nodeid=\"883\"\n                        >流畅度（FPS）和页面加载耗时</strong\n                      >，作为性能指标。FPS指标的采集，一般借助 mChoreographer 和\n                      CFRunLoop 来实现。但由于这两种方法都是在主线程上进行的，而\n                      Flutter 的绘制是在 UI TaskRunner 中完成，在 GPU TaskRunner\n                      中渲染，所以以往的 FPS 检测方法并不适用于Flutter。\n                    </p>\n                    <p data-nodeid=\"791\">\n                      Flutter 官方也提供了 Performane\n                      Overlay，缺点是无法提供在线监控的性能指标。最后我参考了业界，<strong\n                        data-nodeid=\"889\"\n                        >采用 handleBeginFrame和 handleDrawFrame\n                        之间的时间间隔来计算帧率</strong\n                      >。前者用来启动一个新帧，后者用于帧的绘制。\n                    </p>\n                    <p data-nodeid=\"792\">具体是怎么做的呢？</p>\n                    <p data-nodeid=\"793\">\n                      第一步，在使用 App 进行交互操作，开始时计时，1s\n                      内打印下开始时间 startTime，然后在handleBeginTime\n                      方法回调时进行记录，再在 handleDrawFrame\n                      方法回调时进行记录，结束计时打印下 endTime，将 endTime -\n                      startTime 存储数组 PerfArr 中。\n                    </p>\n                    <p data-nodeid=\"794\">\n                      第二步，计时达到 1s 后，计算刷新次数\n                      PerfArr.length。PerfArr 中超过 16.6ms 的认为丢帧，如果连续\n                      5 帧超过 50ms 则认为卡顿，单帧超过 250ms 则认为严重卡顿。\n                    </p>\n                    <p data-nodeid=\"795\">第三步，根据卡顿进行预警即可。</p>\n                    <h3 data-nodeid=\"796\">小程序及其性能治理方案</h3>\n                    <p data-nodeid=\"797\">\n                      我们在开发 Android 和 iOS App 时，H5\n                      会出现白屏和页面切换不流畅的问题，与此同时，我们也希望 App\n                      可以随时更新，而不需要上架审核。随着技术的发展，小程序作为替代方案就出现了。\n                    </p>\n                    <p data-nodeid=\"798\">\n                      小程序分为微信、支付宝、百度、头条系等多种，在这里我以微信小程序为例介绍下。微信小程序是怎么解决的呢？它主要通过设计一套自己的\n                      Web +\n                      离线包方案来实现，这样既能保证跨平台实时更新，还能保证性能体验。\n                    </p>\n                    <p data-nodeid=\"799\">\n                      同时，小程序还能禁掉一些不合适的标签（如外跳 URL 的 A\n                      标签）和\n                      API（如动态执行脚本的API），减少安全问题。此外它还能避免\n                      JS 操作 DOM，从而提升渲染性能。\n                    </p>\n                    <p data-nodeid=\"800\">以下是小程序的架构设计：</p>\n                    <p data-nodeid=\"1664\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/33/CioPOWB-eOSAG59aAAChoXBKxOY460.png\"\n                        alt=\"图片3.png\"\n                        data-nodeid=\"1667\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"802\">\n                      小程序的渲染层使用 WebView 进行渲染，开发者的 JS\n                      逻辑运行在一个独立的 Jscore 线程中。\n                    </p>\n                    <p data-nodeid=\"803\">\n                      渲染层提供了带有数据绑定语法的 WXML，逻辑层提供了setData\n                      等 API，开发者需要更新界面时，通过 setData\n                      把变化的数据传递过去，小程序框架会根据 Dom Diff\n                      的流程把正确的结果更新在 DOM 树上。\n                    </p>\n                    <p data-nodeid=\"804\">\n                      一般小程序的前端性能，我们主要关注<strong\n                        data-nodeid=\"909\"\n                        >首屏时间</strong\n                      >，也就是用户打开小程序到首屏加载完成的时长。\n                    </p>\n                    <p data-nodeid=\"805\">\n                      2016\n                      年我在做微信支付项目时，收到用户反馈，主程序加载慢。当时我先做了首屏时间的采集，通过\n                      setData 结束时间 -\n                      路由开始时间获取到，发现首屏时间一度超过\n                      5s。为了解决这个性能问题，我们开始结合业务场景和架构图进行了定位。\n                    </p>\n                    <p data-nodeid=\"806\">\n                      当时我们的小程序是放在微信支付的九宫格中的，大概有千万级的流量，公司很多业务都想使用这个流量，于是我们在小程序首页就增加了一个入口逻辑，随着业务增加，首页的代码量也越来越大。\n                    </p>\n                    <p data-nodeid=\"807\">\n                      再看小程序的架构图。我们可以知道，小程序启动时，也分为逻辑层的启动和视图层的启动，逻辑层的启动主要是加载\n                      JS 代码，视图层则是启动 WebView\n                      对页面进行加载和渲染。这也增加了时间。\n                    </p>\n                    <p data-nodeid=\"808\">\n                      经过这么一番分析，我们发现问题出在首页包过大上，它导致逻辑层加载过慢，首屏时间超标。\n                    </p>\n                    <p data-nodeid=\"809\">\n                      最后是怎么解决的呢？我的做法是先整理和清理包资源，比如把小\n                      icon\n                      都统一从网络加载的方案，无用资源及时清除；然后采用分包加载的机制减少首屏时间。\n                    </p>\n                    <p data-nodeid=\"810\">\n                      所谓分包加载，就是根据业务场景，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载。具体在这个项目中，我在主包只保留核心页面，如核心页面导航位及首页信息流等，其他内容（如积分种树功能、公益活动等）都放入子包中。启动时只加载主包，使用时再按需下载子包。这样主包从\n                      1.2M 降低到 0.5M，首屏时间达到微信小程序下首屏时间标准的即\n                      3s。\n                    </p>\n                    <p data-nodeid=\"811\">\n                      这里面的注意事项就是，要在项目方案设计时，就做好代码和资源目录文件的划分，主要功能所依赖的资源，要放在主包里，子包的拆分不需要太细。如果用户在点击到子包目录时，感觉有卡顿，可以做一些预加载处理。\n                    </p>\n                    <h3 data-nodeid=\"812\">小结</h3>\n                    <p data-nodeid=\"1288\">\n                      好了，以上就是\n                      RN、Flutter、小程序等的优化方案。在具体的实施过程中，我们遭遇了不少坑，最大的坑是\n                      RN\n                      方案接入期遇到的。我们在新技术生命周期的“早期采用者”阶段就已经介入了。\n                    </p>\n                    <p data-nodeid=\"1289\" class=\"\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M00/3A/2A/Cgp9HWB-eNuAKyT9AAC2PWHXEiY575.png\"\n                        alt=\"图片2.png\"\n                        data-nodeid=\"1293\"\n                      />\n                    </p>\n\n                    <p data-nodeid=\"815\">\n                      这个阶段 BAT\n                      都没有大规模使用，出现问题后（如页面报错）需要去向\n                      Facebook 开发同学提issue 去解决，往往解决一个问题就需要 2\n                      周时间，业务往往等不及，严重影响了项目进入生产环境的进度。所以建议你以后在采用新技术方案时，尽量在上图的“早期大众”阶段再进入，这个时期很多常见的坑都蹚过了，\n                      Flutter 方案我们就是这么做的。\n                    </p>\n                    <p data-nodeid=\"816\">下面给你留一个问题：</p>\n                    <blockquote data-nodeid=\"817\">\n                      <p data-nodeid=\"818\">\n                        你们现在使用的多端方案有哪些性能优化手段呢？\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"819\" class=\"\">\n                      好了，欢迎在评论区和我沟通，马上进入下一讲，前端技术专业能力与业务产出平衡。\n                    </p>\n            "}