{"title":"07 | 如何面向组件跨层级通信？","context":"\n                    <p data-nodeid=\"1053\" class=\"\">\n                      本讲我们一起来探讨“React\n                      如何面向组件跨层级通信”，这个问题在面试中应该如何回答。\n                    </p>\n                    <h3 data-nodeid=\"1054\">破题</h3>\n                    <p data-nodeid=\"1055\">\n                      “React\n                      如何面向组件跨层级通信”当面试官提出这个问题时，其实是在试探你是否有经手大型前端项目的经验。“跨层级通信”是所有现代前端框架都会遇到的一个场景，并且设计大型前端项目中的组件通信，对于开发人员来说非常具有考验。如何让不同的组件在通信中保持一致性、排除副作用，几乎是所有状态管理框架的开发者都在思考的问题。但这里我们暂时先不讨论这个问题，具体的讲解放在第\n                      15 讲。\n                    </p>\n                    <p data-nodeid=\"1056\">\n                      回到本讲的问题上来，我将类似的问题统称为“列举题”。如果你还有印象的话，应该会记得在<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=566#/detail/pc?id=5795\"\n                        data-nodeid=\"1163\"\n                        >第 05 讲</a\n                      >我们也讲解过类似的问题，解题思路是“一个基本，多个场景”，即先确定主题，再根据场景列举。\n                    </p>\n                    <p data-nodeid=\"1057\">\n                      所以该讲我们还是通过结合实践、丰富场景的方式，来表述面向组件跨层级通信的各个分类。\n                    </p>\n                    <h3 data-nodeid=\"1058\">承题</h3>\n                    <p data-nodeid=\"1059\">\n                      由于 React\n                      是一个组件化框架，那么基于组件树的位置分布，组件与组件之间的关系，大致可分为\n                      4 种。\n                    </p>\n                    <ul data-nodeid=\"1060\">\n                      <li data-nodeid=\"1061\">\n                        <p data-nodeid=\"1062\">\n                          父与子：父组件包裹子组件，父组件向子组件传递数据。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1063\">\n                        <p data-nodeid=\"1064\">\n                          子与父：子组件存在于父组件之中，子组件需要向父组件传递数据。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1065\">\n                        <p data-nodeid=\"1066\">\n                          兄弟：两个组件并列存在于父组件中，需要金属数据进行相互传递。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1067\">\n                        <p data-nodeid=\"1068\">\n                          无直接关系：两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1069\">\n                      基于以上的分类思路，本讲初步的知识导图就有了：\n                    </p>\n                    <p data-nodeid=\"1070\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image2/M01/02/CE/Cip5yF_bAqSAFwQOAABM2wB3-sA868.png\"\n                        alt=\"Drawing 1.png\"\n                        data-nodeid=\"1175\"\n                      />\n                    </p>\n                    <p data-nodeid=\"1071\">\n                      接下来就可以结合不同的布局关系进行一一论述。\n                    </p>\n                    <h3 data-nodeid=\"1072\">入手</h3>\n                    <p data-nodeid=\"1073\">\n                      在具体讲解之前，我需要提醒你一下，<strong\n                        data-nodeid=\"1187\"\n                        >每种通信方式一定都有它实际的意义</strong\n                      >，<strong data-nodeid=\"1188\"\n                        >以及具体的业务场景对应，而不只是代码的呈现</strong\n                      >。所以在回答问题时，一定要结合实际的场景才有说服力，才能让面试官信服。\n                    </p>\n                    <h4 data-nodeid=\"1074\">父与子</h4>\n                    <p data-nodeid=\"1075\">\n                      父与子的通信是最常见的场景，React\n                      开发的每个组件都在使用这样的设计模式。每个组件都会在父级被使用，再传入\n                      Props，完成信息的传递。这样的交互方式尽管不起眼，容易让人忽略，但正是最经典的设计。\n                    </p>\n                    <p data-nodeid=\"1076\">\n                      <strong data-nodeid=\"1194\">Props</strong>\n                    </p>\n                    <p data-nodeid=\"1077\">\n                      那就让我们看看\n                      Props，这个最常用、也最容易忽略的通信方式。就像下面这样的场景：\n                    </p>\n                    <ul data-nodeid=\"1078\">\n                      <li data-nodeid=\"1079\">\n                        <p data-nodeid=\"1080\">在初始化时展示默认文案；</p>\n                      </li>\n                      <li data-nodeid=\"1081\">\n                        <p data-nodeid=\"1082\">\n                          初始化以后通过网络请求拉取文案数据；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1083\">\n                        <p data-nodeid=\"1084\">\n                          通过 Props 传递 state 的文案数据，来更新按钮中的文案。\n                        </p>\n                      </li>\n                    </ul>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Button = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ text }</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">    &lt;button type=<span class=\"hljs-string\">\"button\"</span>&gt;{text}&lt;/button&gt;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">   state = {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"默认文案\"</span>\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">   asyc componentDidMount() {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">'/api/buttonText'</span>)\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">       <span class=\"hljs-attr\">text</span>: response.buttoText\n</div></li><li><div class=\"code-word\">     })\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">          text\n</div></li><li><div class=\"code-word\">        } = <span class=\"hljs-keyword\">this</span>.state\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">            <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">{text}</span> /&gt;</span></span>\n</div></li><li><div class=\"code-word\">        )\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1086\">\n                      这样的通信方式非常适用于<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=566#/detail/pc?id=5795\"\n                        data-nodeid=\"1202\"\n                        >第 05 讲</a\n                      >中提到的展示组件。在这段示例代码中，HomePage\n                      是一个容器组件，而 Button\n                      是一个展示组件。在这样一个设计结构中，这种通信方式就非常常见。\n                    </p>\n                    <h4 data-nodeid=\"1087\">子与父</h4>\n                    <p data-nodeid=\"1088\">子与父的通信主要依赖回调函数。</p>\n                    <p data-nodeid=\"1089\">\n                      <strong data-nodeid=\"1209\">回调函数</strong>\n                    </p>\n                    <p data-nodeid=\"1090\">\n                      回调函数在 JavaScript 中称为 callback。React\n                      在设计中沿用了 JavaScript\n                      的经典设计，允许函数作为参数赋值给子组件。最基础的用法就像下面的例子一样，通过包装传递\n                      text 的值。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Input</span> &nbsp;<span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">   handleChanged = (e) =&gt; {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">this</span>.onChangeText(e.target.text)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">   render() {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> &lt;input onChange={handleTextChanged} /&gt;\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">   handleTextChanged = (text) =&gt; {\n</div></li><li><div class=\"code-word\">     console.log(text)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">            &lt;Input onChangeText={<span class=\"hljs-keyword\">this</span>.handleTextChanged} /&gt;\n</div></li><li><div class=\"code-word\">        )\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1092\">\n                      回调函数不仅仅用于传递值，它还可以用在渲染中，父组件根据返回的结果，决定子组件该渲染什么。比如在\n                      React Router 中，我们常常会这样使用它：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\">&lt;Route path=<span class=\"hljs-string\">\"/hello\"</span> render={() =&gt; <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello Everyone<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>} /&gt;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1094\">\n                      这里的回调函数没用具体的参数，所以我们可以看接下来的案例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FetchPosts</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  state = {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">loading</span>: <span class=\"hljs-literal\">true</span>,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">data</span>: []\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">async</span> componentDidMount() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">'/api/posts'</span>)\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">data</span>: response.data,\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">loading</span>: <span class=\"hljs-literal\">false</span>,\n</div></li><li><div class=\"code-word\">    })\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.state.loading) {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Loading</span> /&gt;</span></span>\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.props.renderPosts(<span class=\"hljs-keyword\">this</span>.state.data)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FetchPosts</span>\n</span></span></div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">renderPosts</span>=<span class=\"hljs-string\">{posts</span> =&gt; (\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          {posts.map(post =&gt; (\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{post.id}</span>&gt;</span>\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>{post.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{post.description}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</div></li><li><div class=\"code-word\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n</div></li><li><div class=\"code-word\">          ))}\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</div></li><li><div class=\"code-word\">      )}\n</div></li><li><div class=\"code-word\">    /&gt;)\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1096\">\n                      采用这样的策略可以使<strong data-nodeid=\"1222\"\n                        >子组件专注业务逻辑</strong\n                      >，而<strong data-nodeid=\"1223\">父组件专注渲染结果</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1097\">\n                      <strong data-nodeid=\"1227\">实例函数</strong>\n                    </p>\n                    <p data-nodeid=\"1098\">\n                      需要注意的是，实例函数是一种<strong data-nodeid=\"1233\"\n                        >不被推荐</strong\n                      >的使用方式。这种通信方式常见于 React\n                      流行初期，那时有很多组件都通过封装 jQuery\n                      插件生成。最常见的一种情况是在 Modal\n                      中使用这种方式。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React from <span class=\"hljs-string\">'react'</span>\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">   modalRef = React.createRef()\n</div></li><li><div class=\"code-word\">   showModal = () ={\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">this</span>.modalRef.show()\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">   hideModal = () =&gt; {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">this</span>.modalRef.hide()\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">const</span> {\n</div></li><li><div class=\"code-word\">          text\n</div></li><li><div class=\"code-word\">        } = <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-function\">state\n</span></div></li><li><div class=\"code-word\">        <span class=\"hljs-title\">return</span> <span class=\"hljs-params\">(\n</span></div></li><li><div class=\"code-word\">            &lt;&gt;\n</div></li><li><div class=\"code-word\">              &lt;Button onClick={<span class=\"hljs-keyword\">this</span>.showModal}&gt;展示 Modal &lt;/Button&gt;\n</div></li><li><div class=\"code-word\">              &lt;Button onClick={<span class=\"hljs-keyword\">this</span>.hideModal}&gt;隐藏 Modal &lt;/Button&gt;\n</div></li><li><div class=\"code-word\">              &lt;Modal ref={modalRef} /&gt;\n</div></li><li><div class=\"code-word\">            &lt;/&gt;\n</div></li><li><div class=\"code-word\">          /&gt;\n</div></li><li><div class=\"code-word\">        )\n</div></li><li><div class=\"code-word\">    }\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1100\">\n                      但这种方式并<strong data-nodeid=\"1239\"\n                        >不符合 React 的设计理念</strong\n                      >，如果你使用过 Antd 的 Modal 组件，你可能会有印象，Antd\n                      将 Modal 显隐的控制放在 visible\n                      参数上，直接通过参数控制。如果你有幸在工作中看到类似的代码，那么这个项目一定有些年头了。\n                    </p>\n                    <h4 data-nodeid=\"1101\">兄弟</h4>\n                    <p data-nodeid=\"1102\">\n                      兄弟组件之间的通信，往往依赖共同的父组件进行中转。可以一起看看下面的案例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Input</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">   handleChanged = <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">this</span>.onChangeText(e.target.text)\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\"> \n</div></li><li><div class=\"code-word\">   render() {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{handleTextChanged}</span> /&gt;</span></span>\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> StaticText = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ children }</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">P</span>&gt;</span>{children}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</div></li><li><div class=\"code-word\">  )\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">   state = {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'默认文案'</span>\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">   handleTextChanged = <span class=\"hljs-function\">(<span class=\"hljs-params\">text</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">       text,\n</div></li><li><div class=\"code-word\">     })\n</div></li><li><div class=\"code-word\">   }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">            <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n</span></div></li><li><div class=\"code-word\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Input</span> <span class=\"hljs-attr\">onChangeText</span>=<span class=\"hljs-string\">{this.handleTextChanged}</span> /&gt;</span>\n</div></li><li><div class=\"code-word\">              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StaticText</span>&gt;</span>this.state.text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StaticText</span>&gt;</span> \n</div></li><li><div class=\"code-word\">            <span class=\"hljs-tag\">&lt;/&gt;</span>\n</div></li><li><div class=\"code-word\">        )\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1104\">\n                      在案例中，StaticText\n                      组件需要显示的内容来自输入框输入的值，那么通过父组件的\n                      state 进行收集、中转、赋值给\n                      StaticText，就完成了以上的通信。\n                    </p>\n                    <p data-nodeid=\"1105\">\n                      这种模式主要负责在<strong data-nodeid=\"1248\"\n                        >容器组件中协调各组件</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"1106\">无直接关系</h4>\n                    <p data-nodeid=\"1107\">\n                      无直接关系就是两个组件的直接关联性并不大，它们身处于多层级的嵌套关系中，既不是父子关系，也不相邻，并且相对遥远，但仍然需要共享数据，完成通信。那具体怎样做呢？我们先从\n                      React 提供的通信方案 Context 说起。\n                    </p>\n                    <p data-nodeid=\"1108\">\n                      <strong data-nodeid=\"1254\">Context</strong>\n                    </p>\n                    <p data-nodeid=\"1109\">\n                      Context 第一个最常见的用途就是做\n                      i18n，也就是常说的国际化语言包。我们一起来看下这个案例：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span>  { createContext } from <span class=\"hljs-string\">'react'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> I18nContext = createContext({\n</div></li><li><div class=\"code-word\">  translate: () =&gt; <span class=\"hljs-string\">''</span>,\n</div></li><li><div class=\"code-word\">  getLocale: () =&gt; {},\n</div></li><li><div class=\"code-word\">  setLocale: () =&gt; {},\n</div></li><li><div class=\"code-word\">});\n</div></li><li><div class=\"code-word\">export <span class=\"hljs-keyword\">default</span> I18nContext;\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1111\">\n                      首先使用&nbsp;React.createContext&nbsp;创建 Context\n                      的初始状态。这里包含三个函数。\n                    </p>\n                    <ul data-nodeid=\"1112\">\n                      <li data-nodeid=\"1113\">\n                        <p data-nodeid=\"1114\">\n                          translate，用于翻译指定的键值。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1115\">\n                        <p data-nodeid=\"1116\">getLocale，获取当前的语言包。</p>\n                      </li>\n                      <li data-nodeid=\"1117\">\n                        <p data-nodeid=\"1118\">setLocale，设置当前的语言包。</p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1119\">\n                      为了代码简洁性，这里包裹了\n                      I18nProvider，提供了一个组件。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React, { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> I18nContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./I18nContext'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">I18nProvider</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">  state = {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-attr\">locale</span>: <span class=\"hljs-string\">''</span>,\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">  render() {\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">const</span> i18n =  {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">translate</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.props.languages[locale][key],\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">getLocale</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.state.locale,\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-attr\">setLocale</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">locale</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">          loacal,\n</div></li><li><div class=\"code-word\">        })\n</div></li><li><div class=\"code-word\">     }\n</div></li><li><div class=\"code-word\">     <span class=\"hljs-keyword\">return</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">I18nContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{i18n}</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        {this.props.children}\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">I18nContext.Provider</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> I18nProvider;\b\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1121\">\n                      如果需要共享 Context\n                      的数据，就需要针对每一个组件包装一次消费者，会带来很多无意义的重复代码。这里你可以用我们在<a\n                        href=\"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=566#/detail/pc?id=5795\"\n                        data-nodeid=\"1264\"\n                        >第 05 讲</a\n                      >讲到的高阶函数来减少它。如以下代码就是通过高阶函数封装消费者的逻辑来减少重复代码的。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> I18nContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./I18nContext'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> withI18n = <span class=\"hljs-function\"><span class=\"hljs-params\">wrappedComponent</span> =&gt;</span> {\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> (\n</div></li><li><div class=\"code-word\">      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">I18nContext.Consumer</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">        {i18n =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WrappedComponent</span> {<span class=\"hljs-attr\">...i18n</span>} {<span class=\"hljs-attr\">...props</span>} /&gt;</span>}\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">I18nContext.Consumer</span>&gt;</span>\n</div></li><li><div class=\"code-word\">    )\n</div></li><li><div class=\"code-word\">};\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withI18n;\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"1123\">\n                      准备工作就绪以后，就需要在最顶层注入 Provider。就像下面第\n                      12 行代码所写的那样。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react-dom'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./App'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">import</span> { I18nProvider } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./i18n'</span>;\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> locales = [ <span class=\"hljs-string\">'en-US'</span>, <span class=\"hljs-string\">'zh-CN'</span> ];\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> languages = {\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'en-US'</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./locales/en-US'</span>),\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-string\">'zh-CN'</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./locales/zh-CN'</span>),\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">ReactDOM.render(\n</div></li><li><div class=\"code-word\">  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">I18nProvider</span> <span class=\"hljs-attr\">locales</span>=<span class=\"hljs-string\">{locales}</span> <span class=\"hljs-attr\">languages</span>=<span class=\"hljs-string\">{languages}</span>&gt;</span>\n</span></div></li><li><div class=\"code-word\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span>\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">I18nProvider</span>&gt;</span>,\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n</div></li><li><div class=\"code-word\">);\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1125\">\n                      接下来就是使用 Context 实现国际化的效果。Title 组件中显示\n                      title 标题的内容，而在 Footer 组件通过 setLocale\n                      函数修改当前显示的语言。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Title = withI18n(\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">(<span class=\"hljs-params\">{ translate }</span>) =&gt;</span> { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> ( <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{translate('title')}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span> )\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">)\n</div></li><li><div class=\"code-word\"><span class=\"hljs-keyword\">const</span> Footer = withI18n(\n</div></li><li><div class=\"code-word\">  <span class=\"hljs-function\">(<span class=\"hljs-params\">{ setLocale }</span>) =&gt;</span> { \n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\"> &lt;Button onClick=((</span>) =&gt;</span> {\n</div></li><li><div class=\"code-word\">      setLocale(<span class=\"hljs-string\">'zh-CN'</span>)\n</div></li><li><div class=\"code-word\">    }) /&gt; )\n</div></li><li><div class=\"code-word\">  }\n</div></li><li><div class=\"code-word\">)\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1127\">\n                      这是一个标准的实现方案，接下来看一个不太推荐的方案。\n                    </p>\n                    <p data-nodeid=\"1128\">\n                      <strong data-nodeid=\"1272\">全局变量与事件</strong>\n                    </p>\n                    <p data-nodeid=\"1129\">\n                      全局变量，顾名思义就是放在 Window\n                      上的变量。但值得注意的是修改 Window 上的变量并不会引起\n                      React 组件重新渲染。（具体有哪些因素会造成 React\n                      重新渲染，你可以回顾一下第 03 讲内容）\n                    </p>\n                    <p data-nodeid=\"1130\">\n                      所以在使用场景上，全局变量更推荐用于暂存临时数据。比如在\n                      CallPage 页面点击了按钮之后，需要收集一个 callId，然后在\n                      ReportPage 上报这个 callId。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"js\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CallPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{ \n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> {\n</span></div></li><li><div class=\"code-word\">              window.callId = this.props.callId\n</div></li><li><div class=\"code-word\">        }} /&gt;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReportPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> {\n</span></div></li><li><div class=\"code-word\">              fetch('/api/report', { id: window.callId })\n</div></li><li><div class=\"code-word\">        }} /&gt;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1132\">\n                      如果在这里使用 Context，会显得有点重，但是只依靠 Window\n                      做值的暂存就会简单很多。那为什么不太推荐这个方案呢？因为它跳出了设计模式，用偷懒换取了快捷，在后续的维护中，如果业务需求发生变更，比如需要在某处显示\n                      callId，在 callId 变化后，就要重新渲染新的 callId。那么\n                      Window\n                      的劣势就暴露无遗了。所以这是一个让人可以暂时忘记架构设计，尽情偷懒的方案，但请不要忘记，技术债迟早是要还的。就像兰尼斯特家的家训——有债必偿。\n                    </p>\n                    <p data-nodeid=\"1133\">\n                      除了全局变量以外，还有一种方案是<strong data-nodeid=\"1281\"\n                        >全局事件</strong\n                      >。如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CallPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">    dispatchEvent = () =&gt; {\n</div></li><li><div class=\"code-word\">        document.dispatchEvent(<span class=\"hljs-keyword\">new</span> CustomEvent(<span class=\"hljs-string\">'callEvent'</span>, {\n</div></li><li><div class=\"code-word\">          detail: {\n</div></li><li><div class=\"code-word\">             callId: <span class=\"hljs-keyword\">this</span>.props.callId\n</div></li><li><div class=\"code-word\">          }\n</div></li><li><div class=\"code-word\">        }))\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> &lt;Button onClick={<span class=\"hljs-keyword\">this</span>.dispatchEvent} /&gt;\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReportPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n</div></li><li><div class=\"code-word\">    state = {\n</div></li><li><div class=\"code-word\">      callId: <span class=\"hljs-keyword\">null</span>,\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    changeCallId = (e) =&gt; {\n</div></li><li><div class=\"code-word\">      <span class=\"hljs-keyword\">this</span>.setState({\n</div></li><li><div class=\"code-word\">        callId: e.detail.callId\n</div></li><li><div class=\"code-word\">      })\n</div></li><li><div class=\"code-word\">    } \n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    componentDidMount() {\n</div></li><li><div class=\"code-word\">        document.addEventListener(<span class=\"hljs-string\">'callEvent'</span>, <span class=\"hljs-keyword\">this</span>.changeCallId)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    componentWillUnmount() {\n</div></li><li><div class=\"code-word\">        document.removeEventListener(<span class=\"hljs-string\">'callEvent'</span>, <span class=\"hljs-keyword\">this</span>.changeCallId)\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">    render() {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">return</span> &lt;Button onClick={() =&gt; {\n</div></li><li><div class=\"code-word\">              fetch(<span class=\"hljs-string\">'/api/report'</span>, { id: <span class=\"hljs-keyword\">this</span>.state.callId })\n</div></li><li><div class=\"code-word\">        }} /&gt;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1135\">\n                      粗看代码，事件的方式让我们可以修改 state\n                      的值，所以可以重新渲染组件。但不要忘记，事件的绑定往往会在组件加载时放入，如果\n                      CallPage 与 ReportPage\n                      不是同时存在于页面上，那么这个方案又不适用了。\n                    </p>\n                    <p data-nodeid=\"1136\">\n                      <strong data-nodeid=\"1286\">状态管理框架</strong>\n                    </p>\n                    <p data-nodeid=\"1137\">\n                      状态管理框架提供了非常丰富的解决方案，常见的有 Flux、Redux\n                      及\n                      Mobx，甚至在一定程度上约束了项目的代码结构。因为这些内容庞杂，所以将会在下一讲中详细介绍。引入第三方的状态管理框架主要困难点在于学习成本相对较高，且整个工程的开发思路也将随着框架的引入而改变。\n                    </p>\n                    <h3 data-nodeid=\"1138\">答题</h3>\n                    <p data-nodeid=\"1139\">综合以上的分析，我们可以答题了。</p>\n                    <blockquote data-nodeid=\"1140\">\n                      <p data-nodeid=\"1141\">\n                        在跨层级通信中，主要分为一层或多层的情况。\n                      </p>\n                      <p data-nodeid=\"1142\">\n                        如果只有一层，那么按照 React\n                        的树形结构进行分类的话，主要有以下三种情况：父组件向子组件通信，子组件向父组件通信以及平级的兄弟组件间互相通信。\n                      </p>\n                      <p data-nodeid=\"1143\">\n                        在父与子的情况下，因为 React 的设计实际上就是传递 Props\n                        即可。那么场景体现在容器组件与展示组件之间，通过 Props\n                        传递 state，让展示组件受控。\n                      </p>\n                      <p data-nodeid=\"1144\">\n                        在子与父的情况下，有两种方式，分别是回调函数与实例函数。回调函数，比如输入框向父级组件返回输入内容，按钮向父级组件传递点击事件等。实例函数的情况有些特别，主要是在父组件中通过\n                        React 的 ref API\n                        获取子组件的实例，然后是通过实例调用子组件的实例函数。这种方式在过去常见于\n                        Modal 框的显示与隐藏。这样的代码风格有着明显的 jQuery\n                        时代特征，在现在的 React\n                        社区中已经很少见了，因为流行的做法是希望组件的所有能力都可以通过\n                        Props 控制。\n                      </p>\n                      <p data-nodeid=\"1145\">\n                        多层级间的数据通信，有两种情况。第一种是一个容器中包含了多层子组件，需要最底部的子组件与顶部组件进行通信。在这种情况下，如果不断透传\n                        Props\n                        或回调函数，不仅代码层级太深，后续也很不好维护。第二种是两个组件不相关，在整个\n                        React\n                        的组件树的两侧，完全不相交。那么基于多层级间的通信一般有三个方案。\n                      </p>\n                      <p data-nodeid=\"1146\">\n                        第一个是使用 React 的 Context\n                        API，最常见的用途是做语言包国际化。\n                      </p>\n                      <p data-nodeid=\"1147\">\n                        第二个是使用全局变量与事件。全局变量通过在 Windows\n                        上挂载新对象的方式实现，这种方式一般用于临时存储值，这种值用于计算或者上报，缺点是渲染显示时容易引发错误。全局事件就是使用\n                        document\n                        的自定义事件，因为绑定事件的操作一般会放在组件的\n                        componentDidMount\n                        中，所以一般要求两个组件都已经在页面中加载显示，这就导致了一定的时序依赖。如果加载时机存在差异，那么很有可能导致两者都没能对应响应事件。\n                      </p>\n                      <p data-nodeid=\"1148\">\n                        第三个是使用状态管理框架，比如 Flux、Redux 及\n                        Mobx。优点是由于引入了状态管理，使得项目的开发模式与代码结构得以约束，缺点是学习成本相对较高。\n                      </p>\n                    </blockquote>\n                    <p data-nodeid=\"1149\">还可以梳理出一个完整的知识框架。</p>\n                    <p data-nodeid=\"1150\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/8A/F2/Ciqc1F_bAvqAGCQcAAC9M-t_bsw991.png\"\n                        alt=\"Drawing 3.png\"\n                        data-nodeid=\"1301\"\n                      />\n                    </p>\n                    <h3 data-nodeid=\"1151\">总结</h3>\n                    <p data-nodeid=\"1152\" class=\"\">\n                      在本讲中，我结合开发实践中的常用案例，为你讲解了组件的跨层级通信方案与具体的适用场景。但本题的答案并不是唯一的，并且每一个方案不是只能解决讲到的问题，它们都有更为广泛的适用场景。我希望你可以在日常工作中积极地寻找对应的场景，只有与自己工作相关的场景才更有记忆点，在面试中才能让面试官耳目一新。当然我们的目标不只是拿下面试官，更是从难题中获得成长。\n                    </p>\n                    <p data-nodeid=\"1153\">\n                      前文中提到了状态管理框架内容十分庞杂，所以在下一讲中，将会把状态管理框架中流行的方案一一详细讲解。\n                    </p>\n                    <p data-nodeid=\"1154\">\n                      <a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"1309\"\n                        ><img\n                          src=\"https://s0.lgstatic.com/i/image/M00/72/94/Ciqc1F_EZ0eANc6tAASyC72ZqWw643.png\"\n                          alt=\"Drawing 2.png\"\n                          data-nodeid=\"1308\"\n                      /></a>\n                    </p>\n                    <p data-nodeid=\"1155\">《大前端高薪训练营》</p>\n                    <p data-nodeid=\"1156\" class=\"\">\n                      对标阿里 P7 技术需求 + 每月大厂内推，6\n                      个月助你斩获名企高薪 Offer。<a\n                        href=\"https://shenceyun.lagou.com/t/mka\"\n                        data-nodeid=\"1314\"\n                        >点击链接</a\n                      >，快来领取！\n                    </p>\n            "}