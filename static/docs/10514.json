{"title":"13 | 排序：经典排序算法原理解析与优劣对比","context":"\n                    <p data-nodeid=\"9075\" class=\"\">\n                      前面课时中，我们学习了分治法的思想，以及二分查找的实现方法。我们讲到，二分查找要求原数组必须有序。其实，由无序到有序，这是算法领域最常见的一类问题，即排序问题。本课时，我们就来学习\n                      4\n                      种常见的排序算法，包括冒泡排序、插入排序、归并排序以及快速排序。此外，我们还会对这\n                      4 种排序算法的优劣势进行详细地对比分析。\n                    </p>\n                    <h3 data-nodeid=\"9076\">什么是排序问题</h3>\n                    <p data-nodeid=\"9077\">\n                      <strong data-nodeid=\"9160\"\n                        >排序，就是让一组无序数据变成有序的过程。</strong\n                      >\n                      一般默认这里的有序都是从小到大的排列顺序。下面我们先来讲讲，如何判断不同的排序算法的优劣。\n                    </p>\n                    <p data-nodeid=\"9078\">\n                      衡量一个排序算法的优劣，我们主要会从以下 3\n                      个角度进行分析：\n                    </p>\n                    <p data-nodeid=\"9079\">\n                      1．<strong data-nodeid=\"9167\">时间复杂度</strong\n                      >，具体包括，最好时间复杂度、最坏时间复杂度以及平均时间复杂度。\n                    </p>\n                    <p data-nodeid=\"9080\">\n                      2．<strong data-nodeid=\"9173\">空间复杂度</strong\n                      >，如果空间复杂度为 1，也叫作原地排序。\n                    </p>\n                    <p data-nodeid=\"9081\">\n                      3．<strong data-nodeid=\"9179\">稳定性</strong\n                      >，排序的稳定性是指相等的数据对象，在排序之后，顺序是否能保证不变。\n                    </p>\n                    <h3 data-nodeid=\"9082\">常见的排序算法及其思想</h3>\n                    <p data-nodeid=\"9083\">\n                      接下来，我们就开始详细地介绍一些经典的排序算法。\n                    </p>\n                    <h4 data-nodeid=\"9084\">冒泡排序</h4>\n                    <p data-nodeid=\"9085\">\n                      1、<strong data-nodeid=\"9187\">冒泡排序的原理</strong>\n                    </p>\n                    <p data-nodeid=\"9086\">\n                      <strong data-nodeid=\"9192\"\n                        >从第一个数据开始，依次比较相邻元素的大小。如果前者大于后者，则进行交换操作，把大的元素往后交换。通过多轮迭代，直到没有交换操作为止。</strong\n                      >\n                      冒泡排序就像是在一个水池中处理数据一样，每次会把最大的那个数据传递到最后。\n                    </p>\n                    <p data-nodeid=\"9087\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/29/0F/CgqCHl75xgeAF_xkABrEk0C0heo355.gif\"\n                        alt=\"动画1.gif\"\n                        data-nodeid=\"9195\"\n                      />\n                    </p>\n                    <p data-nodeid=\"9088\">\n                      2、<strong data-nodeid=\"9200\">冒泡排序的性能</strong>\n                    </p>\n                    <p data-nodeid=\"9089\">\n                      <strong data-nodeid=\"9205\"\n                        >冒泡排序最好时间复杂度是 O(n)</strong\n                      >，也就是当输入数组刚好是顺序的时候，只需要挨个比较一遍就行了，不需要做交换操作，所以时间复杂度为\n                      O(n)。\n                    </p>\n                    <p data-nodeid=\"9090\">\n                      <strong data-nodeid=\"9214\"\n                        >冒泡排序最坏时间复杂度会比较惨，是 O(n*n)</strong\n                      >。也就是说当数组刚好是完全逆序的时候，每轮排序都需要挨个比较\n                      n 次，并且重复 n 次，所以时间复杂度为 O(n*n)。\n                    </p>\n                    <p data-nodeid=\"9091\">\n                      很显然，<strong data-nodeid=\"9222\"\n                        >当输入数组杂乱无章时，它的平均时间复杂度也是\n                        O(n*n)</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9092\">\n                      <strong data-nodeid=\"9227\"\n                        >冒泡排序不需要额外的空间，所以空间复杂度是\n                        O(1)。冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定的排序算法</strong\n                      >。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, -<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span> };\n</div></li><li><div class=\"code-word\">\tSystem.out.println(<span class=\"hljs-string\">\"原始数据: \"</span> + Arrays.toString(arr));\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; arr.length - i; j++) {\n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"hljs-number\">1</span>]) {\n</div></li><li><div class=\"code-word\">\t\t\t\t<span class=\"hljs-keyword\">int</span> temp = arr[j];\n</div></li><li><div class=\"code-word\">\t\t\t\tarr[j] = arr[j + <span class=\"hljs-number\">1</span>];\n</div></li><li><div class=\"code-word\">\t\t\t\tarr[j + <span class=\"hljs-number\">1</span>] = temp;\n</div></li><li><div class=\"code-word\">\t\t\t} \n</div></li><li><div class=\"code-word\">\t\t}\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\tSystem.out.println(<span class=\"hljs-string\">\"冒泡排序: \"</span> + Arrays.toString(arr));\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"9094\">插入排序</h4>\n                    <p data-nodeid=\"9095\">\n                      1、<strong data-nodeid=\"9233\">插入排序的原理</strong>\n                    </p>\n                    <p data-nodeid=\"9096\">\n                      <strong data-nodeid=\"9238\"\n                        >选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空</strong\n                      >。插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全都完成插入的动作。\n                    </p>\n                    <p data-nodeid=\"9097\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/29/10/CgqCHl75xmqAXrQnAB7zyryidSU192.gif\"\n                        alt=\"动画2.gif\"\n                        data-nodeid=\"9241\"\n                      />\n                    </p>\n                    <p data-nodeid=\"9098\">\n                      2、<strong data-nodeid=\"9246\">插入排序的性能</strong>\n                    </p>\n                    <p data-nodeid=\"9099\">\n                      <strong data-nodeid=\"9251\"\n                        >插入排序最好时间复杂度是 O(n)</strong\n                      >，即当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置。这个过程重复\n                      n 次，就可以清空未排序区间。\n                    </p>\n                    <p data-nodeid=\"9100\">\n                      <strong data-nodeid=\"9260\"\n                        >插入排序最坏时间复杂度则需要 O(n*n)</strong\n                      >。即当数组刚好是完全逆序时，每次都要比较 n\n                      次才能找到正确位置。这个过程重复 n\n                      次，就可以清空未排序区间，所以最坏时间复杂度为 O(n*n)。\n                    </p>\n                    <p data-nodeid=\"9101\">\n                      <strong data-nodeid=\"9269\"\n                        >插入排序的平均时间复杂度是 O(n*n)</strong\n                      >。这是因为往数组中插入一个元素的平均时间复杂度为\n                      O(n)，而插入排序可以理解为重复 n\n                      次的数组插入操作，所以平均时间复杂度为 O(n*n)。\n                    </p>\n                    <p data-nodeid=\"9102\">\n                      <strong data-nodeid=\"9274\"\n                        >插入排序不需要开辟额外的空间，所以空间复杂度是\n                        O(1)</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9103\">\n                      根据上面的例子可以发现，<strong data-nodeid=\"9280\"\n                        >插入排序是稳定的排序算法</strong\n                      >。代码如下：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">34</span> };\n</div></li><li><div class=\"code-word\">\tSystem.out.println(<span class=\"hljs-string\">\"原始数据: \"</span> + Arrays.toString(arr));\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">int</span> temp = arr[i];\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">int</span> j = i - <span class=\"hljs-number\">1</span>;\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">for</span> (; j &gt;= <span class=\"hljs-number\">0</span>; j--) {\n</div></li><li><div class=\"code-word\">\t\t\t<span class=\"hljs-keyword\">if</span> (arr[j] &gt; temp) {\n</div></li><li><div class=\"code-word\">\t\t\t\tarr[j + <span class=\"hljs-number\">1</span>] = arr[j];\n</div></li><li><div class=\"code-word\">\t\t\t} <span class=\"hljs-keyword\">else</span> {\n</div></li><li><div class=\"code-word\">\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n</div></li><li><div class=\"code-word\">\t\t\t}\n</div></li><li><div class=\"code-word\">\t\t}\n</div></li><li><div class=\"code-word\">\t\tarr[j + <span class=\"hljs-number\">1</span>] = temp;\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\tSystem.out.println(<span class=\"hljs-string\">\"插入排序: \"</span> + Arrays.toString(arr));\t\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <h4 data-nodeid=\"9105\">\n                      小结：插入排序和冒泡排序算法的异同点\n                    </h4>\n                    <p data-nodeid=\"9106\">\n                      接下来我们来比较一下上面这两种排序算法的异同点：\n                    </p>\n                    <p data-nodeid=\"9107\">\n                      <strong data-nodeid=\"9286\">相同点</strong>\n                    </p>\n                    <ul data-nodeid=\"9108\">\n                      <li data-nodeid=\"9109\">\n                        <p data-nodeid=\"9110\">\n                          插入排序和冒泡排序的平均时间复杂度都是\n                          O(n*n)，且都是稳定的排序算法，都属于原地排序。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9111\">\n                      <strong data-nodeid=\"9293\">差异点</strong>\n                    </p>\n                    <ul data-nodeid=\"9112\">\n                      <li data-nodeid=\"9113\">\n                        <p data-nodeid=\"9114\">\n                          冒泡排序每轮的交换操作是动态的，所以需要三个赋值操作才能完成；\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9115\">\n                        <p data-nodeid=\"9116\">\n                          而插入排序每轮的交换动作会固定待插入的数据，因此只需要一步赋值操作。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9117\">\n                      以上两种排序算法都比较简单，通过这两种算法可以帮助我们对排序的思想建立基本的了解，接下来再介绍一些时间复杂度更低的排序算法，它们的时间复杂度都可以达到\n                      O(nlogn)。\n                    </p>\n                    <h4 data-nodeid=\"9118\">归并排序</h4>\n                    <p data-nodeid=\"9119\">\n                      1、<strong data-nodeid=\"9302\">归并排序的原理</strong>\n                    </p>\n                    <p data-nodeid=\"9120\">\n                      <strong data-nodeid=\"9307\"\n                        >归并排序的原理其实就是我们上一课时讲的分治法</strong\n                      >。它首先将数组不断地二分，直到最后每个部分只包含 1\n                      个数据。然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了。\n                    </p>\n                    <p data-nodeid=\"9121\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/29/04/Ciqc1F75xq2APVN0ACXGvhT4W44926.gif\"\n                        alt=\"动画3.gif\"\n                        data-nodeid=\"9310\"\n                      />\n                    </p>\n                    <p data-nodeid=\"9122\">代码如下：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">49</span>, <span class=\"hljs-number\">38</span>, <span class=\"hljs-number\">65</span>, <span class=\"hljs-number\">97</span>, <span class=\"hljs-number\">76</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">27</span>, <span class=\"hljs-number\">50</span> };\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span>[] tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[arr.length];\n</div></li><li><div class=\"code-word\">    System.out.println(<span class=\"hljs-string\">\"原始数据: \"</span> + Arrays.toString(arr));\n</div></li><li><div class=\"code-word\">    customMergeSort(arr, tmp, <span class=\"hljs-number\">0</span>, arr.length - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">    System.out.println(<span class=\"hljs-string\">\"归并排序: \"</span> + Arrays.toString(arr));\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customMergeSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] tmp, <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">if</span> (start &lt; end) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">int</span> mid = (start + end) / <span class=\"hljs-number\">2</span>;\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 对左侧子序列进行递归排序</span>\n</div></li><li><div class=\"code-word\">        customMergeSort(a, tmp, start, mid);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 对右侧子序列进行递归排序</span>\n</div></li><li><div class=\"code-word\">        customMergeSort(a, tmp,mid + <span class=\"hljs-number\">1</span>, end);\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-comment\">// 合并</span>\n</div></li><li><div class=\"code-word\">        customDoubleMerge(a, tmp, start, mid, end);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customDoubleMerge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span>[] tmp, <span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> mid, <span class=\"hljs-keyword\">int</span> right)</span> </span>{\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">int</span> p1 = left, p2 = mid + <span class=\"hljs-number\">1</span>, k = left;\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) {\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">if</span> (a[p1] &lt;= a[p2])\n</div></li><li><div class=\"code-word\">            tmp[k++] = a[p1++];\n</div></li><li><div class=\"code-word\">        <span class=\"hljs-keyword\">else</span>\n</div></li><li><div class=\"code-word\">            tmp[k++] = a[p2++];\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (p1 &lt;= mid)\n</div></li><li><div class=\"code-word\">        tmp[k++] = a[p1++];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">while</span> (p2 &lt;= right)\n</div></li><li><div class=\"code-word\">        tmp[k++] = a[p2++];\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-comment\">// 复制回原素组</span>\n</div></li><li><div class=\"code-word\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = left; i &lt;= right; i++)\n</div></li><li><div class=\"code-word\">        a[i] = tmp[i];\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"9124\">\n                      2、<strong data-nodeid=\"9316\">归并排序的性能</strong>\n                    </p>\n                    <p data-nodeid=\"9125\">\n                      <strong data-nodeid=\"9321\"\n                        >对于归并排序，它采用了二分的迭代方式，复杂度是\n                        logn</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9126\">\n                      每次的迭代，需要对两个有序数组进行合并，这样的动作在 O(n)\n                      的时间复杂度下就可以完成。因此，**归并排序的复杂度就是二者的乘积\n                      O(nlogn)。**同时，<strong data-nodeid=\"9333\"\n                        >它的执行频次与输入序列无关，因此，归并排序最好、最坏、平均时间复杂度都是\n                        O(nlogn)</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9127\">\n                      <strong data-nodeid=\"9342\"\n                        >空间复杂度方面，由于每次合并的操作都需要开辟基于数组的临时内存空间，所以空间复杂度为\n                        O(n)</strong\n                      >。归并排序合并的时候，相同元素的前后顺序不变，所以<strong\n                        data-nodeid=\"9343\"\n                        >归并是稳定的排序算法</strong\n                      >。\n                    </p>\n                    <h4 data-nodeid=\"9128\">快速排序</h4>\n                    <p data-nodeid=\"9129\">\n                      1、<strong data-nodeid=\"9349\">快速排序法的原理</strong>\n                    </p>\n                    <p data-nodeid=\"9130\">\n                      <strong data-nodeid=\"9354\"\n                        >快速排序法的原理也是分治法</strong\n                      >。它的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为\n                      1，则完成排序。\n                    </p>\n                    <p data-nodeid=\"9131\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image/M00/29/05/Ciqc1F75x8KAROF9AFLsWEVvUPU075.gif\"\n                        alt=\"动画4.gif\"\n                        data-nodeid=\"9357\"\n                      />\n                    </p>\n                    <p data-nodeid=\"9132\">代码参考：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"java\"><ol><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span>[] arr = { <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span> };\n</div></li><li><div class=\"code-word\">\tSystem.out.println(<span class=\"hljs-string\">\"原始数据: \"</span> + Arrays.toString(arr));\n</div></li><li><div class=\"code-word\">\tcustomQuickSort(arr, <span class=\"hljs-number\">0</span>, arr.length - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">\tSystem.out.println(<span class=\"hljs-string\">\"快速排序: \"</span> + Arrays.toString(arr));\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customQuickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> low, <span class=\"hljs-keyword\">int</span> high)</span> </span>{\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">int</span> i, j, temp, t;\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">if</span> (low &gt;= high) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">return</span>;\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\n</div></li><li><div class=\"code-word\">\ti = low;\n</div></li><li><div class=\"code-word\">\tj = high;\n</div></li><li><div class=\"code-word\">\ttemp = arr[low];\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-keyword\">while</span> (i &lt; j) {\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-comment\">// 先看右边，依次往左递减</span>\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">while</span> (temp &lt;= arr[j] &amp;&amp; i &lt; j) {\n</div></li><li><div class=\"code-word\">\t\t\tj--;\n</div></li><li><div class=\"code-word\">\t\t}\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-comment\">// 再看左边，依次往右递增</span>\n</div></li><li><div class=\"code-word\">\t\t<span class=\"hljs-keyword\">while</span> (temp &gt;= arr[i] &amp;&amp; i &lt; j) {\n</div></li><li><div class=\"code-word\">\t\t\ti++;\n</div></li><li><div class=\"code-word\">\t\t}\n</div></li><li><div class=\"code-word\">\t\tt = arr[j];\n</div></li><li><div class=\"code-word\">\t\tarr[j] = arr[i];\n</div></li><li><div class=\"code-word\">\t\tarr[i] = t;\n</div></li><li><div class=\"code-word\">\t}\n</div></li><li><div class=\"code-word\">\tarr[low] = arr[i];\n</div></li><li><div class=\"code-word\">\tarr[i] = temp;\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 递归调用左半数组</span>\n</div></li><li><div class=\"code-word\">\tcustomQuickSort(arr, low, j - <span class=\"hljs-number\">1</span>);\n</div></li><li><div class=\"code-word\">\t<span class=\"hljs-comment\">// 递归调用右半数组</span>\n</div></li><li><div class=\"code-word\">\tcustomQuickSort(arr, j + <span class=\"hljs-number\">1</span>, high);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n\n                    <p data-nodeid=\"9134\" class=\"\">\n                      2、<strong data-nodeid=\"9363\">快速排序法的性能</strong>\n                    </p>\n                    <p data-nodeid=\"9135\">\n                      <strong data-nodeid=\"9374\"\n                        >在快排的最好时间的复杂度下</strong\n                      >，如果每次选取分区点时，都能选中中位数，把数组等分成两个，那么<strong\n                        data-nodeid=\"9375\"\n                        >此时的时间复杂度和归并一样，都是 O(n*logn)</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9136\">\n                      <strong data-nodeid=\"9386\">而在最坏的时间复杂度下</strong\n                      >，也就是如果每次分区都选中了最小值或最大值，得到不均等的两组。那么就需要\n                      n 次的分区操作，每次分区平均扫描 n / 2 个元素，<strong\n                        data-nodeid=\"9387\"\n                        >此时时间复杂度就退化为 O(n*n) 了</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9137\">\n                      <strong data-nodeid=\"9394\"\n                        >快速排序法在大部分情况下，统计上是很难选到极端情况的。因此它平均的时间复杂度是\n                        O(n*logn)</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9138\">\n                      <strong data-nodeid=\"9399\"\n                        >快速排序法的空间方面，使用了交换法，因此空间复杂度为\n                        O(1)</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9139\">\n                      很显然，快速排序的分区过程涉及交换操作，所以<strong\n                        data-nodeid=\"9405\"\n                        >快排是不稳定的排序算法</strong\n                      >。\n                    </p>\n                    <h3 data-nodeid=\"9140\">排序算法的性能分析</h3>\n                    <p data-nodeid=\"9141\">\n                      我们先思考一下排序算法性能的下限，也就是最差的情况。在前面的课程中，我们写过求数组最大值的代码，它的时间复杂度是\n                      O(n)。对于 n 个元素的数组，只要重复执行 n\n                      次最大值的查找就能完成排序。因此<strong data-nodeid=\"9414\"\n                        >排序最暴力的方法，时间复杂度是\n                        O(n*n)。这恰如冒泡排序和插入排序</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"9142\">\n                      <strong data-nodeid=\"9422\"\n                        >当我们利用算法思维去解决问题时，就会想到尝试分治法。此时，利用归并排序就能让时间复杂度降低到\n                        O(nlogn)</strong\n                      >。然而，<strong data-nodeid=\"9423\"\n                        >归并排序需要额外开辟临时空间。一方面是为了保证稳定性，另一方面则是在归并时，由于在数组中插入元素导致了数据挪移的问题。</strong\n                      >\n                    </p>\n                    <p data-nodeid=\"9143\">\n                      <strong data-nodeid=\"9428\"\n                        >为了规避因此而带来的时间损耗，此时我们采用快速排序</strong\n                      >。通过交换操作，可以解决插入元素导致的数据挪移问题，而且降低了不必要的空间开销。但是由于其动态二分的交换数据，导致了由此得出的排序结果并不稳定。\n                    </p>\n                    <h3 data-nodeid=\"9144\">总结</h3>\n                    <p data-nodeid=\"9145\">\n                      本课时我们讲了4\n                      种常见的排序算法，包括冒泡排序、插入排序、归并排序以及快速排序。这些经典算法没有绝对的好和坏，它们各有利弊。在工作过程中，需要你根据实际问题的情况来选择最优的排序算法。\n                    </p>\n                    <p data-nodeid=\"9146\">\n                      <strong data-nodeid=\"9439\"\n                        >如果对数据规模比较小的数据进行排序，可以选择时间复杂度为\n                        O(n*n) 的排序算法</strong\n                      >。因为当数据规模小的时候，时间复杂度 O(nlogn) 和 O(n*n)\n                      的区别很小，它们之间仅仅相差几十毫秒，因此对实际的性能影响并不大。\n                    </p>\n                    <p data-nodeid=\"9147\">\n                      <strong data-nodeid=\"9444\"\n                        >但对数据规模比较大的数据进行排序，就需要选择时间复杂度为\n                        O(nlogn) 的排序算法了</strong\n                      >。\n                    </p>\n                    <ul data-nodeid=\"9148\">\n                      <li data-nodeid=\"9149\">\n                        <p data-nodeid=\"9150\">\n                          归并排序的空间复杂度为 O(n)，也就意味着当排序 100M\n                          的数据，就需要 200M 的空间，所以对空间资源消耗会很多。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"9151\">\n                        <p data-nodeid=\"9152\">\n                          快速排序在平均时间复杂度为\n                          O(nlogn)，但是如果分区点选择不好的话，最坏的时间复杂度也有可能逼近\n                          O(n*n)。而且快速排序不具备稳定性，这也需要看你所面对的问题是否有稳定性的需求。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"9153\" class=\"\">\n                      最后，如果你在工作中，遇到了与排序相关的困难或经验，欢迎你在留言区和我分享。\n                    </p>\n            "}