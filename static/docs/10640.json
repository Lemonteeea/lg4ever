{"title":"39 | 责任链模式：如何解决审核、过滤场景问题？","context":"\n                    <p data-nodeid=\"1089\" class=\"\">\n                      相较而言，责任链模式是一个使用频率很高的模式，它是我们所讲的最后一个行为型设计模式了，并且这也是整个课程的最后一讲。今天，我除了会带你搞清楚责任链模式的原理和实现外，还会对行为型设计模式做一次整体的总结。\n                    </p>\n                    <p data-nodeid=\"1090\">话不多说，让我们开始今天的学习吧。</p>\n                    <h3 data-nodeid=\"1091\">模式原理分析</h3>\n                    <p data-nodeid=\"1092\">\n                      责任链模式的原始定义是：通过为多个对象提供处理请求的机会，避免将请求的发送者与其接收者耦合。链接接收对象并沿着链传递请求，直到对象处理它。\n                    </p>\n                    <p data-nodeid=\"1093\">\n                      这个定义读起来还是有点抽象难懂，实际上它只说了一个关键点：<strong\n                        data-nodeid=\"1191\"\n                        >通过构建一个处理流水线来对一次请求进行多次的处理</strong\n                      >。\n                    </p>\n                    <p data-nodeid=\"1094\">\n                      这里我们结合购物的例子来解释下：当你收到了购买的商品后，发现商品有质量问题，于是你打电话询问客服关于退货的流程，客服接到你的电话后，会先打开订单系统查询你提供的订单信息并确认是否正确，确认后再使用物流系统通知快递小哥上门取件，快递小哥取件后会返回商品让仓储系统进行确认，并通知商品系统……这样的一个过程就是责任链模式的真实应用。\n                    </p>\n                    <p data-nodeid=\"1637\">\n                      那么，我们先来看看责任链模式的 UML 图：\n                    </p>\n                    <p data-nodeid=\"2197\">\n                      <img\n                        src=\"https://s0.lgstatic.com/i/image6/M01/4F/B4/Cgp9HWD6qceAZgzWAAFnVYgF1Ak441.jpg\"\n                        alt=\"设计模式 39 插图 01.jpg\"\n                        data-nodeid=\"2201\"\n                      />\n                    </p>\n                    <div data-nodeid=\"2752\" class=\"te-preview-highlight\">\n                      <p style=\"text-align: center\">责任链模式的 UML 图</p>\n                    </div>\n\n                    <p data-nodeid=\"1097\">\n                      从该 UML 图中，我们能看出责任链模式其实只有两个关键角色。\n                    </p>\n                    <ul data-nodeid=\"1098\">\n                      <li data-nodeid=\"1099\">\n                        <p data-nodeid=\"1100\">\n                          <strong data-nodeid=\"1200\">处理类（Handler）</strong\n                          >：可以是一个接口，用于接收请求并将请求分派到处理程序链条中（实际上就是一个数组链表），其中，会先将链中的第一个处理程序放入开头来处理。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1101\">\n                        <p data-nodeid=\"1102\">\n                          <strong data-nodeid=\"1205\"\n                            >具体处理类（HandlerA、B、C）</strong\n                          >：按照链条顺序对请求进行具体处理。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1103\">\n                      下面我们再来看看该 UML 对应的代码实现：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public interface Handler {\n</div></li><li><div class=\"code-word\">    void setNext(Handler handler);\n</div></li><li><div class=\"code-word\">    void handle(Request request);\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class Request {\n</div></li><li><div class=\"code-word\">    private String data;\n</div></li><li><div class=\"code-word\">    public String getData() {\n</div></li><li><div class=\"code-word\">        return data;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    public void setData(String data) {\n</div></li><li><div class=\"code-word\">        this.data = data;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class HandlerA implements Handler{\n</div></li><li><div class=\"code-word\">    private Handler next;\n</div></li><li><div class=\"code-word\">    public HandlerA() {\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void setNext(Handler handler) {\n</div></li><li><div class=\"code-word\">        this.next = handler;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void handle(Request request) {\n</div></li><li><div class=\"code-word\">        System.out.println(\"HandlerA 执行 代码逻辑，处理：\"+request.getData());\n</div></li><li><div class=\"code-word\">        request.setData(request.getData().replace(\"AB\",\"\"));\n</div></li><li><div class=\"code-word\">        if (null != next) {\n</div></li><li><div class=\"code-word\">            next.handle(request);\n</div></li><li><div class=\"code-word\">        } else {\n</div></li><li><div class=\"code-word\">            System.out.println(\"执行中止！\");\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class HandlerB implements Handler {\n</div></li><li><div class=\"code-word\">    private Handler next;\n</div></li><li><div class=\"code-word\">    public HandlerB() {\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void setNext(Handler handler) {\n</div></li><li><div class=\"code-word\">        this.next = handler;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void handle(Request request) {\n</div></li><li><div class=\"code-word\">        System.out.println(\"HandlerB 执行 代码逻辑，处理：\"+request.getData());\n</div></li><li><div class=\"code-word\">        request.setData(request.getData().replace(\"CD\",\"\"));\n</div></li><li><div class=\"code-word\">        if (null != next) {\n</div></li><li><div class=\"code-word\">            next.handle(request);\n</div></li><li><div class=\"code-word\">        } else {\n</div></li><li><div class=\"code-word\">            System.out.println(\"执行中止！\");\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class HandlerC implements Handler{\n</div></li><li><div class=\"code-word\">    private Handler next;\n</div></li><li><div class=\"code-word\">    public HandlerC() {\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void setNext(Handler handler) {\n</div></li><li><div class=\"code-word\">        this.next = handler;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void handle(Request request) {\n</div></li><li><div class=\"code-word\">        System.out.println(\"HandlerC 执行 代码逻辑，处理：\"+request.getData());\n</div></li><li><div class=\"code-word\">        if (null != next) {\n</div></li><li><div class=\"code-word\">            next.handle(request);\n</div></li><li><div class=\"code-word\">        } else {\n</div></li><li><div class=\"code-word\">            System.out.println(\"执行中止！\");\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class Demo {\n</div></li><li><div class=\"code-word\">    public static void main(String[] args) {\n</div></li><li><div class=\"code-word\">        Handler h1 = new HandlerA();\n</div></li><li><div class=\"code-word\">        Handler h2 = new HandlerB();\n</div></li><li><div class=\"code-word\">        Handler h3 = new HandlerC();\n</div></li><li><div class=\"code-word\">        h1.setNext(h2);\n</div></li><li><div class=\"code-word\">        h2.setNext(h3);\n</div></li><li><div class=\"code-word\">        Request request = new Request();\n</div></li><li><div class=\"code-word\">        request.setData(\"请求数据ABCDE\");\n</div></li><li><div class=\"code-word\">        h1.handle(request);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">//输出结果\n</div></li><li><div class=\"code-word\">HandlerA 执行 代码逻辑，处理：请求数据ABCDE\n</div></li><li><div class=\"code-word\">HandlerB 执行 代码逻辑，处理：请求数据CDE\n</div></li><li><div class=\"code-word\">HandlerC 执行 代码逻辑，处理：请求数据E\n</div></li><li><div class=\"code-word\">执行中止！\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1105\">\n                      从这段代码实现可以看出，责任链模式的实现非常简单，每一个具体的处理类都会保存在它之后的下一个处理类。当处理完成后，就会调用设置好的下一个处理类，直到最后一个处理类不再设置下一个处理类，这时处理链条全部完成。在代码示例中，HandlerA\n                      删除掉字符串 ABCDE 中的 AB，并交给 HandlerB 处理；HandlerB\n                      删除掉 CDE 中的 CD，并交给 HandlerC；HandlerC\n                      处理完后，整个执行过程中止。\n                    </p>\n                    <h3 data-nodeid=\"1106\">使用场景分析</h3>\n                    <p data-nodeid=\"1107\">\n                      责任链模式常见的使用场景有以下几种情况。\n                    </p>\n                    <ul data-nodeid=\"1108\">\n                      <li data-nodeid=\"1109\">\n                        <p data-nodeid=\"1110\">\n                          <strong data-nodeid=\"1214\"\n                            >在运行时需要动态使用多个关联对象来处理同一次请求时</strong\n                          >。比如，请假流程、员工入职流程、编译打包发布上线流程等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1111\">\n                        <p data-nodeid=\"1112\">\n                          <strong data-nodeid=\"1219\"\n                            >不想让使用者知道具体的处理逻辑时</strong\n                          >。比如，做权限校验的登录拦截器。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1113\">\n                        <p data-nodeid=\"1114\">\n                          <strong data-nodeid=\"1224\"\n                            >需要动态更换处理对象时</strong\n                          >。比如，工单处理系统、网关 API 过滤规则系统等。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1115\">\n                      为了帮助你更好地理解责任链模式的使用场景，下面我们通过一个简单的例子来为你演示。\n                    </p>\n                    <p data-nodeid=\"1116\">\n                      这里我们要创建一个获取数字并判断正负或零的程序，程序接收一个数字的请求，在链条上进行处理并打印对应的处理结果。\n                    </p>\n                    <p data-nodeid=\"1117\">\n                      我们先创建一个链条\n                      Chain，并设置起始的处理类，如下代码所示：\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public class Chain {\n</div></li><li><div class=\"code-word\">    Excutor chain;\n</div></li><li><div class=\"code-word\">    public Chain(){\n</div></li><li><div class=\"code-word\">        buildChain();\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    private void buildChain(){\n</div></li><li><div class=\"code-word\">        Excutor e1 = new NegativeExcutor();\n</div></li><li><div class=\"code-word\">        Excutor e2 = new ZeroExcutor();\n</div></li><li><div class=\"code-word\">        Excutor e3 = new PositiveExcutor();\n</div></li><li><div class=\"code-word\">        e1.setNext(e2);\n</div></li><li><div class=\"code-word\">        e2.setNext(e3);\n</div></li><li><div class=\"code-word\">        this.chain = e1;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    public void process(Integer num) {\n</div></li><li><div class=\"code-word\">        chain.handle(num);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1119\">\n                      接下来我们创建抽象的处理类 Excutor，声明两个方法：setNext\n                      用于设置下一个处理类，handle 是具体的业务逻辑。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public interface Excutor {\n</div></li><li><div class=\"code-word\">    void setNext(Excutor excutor);\n</div></li><li><div class=\"code-word\">    void handle(Integer num);\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1121\">\n                      NegativeExcutor、PositiveExcutor 和 ZeroExcutor\n                      分别代表处理负数、正数和零。\n                    </p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public class NegativeExcutor implements Excutor {\n</div></li><li><div class=\"code-word\">    private Excutor next;\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void setNext(Excutor excutor) {\n</div></li><li><div class=\"code-word\">        this.next = excutor;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void handle(Integer num) {\n</div></li><li><div class=\"code-word\">        if (null!= num &amp;&amp; num &lt; 0) {\n</div></li><li><div class=\"code-word\">            System.out.println(\"NegativeExcutor获取数字：\"+num+\" ,处理完成！\");\n</div></li><li><div class=\"code-word\">        } else {\n</div></li><li><div class=\"code-word\">            if (null != next) {\n</div></li><li><div class=\"code-word\">                System.out.println(\"===经过NegativeExcutor\");\n</div></li><li><div class=\"code-word\">                next.handle(num);\n</div></li><li><div class=\"code-word\">            } else {\n</div></li><li><div class=\"code-word\">                System.out.println(\"处理中止！-NegativeExcutor\");\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class PositiveExcutor implements Excutor{\n</div></li><li><div class=\"code-word\">    private Excutor next;\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void setNext(Excutor excutor) {\n</div></li><li><div class=\"code-word\">        this.next = excutor;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void handle(Integer num) {\n</div></li><li><div class=\"code-word\">        if (null!= num &amp;&amp; num &gt; 0) {\n</div></li><li><div class=\"code-word\">            System.out.println(\"PositiveExcutor获取数字：\"+num+\" ,处理完成！\");\n</div></li><li><div class=\"code-word\">        } else {\n</div></li><li><div class=\"code-word\">            if (null != next) {\n</div></li><li><div class=\"code-word\">                System.out.println(\"===经过PositiveExcutor\");\n</div></li><li><div class=\"code-word\">                next.handle(num);\n</div></li><li><div class=\"code-word\">            } else {\n</div></li><li><div class=\"code-word\">                System.out.println(\"处理中止！-PositiveExcutor\");\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">public class ZeroExcutor implements Excutor{\n</div></li><li><div class=\"code-word\">    private Excutor next;\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void setNext(Excutor excutor) {\n</div></li><li><div class=\"code-word\">        this.next = excutor;\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">    @Override\n</div></li><li><div class=\"code-word\">    public void handle(Integer num) {\n</div></li><li><div class=\"code-word\">        if (null!= num &amp;&amp; num == 0) {\n</div></li><li><div class=\"code-word\">            System.out.println(\"ZeroExcutor获取数字：\"+num+\" ,处理完成！\");\n</div></li><li><div class=\"code-word\">        } else {\n</div></li><li><div class=\"code-word\">            if (null != next) {\n</div></li><li><div class=\"code-word\">                System.out.println(\"===经过ZeroExcutor\");\n</div></li><li><div class=\"code-word\">                next.handle(num);\n</div></li><li><div class=\"code-word\">            } else {\n</div></li><li><div class=\"code-word\">                System.out.println(\"处理中止！- ZeroExcutor\");\n</div></li><li><div class=\"code-word\">            }\n</div></li><li><div class=\"code-word\">        }\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1123\">最后，运行一个单元测试：</p>\n                    <div class=\"course-code-area\">\n                      <div class=\"copy-btn\">\n                        <div class=\"copy-icon\"></div>\n                        复制代码\n                      </div>\n                      <pre><code data-language=\"plain\"><ol><li><div class=\"code-word\">public class Client {\n</div></li><li><div class=\"code-word\">    public static void main(String[] args) {\n</div></li><li><div class=\"code-word\">        Chain chain = new Chain();\n</div></li><li><div class=\"code-word\">        chain.process(99);\n</div></li><li><div class=\"code-word\">        System.out.println(\"------\");\n</div></li><li><div class=\"code-word\">        chain.process(-11);\n</div></li><li><div class=\"code-word\">        System.out.println(\"------\");\n</div></li><li><div class=\"code-word\">        chain.process(0);\n</div></li><li><div class=\"code-word\">        System.out.println(\"------\");\n</div></li><li><div class=\"code-word\">        chain.process(null);\n</div></li><li><div class=\"code-word\">    }\n</div></li><li><div class=\"code-word\">}\n</div></li><li><div class=\"code-word\">//输出结果\n</div></li><li><div class=\"code-word\">===经过NegativeExcutor\n</div></li><li><div class=\"code-word\">===经过ZeroExcutor\n</div></li><li><div class=\"code-word\">PositiveExcutor获取数字：99 ,处理完成！\n</div></li><li><div class=\"code-word\">------\n</div></li><li><div class=\"code-word\">NegativeExcutor获取数字：-11 ,处理完成！\n</div></li><li><div class=\"code-word\">------\n</div></li><li><div class=\"code-word\">===经过NegativeExcutor\n</div></li><li><div class=\"code-word\">ZeroExcutor获取数字：0 ,处理完成！\n</div></li><li><div class=\"code-word\">------\n</div></li><li><div class=\"code-word\">===经过NegativeExcutor\n</div></li><li><div class=\"code-word\">===经过ZeroExcutor\n</div></li><li><div class=\"code-word\">处理中止！-PositiveExcutor\n</div></li></ol></code></pre>\n                    </div>\n                    <p data-nodeid=\"1125\">\n                      从最后的结果可以看到，当我们输入不同的数时，都会经过一整个链条的流转，直到最终的处理对象完成处理。\n                    </p>\n                    <p data-nodeid=\"1126\">\n                      所以说，责任链模式就像工厂的流水线作业一样，按照某一个标准化的流程来执行，用于规则过滤、Web\n                      请求协议解析等具备链条式的场景中，通过拆分不同的处理节点来完成整个流程的处理。\n                    </p>\n                    <h3 data-nodeid=\"1127\">为什么使用责任链模式？</h3>\n                    <p data-nodeid=\"1128\">\n                      分析完责任链模式的原理和使用场景后，我们再来说说使用责任链模式的原因，可总结为以下三个。\n                    </p>\n                    <p data-nodeid=\"1129\">\n                      <strong data-nodeid=\"1239\"\n                        >第一个，解耦使用者和后台庞大的流程化处理</strong\n                      >。我们都知道，在线购物订单里包含了物流、商品、支付、会员等多个系统的处理逻辑，如果让使用者一一和它们对接，势必会造成使用困难、系统之间调用混乱的情况发生，而通过订单建立一个订单的状态变更流程，就能将这些系统很好地串联在一起，这不仅能够让使用者只需要关注订单流程这一个入口，同时还能够让不同的系统按照各自的职责来发挥作用。比如，订单在未完成支付前，商品系统是不会通知物流系统进行商品发货的。\n                    </p>\n                    <p data-nodeid=\"1130\">\n                      <strong data-nodeid=\"1244\"\n                        >第二个，为了动态更换流程处理中的处理对象</strong\n                      >。比如，在请假流程中，申请人一般会提交申请给直接领导审批，但有时直接领导可能无法进行审批操作，这时系统就可以更换审批人到其他审批人，这样就不会阻塞请假流程的审批。\n                    </p>\n                    <p data-nodeid=\"1131\">\n                      <strong data-nodeid=\"1249\"\n                        >第三个，为了处理一些需要递归遍历的对象列表</strong\n                      >。比如，权限的规则过滤。对于不同部门不同级别人员的权限，就可以采用一个过滤链条来进行权限的管控。\n                    </p>\n                    <h3 data-nodeid=\"1132\">收益什么？损失什么？</h3>\n                    <p data-nodeid=\"1133\">\n                      通过上述分析，我们就可以总结出使用责任链模式的优点。\n                    </p>\n                    <ul data-nodeid=\"1134\">\n                      <li data-nodeid=\"1135\">\n                        <p data-nodeid=\"1136\">\n                          <strong data-nodeid=\"1256\"\n                            >降低客户端对象与处理链条上对象之间的耦合度</strong\n                          >。比如，提交上线审核，提交人只知道最开始申请的处理人是谁，而后续是否需要别的审核人其实是由处理链条来控制的。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1137\">\n                        <p data-nodeid=\"1138\">\n                          <strong data-nodeid=\"1261\">提升系统扩展性</strong\n                          >。对于需要多次处理的同一个请求，可以在链条上增加新的具体处理类，满足开闭原则，能极大地提升系统扩展性。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1139\">\n                        <p data-nodeid=\"1140\">\n                          <strong data-nodeid=\"1266\"\n                            >增强了具体处理类的职责独立性</strong\n                          >。即便链条上的工作流程发生了变化，也可以动态地改变具体处理类的调用次序和增加类的新的职责。每个类只需要处理自己该处理的工作，不该处理的就传递给下一个对象完成，明确各类的责任范围，同时也符合类的单一职责原则。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1141\">\n                        <p data-nodeid=\"1142\">\n                          <strong data-nodeid=\"1271\"\n                            >简化了对象之间前后关联处理的复杂性</strong\n                          >。每个对象只需存储一个指向后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的\n                          if 或者 if···else 语句。\n                        </p>\n                      </li>\n                    </ul>\n                    <p data-nodeid=\"1143\">同样，责任链模式也有一些缺点。</p>\n                    <ul data-nodeid=\"1144\">\n                      <li data-nodeid=\"1145\">\n                        <p data-nodeid=\"1146\">\n                          <strong data-nodeid=\"1277\">降低性能</strong\n                          >。由于每一个请求都需要经历一次完整的链条上具体处理类的处理，系统性能势必会受到一定影响，比如，依赖更多的代码行或依赖更复杂的代码逻辑。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1147\">\n                        <p data-nodeid=\"1148\">\n                          <strong data-nodeid=\"1282\">调试难度增大</strong\n                          >。调试代码需要验证每个具体处理者是否都能接收到请求，一旦出现错误，排查与修改也变得更加麻烦。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1149\">\n                        <p data-nodeid=\"1150\">\n                          <strong data-nodeid=\"1287\">容易出现死锁异常</strong\n                          >。一旦某一个对象设置后继者出现错误，就会出现循环调用，进而导致堆栈溢出的错误。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"1151\">总结</h3>\n                    <p data-nodeid=\"1152\">\n                      在实际的软件开发中，责任链模式的应用非常广泛，可以说只要是与流程相关的软件系统都能够使用责任链模式来构建，一方面可以用在代码中实现松散耦合，另一方面可以动态增删子处理流程。\n                    </p>\n                    <p data-nodeid=\"1153\">\n                      责任链模式的原理和实现虽然都非常简单，但是在实际使用中还需要<strong\n                        data-nodeid=\"1295\"\n                        >注意维护上下文关系的正确性</strong\n                      >，一旦出现循环调用，很容易死锁而导致程序崩溃。\n                    </p>\n                    <p data-nodeid=\"1154\">\n                      另外，要<strong data-nodeid=\"1301\"\n                        >注意控制责任链中的处理对象数量</strong\n                      >。如果处理对象的数量过多，比如超过 20\n                      个，容易让代码变得难以维护，这时还是应该尽可能减少处理对象的数量，将其合并到相类似的处理对象中去。\n                    </p>\n                    <p data-nodeid=\"1155\">\n                      到此，我们的行为型设计模式的课程就学习完了。最后，我再总结一下行为型设计模式的要点。\n                    </p>\n                    <p data-nodeid=\"1156\">\n                      行为型设计模式共有 11\n                      种，每一种的要点可简单提炼和总结为如下，你可以对比理解和记忆。\n                    </p>\n                    <ul data-nodeid=\"1157\">\n                      <li data-nodeid=\"1158\">\n                        <p data-nodeid=\"1159\">\n                          <strong data-nodeid=\"1308\">访问者模式</strong\n                          >，在对象级别中实际为树型结构，与抽象工厂模式类似。它给使用者提供了一种统一访问树结构中数据节点的方式，因此具备灵活扩展的特性。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1160\">\n                        <p data-nodeid=\"1161\">\n                          <strong data-nodeid=\"1313\">模板方法模式</strong\n                          >，定义一个算法模板，并将具体的执行步骤延迟到子类中实现。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1162\">\n                        <p data-nodeid=\"1163\">\n                          <strong data-nodeid=\"1318\">策略模式</strong\n                          >，将多个不同的算法封装成策略，让它们可以互相替换，适合应用于对计算效率有一定要求的系统。策略模式通常会和工厂方法模式配合使用，为使用者提供一组使用策略。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1164\">\n                        <p data-nodeid=\"1165\">\n                          <strong data-nodeid=\"1323\">状态模式</strong\n                          >，最常用的实现方式是状态机，大量应用于需要控制状态流转的系统中。常用在游戏、工作流引擎、购物流程等系统开发中。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1166\">\n                        <p data-nodeid=\"1167\">\n                          <strong data-nodeid=\"1328\">观察者模式</strong>，是经典\n                          MVC\n                          模式的变形，与中介者模式的结构很类似，在结构上都是星形结构，但侧重点不同。观察者模式侧重于将观察者和被观察者代码解耦，中介者则侧重于充当两个对象之间的新媒介。观察者模式的应用场景非常广泛，比如，邮件订阅、公众号推送、RSS、消息中间件等。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1168\">\n                        <p data-nodeid=\"1169\">\n                          <strong data-nodeid=\"1333\">备忘录模式</strong\n                          >，也叫快照模式，通常用于捕获一个对象的内部状态，比如保存、打开、关闭等状态，并在执行对象之外保存一个副本状态，方便用于之后恢复对象到某一个时间状态。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1170\">\n                        <p data-nodeid=\"1171\">\n                          <strong data-nodeid=\"1338\">中介者模式</strong\n                          >，最大的作用在于解耦对象之间的直接引用，在结构上体现为将网状的结构变成以中介者为中心的星形结构，从而保证了对象行为上的稳定性，即不会因为新对象的引入造成大量类之间引用的修改。它的设计思想和分层思想很像，通过引入一个中间层，将层与层之间的多对多关系变为一对多关系。不过要注意，中间层不能设计得过于复杂而变成另一种过度依赖的层。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1172\">\n                        <p data-nodeid=\"1173\">\n                          <strong data-nodeid=\"1343\">迭代器模式</strong\n                          >，大量应用于基础类库中，对重复遍历操作进行封装。现在大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1174\">\n                        <p data-nodeid=\"1175\">\n                          <strong data-nodeid=\"1348\">解释器模式</strong\n                          >，为某个语言（编程语言也是语言）定义它的语法表示，比如\n                          if-else 语法，并定义一个解释器用来处理这个语法。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1176\">\n                        <p data-nodeid=\"1177\">\n                          <strong data-nodeid=\"1353\">命令模式</strong\n                          >，将某个命令（函数方法）封装成对象进行传递，关注的维度是命令，比如，打开、关闭文件的命令。用于处理多个命令调用和使用远程服务的场景。另外，它还会与备忘录模式结合在一起用于撤销和重做等场景。\n                        </p>\n                      </li>\n                      <li data-nodeid=\"1178\">\n                        <p data-nodeid=\"1179\">\n                          <strong data-nodeid=\"1358\">责任链模式</strong\n                          >，用于链条状结构，将处理请求沿链条进行传递，动态指定职责的承担对象，由各自对象实现对应职责。比如，一个请求先经过\n                          A 拦截器处理，然后再把请求传递给 B 拦截器，B\n                          拦截器处理完后再传递给 C\n                          拦截器，以此类推，形成一个链条，因此也叫拦截器模式。\n                        </p>\n                      </li>\n                    </ul>\n                    <h3 data-nodeid=\"1180\">课后思考</h3>\n                    <p data-nodeid=\"1181\" class=\"\">\n                      学完这 23\n                      种设计模式后，你能第一时间使用的模式有哪些？还有哪些关于课程的疑问？欢迎你在留言区与我分享。\n                    </p>\n            "}